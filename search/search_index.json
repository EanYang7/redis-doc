{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-]","pipeline":["stemmer"]},"docs":[{"location":"","title":"Documentation","text":"<p>Welcome to the Redis documentation.</p>"},{"location":"0-about/_index/","title":"Introduction to Redis","text":"<p>Redis is an open source (BSD licensed), in-memory data structure store used as a database, cache, message broker, and streaming engine. Redis provides data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams. Redis has built-in replication, Lua scripting, LRU eviction, transactions, and different levels of on-disk persistence, and provides high availability via Redis Sentinel and automatic partitioning with Redis Cluster.</p> <p>You can run atomic operations on these types, like appending to a string; incrementing the value in a hash; pushing an element to a list; computing set intersection, union and difference; or getting the member with highest ranking in a sorted set.</p> <p>To achieve top performance, Redis works with an in-memory dataset. Depending on your use case, Redis can persist your data either by periodically dumping the dataset to disk or by appending each command to a disk-based log. You can also disable persistence if you just need a feature-rich, networked, in-memory cache.</p> <p>Redis supports asynchronous replication, with fast non-blocking synchronization and auto-reconnection with partial resynchronization on net split.</p> <p>Redis also includes:</p> <ul> <li>Transactions</li> <li>Pub/Sub</li> <li>Lua scripting</li> <li>Keys with a limited time-to-live</li> <li>LRU eviction of keys</li> <li>Automatic failover</li> </ul> <p>You can use Redis from most programming languages.</p> <p>Redis is written in ANSI C and works on most POSIX systems like Linux, *BSD, and Mac OS X, without external dependencies. Linux and OS X are the two operating systems where Redis is developed and tested the most, and we recommend using Linux for deployment. Redis may work in Solaris-derived systems like SmartOS, but support is best effort. There is no official support for Windows builds.</p>"},{"location":"0-about/governance/","title":"Redis open source governance","text":"<p>From 2009-2020, Salvatore Sanfilippo built, led, and maintained the Redis open source project. During this time, Redis had no formal governance structure, operating primarily as a BDFL-style project.</p> <p>As Redis grew, matured, and expanded its user base, it became increasingly important to form a sustainable structure for its ongoing development and maintenance. Salvatore and the core Redis contributors wanted to ensure the project\u2019s continuity and reflect its larger community.  With this in mind, a new governance structure was adopted.</p>"},{"location":"0-about/governance/#current-governance-structure","title":"Current governance structure","text":"<p>Starting on June 30, 2020, Redis adopted a light governance model that matches the current size of the project and minimizes the changes from its earlier model. The governance model is intended to be a meritocracy, aiming to empower individuals who demonstrate a long-term commitment and make significant contributions.</p>"},{"location":"0-about/governance/#the-redis-core-team","title":"The Redis core team","text":"<p>Salvatore Sanfilippo named two successors to take over and lead the Redis project: Yossi Gottlieb (yossigo) and Oran Agra (oranagra)</p> <p>With the backing and blessing of Redis Ltd., we took this opportunity to create a more open, scalable, and community-driven \u201ccore team\u201d structure to run the project. The core team consists of members selected based on demonstrated, long-term personal involvement and contributions.</p> <p>The current core team members are:</p> <ul> <li>Project Lead: Yossi Gottlieb (yossigo) from Redis Ltd.</li> <li>Project Lead: Oran Agra  (oranagra) from Redis Ltd.</li> <li>Community Lead: Itamar Haber (itamarhaber) from Redis Ltd.</li> <li>Member: Zhao Zhao (soloestoy) from Alibaba</li> <li>Member: Madelyn Olson (madolson) from Amazon Web Services</li> </ul> <p>The Redis core team members serve the Redis open source project and community. They are expected to set a good example of behavior, culture, and tone in accordance with the adopted Code of Conduct. They should also consider and act upon the best interests of the project and the community in a way that is free from foreign or conflicting interests.</p> <p>The core team will be responsible for the Redis core project, which is the part of Redis that is hosted in the main Redis repository and is BSD licensed. It will also aim to maintain coordination and collaboration with other projects that make up the Redis ecosystem, including Redis clients, satellite projects, major middleware that relies on Redis, etc.</p>"},{"location":"0-about/governance/#roles-and-responsibilities","title":"Roles and responsibilities","text":"<p>The core team has the following remit:</p> <ul> <li>Managing the core Redis code and documentation</li> <li>Managing new Redis releases</li> <li>Maintaining a high-level technical direction/roadmap</li> <li>Providing a fast response, including fixes/patches, to address security vulnerabilities and other major issues</li> <li>Project governance decisions and changes</li> <li>Coordination of Redis core with the rest of the Redis ecosystem</li> <li>Managing the membership of the core team</li> </ul> <p>The core team aims to form and empower a community of contributors by further delegating tasks to individuals who demonstrate commitment, know-how, and skills. In particular, we hope to see greater community involvement in the following areas:</p> <ul> <li>Support, troubleshooting, and bug fixes of reported issues</li> <li>Triage of contributions/pull requests</li> </ul>"},{"location":"0-about/governance/#decision-making","title":"Decision making","text":"<ul> <li>Normal decisions will be made by core team members based on a lazy consensus approach: each member may vote +1 (positive) or -1 (negative). A negative vote must include thorough reasoning and better yet, an alternative proposal. The core team will always attempt to reach a full consensus rather than a majority. Examples of normal decisions:<ul> <li>Day-to-day approval of pull requests and closing issues</li> <li>Opening new issues for discussion</li> </ul> </li> <li>Major decisions that have a significant impact on the Redis architecture, design, or philosophy as well as core-team structure or membership changes should preferably be determined by full consensus. If the team is not able to achieve a full consensus, a majority vote is required. Examples of major decisions:<ul> <li>Fundamental changes to the Redis core</li> <li>Adding a new data structure</li> <li>Creating a new version of RESP (Redis Serialization Protocol)</li> <li>Changes that affect backward compatibility</li> <li>Adding or changing core team members</li> </ul> </li> <li>Project leads have a right to veto major decisions</li> </ul>"},{"location":"0-about/governance/#core-team-membership","title":"Core team membership","text":"<ul> <li>The core team is not expected to serve for life, however, long-term participation is desired to provide stability and consistency in the Redis programming style and the community.</li> <li>If a core-team member whose work is funded by Redis Ltd. must be replaced, the replacement will be designated by Redis Ltd. after consultation with the remaining core-team members.</li> <li>If a core-team member not funded by Redis Ltd. will no longer participate, for whatever reason, the other team members will select a replacement.</li> </ul>"},{"location":"0-about/governance/#community-forums-and-communications","title":"Community forums and communications","text":"<p>We want the Redis community to be as welcoming and inclusive as possible. To that end, we have adopted a Code of Conduct that we ask all community members to read and observe.</p> <p>We encourage that all significant communications will be public, asynchronous, archived, and open for the community to actively participate in using the channels described here. The exception to that is sensitive security issues that require resolution prior to public disclosure.</p> <p>To contact the core team about sensitive matters, such as misconduct or security issues, please email redis@redis.io.</p>"},{"location":"0-about/governance/#new-redis-repository-and-commits-approval-process","title":"New Redis repository and commits approval process","text":"<p>The Redis core source repository is hosted under https://github.com/redis/redis. Our target is to eventually host everything (the Redis core source and other ecosystem projects) under the Redis GitHub organization (https://github.com/redis). Commits to the Redis source repository will require code review, approval of at least one core-team member who is not the author of the commit, and no objections.</p>"},{"location":"0-about/governance/#project-and-development-updates","title":"Project and development updates","text":"<p>Stay connected to the project and the community! For project and community updates, follow the project channels. Development announcements will be made via the Redis mailing list.</p>"},{"location":"0-about/governance/#updates-to-these-governance-rules","title":"Updates to these governance rules","text":"<p>Any substantial changes to these rules will be treated as a major decision. Minor changes or ministerial corrections will be treated as normal decisions.</p>"},{"location":"0-about/license/","title":"Redis license","text":"<ul> <li>Redis is open source software released under the terms of the three clause BSD license. Most of the Redis source code was written and is copyrighted by Salvatore Sanfilippo and Pieter Noordhuis. A list of other contributors can be found in the git history.</li> </ul> <p>The Redis trademark and logo are owned by Redis Ltd. and can be used in accordance with the Redis Trademark Guidelines.</p> <ul> <li> <p>RedisInsight is licensed under the Server Side Public License (SSPL).</p> </li> <li> <p>Redis Stack Server, which combines open source Redis with Search and Query features, JSON, Time Series, and Probabilistic data structures is dual-licensed under the Redis Source Available License (RSALv2), as described below, and the Server Side Public License (SSPL). For information about licensing per version, see Versions and licenses.</p> </li> </ul>"},{"location":"0-about/license/#licences","title":"Licences:","text":""},{"location":"0-about/license/#three-clause-bsd-license","title":"Three clause BSD license","text":"<p>Every file in the Redis distribution, with the exceptions of third party files specified in the list below, contain the following license:</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul> <li> <p>Redistributions of source code must retain the above copyright notice,   this list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright   notice, this list of conditions and the following disclaimer in the   documentation and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of Redis nor the names of its contributors may be used   to endorse or promote products derived from this software without   specific prior written permission.</p> </li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"0-about/license/#redis-source-available-license-rsal-20","title":"REDIS SOURCE AVAILABLE LICENSE (RSAL) 2.0","text":"<p>Last updated: November 15, 2022</p>"},{"location":"0-about/license/#acceptance","title":"Acceptance","text":"<p>By using the software, you agree to all of the terms and conditions below.</p>"},{"location":"0-about/license/#copyright-license","title":"Copyright License","text":"<p>The licensor grants you a non-exclusive, royalty-free, worldwide, non-sublicensable, non-transferable license to use, copy, distribute, make available, and prepare derivative works of the software, in each case subject to the limitations and conditions below.</p>"},{"location":"0-about/license/#limitations","title":"Limitations","text":"<p>You may not make the functionality of the software or a modified version available to third parties as a service, or distribute the software or a modified version in a manner that makes the functionality of the software available to third parties.  Making the functionality of the software or modified version available to third parties includes, without limitation, enabling third parties to interact with the functionality of the software or modified version in distributed form or remotely through a computer network, offering a product or service the value of which entirely or primarily derives from the value of the software or modified version, or offering a product or service that accomplishes for users the primary purpose of the software or modified version.</p> <p>You may not alter, remove, or obscure any licensing, copyright, or other notices of the licensor in the software. Any use of the licensor\u2019s trademarks is subject to applicable law.</p>"},{"location":"0-about/license/#patents","title":"Patents","text":"<p>The licensor grants you a license, under any patent claims the licensor can license, or becomes able to license, to make, have made, use, sell, offer for sale, import and have imported the software, in each case subject to the limitations and conditions in this license. This license does not cover any patent claims that you cause to be infringed by modifications or additions to the software. If you or your company make any written claim that the software infringes or contributes to infringement of any patent, your patent license for the software granted under these terms ends immediately. If your company makes such a claim, your patent license ends immediately for work on behalf of your company.</p>"},{"location":"0-about/license/#notices","title":"Notices","text":"<p>You must ensure that anyone who gets a copy of any part of the software from you also gets a copy of these terms. If you modify the software, you must include in any modified copies of the software prominent notices stating that you have modified the software.</p>"},{"location":"0-about/license/#no-other-rights","title":"No Other Rights","text":"<p>These terms do not imply any licenses other than those expressly granted in these terms.</p>"},{"location":"0-about/license/#termination","title":"Termination","text":"<p>If you use the software in violation of these terms, such use is not licensed, and your licenses will automatically terminate. If the licensor provides you with a notice of your violation, and you cease all violations of this license no later than 30 days after you receive that notice, your licenses will be reinstated retroactively. However, if you violate these terms after such reinstatement, any additional violation of these terms will cause your licenses to terminate automatically and permanently.</p>"},{"location":"0-about/license/#no-liability","title":"No Liability","text":"<p>As far as the law allows, the software comes as is, without any warranty or condition, and the licensor will not be liable to you for any damages arising out of these terms or the use or nature of the software, under any kind of legal claim.</p>"},{"location":"0-about/license/#definitions","title":"Definitions","text":"<p>The licensor is the entity offering these terms, and the software is the software the licensor makes available under these terms, including any portion of it.</p> <p>To modify a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission other than making an exact copy. The resulting work is called a modified version of the earlier work.</p> <p>you refers to the individual or entity agreeing to these terms.</p> <p>your company is any legal entity, sole proprietorship, or other kind of organization that you work for, plus all organizations that have control over, are under the control of, or are under common control with that organization. </p> <p>control means ownership of substantially all the assets of an entity, or the power to direct its management and policies by vote, contract, or otherwise. Control can be direct or indirect.</p> <p>your licenses are all the licenses granted to you for the software under these terms. use means anything you do with the software requiring one of your licenses.</p> <p>trademark means trademarks, service marks, and similar rights.</p>"},{"location":"0-about/license/#third-party-files-and-licenses","title":"Third-party files and licenses","text":"<p>Redis uses source code from third parties. All this code contains a BSD or BSD-compatible license. The following is a list of third-party files and information about their copyright.</p> <ul> <li> <p>Redis uses the LHF compression library. LibLZF is copyright Marc Alexander Lehmann and is released under the terms of the two-clause BSD license.</p> </li> <li> <p>Redis uses the <code>sha1.c</code> file that is copyright by Steve Reid and released under the public domain. This file is extremely popular and used among open source and proprietary code.</p> </li> <li> <p>When compiled on Linux, Redis uses the Jemalloc allocator, which is copyrighted by Jason Evans, Mozilla Foundation, and Facebook, Inc and released under the two-clause BSD license.</p> </li> <li> <p>Inside Jemalloc, the file <code>pprof</code> is copyrighted by Google Inc. and released under the three-clause BSD license.</p> </li> <li> <p>Inside Jemalloc the files <code>inttypes.h</code>, <code>stdbool.h</code>, <code>stdint.h</code>, <code>strings.h</code> under the <code>msvc_compat</code> directory are copyright Alexander Chemeris and released under the three-clause BSD license.</p> </li> <li> <p>The libraries hiredis and linenoise also included inside the Redis distribution are copyright Salvatore Sanfilippo and Pieter Noordhuis and released under the terms respectively of the three-clause BSD license and two-clause BSD license.</p> </li> </ul>"},{"location":"0-about/releases/","title":"Redis release cycle","text":"<p>Redis is system software and a type of system software that holds user data, so it is among the most critical pieces of a software stack.</p> <p>For this reason, Redis' release cycle is such that it ensures highly-stable releases, even at the cost of slower cycles.</p> <p>New releases are published in the Redis GitHub repository and are also available for download. Announcements are sent to the Redis mailing list and by @redisfeed on Twitter.</p>"},{"location":"0-about/releases/#release-cycle","title":"Release cycle","text":"<p>A given version of Redis can be at three different levels of stability:</p> <ul> <li>Unstable</li> <li>Release Candidate</li> <li>Stable</li> </ul>"},{"location":"0-about/releases/#unstable-tree","title":"Unstable tree","text":"<p>The unstable version of Redis is located in the <code>unstable</code> branch in the Redis GitHub repository.</p> <p>This branch is the source tree where most of the new features are under development. <code>unstable</code> is not considered production-ready: it may contain critical bugs, incomplete features, and is potentially unstable.</p> <p>However, we try hard to make sure that even the unstable branch is usable most of the time in a development environment without significant issues.</p>"},{"location":"0-about/releases/#release-candidate","title":"Release candidate","text":"<p>New minor and major versions of Redis begin as forks of the <code>unstable</code> branch. The forked branch's name is the target release</p> <p>For example, when Redis 6.0 was released as a release candidate, the <code>unstable</code> branch was forked into the <code>6.0</code> branch. The new branch is the release candidate (RC) for that version.</p> <p>Bug fixes and new features that can be stabilized during the release's time frame are committed to the unstable branch and backported to the release candidate branch. The <code>unstable</code> branch may include additional work that is not a part of the release candidate and scheduled for future releases.</p> <p>The first release candidate, or RC1, is released once it can be used for development purposes and for testing the new version. At this stage, most of the new features and changes the new version brings are ready for review, and the release's purpose is collecting the public's feedback.</p> <p>Subsequent release candidates are released every three weeks or so, primarily for fixing bugs. These may also add new features and introduce changes, but at a decreasing rate and decreasing potential risk towards the final release candidate.</p>"},{"location":"0-about/releases/#stable-tree","title":"Stable tree","text":"<p>Once development has ended and the frequency of critical bug reports for the release candidate wanes, it is ready for the final release. At this point, the release is marked as stable and is released with \"0\" as its patch-level version.</p>"},{"location":"0-about/releases/#versioning","title":"Versioning","text":"<p>Stable releases liberally follow the usual <code>major.minor.patch</code> semantic versioning schema. The primary goal is to provide explicit guarantees regarding backward compatibility.</p>"},{"location":"0-about/releases/#patch-level-versions","title":"Patch-Level versions","text":"<p>Patches primarily consist of bug fixes and very rarely introduce any compatibility issues.</p> <p>Upgrading from a previous patch-level version is almost always safe and seamless.</p> <p>New features and configuration directives may be added, or default values changed, as long as these don\u2019t carry significant impacts or introduce operations-related issues.</p>"},{"location":"0-about/releases/#minor-versions","title":"Minor versions","text":"<p>Minor versions usually deliver maturity and extended functionality.</p> <p>Upgrading between minor versions does not introduce any application-level compatibility issues.</p> <p>Minor releases may include new commands and data types that introduce operations-related incompatibilities, including changes in data persistence format and replication protocol.</p>"},{"location":"0-about/releases/#major-versions","title":"Major versions","text":"<p>Major versions introduce new capabilities and significant changes.</p> <p>Ideally, these don't introduce application-level compatibility issues.</p>"},{"location":"0-about/releases/#release-schedule","title":"Release schedule","text":"<p>A new major version is planned for release once a year.</p> <p>Generally, every major release is followed by a minor version after six months.</p> <p>Patches are released as needed to fix high-urgency issues, or once a stable version accumulates enough fixes to justify it.</p> <p>For contacting the core team on sensitive matters and security issues, please email redis@redis.io.</p>"},{"location":"0-about/releases/#support","title":"Support","text":"<p>As a rule, older versions are not supported as we try very hard to make the Redis API mostly backward compatible.</p> <p>Upgrading to newer versions is the recommended approach and is usually trivial.</p> <p>The latest stable release is always fully supported and maintained.</p> <p>Two additional versions receive maintenance only, meaning that only fixes for critical bugs and major security issues are committed and released as patches:</p> <ul> <li>The previous minor version of the latest stable release.</li> <li>The previous stable major release.</li> </ul> <p>For example, consider the following hypothetical versions: 1.2, 2.0, 2.2, 3.0, 3.2.</p> <p>When version 2.2 is the latest stable release, both 2.0 and 1.2 are maintained.</p> <p>Once version 3.0.0 replaces 2.2 as the latest stable, versions 2.0 and 2.2 are maintained, whereas version 1.x reaches its end of life.</p> <p>This process repeats with version 3.2.0, after which only versions 2.2 and 3.0 are maintained.</p> <p>The above are guidelines rather than rules set in stone and will not replace common sense.</p>"},{"location":"0-about/sponsors/","title":"Redis sponsors","text":"<p>From 2015 to 2020, Salvatore Sanfilippo's work on Redis was sponsored by Redis Ltd. Since June 2020, Redis Ltd. has sponsored the governance of Redis. Redis Ltd. also sponsors the hosting and maintenance of redis.io. </p> <p>Past sponsorships:</p> <ul> <li>The Shuttleworth Foundation has donated 5000 USD to the Redis project in form of a flash grant.</li> <li>From May 2013 to June 2015, the work Salvatore Sanfilippo did to develop Redis was sponsored by Pivotal.</li> <li>Before May 2013, the project was sponsored by VMware with the work of Salvatore Sanfilippo and Pieter Noordhuis.</li> <li>VMware and later Pivotal provided a 24 GB RAM workstation for Salvatore to run the Redis CI test and other long running tests. Later, Salvatore equipped the server with an SSD drive in order to test in the same hardware with rotating and flash drives.</li> <li>Linode, in January 2010, provided virtual machines for Redis testing in a virtualized environment.</li> <li>Slicehost, January 2010, provided Virtual Machines for Redis testing in a virtualized environment.</li> <li>Citrusbyte, in December 2009, contributed part of Virtual Memory implementation.</li> <li>Hitmeister, in December 2009, contributed part of Redis Cluster.</li> <li>Engine Yard, in December 2009, contributed blocking POP (BLPOP) and part of the Virtual Memory implementation.</li> </ul> <p>Also thanks to the following people or organizations that donated to the Project:</p> <ul> <li>Emil Vladev</li> <li>Brad Jasper</li> <li>Mrkris</li> </ul> <p>The Redis community is grateful to Redis Ltd., Pivotal, VMware and to the other companies and people who have donated to the Redis project. Thank you.</p>"},{"location":"0-about/sponsors/#redisio","title":"redis.io","text":"<p>Citrusbyte sponsored the creation of the official Redis logo (designed by Carlos Prioglio) and transferred its copyright to Salvatore Sanfilippo.</p> <p>They also sponsored the initial implementation of this site by Damian Janowski and Michel Martens.</p> <p>The <code>redis.io</code> domain was donated for a few years to the project by I Want My Name.</p>"},{"location":"0-about/users/","title":"Who's using Redis?","text":"<p>A list of well known companies using Redis:</p> <ul> <li>Twitter</li> <li>GitHub</li> <li>Snapchat</li> <li>Craigslist</li> <li>StackOverflow</li> </ul> <p>And many others! techstacks.io maintains a list of popular sites using Redis.</p>"},{"location":"1-get-started/_index/","title":"Quick starts","text":"<p>Redis can be used as a database, cache, streaming engine, message broker, and more. The following quick start guides will show you how to use Redis for the following specific purposes:</p> <ol> <li>Data structure store</li> <li>Document database</li> <li>Vector database</li> </ol> <p>Please select the guide that aligns best with your specific usage scenario.</p> <p>You can find answers to frequently asked questions in the FAQ.</p>"},{"location":"1-get-started/data-store/","title":"Redis as an in-memory data structure store quick start guide","text":"<p>This quick start guide shows you how to:</p> <ol> <li>Get started with Redis </li> <li>Store data under a key in Redis</li> <li>Retrieve data with a key from Redis</li> <li>Scan the keyspace for keys that match a specific pattern</li> </ol> <p>The examples in this article refer to a simple bicycle inventory.</p>"},{"location":"1-get-started/data-store/#setup","title":"Setup","text":"<p>The easiest way to get started with Redis is to use Redis Cloud:</p> <ol> <li>Create a free account.</li> <li>Follow the instructions to create a free database.</li> </ol> <p></p> <p>You can alternatively follow the installation guides to install Redis on your local machine.</p>"},{"location":"1-get-started/data-store/#connect","title":"Connect","text":"<p>The first step is to connect to Redis. You can find further details about the connection options in this documentation site's connection section. The following example shows how to connect to a Redis server that runs on localhost (<code>-h 127.0.0.1</code>) and listens on the default port (<code>-p 6379</code>): </p> <p>{{&lt; clients-example search_quickstart connect &gt;}}</p> <p>redis-cli -h 127.0.0.1 -p 6379 {{&lt; /clients-example&gt;}}  {{% alert title=\"Tip\" color=\"warning\" %}} You can copy and paste the connection details from the Redis Cloud database configuration page. Here is an example connection string of a Cloud database that is hosted in the AWS region <code>us-east-1</code> and listens on port 16379: <code>redis-16379.c283.us-east-1-4.ec2.cloud.redislabs.com:16379</code>. The connection string has the format <code>host:port</code>. You must also copy and paste the username and password of your Cloud database and then either pass the credentials to your client or use the AUTH command after the connection is established. {{% /alert  %}}</p>"},{"location":"1-get-started/data-store/#store-and-retrieve-data","title":"Store and retrieve data","text":"<p>Redis stands for Remote Dictionary Server. You can use the same data types as in your local programming environment but on the server side within Redis.</p> <p>Similar to byte arrays, Redis strings store sequences of bytes, including text, serialized objects, counter values, and binary arrays. The following example shows you how to set and get a string value:</p> <p>{{&lt; clients-example set_and_get &gt;}} SET bike:1 \"Process 134\" GET bike:1 {{&lt; /clients-example &gt;}}</p> <p>Hashes are the equivalent of dictionaries (dicts or hash maps). Among other things, you can use hashes to represent plain objects and to store groupings of counters. The following example explains how to set and access field values of an object:</p> <p>{{&lt; clients-example hash_tutorial set_get_all &gt;}}</p> <p>HSET bike:1 model Deimos brand Ergonom type 'Enduro bikes' price 4972 (integer) 4 HGET bike:1 model \"Deimos\" HGET bike:1 price \"4972\" HGETALL bike:1 1) \"model\" 2) \"Deimos\" 3) \"brand\" 4) \"Ergonom\" 5) \"type\" 6) \"Enduro bikes\" 7) \"price\" 8) \"4972\" {{&lt; /clients-example &gt;}}</p> <p>You can get a complete overview of available data types in this documentation site's data types section. Each data type has commands allowing you to manipulate or retrieve data. The commands reference provides a sophisticated explanation.</p>"},{"location":"1-get-started/data-store/#scan-the-keyspace","title":"Scan the keyspace","text":"<p>Each item within Redis has a unique key. All items live within the Redis keyspace. You can scan the Redis keyspace via the SCAN command. Here is an example that scans for the first 100 keys that have the prefix <code>bike:</code>:</p> <p>{{&lt; clients-example scan_example &gt;}} SCAN 0 MATCH \"bike:*\" COUNT 100 {{&lt; /clients-example &gt;}}</p> <p>SCAN returns a cursor position, allowing you to scan iteratively for the next batch of keys until you reach the cursor value 0.</p>"},{"location":"1-get-started/data-store/#next-steps","title":"Next steps","text":"<p>You can address more use cases with Redis by learning about Redis Stack. Here are two additional quick start guides:</p> <ul> <li>Redis as a document database</li> <li>Redis as a vector database</li> </ul>"},{"location":"1-get-started/faq/","title":"Redis FAQ","text":""},{"location":"1-get-started/faq/#how-is-redis-different-from-other-key-value-stores","title":"How is Redis different from other key-value stores?","text":"<ul> <li>Redis has a different evolution path in the key-value DBs where values can contain more complex data types, with atomic operations defined on those data types. Redis data types are closely related to fundamental data structures and are exposed to the programmer as such, without additional abstraction layers.</li> <li>Redis is an in-memory but persistent on disk database, so it represents a different trade off where very high write and read speed is achieved with the limitation of data sets that can't be larger than memory. Another advantage of in-memory databases is that the memory representation of complex data structures is much simpler to manipulate compared to the same data structures on disk, so Redis can do a lot with little internal complexity. At the same time the two on-disk storage formats (RDB and AOF) don't need to be suitable for random access, so they are compact and always generated in an append-only fashion (Even the AOF log rotation is an append-only operation, since the new version is generated from the copy of data in memory). However this design also involves different challenges compared to traditional on-disk stores. Being the main data representation on memory, Redis operations must be carefully handled to make sure there is always an updated version of the data set on disk.</li> </ul>"},{"location":"1-get-started/faq/#whats-the-redis-memory-footprint","title":"What's the Redis memory footprint?","text":"<p>To give you a few examples (all obtained using 64-bit instances):</p> <ul> <li>An empty instance uses ~ 3MB of memory.</li> <li>1 Million small Keys -&gt; String Value pairs use ~ 85MB of memory.</li> <li>1 Million Keys -&gt; Hash value, representing an object with 5 fields, use ~ 160 MB of memory.</li> </ul> <p>Testing your use case is trivial. Use the <code>redis-benchmark</code> utility to generate random data sets then check the space used with the <code>INFO memory</code> command.</p> <p>64-bit systems will use considerably more memory than 32-bit systems to store the same keys, especially if the keys and values are small. This is because pointers take 8 bytes in 64-bit systems. But of course the advantage is that you can have a lot of memory in 64-bit systems, so in order to run large Redis servers a 64-bit system is more or less required. The alternative is sharding.</p>"},{"location":"1-get-started/faq/#why-does-redis-keep-its-entire-dataset-in-memory","title":"Why does Redis keep its entire dataset in memory?","text":"<p>In the past the Redis developers experimented with Virtual Memory and other systems in order to allow larger than RAM datasets, but after all we are very happy if we can do one thing well: data served from memory, disk used for storage. So for now there are no plans to create an on disk backend for Redis. Most of what Redis is, after all, a direct result of its current design.</p> <p>If your real problem is not the total RAM needed, but the fact that you need to split your data set into multiple Redis instances, please read the partitioning page in this documentation for more info.</p> <p>Redis Ltd., the company sponsoring Redis development, has developed a \"Redis on Flash\" solution that uses a mixed RAM/flash approach for larger data sets with a biased access pattern. You may check their offering for more information, however this feature is not part of the open source Redis code base.</p>"},{"location":"1-get-started/faq/#can-you-use-redis-with-a-disk-based-database","title":"Can you use Redis with a disk-based database?","text":"<p>Yes, a common design pattern involves taking very write-heavy small data in Redis (and data you need the Redis data structures to model your problem in an efficient way), and big blobs of data into an SQL or eventually consistent on-disk database. Similarly sometimes Redis is used in order to take in memory another copy of a subset of the same data stored in the on-disk database. This may look similar to caching, but actually is a more advanced model since normally the Redis dataset is updated together with the on-disk DB dataset, and not refreshed on cache misses.</p>"},{"location":"1-get-started/faq/#how-can-i-reduce-redis-overall-memory-usage","title":"How can I reduce Redis' overall memory usage?","text":"<p>A good practice is to consider memory consumption when mapping your logical data model to the physical data model within Redis. These considerations include using specific data types, key patterns, and normalization.</p> <p>Beyond data modeling, there is more info in the Memory Optimization page.</p>"},{"location":"1-get-started/faq/#what-happens-if-redis-runs-out-of-memory","title":"What happens if Redis runs out of memory?","text":"<p>Redis has built-in protections allowing the users to set a max limit on memory usage, using the <code>maxmemory</code> option in the configuration file to put a limit to the memory Redis can use. If this limit is reached, Redis will start to reply with an error to write commands (but will continue to accept read-only commands).</p> <p>You can also configure Redis to evict keys when the max memory limit is reached. See the eviction policy docs for more information on this.</p>"},{"location":"1-get-started/faq/#background-saving-fails-with-a-fork-error-on-linux","title":"Background saving fails with a fork() error on Linux?","text":"<p>Short answer: <code>echo 1 &gt; /proc/sys/vm/overcommit_memory</code> :)</p> <p>And now the long one:</p> <p>The Redis background saving schema relies on the copy-on-write semantic of the <code>fork</code> system call in modern operating systems: Redis forks (creates a child process) that is an exact copy of the parent. The child process dumps the DB on disk and finally exits. In theory the child should use as much memory as the parent being a copy, but actually thanks to the copy-on-write semantic implemented by most modern operating systems the parent and child process will share the common memory pages. A page will be duplicated only when it changes in the child or in the parent. Since in theory all the pages may change while the child process is saving, Linux can't tell in advance how much memory the child will take, so if the <code>overcommit_memory</code> setting is set to zero the fork will fail unless there is as much free RAM as required to really duplicate all the parent memory pages. If you have a Redis dataset of 3 GB and just 2 GB of free memory it will fail.</p> <p>Setting <code>overcommit_memory</code> to 1 tells Linux to relax and perform the fork in a more optimistic allocation fashion, and this is indeed what you want for Redis.</p> <p>You can refer to the proc(5) man page for explanations of the available values.</p>"},{"location":"1-get-started/faq/#are-redis-on-disk-snapshots-atomic","title":"Are Redis on-disk snapshots atomic?","text":"<p>Yes, the Redis background saving process is always forked when the server is outside of the execution of a command, so every command reported to be atomic in RAM is also atomic from the point of view of the disk snapshot.</p>"},{"location":"1-get-started/faq/#how-can-redis-use-multiple-cpus-or-cores","title":"How can Redis use multiple CPUs or cores?","text":"<p>It's not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound. For instance, when using pipelining a Redis instance running on an average Linux system can deliver 1 million requests per second, so if your application mainly uses O(N) or O(log(N)) commands, it is hardly going to use too much CPU.</p> <p>However, to maximize CPU usage you can start multiple instances of Redis in the same box and treat them as different servers. At some point a single box may not be enough anyway, so if you want to use multiple CPUs you can start thinking of some way to shard earlier.</p> <p>You can find more information about using multiple Redis instances in the Partitioning page.</p> <p>As of version 4.0, Redis has started implementing threaded actions. For now this is limited to deleting objects in the background and blocking commands implemented via Redis modules. For subsequent releases, the plan is to make Redis more and more threaded.</p>"},{"location":"1-get-started/faq/#what-is-the-maximum-number-of-keys-a-single-redis-instance-can-hold-what-is-the-maximum-number-of-elements-in-a-hash-list-set-and-sorted-set","title":"What is the maximum number of keys a single Redis instance can hold? What is the maximum number of elements in a Hash, List, Set, and Sorted Set?","text":"<p>Redis can handle up to 2^32 keys, and was tested in practice to handle at least 250 million keys per instance.</p> <p>Every hash, list, set, and sorted set, can hold 2^32 elements.</p> <p>In other words your limit is likely the available memory in your system.</p>"},{"location":"1-get-started/faq/#why-does-my-replica-have-a-different-number-of-keys-its-master-instance","title":"Why does my replica have a different number of keys its master instance?","text":"<p>If you use keys with limited time to live (Redis expires) this is normal behavior. This is what happens:</p> <ul> <li>The primary generates an RDB file on the first synchronization with the replica.</li> <li>The RDB file will not include keys already expired in the primary but which are still in memory.</li> <li>These keys are still in the memory of the Redis primary, even if logically expired. They'll be considered non-existent, and their memory will be reclaimed later, either incrementally or explicitly on access. While these keys are not logically part of the dataset, they are accounted for in the <code>INFO</code> output and in the <code>DBSIZE</code> command.</li> <li>When the replica reads the RDB file generated by the primary, this set of keys will not be loaded.</li> </ul> <p>Because of this, it's common for users with many expired keys to see fewer keys in the replicas. However, logically, the primary and replica will have the same content.</p>"},{"location":"1-get-started/faq/#where-does-the-name-redis-come-from","title":"Where does the name \"Redis\" come from?","text":"<p>Redis is an acronym that stands for REmote DIctionary Server.</p>"},{"location":"1-get-started/faq/#why-did-salvatore-sanfilippo-start-the-redis-project","title":"Why did Salvatore Sanfilippo start the Redis project?","text":"<p>Salvatore originally created Redis to scale LLOOGG, a real-time log analysis tool. But after getting the basic Redis server working, he decided to share the work with other people and turn Redis into an open source project.</p>"},{"location":"1-get-started/faq/#how-is-redis-pronounced","title":"How is Redis pronounced?","text":"<p>\"Redis\" (/\u02c8r\u025bd-\u026as/) is pronounced like the word \"red\" plus the word \"kiss\" without the \"k\".</p>"},{"location":"2-install/_index/","title":"Install Redis or Redis Stack","text":"<p>You can install both Redis or Redis Stack locally on your machine. Redis and Redis Stack are available on Linux, macOS, and Windows. </p> <p>Here are the installation instructions:</p> <ul> <li>Install Redis</li> <li>Install Redis Stack</li> </ul> <p>While you can install Redis (Stack) locally, you might also consider using Redis Cloud by creating a free account.</p>"},{"location":"2-install/install-redis/_index/","title":"Install Redis","text":"<p>This is a an installation guide. You'll learn how to install, run, and experiment with the Redis server process.</p> <p>While you can install Redis on any of the platforms listed below, you might also consider using Redis Cloud by creating a free account.</p>"},{"location":"2-install/install-redis/_index/#install-redis","title":"Install Redis","text":"<p>How you install Redis depends on your operating system and whether you'd like to install it bundled with Redis Stack and Redis UI. See the guide below that best fits your needs:</p> <ul> <li>Install Redis from Source</li> <li>Install Redis on Linux</li> <li>Install Redis on macOS</li> <li>Install Redis on Windows</li> <li>Install Redis with Redis Stack and RedisInsight</li> </ul>"},{"location":"2-install/install-redis/_index/#test-if-you-can-connect-using-the-cli","title":"Test if you can connect using the CLI","text":"<p>Once you have Redis up and running, you can connect using <code>redis-cli</code>.</p> <p>External programs talk to Redis using a TCP socket and a Redis specific protocol. This protocol is implemented in the Redis client libraries for the different programming languages. However to make hacking with Redis simpler Redis provides a command line utility that can be used to send commands to Redis. This program is called redis-cli.</p> <p>The first thing to do in order to check if Redis is working properly is sending a PING command using redis-cli:</p> <pre><code>$ redis-cli ping\nPONG\n</code></pre> <p>Running redis-cli followed by a command name and its arguments will send this command to the Redis instance running on localhost at port 6379. You can change the host and port used by <code>redis-cli</code> - just try the <code>--help</code> option to check the usage information.</p> <p>Another interesting way to run <code>redis-cli</code> is without arguments: the program will start in interactive mode. You can type different commands and see their replies.</p> <pre><code>$ redis-cli\nredis 127.0.0.1:6379&gt; ping\nPONG\n</code></pre>"},{"location":"2-install/install-redis/_index/#securing-redis","title":"Securing Redis","text":"<p>By default Redis binds to all the interfaces and has no authentication at all. If you use Redis in a very controlled environment, separated from the external internet and in general from attackers, that's fine. However if an unhardened Redis is exposed to the internet, it is a big security concern. If you are not 100% sure your environment is secured properly, please check the following steps in order to make Redis more secure:</p> <ol> <li>Make sure the port Redis uses to listen for connections (by default 6379 and additionally 16379 if you run Redis in cluster mode, plus 26379 for Sentinel) is firewalled, so that it is not possible to contact Redis from the outside world.</li> <li>Use a configuration file where the <code>bind</code> directive is set in order to guarantee that Redis listens on only the network interfaces you are using. For example only the loopback interface (127.0.0.1) if you are accessing Redis just locally from the same computer, and so forth.</li> <li>Use the <code>requirepass</code> option in order to add an additional layer of security so that clients will require to authenticate using the <code>AUTH</code> command.</li> <li>Use spiped or another SSL tunneling software in order to encrypt traffic between Redis servers and Redis clients if your environment requires encryption.</li> </ol> <p>Note that a Redis instance exposed to the internet without any security is very simple to exploit, so make sure you understand the above and apply at least a firewall layer. After the firewall is in place, try to connect with <code>redis-cli</code> from an external host in order to prove yourself the instance is actually not reachable.</p>"},{"location":"2-install/install-redis/_index/#use-redis-from-your-application","title":"Use Redis from your application","text":"<p>Of course using Redis just from the command line interface is not enough as the goal is to use it from your application. In order to do so you need to download and install a Redis client library for your programming language.</p> <p>You'll find a full list of clients for different languages in this page.</p>"},{"location":"2-install/install-redis/_index/#redis-persistence","title":"Redis persistence","text":"<p>You can learn how Redis persistence works on this page, however what is important to understand for a quick start is that by default, if you start Redis with the default configuration, Redis will spontaneously save the dataset only from time to time (for instance after at least five minutes if you have at least 100 changes in your data), so if you want your database to persist and be reloaded after a restart make sure to call the SAVE command manually every time you want to force a data set snapshot. Otherwise make sure to shutdown the database using the SHUTDOWN command:</p> <pre><code>$ redis-cli shutdown\n</code></pre> <p>This way Redis will make sure to save the data on disk before quitting. Reading the persistence page is strongly suggested in order to better understand how Redis persistence works.</p>"},{"location":"2-install/install-redis/_index/#install-redis-more-properly","title":"Install Redis more properly","text":"<p>Running Redis from the command line is fine just to hack a bit or for development. However, at some point you'll have some actual application to run on a real server. For this kind of usage you have two different choices:</p> <ul> <li>Run Redis using screen.</li> <li>Install Redis in your Linux box in a proper way using an init script, so that after a restart everything will start again properly.</li> </ul> <p>A proper install using an init script is strongly recommended. </p> <p>{{% alert title=\"Note\" color=\"warning\" %}} The available packages for supported Linux distributions already include the capability of starting the Redis server from <code>/etc/init</code>. {{% /alert  %}}</p> <p>{{% alert title=\"Note\" color=\"warning\" %}} The remainder of this section assumes you've installed Redis from its source code. If instead you have installed Redis Stack, you will need to download a basic init script and then modify both it and the following instructions to conform to the way Redis Stack was installed on your platform. For example, on Ubuntu 20.04 LTS, Redis Stack is installed in <code>/opt/redis-stack</code>, not <code>/usr/local</code>, so you'll need to adjust accordingly. {{% /alert  %}}</p> <p>The following instructions can be used to perform a proper installation using the init script shipped with the Redis source code, <code>/path/to/redis-stable/utils/redis_init_script</code>.</p> <p>If you have not yet run <code>make install</code> after building the Redis source, you will need to do so before continuing. By default, <code>make install</code> will copy the <code>redis-server</code> and <code>redis-cli</code> binaries to <code>/usr/local/bin</code>.</p> <ul> <li> <p>Create a directory in which to store your Redis config files and your data:</p> <pre><code>sudo mkdir /etc/redis\nsudo mkdir /var/redis\n</code></pre> </li> <li> <p>Copy the init script that you'll find in the Redis distribution under the utils directory into <code>/etc/init.d</code>. We suggest calling it with the name of the port where you are running this instance of Redis. Make sure the resulting file has <code>0755</code> permissions.</p> <pre><code>sudo cp utils/redis_init_script /etc/init.d/redis_6379\n</code></pre> </li> <li> <p>Edit the init script.</p> <pre><code>sudo vi /etc/init.d/redis_6379\n</code></pre> </li> </ul> <p>Make sure to set the REDISPORT variable to the port you are using. Both the pid file path and the configuration file name depend on the port number.</p> <ul> <li> <p>Copy the template configuration file you'll find in the root directory of the Redis distribution into <code>/etc/redis/</code> using the port number as the name, for instance:</p> <pre><code>sudo cp redis.conf /etc/redis/6379.conf\n</code></pre> </li> <li> <p>Create a directory inside <code>/var/redis</code> that will work as both data and working directory for this Redis instance:</p> <pre><code>sudo mkdir /var/redis/6379\n</code></pre> </li> <li> <p>Edit the configuration file, making sure to perform the following changes:</p> <ul> <li>Set daemonize to yes (by default it is set to no).</li> <li>Set the pidfile to <code>/var/run/redis_6379.pid</code>, modifying the port as necessary.</li> <li>Change the port accordingly. In our example it is not needed as the default port is already <code>6379</code>.</li> <li>Set your preferred loglevel.</li> <li>Set the logfile to <code>/var/log/redis_6379.log</code></li> <li>Set the dir to <code>/var/redis/6379</code> (very important step!)</li> </ul> </li> <li> <p>Finally, add the new Redis init script to all the default runlevels using the following command:</p> <pre><code>sudo update-rc.d redis_6379 defaults\n</code></pre> </li> </ul> <p>You are done! Now you can try running your instance with:</p> <pre><code>sudo /etc/init.d/redis_6379 start\n</code></pre> <p>Make sure that everything is working as expected:</p> <ol> <li>Try pinging your instance within a <code>redis-cli</code> session using the <code>PING</code> command.</li> <li>Do a test save with <code>redis-cli save</code> and check that a dump file is correctly saved to <code>/var/redis/6379/dump.rdb</code>.</li> <li>Check that your Redis instance is logging to the <code>/var/log/redis_6379.log</code> file.</li> <li>If it's a new machine where you can try it without problems, make sure that after a reboot everything is still working.</li> </ol> <p>{{% alert title=\"Note\" color=\"warning\" %}} The above instructions don't include all of the Redis configuration parameters that you could change. For example, to use AOF persistence instead of RDB persistence, or to set up replication, and so forth. {{% /alert  %}}</p> <p>You should also read the example redis.conf file, which is heavily annotated to help guide you on making changes. Further details can also be found in the configuration article on this site.</p>"},{"location":"2-install/install-redis/install-redis-from-source/","title":"Install Redis from Source","text":"<p>You can compile and install Redis from source on variety of platforms and operating systems including Linux and macOS. Redis has no dependencies other than a C  compiler and <code>libc</code>.</p>"},{"location":"2-install/install-redis/install-redis-from-source/#downloading-the-source-files","title":"Downloading the source files","text":"<p>The Redis source files are available from the Download page. You can verify the integrity of these downloads by checking them against the digests in the redis-hashes git repository.</p> <p>To obtain the source files for the latest stable version of Redis from the Redis downloads site, run:</p> <p>{{&lt; highlight bash &gt;}} wget https://download.redis.io/redis-stable.tar.gz {{&lt; / highlight &gt;}}</p>"},{"location":"2-install/install-redis/install-redis-from-source/#compiling-redis","title":"Compiling Redis","text":"<p>To compile Redis, first the tarball, change to the root directory, and then run <code>make</code>:</p> <p>{{&lt; highlight bash &gt;}} tar -xzvf redis-stable.tar.gz cd redis-stable make {{&lt; / highlight &gt;}}</p> <p>If the compile succeeds, you'll find several Redis binaries in the <code>src</code> directory, including:</p> <ul> <li>redis-server: the Redis Server itself</li> <li>redis-cli is the command line interface utility to talk with Redis.</li> </ul> <p>To install these binaries in <code>/usr/local/bin</code>, run:</p> <p>{{&lt; highlight bash  &gt;}} sudo make install {{&lt; / highlight &gt;}}</p>"},{"location":"2-install/install-redis/install-redis-from-source/#starting-and-stopping-redis-in-the-foreground","title":"Starting and stopping Redis in the foreground","text":"<p>Once installed, you can start Redis by running</p> <p>{{&lt; highlight bash  &gt;}} redis-server {{&lt; / highlight &gt;}}</p> <p>If successful, you'll see the startup logs for Redis, and Redis will be running in the foreground.</p> <p>To stop Redis, enter <code>Ctrl-C</code>.</p> <p>For a more complete installation, continue with these instructions.</p>"},{"location":"2-install/install-redis/install-redis-on-linux/","title":"Install Redis on Linux","text":"<p>Most major Linux distributions provide packages for Redis.</p>"},{"location":"2-install/install-redis/install-redis-on-linux/#install-on-ubuntudebian","title":"Install on Ubuntu/Debian","text":"<p>You can install recent stable versions of Redis from the official <code>packages.redis.io</code> APT repository.</p> <p>{{% alert title=\"Prerequisites\" color=\"warning\" %}} If you're running a very minimal distribution (such as a Docker container) you may need to install <code>lsb-release</code>, <code>curl</code> and <code>gpg</code> first:</p> <p>{{&lt; highlight bash  &gt;}} sudo apt install lsb-release curl gpg {{&lt; / highlight  &gt;}} {{% /alert  %}}</p> <p>Add the repository to the <code>apt</code> index, update it, and then install:</p> <p>{{&lt; highlight bash  &gt;}} curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg</p> <p>echo \"deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/redis.list</p> <p>sudo apt-get update sudo apt-get install redis {{&lt; / highlight  &gt;}}</p>"},{"location":"2-install/install-redis/install-redis-on-linux/#install-from-snapcraft","title":"Install from Snapcraft","text":"<p>The Snapcraft store provides Redis packages that can be installed on platforms that support snap. Snap is supported and available on most major Linux distributions.</p> <p>To install via snap, run:</p> <p>{{&lt; highlight bash  &gt;}} sudo snap install redis {{&lt; / highlight  &gt;}}</p> <p>If your Linux does not currently have snap installed, install it using the instructions described in Installing snapd.</p>"},{"location":"2-install/install-redis/install-redis-on-mac-os/","title":"Install Redis on macOS","text":"<p>This guide shows you how to install Redis on macOS using Homebrew. Homebrew is the easiest way to install Redis on macOS. If you'd prefer to build Redis from the source files on macOS, see Installing Redis from Source.</p>"},{"location":"2-install/install-redis/install-redis-on-mac-os/#prerequisites","title":"Prerequisites","text":"<p>First, make sure you have Homebrew installed. From the terminal, run:</p> <p>{{&lt; highlight bash  &gt;}} brew --version {{&lt; / highlight &gt;}}</p> <p>If this command fails, you'll need to follow the Homebrew installation instructions.</p>"},{"location":"2-install/install-redis/install-redis-on-mac-os/#installation","title":"Installation","text":"<p>From the terminal, run:</p> <p>{{&lt; highlight bash  &gt;}} brew install redis {{&lt; / highlight &gt;}}</p> <p>This will install Redis on your system.</p>"},{"location":"2-install/install-redis/install-redis-on-mac-os/#starting-and-stopping-redis-in-the-foreground","title":"Starting and stopping Redis in the foreground","text":"<p>To test your Redis installation, you can run the <code>redis-server</code> executable from the command line:</p> <p>{{&lt; highlight bash  &gt;}} redis-server {{&lt; / highlight &gt;}}</p> <p>If successful, you'll see the startup logs for Redis, and Redis will be running in the foreground.</p> <p>To stop Redis, enter <code>Ctrl-C</code>.</p>"},{"location":"2-install/install-redis/install-redis-on-mac-os/#starting-and-stopping-redis-using-launchd","title":"Starting and stopping Redis using launchd","text":"<p>As an alternative to running Redis in the foreground, you can also use <code>launchd</code> to start the process in the background:</p> <p>{{&lt; highlight bash  &gt;}} brew services start redis {{&lt; / highlight &gt;}}</p> <p>This launches Redis and restarts it at login. You can check the status of a <code>launchd</code> managed Redis by running the following:</p> <p>{{&lt; highlight bash  &gt;}} brew services info redis {{&lt; / highlight &gt;}}</p> <p>If the service is running, you'll see output like the following:</p> <p>{{&lt; highlight bash  &gt;}} redis (homebrew.mxcl.redis) Running: \u2714 Loaded: \u2714 User: miranda PID: 67975 {{&lt; / highlight &gt;}}</p> <p>To stop the service, run:</p> <p>{{&lt; highlight bash  &gt;}} brew services stop redis {{&lt; / highlight &gt;}}</p>"},{"location":"2-install/install-redis/install-redis-on-mac-os/#connect-to-redis","title":"Connect to Redis","text":"<p>Once Redis is running, you can test it by running <code>redis-cli</code>:</p> <p>{{&lt; highlight bash  &gt;}} redis-cli {{&lt; / highlight &gt;}}</p> <p>This will open the Redis REPL. Try running some commands:</p> <p>{{&lt; highlight bash &gt;}} 127.0.0.1:6379&gt; lpush demos redis-macOS-demo OK 127.0.0.1:6379&gt; rpop demos \"redis-macOS-demo\" {{&lt; / highlight &gt;}}</p>"},{"location":"2-install/install-redis/install-redis-on-mac-os/#next-steps","title":"Next steps","text":"<p>Once you have a running Redis instance, you may want to:</p> <ul> <li>Try the Redis CLI tutorial</li> <li>Connect using one of the Redis clients</li> </ul>"},{"location":"2-install/install-redis/install-redis-on-windows/","title":"Install Redis on Windows","text":"<p>Redis is not officially supported on Windows. However, you can install Redis on Windows for development by following the instructions below.</p> <p>To install Redis on Windows, you'll first need to enable WSL2 (Windows Subsystem for Linux). WSL2 lets you run Linux binaries natively on Windows. For this method to work, you'll need to be running Windows 10 version 2004 and higher or Windows 11.</p>"},{"location":"2-install/install-redis/install-redis-on-windows/#install-or-enable-wsl2","title":"Install or enable WSL2","text":"<p>Microsoft provides detailed instructions for installing WSL. Follow these instructions, and take note of the default Linux distribution it installs. This guide assumes Ubuntu.</p>"},{"location":"2-install/install-redis/install-redis-on-windows/#install-redis","title":"Install Redis","text":"<p>Once you're running Ubuntu on Windows, you can follow the steps detailed at Install on Ubuntu/Debian to install recent stable versions of Redis from the official <code>packages.redis.io</code> APT repository. Add the repository to the <code>apt</code> index, update it, and then install:</p> <p>{{&lt; highlight bash  &gt;}} curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg</p> <p>echo \"deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/redis.list</p> <p>sudo apt-get update sudo apt-get install redis {{&lt; / highlight  &gt;}}</p> <p>Lastly, start the Redis server like so:</p> <p>{{&lt; highlight bash  &gt;}} sudo service redis-server start {{&lt; / highlight  &gt;}}</p>"},{"location":"2-install/install-redis/install-redis-on-windows/#connect-to-redis","title":"Connect to Redis","text":"<p>You can test that your Redis server is running by connecting with the Redis CLI:</p> <p>{{&lt; highlight bash  &gt;}} redis-cli  127.0.0.1:6379&gt; ping PONG {{&lt; / highlight &gt;}}</p>"},{"location":"3-connect/_index/","title":"Connect to Redis","text":"<p>You can connect to Redis in the following ways:</p> <ul> <li>With the <code>redis-cli</code> command line tool</li> <li>Use RedisInsight as a graphical user interface</li> <li>Via a client library for your programming language</li> </ul>"},{"location":"3-connect/_index/#redis-command-line-interface","title":"Redis command line interface","text":"<p>The Redis command line interface (also known as <code>redis-cli</code>) is a terminal program that sends commands to and reads replies from the Redis server. It has the following two main modes: </p> <ol> <li>An interactive Read Eval Print Loop (REPL) mode where the user types Redis commands and receives replies.</li> <li>A command mode where <code>redis-cli</code> is executed with additional arguments, and the reply is printed to the standard output.</li> </ol>"},{"location":"3-connect/_index/#redisinsight","title":"RedisInsight","text":"<p>RedisInsight combines a graphical user interface with Redis CLI to let you work with any Redis deployment. You can visually browse and interact with data, take advantage of diagnostic tools, learn by example, and much more. Best of all, RedisInsight is free.</p>"},{"location":"3-connect/_index/#client-libraries","title":"Client libraries","text":"<p>It's easy to connect your application to a Redis database. The official client libraries cover the following languages:</p> <ul> <li>C#/.NET</li> <li>Go</li> <li>Java</li> <li>Node.js</li> <li>Python</li> </ul> <p>You can find a complete list of all client libraries, including the community-maintained ones, on the clients page.</p>"},{"location":"3-connect/cli/","title":"Redis CLI","text":"<p>In interactive mode, <code>redis-cli</code> has basic line editing capabilities to provide a familiar typing experience.</p> <p>To launch the program in special modes, you can use several options, including:</p> <ul> <li>Simulate a replica and print the replication stream it receives from the primary.</li> <li>Check the latency of a Redis server and display statistics. </li> <li>Request ASCII-art spectrogram of latency samples and frequencies.</li> </ul> <p>This topic covers the different aspects of <code>redis-cli</code>, starting from the simplest and ending with the more advanced features.</p>"},{"location":"3-connect/cli/#command-line-usage","title":"Command line usage","text":"<p>To run a Redis command and return a standard output at the terminal, include the command to execute as separate arguments of <code>redis-cli</code>:</p> <pre><code>$ redis-cli INCR mycounter\n(integer) 7\n</code></pre> <p>The reply of the command is \"7\". Since Redis replies are typed (strings, arrays, integers, nil, errors, etc.), you see the type of the reply between parentheses. This additional information may not be ideal when the output of <code>redis-cli</code> must be used as input of another command or redirected into a file.</p> <p><code>redis-cli</code> only shows additional information for human readability when it detects the standard output is a tty, or terminal. For all other outputs it will auto-enable the raw output mode, as in the following example:</p> <pre><code>$ redis-cli INCR mycounter &gt; /tmp/output.txt\n$ cat /tmp/output.txt\n8\n</code></pre> <p>Note that <code>(integer)</code> is omitted from the output because <code>redis-cli</code> detects the output is no longer written to the terminal. You can force raw output even on the terminal with the <code>--raw</code> option:</p> <pre><code>$ redis-cli --raw INCR mycounter\n9\n</code></pre> <p>You can force human readable output when writing to a file or in pipe to other commands by using <code>--no-raw</code>.</p>"},{"location":"3-connect/cli/#string-quoting-and-escaping","title":"String quoting and escaping","text":"<p>When <code>redis-cli</code> parses a command, whitespace characters automatically delimit the arguments. In interactive mode, a newline sends the command for parsing and execution. To input string values that contain whitespaces or non-printable characters, you can use quoted and escaped strings.</p> <p>Quoted string values are enclosed in double (<code>\"</code>) or single (<code>'</code>) quotation marks. Escape sequences are used to put nonprintable characters in character and string literals.</p> <p>An escape sequence contains a backslash (<code>\\</code>) symbol followed by one of the escape sequence characters.</p> <p>Doubly-quoted strings support the following escape sequences:</p> <ul> <li><code>\\\"</code> - double-quote</li> <li><code>\\n</code> - newline</li> <li><code>\\r</code> - carriage return</li> <li><code>\\t</code> - horizontal tab</li> <li><code>\\b</code> - backspace</li> <li><code>\\a</code> - alert</li> <li><code>\\\\</code> - backslash</li> <li><code>\\xhh</code> - any ASCII character represented by a hexadecimal number (hh)</li> </ul> <p>Single quotes assume the string is literal, and allow only the following escape sequences: * <code>\\'</code> - single quote * <code>\\\\</code> - backslash</p> <p>For example, to return <code>Hello World</code> on two lines:</p> <pre><code>127.0.0.1:6379&gt; SET mykey \"Hello\\nWorld\"\nOK\n127.0.0.1:6379&gt; GET mykey\nHello\nWorld\n</code></pre> <p>When you input strings that contain single or double quotes, as you might in passwords, for example, escape the string, like so: </p> <p><code>127.0.0.1:6379&gt; AUTH some_admin_user \"&gt;^8T&gt;6Na{u|jp&gt;+v\\\"55\\@_;OU(OR]7mbAYGqsfyu48(j'%hQH7;v*f1H${*gD(Se'\"</code></p>"},{"location":"3-connect/cli/#host-port-password-and-database","title":"Host, port, password, and database","text":"<p>By default, <code>redis-cli</code> connects to the server at the address 127.0.0.1 with port 6379. You can change the port using several command line options. To specify a different host name or an IP address, use the <code>-h</code> option. In order to set a different port, use <code>-p</code>.</p> <pre><code>$ redis-cli -h redis15.localnet.org -p 6390 PING\nPONG\n</code></pre> <p>If your instance is password protected, the <code>-a &lt;password&gt;</code> option will perform authentication saving the need of explicitly using the <code>AUTH</code> command:</p> <pre><code>$ redis-cli -a myUnguessablePazzzzzword123 PING\nPONG\n</code></pre> <p>NOTE: For security reasons, provide the password to <code>redis-cli</code> automatically via the <code>REDISCLI_AUTH</code> environment variable.</p> <p>Finally, it's possible to send a command that operates on a database number other than the default number zero by using the <code>-n &lt;dbnum&gt;</code> option:</p> <pre><code>$ redis-cli FLUSHALL\nOK\n$ redis-cli -n 1 INCR a\n(integer) 1\n$ redis-cli -n 1 INCR a\n(integer) 2\n$ redis-cli -n 2 INCR a\n(integer) 1\n</code></pre> <p>Some or all of this information can also be provided by using the <code>-u &lt;uri&gt;</code> option and the URI pattern <code>redis://user:password@host:port/dbnum</code>:</p> <pre><code>$ redis-cli -u redis://LJenkins:p%40ssw0rd@redis-16379.hosted.com:16379/0 PING\nPONG\n</code></pre> <p>NOTE: User, password and dbnum are optional. For authentication without a username, use username <code>default</code>. For TLS, use the scheme <code>rediss</code>.</p>"},{"location":"3-connect/cli/#ssltls","title":"SSL/TLS","text":"<p>By default, <code>redis-cli</code> uses a plain TCP connection to connect to Redis. You may enable SSL/TLS using the <code>--tls</code> option, along with <code>--cacert</code> or <code>--cacertdir</code> to configure a trusted root certificate bundle or directory.</p> <p>If the target server requires authentication using a client side certificate, you can specify a certificate and a corresponding private key using <code>--cert</code> and <code>--key</code>.</p>"},{"location":"3-connect/cli/#getting-input-from-other-programs","title":"Getting input from other programs","text":"<p>There are two ways you can use <code>redis-cli</code> in order to receive input from other commands via the standard input. One is to use the target payload as the last argument from stdin. For example, in order to set the Redis key <code>net_services</code> to the content of the file <code>/etc/services</code> from a local file system, use the <code>-x</code> option:</p> <pre><code>$ redis-cli -x SET net_services &lt; /etc/services\nOK\n$ redis-cli GETRANGE net_services 0 50\n\"#\\n# Network services, Internet style\\n#\\n# Note that \"\n</code></pre> <p>In the first line of the above session, <code>redis-cli</code> was executed with the <code>-x</code> option and a file was redirected to the CLI's standard input as the value to satisfy the <code>SET net_services</code> command phrase. This is useful for scripting.</p> <p>A different approach is to feed <code>redis-cli</code> a sequence of commands written in a text file:</p> <pre><code>$ cat /tmp/commands.txt\nSET item:3374 100\nINCR item:3374\nAPPEND item:3374 xxx\nGET item:3374\n$ cat /tmp/commands.txt | redis-cli\nOK\n(integer) 101\n(integer) 6\n\"101xxx\"\n</code></pre> <p>All the commands in <code>commands.txt</code> are executed consecutively by <code>redis-cli</code> as if they were typed by the user in interactive mode. Strings can be quoted inside the file if needed, so that it's possible to have single arguments with spaces, newlines, or other special characters:</p> <pre><code>$ cat /tmp/commands.txt\nSET arg_example \"This is a single argument\"\nSTRLEN arg_example\n$ cat /tmp/commands.txt | redis-cli\nOK\n(integer) 25\n</code></pre>"},{"location":"3-connect/cli/#continuously-run-the-same-command","title":"Continuously run the same command","text":"<p>It is possible to execute a single command a specified number of times with a user-selected pause between executions. This is useful in different contexts - for example when we want to continuously monitor some key content or <code>INFO</code> field output, or when we want to simulate some recurring write event, such as pushing a new item into a list every 5 seconds.</p> <p>This feature is controlled by two options: <code>-r &lt;count&gt;</code> and <code>-i &lt;delay&gt;</code>. The <code>-r</code> option states how many times to run a command and <code>-i</code> sets the delay between the different command calls in seconds (with the ability to specify values such as 0.1 to represent 100 milliseconds).</p> <p>By default the interval (or delay) is set to 0, so commands are just executed ASAP:</p> <pre><code>$ redis-cli -r 5 INCR counter_value\n(integer) 1\n(integer) 2\n(integer) 3\n(integer) 4\n(integer) 5\n</code></pre> <p>To run the same command indefinitely, use <code>-1</code> as the count value. To monitor over time the RSS memory size it's possible to use the following command:</p> <pre><code>$ redis-cli -r -1 -i 1 INFO | grep rss_human\nused_memory_rss_human:2.71M\nused_memory_rss_human:2.73M\nused_memory_rss_human:2.73M\nused_memory_rss_human:2.73M\n... a new line will be printed each second ...\n</code></pre>"},{"location":"3-connect/cli/#mass-insertion-of-data-using-redis-cli","title":"Mass insertion of data using <code>redis-cli</code>","text":"<p>Mass insertion using <code>redis-cli</code> is covered in a separate page as it is a worthwhile topic itself. Please refer to our mass insertion guide.</p>"},{"location":"3-connect/cli/#csv-output","title":"CSV output","text":"<p>A CSV (Comma Separated Values) output feature exists within <code>redis-cli</code> to export data from Redis to an external program.  </p> <pre><code>$ redis-cli LPUSH mylist a b c d\n(integer) 4\n$ redis-cli --csv LRANGE mylist 0 -1\n\"d\",\"c\",\"b\",\"a\"\n</code></pre> <p>Note that the <code>--csv</code> flag will only work on a single command, not the entirety of a DB as an export.</p>"},{"location":"3-connect/cli/#running-lua-scripts","title":"Running Lua scripts","text":"<p>The <code>redis-cli</code> has extensive support for using the debugging facility of Lua scripting, available with Redis 3.2 onwards. For this feature, refer to the Redis Lua debugger documentation.</p> <p>Even without using the debugger, <code>redis-cli</code> can be used to run scripts from a file as an argument:</p> <pre><code>$ cat /tmp/script.lua\nreturn redis.call('SET',KEYS[1],ARGV[1])\n$ redis-cli --eval /tmp/script.lua location:hastings:temp , 23\nOK\n</code></pre> <p>The Redis <code>EVAL</code> command takes the list of keys the script uses, and the other non key arguments, as different arrays. When calling <code>EVAL</code> you provide the number of keys as a number. </p> <p>When calling <code>redis-cli</code> with the <code>--eval</code> option above, there is no need to specify the number of keys explicitly. Instead it uses the convention of separating keys and arguments with a comma. This is why in the above call you see <code>location:hastings:temp , 23</code> as arguments.</p> <p>So <code>location:hastings:temp</code> will populate the <code>KEYS</code> array, and <code>23</code> the <code>ARGV</code> array.</p> <p>The <code>--eval</code> option is useful when writing simple scripts. For more complex work, the Lua debugger is recommended. It is possible to mix the two approaches, since the debugger can also execute scripts from an external file.</p>"},{"location":"3-connect/cli/#interactive-mode","title":"Interactive mode","text":"<p>We have explored how to use the Redis CLI as a command line program. This is useful for scripts and certain types of testing, however most people will spend the majority of time in <code>redis-cli</code> using its interactive mode.</p> <p>In interactive mode the user types Redis commands at the prompt. The command is sent to the server, processed, and the reply is parsed back and rendered into a simpler form to read.</p> <p>Nothing special is needed for running the <code>redis-cli</code> in interactive mode - just execute it without any arguments</p> <pre><code>$ redis-cli\n127.0.0.1:6379&gt; PING\nPONG\n</code></pre> <p>The string <code>127.0.0.1:6379&gt;</code> is the prompt. It displays the connected Redis server instance's hostname and port.</p> <p>The prompt updates as the connected server changes or when operating on a database different from the database number zero:</p> <pre><code>127.0.0.1:6379&gt; SELECT 2\nOK\n127.0.0.1:6379[2]&gt; DBSIZE\n(integer) 1\n127.0.0.1:6379[2]&gt; SELECT 0\nOK\n127.0.0.1:6379&gt; DBSIZE\n(integer) 503\n</code></pre>"},{"location":"3-connect/cli/#handling-connections-and-reconnections","title":"Handling connections and reconnections","text":"<p>Using the <code>CONNECT</code> command in interactive mode makes it possible to connect to a different instance, by specifying the hostname and port we want to connect to:</p> <pre><code>127.0.0.1:6379&gt; CONNECT metal 6379\nmetal:6379&gt; PING\nPONG\n</code></pre> <p>As you can see the prompt changes accordingly when connecting to a different server instance. If a connection is attempted to an instance that is unreachable, the <code>redis-cli</code> goes into disconnected mode and attempts to reconnect with each new command:</p> <pre><code>127.0.0.1:6379&gt; CONNECT 127.0.0.1 9999\nCould not connect to Redis at 127.0.0.1:9999: Connection refused\nnot connected&gt; PING\nCould not connect to Redis at 127.0.0.1:9999: Connection refused\nnot connected&gt; PING\nCould not connect to Redis at 127.0.0.1:9999: Connection refused\n</code></pre> <p>Generally after a disconnection is detected, <code>redis-cli</code> always attempts to reconnect transparently; if the attempt fails, it shows the error and enters the disconnected state. The following is an example of disconnection and reconnection:</p> <pre><code>127.0.0.1:6379&gt; INFO SERVER\nCould not connect to Redis at 127.0.0.1:6379: Connection refused\nnot connected&gt; PING\nPONG\n127.0.0.1:6379&gt; \n(now we are connected again)\n</code></pre> <p>When a reconnection is performed, <code>redis-cli</code> automatically re-selects the last database number selected. However, all other states about the connection is lost, such as within a MULTI/EXEC transaction:</p> <pre><code>$ redis-cli\n127.0.0.1:6379&gt; MULTI\nOK\n127.0.0.1:6379&gt; PING\nQUEUED\n\n( here the server is manually restarted )\n\n127.0.0.1:6379&gt; EXEC\n(error) ERR EXEC without MULTI\n</code></pre> <p>This is usually not an issue when using the <code>redis-cli</code> in interactive mode for testing, but this limitation should be known.</p>"},{"location":"3-connect/cli/#editing-history-completion-and-hints","title":"Editing, history, completion and hints","text":"<p>Because <code>redis-cli</code> uses the linenoise line editing library, it always has line editing capabilities, without depending on <code>libreadline</code> or other optional libraries.</p> <p>Command execution history can be accessed in order to avoid retyping commands by pressing the arrow keys (up and down). The history is preserved between restarts of the CLI, in a file named <code>.rediscli_history</code> inside the user home directory, as specified by the <code>HOME</code> environment variable. It is possible to use a different history filename by setting the <code>REDISCLI_HISTFILE</code> environment variable, and disable it by setting it to <code>/dev/null</code>.</p> <p>The <code>redis-cli</code> is also able to perform command-name completion by pressing the TAB key, as in the following example:</p> <pre><code>127.0.0.1:6379&gt; Z&lt;TAB&gt;\n127.0.0.1:6379&gt; ZADD&lt;TAB&gt;\n127.0.0.1:6379&gt; ZCARD&lt;TAB&gt;\n</code></pre> <p>Once Redis command name has been entered at the prompt, the <code>redis-cli</code> will display syntax hints. Like command history, this behavior can be turned on and off via the <code>redis-cli</code> preferences.</p>"},{"location":"3-connect/cli/#preferences","title":"Preferences","text":"<p>There are two ways to customize <code>redis-cli</code> behavior. The file <code>.redisclirc</code> in the home directory is loaded by the CLI on startup. You can override the file's default location by setting the <code>REDISCLI_RCFILE</code> environment variable to an alternative path. Preferences can also be set during a CLI session, in which  case they will last only the duration of the session.</p> <p>To set preferences, use the special <code>:set</code> command. The following preferences can be set, either by typing the command in the CLI or adding it to the <code>.redisclirc</code> file:</p> <ul> <li><code>:set hints</code> - enables syntax hints</li> <li><code>:set nohints</code> - disables syntax hints</li> </ul>"},{"location":"3-connect/cli/#running-the-same-command-n-times","title":"Running the same command N times","text":"<p>It is possible to run the same command multiple times in interactive mode by prefixing the command name by a number:</p> <pre><code>127.0.0.1:6379&gt; 5 INCR mycounter\n(integer) 1\n(integer) 2\n(integer) 3\n(integer) 4\n(integer) 5\n</code></pre>"},{"location":"3-connect/cli/#showing-help-about-redis-commands","title":"Showing help about Redis commands","text":"<p><code>redis-cli</code> provides online help for most Redis commands, using the <code>HELP</code> command. The command can be used in two forms:</p> <ul> <li><code>HELP @&lt;category&gt;</code> shows all the commands about a given category. The categories are: <ul> <li><code>@generic</code></li> <li><code>@string</code></li> <li><code>@list</code></li> <li><code>@set</code></li> <li><code>@sorted_set</code></li> <li><code>@hash</code></li> <li><code>@pubsub</code></li> <li><code>@transactions</code></li> <li><code>@connection</code></li> <li><code>@server</code></li> <li><code>@scripting</code></li> <li><code>@hyperloglog</code></li> <li><code>@cluster</code></li> <li><code>@geo</code></li> <li><code>@stream</code></li> </ul> </li> <li><code>HELP &lt;commandname&gt;</code> shows specific help for the command given as argument.</li> </ul> <p>For example in order to show help for the <code>PFADD</code> command, use:</p> <pre><code>127.0.0.1:6379&gt; HELP PFADD\n\nPFADD key element [element ...]\nsummary: Adds the specified elements to the specified HyperLogLog.\nsince: 2.8.9\n</code></pre> <p>Note that <code>HELP</code> supports TAB completion as well.</p>"},{"location":"3-connect/cli/#clearing-the-terminal-screen","title":"Clearing the terminal screen","text":"<p>Using the <code>CLEAR</code> command in interactive mode clears the terminal's screen.</p>"},{"location":"3-connect/cli/#special-modes-of-operation","title":"Special modes of operation","text":"<p>So far we saw two main modes of <code>redis-cli</code>.</p> <ul> <li>Command line execution of Redis commands.</li> <li>Interactive \"REPL\" usage.</li> </ul> <p>The CLI performs other auxiliary tasks related to Redis that are explained in the next sections:</p> <ul> <li>Monitoring tool to show continuous stats about a Redis server.</li> <li>Scanning a Redis database for very large keys.</li> <li>Key space scanner with pattern matching.</li> <li>Acting as a Pub/Sub client to subscribe to channels.</li> <li>Monitoring the commands executed into a Redis instance.</li> <li>Checking the latency of a Redis server in different ways.</li> <li>Checking the scheduler latency of the local computer.</li> <li>Transferring RDB backups from a remote Redis server locally.</li> <li>Acting as a Redis replica for showing what a replica receives.</li> <li>Simulating LRU workloads for showing stats about keys hits.</li> <li>A client for the Lua debugger.</li> </ul>"},{"location":"3-connect/cli/#continuous-stats-mode","title":"Continuous stats mode","text":"<p>Continuous stats mode is probably one of the lesser known yet very useful features of <code>redis-cli</code> to monitor Redis instances in real time. To enable this mode, the <code>--stat</code> option is used. The output is very clear about the behavior of the CLI in this mode:</p> <pre><code>$ redis-cli --stat\n------- data ------ --------------------- load -------------------- - child -\nkeys       mem      clients blocked requests            connections\n506        1015.00K 1       0       24 (+0)             7\n506        1015.00K 1       0       25 (+1)             7\n506        3.40M    51      0       60461 (+60436)      57\n506        3.40M    51      0       146425 (+85964)     107\n507        3.40M    51      0       233844 (+87419)     157\n507        3.40M    51      0       321715 (+87871)     207\n508        3.40M    51      0       408642 (+86927)     257\n508        3.40M    51      0       497038 (+88396)     257\n</code></pre> <p>In this mode a new line is printed every second with useful information and differences of request values between old data points. Memory usage, client connection counts, and various other statistics about the connected Redis database can be easily understood with this auxiliary <code>redis-cli</code> tool.</p> <p>The <code>-i &lt;interval&gt;</code> option in this case works as a modifier in order to change the frequency at which new lines are emitted. The default is one second.</p>"},{"location":"3-connect/cli/#scanning-for-big-keys","title":"Scanning for big keys","text":"<p>In this special mode, <code>redis-cli</code> works as a key space analyzer. It scans the dataset for big keys, but also provides information about the data types that the data set consists of. This mode is enabled with the <code>--bigkeys</code> option, and produces verbose output:</p> <pre><code>$ redis-cli --bigkeys\n\n# Scanning the entire keyspace to find biggest keys as well as\n# average sizes per key type.  You can use -i 0.01 to sleep 0.01 sec\n# per SCAN command (not usually needed).\n\n[00.00%] Biggest string found so far 'key-419' with 3 bytes\n[05.14%] Biggest list   found so far 'mylist' with 100004 items\n[35.77%] Biggest string found so far 'counter:__rand_int__' with 6 bytes\n[73.91%] Biggest hash   found so far 'myobject' with 3 fields\n\n-------- summary -------\n\nSampled 506 keys in the keyspace!\nTotal key length in bytes is 3452 (avg len 6.82)\n\nBiggest string found 'counter:__rand_int__' has 6 bytes\nBiggest   list found 'mylist' has 100004 items\nBiggest   hash found 'myobject' has 3 fields\n\n504 strings with 1403 bytes (99.60% of keys, avg size 2.78)\n1 lists with 100004 items (00.20% of keys, avg size 100004.00)\n0 sets with 0 members (00.00% of keys, avg size 0.00)\n1 hashs with 3 fields (00.20% of keys, avg size 3.00)\n0 zsets with 0 members (00.00% of keys, avg size 0.00)\n</code></pre> <p>In the first part of the output, each new key larger than the previous larger key (of the same type) encountered is reported. The summary section provides general stats about the data inside the Redis instance.</p> <p>The program uses the <code>SCAN</code> command, so it can be executed against a busy server without impacting the operations, however the <code>-i</code> option can be used in order to throttle the scanning process of the specified fraction of second for each <code>SCAN</code> command. </p> <p>For example, <code>-i 0.01</code> will slow down the program execution considerably, but will also reduce the load on the server to a negligible amount.</p> <p>Note that the summary also reports in a cleaner form the biggest keys found for each time. The initial output is just to provide some interesting info ASAP if running against a very large data set.</p>"},{"location":"3-connect/cli/#getting-a-list-of-keys","title":"Getting a list of keys","text":"<p>It is also possible to scan the key space, again in a way that does not block the Redis server (which does happen when you use a command like <code>KEYS *</code>), and print all the key names, or filter them for specific patterns. This mode, like the <code>--bigkeys</code> option, uses the <code>SCAN</code> command, so keys may be reported multiple times if the dataset is changing, but no key would ever be missing, if that key was present since the start of the iteration. Because of the command that it uses this option is called <code>--scan</code>.</p> <pre><code>$ redis-cli --scan | head -10\nkey-419\nkey-71\nkey-236\nkey-50\nkey-38\nkey-458\nkey-453\nkey-499\nkey-446\nkey-371\n</code></pre> <p>Note that <code>head -10</code> is used in order to print only the first ten lines of the output.</p> <p>Scanning is able to use the underlying pattern matching capability of the <code>SCAN</code> command with the <code>--pattern</code> option.</p> <pre><code>$ redis-cli --scan --pattern '*-11*'\nkey-114\nkey-117\nkey-118\nkey-113\nkey-115\nkey-112\nkey-119\nkey-11\nkey-111\nkey-110\nkey-116\n</code></pre> <p>Piping the output through the <code>wc</code> command can be used to count specific kind of objects, by key name:</p> <pre><code>$ redis-cli --scan --pattern 'user:*' | wc -l\n3829433\n</code></pre> <p>You can use <code>-i 0.01</code> to add a delay between calls to the <code>SCAN</code> command. This will make the command slower but will significantly reduce load on the server.</p>"},{"location":"3-connect/cli/#pubsub-mode","title":"Pub/sub mode","text":"<p>The CLI is able to publish messages in Redis Pub/Sub channels using the <code>PUBLISH</code> command. Subscribing to channels in order to receive messages is different - the terminal is blocked and waits for messages, so this is implemented as a special mode in <code>redis-cli</code>. Unlike other special modes this mode is not enabled by using a special option, but simply by using the <code>SUBSCRIBE</code> or <code>PSUBSCRIBE</code> command, which are available in interactive or command mode:</p> <pre><code>$ redis-cli PSUBSCRIBE '*'\nReading messages... (press Ctrl-C to quit)\n1) \"PSUBSCRIBE\"\n2) \"*\"\n3) (integer) 1\n</code></pre> <p>The reading messages message shows that we entered Pub/Sub mode. When another client publishes some message in some channel, such as with the command <code>redis-cli PUBLISH mychannel mymessage</code>, the CLI in Pub/Sub mode will show something such as:</p> <pre><code>1) \"pmessage\"\n2) \"*\"\n3) \"mychannel\"\n4) \"mymessage\"\n</code></pre> <p>This is very useful for debugging Pub/Sub issues. To exit the Pub/Sub mode just process <code>CTRL-C</code>.</p>"},{"location":"3-connect/cli/#monitoring-commands-executed-in-redis","title":"Monitoring commands executed in Redis","text":"<p>Similarly to the Pub/Sub mode, the monitoring mode is entered automatically once you use the <code>MONITOR</code> command. All commands received by the active Redis instance will be printed to the standard output:</p> <pre><code>$ redis-cli MONITOR\nOK\n1460100081.165665 [0 127.0.0.1:51706] \"set\" \"shipment:8000736522714:status\" \"sorting\"\n1460100083.053365 [0 127.0.0.1:51707] \"get\" \"shipment:8000736522714:status\"\n</code></pre> <p>Note that it is possible to pipe the output, so you can monitor for specific patterns using tools such as <code>grep</code>.</p>"},{"location":"3-connect/cli/#monitoring-the-latency-of-redis-instances","title":"Monitoring the latency of Redis instances","text":"<p>Redis is often used in contexts where latency is very critical. Latency involves multiple moving parts within the application, from the client library to the network stack, to the Redis instance itself.</p> <p>The <code>redis-cli</code> has multiple facilities for studying the latency of a Redis instance and understanding the latency's maximum, average and distribution.</p> <p>The basic latency-checking tool is the <code>--latency</code> option. Using this option the CLI runs a loop where the <code>PING</code> command is sent to the Redis instance and the time to receive a reply is measured. This happens 100 times per second, and stats are updated in a real time in the console:</p> <pre><code>$ redis-cli --latency\nmin: 0, max: 1, avg: 0.19 (427 samples)\n</code></pre> <p>The stats are provided in milliseconds. Usually, the average latency of a very fast instance tends to be overestimated a bit because of the latency due to the kernel scheduler of the system running <code>redis-cli</code> itself, so the average latency of 0.19 above may easily be 0.01 or less. However this is usually not a big problem, since most developers are interested in events of a few milliseconds or more.</p> <p>Sometimes it is useful to study how the maximum and average latencies evolve during time. The <code>--latency-history</code> option is used for that purpose: it works exactly like <code>--latency</code>, but every 15 seconds (by default) a new sampling session is started from scratch:</p> <pre><code>$ redis-cli --latency-history\nmin: 0, max: 1, avg: 0.14 (1314 samples) -- 15.01 seconds range\nmin: 0, max: 1, avg: 0.18 (1299 samples) -- 15.00 seconds range\nmin: 0, max: 1, avg: 0.20 (113 samples)^C\n</code></pre> <p>Sampling sessions' length can be changed with the <code>-i &lt;interval&gt;</code> option.</p> <p>The most advanced latency study tool, but also the most complex to interpret for non-experienced users, is the ability to use color terminals to show a spectrum of latencies. You'll see a colored output that indicates the different percentages of samples, and different ASCII characters that indicate different latency figures. This mode is enabled using the <code>--latency-dist</code> option:</p> <pre><code>$ redis-cli --latency-dist\n(output not displayed, requires a color terminal, try it!)\n</code></pre> <p>There is another pretty unusual latency tool implemented inside <code>redis-cli</code>. It does not check the latency of a Redis instance, but the latency of the computer running <code>redis-cli</code>. This latency is intrinsic to the kernel scheduler,  the hypervisor in case of virtualized instances, and so forth.</p> <p>Redis calls it intrinsic latency because it's mostly opaque to the programmer. If the Redis instance has high latency regardless of all the obvious things that may be the source cause, it's worth to check what's the best your system can do by running <code>redis-cli</code> in this special mode directly in the system you are running Redis servers on.</p> <p>By measuring the intrinsic latency, you know that this is the baseline, and Redis cannot outdo your system. In order to run the CLI in this mode, use the <code>--intrinsic-latency &lt;test-time&gt;</code>. Note that the test time is in seconds and dictates how long the test should run.</p> <pre><code>$ ./redis-cli --intrinsic-latency 5\nMax latency so far: 1 microseconds.\nMax latency so far: 7 microseconds.\nMax latency so far: 9 microseconds.\nMax latency so far: 11 microseconds.\nMax latency so far: 13 microseconds.\nMax latency so far: 15 microseconds.\nMax latency so far: 34 microseconds.\nMax latency so far: 82 microseconds.\nMax latency so far: 586 microseconds.\nMax latency so far: 739 microseconds.\n\n65433042 total runs (avg latency: 0.0764 microseconds / 764.14 nanoseconds per run).\nWorst run took 9671x longer than the average latency.\n</code></pre> <p>IMPORTANT: this command must be executed on the computer that runs the Redis server instance, not on a different host. It does not connect to a Redis instance and performs the test locally.</p> <p>In the above case, the system cannot do better than 739 microseconds of worst case latency, so one can expect certain queries to occasionally run less than 1 millisecond.</p>"},{"location":"3-connect/cli/#remote-backups-of-rdb-files","title":"Remote backups of RDB files","text":"<p>During a Redis replication's first synchronization, the primary and the replica exchange the whole data set in the form of an RDB file. This feature is exploited by <code>redis-cli</code> in order to provide a remote backup facility that allows a transfer of an RDB file from any Redis instance to the local computer running <code>redis-cli</code>. To use this mode, call the CLI with the <code>--rdb &lt;dest-filename&gt;</code> option:</p> <pre><code>$ redis-cli --rdb /tmp/dump.rdb\nSYNC sent to master, writing 13256 bytes to '/tmp/dump.rdb'\nTransfer finished with success.\n</code></pre> <p>This is a simple but effective way to ensure disaster recovery RDB backups exist of your Redis instance. When using this options in scripts or <code>cron</code> jobs, make sure to check the return value of the command. If it is non zero, an error occurred as in the following example:</p> <pre><code>$ redis-cli --rdb /tmp/dump.rdb\nSYNC with master failed: -ERR Can't SYNC while not connected with my master\n$ echo $?\n1\n</code></pre>"},{"location":"3-connect/cli/#replica-mode","title":"Replica mode","text":"<p>The replica mode of the CLI is an advanced feature useful for Redis developers and for debugging operations. It allows for the inspection of the content a primary sends to its replicas in the replication stream in order to propagate the writes to its replicas. The option name is simply <code>--replica</code>. The following is a working example:</p> <pre><code>$ redis-cli --replica\nSYNC with master, discarding 13256 bytes of bulk transfer...\nSYNC done. Logging commands from master.\n\"PING\"\n\"SELECT\",\"0\"\n\"SET\",\"last_name\",\"Enigk\"\n\"PING\"\n\"INCR\",\"mycounter\"\n</code></pre> <p>The command begins by discarding the RDB file of the first synchronization and then logs each command received in CSV format.</p> <p>If you think some of the commands are not replicated correctly in your replicas this is a good way to check what's happening, and also useful information in order to improve the bug report.</p>"},{"location":"3-connect/cli/#performing-an-lru-simulation","title":"Performing an LRU simulation","text":"<p>Redis is often used as a cache with LRU eviction. Depending on the number of keys and the amount of memory allocated for the cache (specified via the <code>maxmemory</code> directive), the amount of cache hits and misses will change. Sometimes, simulating the rate of hits is very useful to correctly provision your cache.</p> <p>The <code>redis-cli</code> has a special mode where it performs a simulation of GET and SET operations, using an 80-20% power law distribution in the requests pattern. This means that 20% of keys will be requested 80% of times, which is a common distribution in caching scenarios.</p> <p>Theoretically, given the distribution of the requests and the Redis memory overhead, it should be possible to compute the hit rate analytically with a mathematical formula. However, Redis can be configured with different LRU settings (number of samples) and LRU's implementation, which is approximated in Redis, changes a lot between different versions. Similarly the amount of memory per key may change between versions. That is why this tool was built: its main motivation was for testing the quality of Redis' LRU implementation, but now is also useful for testing how a given version behaves with the settings originally intended for deployment.</p> <p>To use this mode, specify the amount of keys in the test and configure a sensible <code>maxmemory</code> setting as a first attempt.</p> <p>IMPORTANT NOTE: Configuring the <code>maxmemory</code> setting in the Redis configuration is crucial: if there is no cap to the maximum memory usage, the hit will eventually be 100% since all the keys can be stored in memory. If too many keys are specified with maximum memory, eventually all of the computer RAM will be used. It is also needed to configure an appropriate maxmemory policy; most of the time <code>allkeys-lru</code> is selected.</p> <p>In the following example there is a configured a memory limit of 100MB and an LRU simulation using 10 million keys.</p> <p>WARNING: the test uses pipelining and will stress the server, don't use it with production instances.</p> <pre><code>$ ./redis-cli --lru-test 10000000\n156000 Gets/sec | Hits: 4552 (2.92%) | Misses: 151448 (97.08%)\n153750 Gets/sec | Hits: 12906 (8.39%) | Misses: 140844 (91.61%)\n159250 Gets/sec | Hits: 21811 (13.70%) | Misses: 137439 (86.30%)\n151000 Gets/sec | Hits: 27615 (18.29%) | Misses: 123385 (81.71%)\n145000 Gets/sec | Hits: 32791 (22.61%) | Misses: 112209 (77.39%)\n157750 Gets/sec | Hits: 42178 (26.74%) | Misses: 115572 (73.26%)\n154500 Gets/sec | Hits: 47418 (30.69%) | Misses: 107082 (69.31%)\n151250 Gets/sec | Hits: 51636 (34.14%) | Misses: 99614 (65.86%)\n</code></pre> <p>The program shows stats every second. In the first seconds the cache starts to be populated. The misses rate later stabilizes into the actual figure that can be expected:</p> <pre><code>120750 Gets/sec | Hits: 48774 (40.39%) | Misses: 71976 (59.61%)\n122500 Gets/sec | Hits: 49052 (40.04%) | Misses: 73448 (59.96%)\n127000 Gets/sec | Hits: 50870 (40.06%) | Misses: 76130 (59.94%)\n124250 Gets/sec | Hits: 50147 (40.36%) | Misses: 74103 (59.64%)\n</code></pre> <p>A miss rate of 59% may not be acceptable for certain use cases therefor 100MB of memory is not enough. Observe an example using a half gigabyte of memory. After several minutes the output stabilizes to the following figures:</p> <pre><code>140000 Gets/sec | Hits: 135376 (96.70%) | Misses: 4624 (3.30%)\n141250 Gets/sec | Hits: 136523 (96.65%) | Misses: 4727 (3.35%)\n140250 Gets/sec | Hits: 135457 (96.58%) | Misses: 4793 (3.42%)\n140500 Gets/sec | Hits: 135947 (96.76%) | Misses: 4553 (3.24%)\n</code></pre> <p>With 500MB there is sufficient space for the key quantity (10 million) and distribution (80-20 style).</p>"},{"location":"3-connect/clients/_index/","title":"Connect with Redis clients","text":"<p>Here, you will learn how to connect your application to a Redis database. If you're new to Redis, you might first want to install Redis with Redis Stack and RedisInsight.</p> <p>For more Redis topics, see Using and Managing Redis.</p> <p>If you're ready to get started, see the following guides for the official client libraries you can use with Redis. For a complete list of community-driven clients, see Clients.</p>"},{"location":"3-connect/clients/_index/#high-level-client-libraries","title":"High-level client libraries","text":"<p>The Redis OM client libraries let you use the document modeling, indexing, and querying capabilities of Redis Stack much like the way you'd use an ORM. The following Redis OM libraries support Redis Stack:</p> <ul> <li>Redis OM .NET</li> <li>Redis OM Node</li> <li>Redis OM Python</li> <li>Redis OM Spring</li> </ul>"},{"location":"3-connect/clients/dotnet/","title":"C#/.NET guide","text":"<p>Install Redis and the Redis client, then connect your .NET application to a Redis database. </p>"},{"location":"3-connect/clients/dotnet/#nredisstack","title":"NRedisStack","text":"<p>NRedisStack is a .NET client for Redis. <code>NredisStack</code> requires a running Redis or Redis Stack server. See Getting started for Redis installation instructions.</p>"},{"location":"3-connect/clients/dotnet/#install","title":"Install","text":"<p>Using the <code>dotnet</code> CLI, run:</p> <pre><code>dotnet add package NRedisStack\n</code></pre>"},{"location":"3-connect/clients/dotnet/#connect","title":"Connect","text":"<p>Connect to localhost on port 6379.</p> <pre><code>using NRedisStack;\nusing NRedisStack.RedisStackCommands;\nusing StackExchange.Redis;\n//...\nConnectionMultiplexer redis = ConnectionMultiplexer.Connect(\"localhost\");\nIDatabase db = redis.GetDatabase();\n</code></pre> <p>Store and retrieve a simple string.</p> <pre><code>db.StringSet(\"foo\", \"bar\");\nConsole.WriteLine(db.StringGet(\"foo\")); // prints bar\n</code></pre> <p>Store and retrieve a HashMap.</p> <pre><code>var hash = new HashEntry[] { \n    new HashEntry(\"name\", \"John\"), \n    new HashEntry(\"surname\", \"Smith\"),\n    new HashEntry(\"company\", \"Redis\"),\n    new HashEntry(\"age\", \"29\"),\n    };\ndb.HashSet(\"user-session:123\", hash);\n\nvar hashFields = db.HashGetAll(\"user-session:123\");\nConsole.WriteLine(String.Join(\"; \", hashFields));\n// Prints: \n// name: John; surname: Smith; company: Redis; age: 29\n</code></pre> <p>To access Redis Stack capabilities, you should use appropriate interface like this:</p> <pre><code>IBloomCommands bf = db.BF();\nICuckooCommands cf = db.CF();\nICmsCommands cms = db.CMS();\nIGraphCommands graph = db.GRAPH();\nITopKCommands topk = db.TOPK();\nITdigestCommands tdigest = db.TDIGEST();\nISearchCommands ft = db.FT();\nIJsonCommands json = db.JSON();\nITimeSeriesCommands ts = db.TS();\n</code></pre>"},{"location":"3-connect/clients/dotnet/#connect-to-a-redis-cluster","title":"Connect to a Redis cluster","text":"<p>To connect to a Redis cluster, you just need to specify one or all cluster endpoints in the client configuration:</p> <pre><code>ConfigurationOptions options = new ConfigurationOptions\n{\n    //list of available nodes of the cluster along with the endpoint port.\n    EndPoints = {\n        { \"localhost\", 16379 },\n        { \"localhost\", 16380 },\n        // ...\n    },            \n};\n\nConnectionMultiplexer cluster = ConnectionMultiplexer.Connect(options);\nIDatabase db = cluster.GetDatabase();\n\ndb.StringSet(\"foo\", \"bar\");\nConsole.WriteLine(db.StringGet(\"foo\")); // prints bar\n</code></pre>"},{"location":"3-connect/clients/dotnet/#connect-to-your-production-redis-with-tls","title":"Connect to your production Redis with TLS","text":"<p>When you deploy your application, use TLS and follow the Redis security guidelines.</p> <p>Before connecting your application to the TLS-enabled Redis server, ensure that your certificates and private keys are in the correct format.</p> <p>To convert user certificate and private key from the PEM format to <code>pfx</code>, use this command:</p> <pre><code>openssl pkcs12 -inkey redis_user_private.key -in redis_user.crt -export -out redis.pfx\n</code></pre> <p>Enter password to protect your <code>pfx</code> file.</p> <p>Establish a secure connection with your Redis database using this snippet.</p> <pre><code>ConfigurationOptions options = new ConfigurationOptions\n{\n    EndPoints = { { \"my-redis.cloud.redislabs.com\", 6379 } },\n    User = \"default\",  // use your Redis user. More info https://redis.io/docs/management/security/acl/\n    Password = \"secret\", // use your Redis password\n    Ssl = true,\n    SslProtocols = System.Security.Authentication.SslProtocols.Tls12                \n};\n\noptions.CertificateSelection += delegate\n{\n    return new X509Certificate2(\"redis.pfx\", \"secret\"); // use the password you specified for pfx file\n};\noptions.CertificateValidation += ValidateServerCertificate;\n\nbool ValidateServerCertificate(\n        object sender,\n        X509Certificate? certificate,\n        X509Chain? chain,\n        SslPolicyErrors sslPolicyErrors)\n{\n    if (certificate == null) {\n        return false;       \n    }\n\n    var ca = new X509Certificate2(\"redis_ca.pem\");\n    bool verdict = (certificate.Issuer == ca.Subject);\n    if (verdict) {\n        return true;\n    }\n    Console.WriteLine(\"Certificate error: {0}\", sslPolicyErrors);\n    return false;\n}\n\nConnectionMultiplexer muxer = ConnectionMultiplexer.Connect(options);   \n\n//Creation of the connection to the DB\nIDatabase conn = muxer.GetDatabase();\n\n//send SET command\nconn.StringSet(\"foo\", \"bar\");\n\n//send GET command and print the value\nConsole.WriteLine(conn.StringGet(\"foo\"));   \n</code></pre>"},{"location":"3-connect/clients/dotnet/#example-indexing-and-querying-json-documents","title":"Example: Indexing and querying JSON documents","text":"<p>This example shows how to convert Redis search results to JSON format using <code>NRedisStack</code>.</p> <p>Make sure that you have Redis Stack and <code>NRedisStack</code> installed. </p> <p>Import dependencies and connect to the Redis server:</p> <pre><code>using NRedisStack;\nusing NRedisStack.RedisStackCommands;\nusing NRedisStack.Search;\nusing NRedisStack.Search.Aggregation;\nusing NRedisStack.Search.Literals.Enums;\nusing StackExchange.Redis;\n\n// ...\n\nConnectionMultiplexer redis = ConnectionMultiplexer.Connect(\"localhost\");\n</code></pre> <p>Get a reference to the database and for search and JSON commands.</p> <pre><code>var db = redis.GetDatabase();\nvar ft = db.FT();\nvar json = db.JSON();\n</code></pre> <p>Let's create some test data to add to your database.</p> <pre><code>var user1 = new {\n    name = \"Paul John\",\n    email = \"paul.john@example.com\",\n    age = 42,\n    city = \"London\"\n};\n\nvar user2 = new {\n    name = \"Eden Zamir\",\n    email = \"eden.zamir@example.com\",\n    age = 29,\n    city = \"Tel Aviv\"\n};\n\nvar user3 = new {\n    name = \"Paul Zamir\",\n    email = \"paul.zamir@example.com\",\n    age = 35,\n    city = \"Tel Aviv\"\n};\n</code></pre> <p>Create an index. In this example, all JSON documents with the key prefix <code>user:</code> are indexed. For more information, see Query syntax.</p> <pre><code>var schema = new Schema()\n    .AddTextField(new FieldName(\"$.name\", \"name\"))\n    .AddTagField(new FieldName(\"$.city\", \"city\"))\n    .AddNumericField(new FieldName(\"$.age\", \"age\"));\n\nft.Create(\n    \"idx:users\",\n    new FTCreateParams().On(IndexDataType.JSON).Prefix(\"user:\"),\n    schema);\n</code></pre> <p>Use <code>JSON.SET</code> to set each user value at the specified path.</p> <pre><code>json.Set(\"user:1\", \"$\", user1);\njson.Set(\"user:2\", \"$\", user2);\njson.Set(\"user:3\", \"$\", user3);\n</code></pre> <p>Let's find user <code>Paul</code> and filter the results by age.</p> <pre><code>var res = ft.Search(\"idx:users\", new Query(\"Paul @age:[30 40]\")).Documents.Select(x =&gt; x[\"json\"]);\nConsole.WriteLine(string.Join(\"\\n\", res)); \n// Prints: {\"name\":\"Paul Zamir\",\"email\":\"paul.zamir@example.com\",\"age\":35,\"city\":\"Tel Aviv\"}\n</code></pre> <p>Return only the <code>city</code> field.</p> <pre><code>var res_cities = ft.Search(\"idx:users\", new Query(\"Paul\").ReturnFields(new FieldName(\"$.city\", \"city\"))).Documents.Select(x =&gt; x[\"city\"]);\nConsole.WriteLine(string.Join(\", \", res_cities)); \n// Prints: London, Tel Aviv\n</code></pre> <p>Count all users in the same city.</p> <pre><code>var request = new AggregationRequest(\"*\").GroupBy(\"@city\", Reducers.Count().As(\"count\"));\nvar result = ft.Aggregate(\"idx:users\", request);\n\nfor (var i=0; i&lt;result.TotalResults; i++)\n{\n    var row = result.GetRow(i);\n    Console.WriteLine($\"{row[\"city\"]} - {row[\"count\"]}\");\n}\n// Prints:\n// London - 1\n// Tel Aviv - 2\n</code></pre>"},{"location":"3-connect/clients/dotnet/#learn-more","title":"Learn more","text":"<ul> <li>GitHub</li> </ul>"},{"location":"3-connect/clients/go/","title":"Go guide","text":"<p>Install Redis and the Redis client, then connect your Go application to a Redis database. </p>"},{"location":"3-connect/clients/go/#go-redis","title":"go-redis","text":"<p>go-redis provides Go clients for various flavors of Redis and a type-safe API for each Redis command.</p>"},{"location":"3-connect/clients/go/#install","title":"Install","text":"<p><code>go-redis</code> supports last two Go versions and only works with Go modules.  So, first, you need to initialize a Go module:</p> <pre><code>go mod init github.com/my/repo\n</code></pre> <p>To install go-redis/v9:</p> <pre><code>go get github.com/redis/go-redis/v9\n</code></pre>"},{"location":"3-connect/clients/go/#connect","title":"Connect","text":"<p>To connect to a Redis server:</p> <pre><code>import (\n    \"context\"\n    \"fmt\"\n    \"github.com/redis/go-redis/v9\"\n)\n\nfunc main() {\n    client := redis.NewClient(&amp;redis.Options{\n        Addr:     \"localhost:6379\",\n        Password: \"\", // no password set\n        DB:       0,  // use default DB\n    })\n}\n</code></pre> <p>Another way to connect is using a connection string.</p> <pre><code>opt, err := redis.ParseURL(\"redis://&lt;user&gt;:&lt;pass&gt;@localhost:6379/&lt;db&gt;\")\nif err != nil {\n    panic(err)\n}\n\nclient := redis.NewClient(opt)\n</code></pre> <p>Store and retrieve a simple string.</p> <pre><code>ctx := context.Background()\n\nerr := client.Set(ctx, \"foo\", \"bar\", 0).Err()\nif err != nil {\n    panic(err)\n}\n\nval, err := client.Get(ctx, \"foo\").Result()\nif err != nil {\n    panic(err)\n}\nfmt.Println(\"foo\", val)\n</code></pre> <p>Store and retrieve a map.</p> <pre><code>session := map[string]string{\"name\": \"John\", \"surname\": \"Smith\", \"company\": \"Redis\", \"age\": \"29\"}\nfor k, v := range session {\n    err := client.HSet(ctx, \"user-session:123\", k, v).Err()\n    if err != nil {\n        panic(err)\n    }\n}\n\nuserSession := client.HGetAll(ctx, \"user-session:123\").Val()\nfmt.Println(userSession)\n ```\n\n#### Connect to a Redis cluster\n\nTo connect to a Redis cluster, use `NewClusterClient`. \n\n```go\nclient := redis.NewClusterClient(&amp;redis.ClusterOptions{\n    Addrs: []string{\":16379\", \":16380\", \":16381\", \":16382\", \":16383\", \":16384\"},\n\n    // To route commands by latency or randomly, enable one of the following.\n    //RouteByLatency: true,\n    //RouteRandomly: true,\n})\n</code></pre>"},{"location":"3-connect/clients/go/#connect-to-your-production-redis-with-tls","title":"Connect to your production Redis with TLS","text":"<p>When you deploy your application, use TLS and follow the Redis security guidelines.</p> <p>Establish a secure connection with your Redis database using this snippet.</p> <pre><code>// Load client cert\ncert, err := tls.LoadX509KeyPair(\"redis_user.crt\", \"redis_user_private.key\")\nif err != nil {\n    log.Fatal(err)\n}\n\n// Load CA cert\ncaCert, err := os.ReadFile(\"redis_ca.pem\")\nif err != nil {\n    log.Fatal(err)\n}\ncaCertPool := x509.NewCertPool()\ncaCertPool.AppendCertsFromPEM(caCert)\n\nclient := redis.NewClient(&amp;redis.Options{\n    Addr:     \"my-redis.cloud.redislabs.com:6379\",\n    Username: \"default\", // use your Redis user. More info https://redis.io/docs/management/security/acl/\n    Password: \"secret\", // use your Redis password\n    TLSConfig: &amp;tls.Config{\n        MinVersion:   tls.VersionTLS12,\n        Certificates: []tls.Certificate{cert},\n        RootCAs:      caCertPool,\n    },\n})\n\n//send SET command\nerr = client.Set(ctx, \"foo\", \"bar\", 0).Err()\nif err != nil {\n    panic(err)\n}\n\n//send GET command and print the value\nval, err := client.Get(ctx, \"foo\").Result()\nif err != nil {\n    panic(err)\n}\nfmt.Println(\"foo\", val)\n</code></pre>"},{"location":"3-connect/clients/go/#dial-tcp-io-timeout","title":"dial tcp: i/o timeout","text":"<p>You get a <code>dial tcp: i/o timeout</code> error when <code>go-redis</code> can't connect to the Redis Server, for example, when the server is down or the port is protected by a firewall. To check if Redis Server is listening on the port, run telnet command on the host where the <code>go-redis</code> client is running.</p> <pre><code>telnet localhost 6379\nTrying 127.0.0.1...\ntelnet: Unable to connect to remote host: Connection refused\n</code></pre> <p>If you use Docker, Istio, or any other service mesh/sidecar, make sure the app starts after the container is fully available, for example, by configuring healthchecks with Docker and holdApplicationUntilProxyStarts with Istio.  For more information, see Healthcheck.</p>"},{"location":"3-connect/clients/go/#learn-more","title":"Learn more","text":"<ul> <li>Documentation</li> <li>GitHub</li> </ul>"},{"location":"3-connect/clients/java/","title":"Java guide","text":"<p>Install Redis and the Redis client, then connect your Java application to a Redis database. </p>"},{"location":"3-connect/clients/java/#jedis","title":"Jedis","text":"<p>Jedis is a Java client for Redis designed for performance and ease of use.</p>"},{"location":"3-connect/clients/java/#install","title":"Install","text":"<p>To include <code>Jedis</code> as a dependency in your application, edit the dependency file, as follows.</p> <ul> <li>If you use Maven:   </li> </ul> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;redis.clients&lt;/groupId&gt;\n    &lt;artifactId&gt;jedis&lt;/artifactId&gt;\n    &lt;version&gt;4.3.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <ul> <li>If you use Gradle: </li> </ul> <pre><code>repositories {\n    mavenCentral()\n}\n//...\ndependencies {\n    implementation 'redis.clients:jedis:4.3.1'\n    //...\n}\n</code></pre> <ul> <li> <p>If you use the JAR files, download the latest Jedis and Apache Commons Pool2 JAR files from Maven Central or any other Maven repository.</p> </li> <li> <p>Build from source</p> </li> </ul>"},{"location":"3-connect/clients/java/#connect","title":"Connect","text":"<p>For many applications, it's best to use a connection pool. You can instantiate and use a <code>Jedis</code> connection pool like so:</p> <pre><code>package org.example;\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.JedisPool;\n\npublic class Main {\n    public static void main(String[] args) {\n        JedisPool pool = new JedisPool(\"localhost\", 6379);\n\n        try (Jedis jedis = pool.getResource()) {\n            // Store &amp; Retrieve a simple string\n            jedis.set(\"foo\", \"bar\");\n            System.out.println(jedis.get(\"foo\")); // prints bar\n\n            // Store &amp; Retrieve a HashMap\n            Map&lt;String, String&gt; hash = new HashMap&lt;&gt;();;\n            hash.put(\"name\", \"John\");\n            hash.put(\"surname\", \"Smith\");\n            hash.put(\"company\", \"Redis\");\n            hash.put(\"age\", \"29\");\n            jedis.hset(\"user-session:123\", hash);\n            System.out.println(jedis.hgetAll(\"user-session:123\"));\n            // Prints: {name=John, surname=Smith, company=Redis, age=29}\n        }\n    }\n}\n</code></pre> <p>Because adding a <code>try-with-resources</code> block for each command can be cumbersome, consider using <code>JedisPooled</code> as an easier way to pool connections.</p> <pre><code>import redis.clients.jedis.JedisPooled;\n\n//...\n\nJedisPooled jedis = new JedisPooled(\"localhost\", 6379);\njedis.set(\"foo\", \"bar\");\nSystem.out.println(jedis.get(\"foo\")); // prints \"bar\"\n</code></pre>"},{"location":"3-connect/clients/java/#connect-to-a-redis-cluster","title":"Connect to a Redis cluster","text":"<p>To connect to a Redis cluster, use <code>JedisCluster</code>. </p> <pre><code>import redis.clients.jedis.JedisCluster;\nimport redis.clients.jedis.HostAndPort;\n\n//...\n\nSet&lt;HostAndPort&gt; jedisClusterNodes = new HashSet&lt;HostAndPort&gt;();\njedisClusterNodes.add(new HostAndPort(\"127.0.0.1\", 7379));\njedisClusterNodes.add(new HostAndPort(\"127.0.0.1\", 7380));\nJedisCluster jedis = new JedisCluster(jedisClusterNodes);\n</code></pre>"},{"location":"3-connect/clients/java/#connect-to-your-production-redis-with-tls","title":"Connect to your production Redis with TLS","text":"<p>When you deploy your application, use TLS and follow the Redis security guidelines.</p> <p>Before connecting your application to the TLS-enabled Redis server, ensure that your certificates and private keys are in the correct format.</p> <p>To convert user certificate and private key from the PEM format to <code>pkcs12</code>, use this command:</p> <pre><code>openssl pkcs12 -export -in ./redis_user.crt -inkey ./redis_user_private.key -out redis-user-keystore.p12 -name \"redis\"\n</code></pre> <p>Enter password to protect your <code>pkcs12</code> file.</p> <p>Convert the server (CA) certificate to the JKS format using the keytool shipped with JDK.</p> <pre><code>keytool -importcert -keystore truststore.jks \\ \n  -storepass REPLACE_WITH_YOUR_PASSWORD \\\n  -file redis_ca.pem\n</code></pre> <p>Establish a secure connection with your Redis database using this snippet.</p> <pre><code>package org.example;\n\nimport redis.clients.jedis.*;\n\nimport javax.net.ssl.*;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.security.GeneralSecurityException;\nimport java.security.KeyStore;\n\npublic class Main {\n\n    public static void main(String[] args) throws GeneralSecurityException, IOException {\n        HostAndPort address = new HostAndPort(\"my-redis-instance.cloud.redislabs.com\", 6379);\n\n        SSLSocketFactory sslFactory = createSslSocketFactory(\n                \"./truststore.jks\",\n                \"secret!\", // use the password you specified for keytool command\n                \"./redis-user-keystore.p12\",\n                \"secret!\" // use the password you specified for openssl command\n        );\n\n        JedisClientConfig config = DefaultJedisClientConfig.builder()\n                .ssl(true).sslSocketFactory(sslFactory)\n                .user(\"default\") // use your Redis user. More info https://redis.io/docs/management/security/acl/\n                .password(\"secret!\") // use your Redis password\n                .build();\n\n        JedisPooled jedis = new JedisPooled(address, config);\n        jedis.set(\"foo\", \"bar\");\n        System.out.println(jedis.get(\"foo\")); // prints bar\n    }\n\n    private static SSLSocketFactory createSslSocketFactory(\n            String caCertPath, String caCertPassword, String userCertPath, String userCertPassword)\n            throws IOException, GeneralSecurityException {\n\n        KeyStore keyStore = KeyStore.getInstance(\"pkcs12\");\n        keyStore.load(new FileInputStream(userCertPath), userCertPassword.toCharArray());\n\n        KeyStore trustStore = KeyStore.getInstance(\"jks\");\n        trustStore.load(new FileInputStream(caCertPath), caCertPassword.toCharArray());\n\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(\"X509\");\n        trustManagerFactory.init(trustStore);\n\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"PKIX\");\n        keyManagerFactory.init(keyStore, userCertPassword.toCharArray());\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\n\n        return sslContext.getSocketFactory();\n    }\n}\n</code></pre>"},{"location":"3-connect/clients/java/#example-indexing-and-querying-json-documents","title":"Example: Indexing and querying JSON documents","text":"<p>Make sure that you have Redis Stack and <code>Jedis</code> installed. </p> <p>Import dependencies and add a sample <code>User</code> class:</p> <pre><code>import redis.clients.jedis.JedisPooled;\nimport redis.clients.jedis.search.*;\nimport redis.clients.jedis.search.aggr.*;\nimport redis.clients.jedis.search.schemafields.*;\n\nclass User {\n    private String name;\n    private String email;\n    private int age;\n    private String city;\n\n    public User(String name, String email, int age, String city) {\n        this.name = name;\n        this.email = email;\n        this.age = age;\n        this.city = city;\n    }\n\n    //...\n}\n</code></pre> <p>Connect to your Redis database with <code>JedisPooled</code>.</p> <pre><code>JedisPooled jedis = new JedisPooled(\"localhost\", 6379);\n</code></pre> <p>Let's create some test data to add to your database.</p> <pre><code>User user1 = new User(\"Paul John\", \"paul.john@example.com\", 42, \"London\");\nUser user2 = new User(\"Eden Zamir\", \"eden.zamir@example.com\", 29, \"Tel Aviv\");\nUser user3 = new User(\"Paul Zamir\", \"paul.zamir@example.com\", 35, \"Tel Aviv\");\n</code></pre> <p>Create an index. In this example, all JSON documents with the key prefix <code>user:</code> are indexed. For more information, see Query syntax.</p> <pre><code>jedis.ftCreate(\"idx:users\",\n    FTCreateParams.createParams()\n            .on(IndexDataType.JSON)\n            .addPrefix(\"user:\"),\n    TextField.of(\"$.name\").as(\"name\"),\n    TagField.of(\"$.city\").as(\"city\"),\n    NumericField.of(\"$.age\").as(\"age\")\n);\n</code></pre> <p>Use <code>JSON.SET</code> to set each user value at the specified path.</p> <pre><code>jedis.jsonSetWithEscape(\"user:1\", user1);\njedis.jsonSetWithEscape(\"user:2\", user2);\njedis.jsonSetWithEscape(\"user:3\", user3);\n</code></pre> <p>Let's find user <code>Paul</code> and filter the results by age.</p> <pre><code>var query = new Query(\"Paul @age:[30 40]\");\nvar result = jedis.ftSearch(\"idx:users\", query).getDocuments();\nSystem.out.println(result);\n// Prints: [id:user:3, score: 1.0, payload:null, properties:[$={\"name\":\"Paul Zamir\",\"email\":\"paul.zamir@example.com\",\"age\":35,\"city\":\"Tel Aviv\"}]]\n</code></pre> <p>Return only the <code>city</code> field.</p> <pre><code>var city_query = new Query(\"Paul @age:[30 40]\");\nvar city_result = jedis.ftSearch(\"idx:users\", city_query.returnFields(\"city\")).getDocuments();\nSystem.out.println(city_result);\n// Prints: [id:user:3, score: 1.0, payload:null, properties:[city=Tel Aviv]]\n</code></pre> <p>Count all users in the same city.</p> <pre><code>AggregationBuilder ab = new AggregationBuilder(\"*\")\n        .groupBy(\"@city\", Reducers.count().as(\"count\"));\nAggregationResult ar = jedis.ftAggregate(\"idx:users\", ab);\n\nfor (int idx=0; idx &lt; ar.getTotalResults(); idx++) {\n    System.out.println(ar.getRow(idx).getString(\"city\") + \" - \" + ar.getRow(idx).getString(\"count\"));\n}\n// Prints:\n// London - 1\n// Tel Aviv - 2\n</code></pre>"},{"location":"3-connect/clients/java/#learn-more","title":"Learn more","text":"<ul> <li>Jedis API reference</li> <li>GitHub</li> </ul>"},{"location":"3-connect/clients/nodejs/","title":"Node.js guide","text":"<p>Install Redis and the Redis client, then connect your Node.js application to a Redis database. </p>"},{"location":"3-connect/clients/nodejs/#node-redis","title":"node-redis","text":"<p>node-redis is a modern, high-performance Redis client for Node.js. <code>node-redis</code> requires a running Redis or Redis Stack server. See Getting started for Redis installation instructions.</p>"},{"location":"3-connect/clients/nodejs/#install","title":"Install","text":"<p>To install node-redis, run:</p> <pre><code>npm install redis\n</code></pre>"},{"location":"3-connect/clients/nodejs/#connect","title":"Connect","text":"<p>Connect to localhost on port 6379. </p> <pre><code>import { createClient } from 'redis';\n\nconst client = createClient();\n\nclient.on('error', err =&gt; console.log('Redis Client Error', err));\n\nawait client.connect();\n</code></pre> <p>Store and retrieve a simple string.</p> <pre><code>await client.set('key', 'value');\nconst value = await client.get('key');\n</code></pre> <p>Store and retrieve a map.</p> <pre><code>await client.hSet('user-session:123', {\n    name: 'John',\n    surname: 'Smith',\n    company: 'Redis',\n    age: 29\n})\n\nlet userSession = await client.hGetAll('user-session:123');\nconsole.log(JSON.stringify(userSession, null, 2));\n/*\n{\n  \"surname\": \"Smith\",\n  \"name\": \"John\",\n  \"company\": \"Redis\",\n  \"age\": \"29\"\n}\n */\n</code></pre> <p>To connect to a different host or port, use a connection string in the format <code>redis[s]://[[username][:password]@][host][:port][/db-number]</code>:</p> <p><pre><code>createClient({\n  url: 'redis://alice:foobared@awesome.redis.server:6380'\n});\n</code></pre> To check if the client is connected and ready to send commands, use <code>client.isReady</code>, which returns a Boolean. <code>client.isOpen</code> is also available. This returns <code>true</code> when the client's underlying socket is open, and <code>false</code> when it isn't (for example, when the client is still connecting or reconnecting after a network error).</p>"},{"location":"3-connect/clients/nodejs/#connect-to-a-redis-cluster","title":"Connect to a Redis cluster","text":"<p>To connect to a Redis cluster, use <code>createCluster</code>.</p> <pre><code>import { createCluster } from 'redis';\n\nconst cluster = createCluster({\n    rootNodes: [\n        {\n            url: 'redis://127.0.0.1:16379'\n        },\n        {\n            url: 'redis://127.0.0.1:16380'\n        },\n        // ...\n    ]\n});\n\ncluster.on('error', (err) =&gt; console.log('Redis Cluster Error', err));\n\nawait cluster.connect();\n\nawait cluster.set('foo', 'bar');\nconst value = await cluster.get('foo');\nconsole.log(value); // returns 'bar'\n\nawait cluster.quit();\n</code></pre>"},{"location":"3-connect/clients/nodejs/#connect-to-your-production-redis-with-tls","title":"Connect to your production Redis with TLS","text":"<p>When you deploy your application, use TLS and follow the Redis security guidelines.</p> <pre><code>const client = createClient({\n    username: 'default', // use your Redis user. More info https://redis.io/docs/management/security/acl/\n    password: 'secret', // use your password here\n    socket: {\n        host: 'my-redis.cloud.redislabs.com',\n        port: 6379,\n        tls: true,\n        key: readFileSync('./redis_user_private.key'),\n        cert: readFileSync('./redis_user.crt'),\n        ca: [readFileSync('./redis_ca.pem')]\n    }\n});\n\nclient.on('error', (err) =&gt; console.log('Redis Client Error', err));\n\nawait client.connect();\n\nawait client.set('foo', 'bar');\nconst value = await client.get('foo');\nconsole.log(value) // returns 'bar'\n\nawait client.disconnect();\n</code></pre> <p>You can also use discrete parameters and UNIX sockets. Details can be found in the client configuration guide.</p>"},{"location":"3-connect/clients/nodejs/#example-indexing-and-querying-json-documents","title":"Example: Indexing and querying JSON documents","text":"<p>Make sure that you have Redis Stack and <code>node-redis</code> installed. Import dependencies:</p> <pre><code>import {AggregateSteps, AggregateGroupByReducers, createClient, SchemaFieldTypes} from 'redis';\nconst client = createClient();\nawait client.connect();\n</code></pre> <p>Create an index.</p> <pre><code>try {\n    await client.ft.create('idx:users', {\n        '$.name': {\n            type: SchemaFieldTypes.TEXT,\n            SORTABLE: true\n        },\n        '$.city': {\n            type: SchemaFieldTypes.TEXT,\n            AS: 'city'\n        },\n        '$.age': {\n            type: SchemaFieldTypes.NUMERIC,\n            AS: 'age'\n        }\n    }, {\n        ON: 'JSON',\n        PREFIX: 'user:'\n    });\n} catch (e) {\n    if (e.message === 'Index already exists') {\n        console.log('Index exists already, skipped creation.');\n    } else {\n        // Something went wrong, perhaps RediSearch isn't installed...\n        console.error(e);\n        process.exit(1);\n    }\n}\n</code></pre> <p>Create JSON documents to add to your database.</p> <pre><code>await Promise.all([\n    client.json.set('user:1', '$', {\n        \"name\": \"Paul John\",\n        \"email\": \"paul.john@example.com\",\n        \"age\": 42,\n        \"city\": \"London\"\n    }),\n    client.json.set('user:2', '$', {\n        \"name\": \"Eden Zamir\",\n        \"email\": \"eden.zamir@example.com\",\n        \"age\": 29,\n        \"city\": \"Tel Aviv\"\n    }),\n    client.json.set('user:3', '$', {\n        \"name\": \"Paul Zamir\",\n        \"email\": \"paul.zamir@example.com\",\n        \"age\": 35,\n        \"city\": \"Tel Aviv\"\n    }),\n]);\n</code></pre> <p>Let's find user 'Paul` and filter the results by age.</p> <pre><code>let result = await client.ft.search(\n    'idx:users',\n    'Paul @age:[30 40]'\n);\nconsole.log(JSON.stringify(result, null, 2));\n/*\n{\n  \"total\": 1,\n  \"documents\": [\n    {\n      \"id\": \"user:3\",\n      \"value\": {\n        \"name\": \"Paul Zamir\",\n        \"email\": \"paul.zamir@example.com\",\n        \"age\": 35,\n        \"city\": \"Tel Aviv\"\n      }\n    }\n  ]\n}\n */\n</code></pre> <p>Return only the city field.</p> <pre><code>result = await client.ft.search(\n    'idx:users',\n    'Paul @age:[30 40]',\n    {\n        RETURN: ['$.city']\n    }\n);\nconsole.log(JSON.stringify(result, null, 2));\n\n/*\n{\n  \"total\": 1,\n  \"documents\": [\n    {\n      \"id\": \"user:3\",\n      \"value\": {\n        \"$.city\": \"Tel Aviv\"\n      }\n    }\n  ]\n}\n */\n</code></pre> <p>Count all users in the same city.</p> <pre><code>result = await client.ft.aggregate('idx:users', '*', {\n    STEPS: [\n        {\n            type: AggregateSteps.GROUPBY,\n            properties: ['@city'],\n            REDUCE: [\n                {\n                    type: AggregateGroupByReducers.COUNT,\n                    AS: 'count'\n                }\n            ]\n        }\n    ]\n})\nconsole.log(JSON.stringify(result, null, 2));\n\n/*\n{\n  \"total\": 2,\n  \"results\": [\n    {\n      \"city\": \"London\",\n      \"count\": \"1\"\n    },\n    {\n      \"city\": \"Tel Aviv\",\n      \"count\": \"2\"\n    }\n  ]\n}\n */\n\nawait client.quit();\n</code></pre>"},{"location":"3-connect/clients/nodejs/#learn-more","title":"Learn more","text":"<ul> <li>Redis commands</li> <li>Programmability</li> <li>Clustering</li> <li>GitHub</li> </ul>"},{"location":"3-connect/clients/python/","title":"Python guide","text":"<p>Install Redis and the Redis client, then connect your Python application to a Redis database. </p>"},{"location":"3-connect/clients/python/#redis-py","title":"redis-py","text":"<p>Get started with the redis-py client for Redis. </p> <p><code>redis-py</code> requires a running Redis or Redis Stack server. See Getting started for Redis installation instructions.</p>"},{"location":"3-connect/clients/python/#install","title":"Install","text":"<p>To install <code>redis-py</code>, enter:</p> <pre><code>pip install redis\n</code></pre> <p>For faster performance, install Redis with <code>hiredis</code> support. This provides a compiled response parser, and for most cases requires zero code changes. By default, if <code>hiredis</code> &gt;= 1.0 is available, <code>redis-py</code> attempts to use it for response parsing.</p> <pre><code>pip install redis[hiredis]\n</code></pre>"},{"location":"3-connect/clients/python/#connect","title":"Connect","text":"<p>Connect to localhost on port 6379, set a value in Redis, and retrieve it. All responses are returned as bytes in Python. To receive decoded strings, set <code>decode_responses=True</code>. For more connection options, see these examples.</p> <pre><code>r = redis.Redis(host='localhost', port=6379, decode_responses=True)\n</code></pre> <p>Store and retrieve a simple string.</p> <pre><code>r.set('foo', 'bar')\n# True\nr.get('foo')\n# bar\n</code></pre> <p>Store and retrieve a dict.</p> <pre><code>r.hset('user-session:123', mapping={\n    'name': 'John',\n    \"surname\": 'Smith',\n    \"company\": 'Redis',\n    \"age\": 29\n})\n# True\n\nr.hgetall('user-session:123')\n# {'surname': 'Smith', 'name': 'John', 'company': 'Redis', 'age': '29'}\n</code></pre>"},{"location":"3-connect/clients/python/#connect-to-a-redis-cluster","title":"Connect to a Redis cluster","text":"<p>To connect to a Redis cluster, use <code>RedisCluster</code>.</p> <p><pre><code>from redis.cluster import RedisCluster\n\nrc = RedisCluster(host='localhost', port=16379)\n\nprint(rc.get_nodes())\n# [[host=127.0.0.1,port=16379,name=127.0.0.1:16379,server_type=primary,redis_connection=Redis&lt;ConnectionPool&lt;Connection&lt;host=127.0.0.1,port=16379,db=0&gt;&gt;&gt;], ...\n\nrc.set('foo', 'bar')\n# True\n\nrc.get('foo')\n# b'bar'\n</code></pre> For more information, see redis-py Clustering.</p>"},{"location":"3-connect/clients/python/#connect-to-your-production-redis-with-tls","title":"Connect to your production Redis with TLS","text":"<p>When you deploy your application, use TLS and follow the Redis security guidelines.</p> <p><pre><code>import redis\n\nr = redis.Redis(\n    host=\"my-redis.cloud.redislabs.com\", port=6379,\n    username=\"default\", # use your Redis user. More info https://redis.io/docs/management/security/acl/\n    password=\"secret\", # use your Redis password\n    ssl=True,\n    ssl_certfile=\"./redis_user.crt\",\n    ssl_keyfile=\"./redis_user_private.key\",\n    ssl_ca_certs=\"./redis_ca.pem\",\n)\nr.set('foo', 'bar')\n# True\n\nr.get('foo')\n# b'bar'\n</code></pre> For more information, see redis-py TLS examples.</p>"},{"location":"3-connect/clients/python/#example-indexing-and-querying-json-documents","title":"Example: Indexing and querying JSON documents","text":"<p>Make sure that you have Redis Stack and <code>redis-py</code> installed. Import dependencies:</p> <pre><code>import redis\nfrom redis.commands.json.path import Path\nimport redis.commands.search.aggregation as aggregations\nimport redis.commands.search.reducers as reducers\nfrom redis.commands.search.field import TextField, NumericField, TagField\nfrom redis.commands.search.indexDefinition import IndexDefinition, IndexType\nfrom redis.commands.search.query import NumericFilter, Query\n</code></pre> <p>Connect to your Redis database.</p> <pre><code>r = redis.Redis(host='localhost', port=6379)\n</code></pre> <p>Let's create some test data to add to your database.</p> <pre><code>user1 = {\n    \"name\": \"Paul John\",\n    \"email\": \"paul.john@example.com\",\n    \"age\": 42,\n    \"city\": \"London\"\n}\nuser2 = {\n    \"name\": \"Eden Zamir\",\n    \"email\": \"eden.zamir@example.com\",\n    \"age\": 29,\n    \"city\": \"Tel Aviv\"\n}\nuser3 = {\n    \"name\": \"Paul Zamir\",\n    \"email\": \"paul.zamir@example.com\",\n    \"age\": 35,\n    \"city\": \"Tel Aviv\"\n}\n</code></pre> <p>Define indexed fields and their data types using <code>schema</code>. Use JSON path expressions to map specific JSON elements to the schema fields.</p> <pre><code>schema = (\n    TextField(\"$.name\", as_name=\"name\"), \n    TagField(\"$.city\", as_name=\"city\"), \n    NumericField(\"$.age\", as_name=\"age\")\n)\n</code></pre> <p>Create an index. In this example, all JSON documents with the key prefix <code>user:</code> will be indexed. For more information, see Query syntax. </p> <pre><code>rs = r.ft(\"idx:users\")\nrs.create_index(\n    schema,\n    definition=IndexDefinition(\n        prefix=[\"user:\"], index_type=IndexType.JSON\n    )\n)\n# b'OK'\n</code></pre> <p>Use <code>JSON.SET</code> to set each user value at the specified path.</p> <pre><code>r.json().set(\"user:1\", Path.root_path(), user1)\nr.json().set(\"user:2\", Path.root_path(), user2)\nr.json().set(\"user:3\", Path.root_path(), user3)\n</code></pre> <p>Let's find user <code>Paul</code> and filter the results by age.</p> <pre><code>res = rs.search(\n    Query(\"Paul @age:[30 40]\")\n)\n# Result{1 total, docs: [Document {'id': 'user:3', 'payload': None, 'json': '{\"name\":\"Paul Zamir\",\"email\":\"paul.zamir@example.com\",\"age\":35,\"city\":\"Tel Aviv\"}'}]}\n</code></pre> <p>Query using JSON Path expressions.</p> <pre><code>rs.search(\n    Query(\"Paul\").return_field(\"$.city\", as_field=\"city\")\n).docs\n# [Document {'id': 'user:1', 'payload': None, 'city': 'London'}, Document {'id': 'user:3', 'payload': None, 'city': 'Tel Aviv'}]\n</code></pre> <p>Aggregate your results using <code>FT.AGGREGATE</code>.</p> <pre><code>req = aggregations.AggregateRequest(\"*\").group_by('@city', reducers.count().alias('count'))\nprint(rs.aggregate(req).rows)\n# [[b'city', b'Tel Aviv', b'count', b'2'], [b'city', b'London', b'count', b'1']]\n</code></pre>"},{"location":"3-connect/clients/python/#learn-more","title":"Learn more","text":"<ul> <li>Command reference</li> <li>Tutorials</li> <li>GitHub</li> </ul>"},{"location":"4-data-types/_index/","title":"Understand Redis data types","text":"<p>Redis is a data structure server. At its core, Redis provides a collection of native data types that help you solve a wide variety of problems, from caching to queuing to event processing. Below is a short description of each data type, with links to broader overviews and command references.</p> <p>If you'd like to try a comprehensive tutorial for each data structure, see their overview pages below.</p>"},{"location":"4-data-types/_index/#core","title":"Core","text":""},{"location":"4-data-types/_index/#strings","title":"Strings","text":"<p>Redis strings are the most basic Redis data type, representing a sequence of bytes. For more information, see:</p> <ul> <li>Overview of Redis strings</li> <li>Redis string command reference</li> </ul>"},{"location":"4-data-types/_index/#lists","title":"Lists","text":"<p>Redis lists are lists of strings sorted by insertion order. For more information, see:</p> <ul> <li>Overview of Redis lists</li> <li>Redis list command reference</li> </ul>"},{"location":"4-data-types/_index/#sets","title":"Sets","text":"<p>Redis sets are unordered collections of unique strings that act like the sets from your favorite programming language (for example, Java HashSets, Python sets, and so on). With a Redis set, you can add, remove, and test for existence in O(1) time (in other words, regardless of the number of set elements). For more information, see:</p> <ul> <li>Overview of Redis sets</li> <li>Redis set command reference</li> </ul>"},{"location":"4-data-types/_index/#hashes","title":"Hashes","text":"<p>Redis hashes are record types modeled as collections of field-value pairs. As such, Redis hashes resemble Python dictionaries, Java HashMaps, and Ruby hashes. For more information, see:</p> <ul> <li>Overview of Redis hashes</li> <li>Redis hashes command reference</li> </ul>"},{"location":"4-data-types/_index/#sorted-sets","title":"Sorted sets","text":"<p>Redis sorted sets are collections of unique strings that maintain order by each string's associated score. For more information, see:</p> <ul> <li>Overview of Redis sorted sets</li> <li>Redis sorted set command reference</li> </ul>"},{"location":"4-data-types/_index/#streams","title":"Streams","text":"<p>A Redis stream is a data structure that acts like an append-only log. Streams help record events in the order they occur and then syndicate them for processing. For more information, see:</p> <ul> <li>Overview of Redis Streams</li> <li>Redis Streams command reference</li> </ul>"},{"location":"4-data-types/_index/#geospatial-indexes","title":"Geospatial indexes","text":"<p>Redis geospatial indexes are useful for finding locations within a given geographic radius or bounding box. For more information, see:</p> <ul> <li>Overview of Redis geospatial indexes</li> <li>Redis geospatial indexes command reference</li> </ul>"},{"location":"4-data-types/_index/#bitmaps","title":"Bitmaps","text":"<p>Redis bitmaps let you perform bitwise operations on strings.  For more information, see:</p> <ul> <li>Overview of Redis bitmaps</li> <li>Redis bitmap command reference</li> </ul>"},{"location":"4-data-types/_index/#bitfields","title":"Bitfields","text":"<p>Redis bitfields efficiently encode multiple counters in a string value. Bitfields provide atomic get, set, and increment operations and support different overflow policies. For more information, see:</p> <ul> <li>Overview of Redis bitfields</li> <li>The <code>BITFIELD</code> command.</li> </ul>"},{"location":"4-data-types/_index/#hyperloglog","title":"HyperLogLog","text":"<p>The Redis HyperLogLog data structures provide probabilistic estimates of the cardinality (i.e., number of elements) of large sets. For more information, see:</p> <ul> <li>Overview of Redis HyperLogLog</li> <li>Redis HyperLogLog command reference</li> </ul>"},{"location":"4-data-types/_index/#extensions","title":"Extensions","text":"<p>To extend the features provided by the included data types, use one of these options:</p> <ol> <li>Write your own custom server-side functions in Lua.</li> <li>Write your own Redis module using the modules API or check out the community-supported modules.</li> <li>Use JSON, querying, time series, and other capabilities provided by Redis Stack.</li> </ol>"},{"location":"4-data-types/bitfields/","title":"Redis bitfields","text":"<p>Redis bitfields let you set, increment, and get integer values of arbitrary bit length. For example, you can operate on anything from unsigned 1-bit integers to signed 63-bit integers.</p> <p>These values are stored using binary-encoded Redis strings. Bitfields support atomic read, write and increment operations, making them a good choice for managing counters and similar numerical values.</p>"},{"location":"4-data-types/bitfields/#basic-commands","title":"Basic commands","text":"<ul> <li><code>BITFIELD</code> atomically sets, increments and reads one or more values.</li> <li><code>BITFIELD_RO</code> is a read-only variant of <code>BITFIELD</code>.</li> </ul>"},{"location":"4-data-types/bitfields/#examples","title":"Examples","text":"<p>Suppose you're keeping track of activity in an online game. You want to maintain two crucial metrics for each player: the total amount of gold and the number of monsters slain. Because your game is highly addictive, these counters should be at least 32 bits wide.</p> <p>You can represent these counters with one bitfield per player.</p> <ul> <li> <p>New players start the tutorial with 1000 gold (counter in offset 0). <pre><code>&gt; BITFIELD player:1:stats SET u32 #0 1000\n1) (integer) 0\n</code></pre></p> </li> <li> <p>After killing the goblin holding the prince captive, add the 50 gold earned and increment the \"slain\" counter (offset 1). <pre><code>&gt; BITFIELD player:1:stats INCRBY u32 #0 50 INCRBY u32 #1 1\n1) (integer) 1050\n2) (integer) 1\n</code></pre></p> </li> <li> <p>Pay the blacksmith 999 gold to buy a legendary rusty dagger. <pre><code>&gt; BITFIELD player:1:stats INCRBY u32 #0 -999\n1) (integer) 51\n</code></pre></p> </li> <li> <p>Read the player's stats: <pre><code>&gt; BITFIELD player:1:stats GET u32 #0 GET u32 #1\n1) (integer) 51\n2) (integer) 1\n</code></pre></p> </li> </ul>"},{"location":"4-data-types/bitfields/#performance","title":"Performance","text":"<p><code>BITFIELD</code> is O(n), where n is the number of counters accessed.</p>"},{"location":"4-data-types/bitmaps/","title":"Redis bitmaps","text":"<p>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type which is treated like a bit vector. Since strings are binary safe blobs and their maximum length is 512 MB, they are suitable to set up to 2^32 different bits.</p> <p>You can perform bitwise operations on one or more strings. Some examples of bitmap use cases include:</p> <ul> <li>Efficient set representations for cases where the members of a set correspond to the integers 0-N.</li> <li>Object permissions, where each bit represents a particular permission, similar to the way that file systems store permissions.</li> </ul>"},{"location":"4-data-types/bitmaps/#basic-commands","title":"Basic commands","text":"<ul> <li><code>SETBIT</code> sets a bit at the provided offset to 0 or 1.</li> <li><code>GETBIT</code> returns the value of a bit at a given offset.</li> <li><code>BITOP</code> lets you perform bitwise operations against one or more strings.</li> </ul> <p>See the complete list of bitmap commands.</p>"},{"location":"4-data-types/bitmaps/#examples","title":"Examples","text":"<p>Suppose you have 1000 sensors deployed in the field, labeled 0-999. You want to quickly determine whether a given sensor has pinged the server within the hour. </p> <p>You can represent this scenario using a bitmap whose key references the current hour.</p> <ul> <li> <p>Sensor 123 pings the server on January 1, 2024 within the 00:00 hour. <pre><code>&gt; SETBIT pings:2024-01-01-00:00 123 1\n(integer) 0\n</code></pre></p> </li> <li> <p>Did sensor 123 ping the server on January 1, 2024 within the 00:00 hour? <pre><code>&gt; GETBIT pings:2024-01-01-00:00 123\n1\n</code></pre></p> </li> <li> <p>What about sensor 456? <pre><code>&gt; GETBIT pings:2024-01-01-00:00 456\n0\n</code></pre></p> </li> </ul> <p>Bit operations are divided into two groups: constant-time single bit operations, like setting a bit to 1 or 0, or getting its value, and operations on groups of bits, for example counting the number of set bits in a given range of bits (e.g., population counting).</p> <p>One of the biggest advantages of bitmaps is that they often provide extreme space savings when storing information. For example in a system where different users are represented by incremental user IDs, it is possible to remember a single bit information (for example, knowing whether a user wants to receive a newsletter) of 4 billion users using just 512 MB of memory.</p> <p>Bits are set and retrieved using the <code>SETBIT</code> and <code>GETBIT</code> commands:</p> <pre><code>&gt; setbit key 10 1\n(integer) 0\n&gt; getbit key 10\n(integer) 1\n&gt; getbit key 11\n(integer) 0\n</code></pre> <p>The <code>SETBIT</code> command takes as its first argument the bit number, and as its second argument the value to set the bit to, which is 1 or 0. The command automatically enlarges the string if the addressed bit is outside the current string length.</p> <p><code>GETBIT</code> just returns the value of the bit at the specified index. Out of range bits (addressing a bit that is outside the length of the string stored into the target key) are always considered to be zero.</p> <p>There are three commands operating on group of bits:</p> <ol> <li><code>BITOP</code> performs bit-wise operations between different strings. The provided operations are AND, OR, XOR and NOT.</li> <li><code>BITCOUNT</code> performs population counting, reporting the number of bits set to 1.</li> <li><code>BITPOS</code> finds the first bit having the specified value of 0 or 1.</li> </ol> <p>Both <code>BITPOS</code> and <code>BITCOUNT</code> are able to operate with byte ranges of the string, instead of running for the whole length of the string. The following is a trivial example of <code>BITCOUNT</code> call:</p> <pre><code>&gt; setbit key 0 1\n(integer) 0\n&gt; setbit key 100 1\n(integer) 0\n&gt; bitcount key\n(integer) 2\n</code></pre> <p>For example imagine you want to know the longest streak of daily visits of your web site users. You start counting days starting from zero, that is the day you made your web site public, and set a bit with <code>SETBIT</code> every time the user visits the web site. As a bit index you simply take the current unix time, subtract the initial offset, and divide by the number of seconds in a day (normally, 3600*24).</p> <p>This way for each user you have a small string containing the visit information for each day. With <code>BITCOUNT</code> it is possible to easily get the number of days a given user visited the web site, while with a few <code>BITPOS</code> calls, or simply fetching and analyzing the bitmap client-side, it is possible to easily compute the longest streak.</p> <p>Bitmaps are trivial to split into multiple keys, for example for the sake of sharding the data set and because in general it is better to avoid working with huge keys. To split a bitmap across different keys instead of setting all the bits into a key, a trivial strategy is just to store M bits per key and obtain the key name with <code>bit-number/M</code> and the Nth bit to address inside the key with <code>bit-number MOD M</code>.</p>"},{"location":"4-data-types/bitmaps/#performance","title":"Performance","text":"<p><code>SETBIT</code> and <code>GETBIT</code> are O(1). <code>BITOP</code> is O(n), where n is the length of the longest string in the comparison.</p>"},{"location":"4-data-types/bitmaps/#learn-more","title":"Learn more","text":"<ul> <li>Redis Bitmaps Explained teaches you how to use bitmaps for map exploration in an online game. </li> <li>Redis University's RU101 covers Redis bitmaps in detail.</li> </ul>"},{"location":"4-data-types/geospatial/","title":"Redis geospatial","text":"<p>Redis geospatial indexes let you store coordinates and search for them. This data structure is useful for finding nearby points within a given radius or bounding box.</p>"},{"location":"4-data-types/geospatial/#basic-commands","title":"Basic commands","text":"<ul> <li><code>GEOADD</code> adds a location to a given geospatial index (note that longitude comes before latitude with this command).</li> <li><code>GEOSEARCH</code> returns locations with a given radius or a bounding box.</li> </ul> <p>See the complete list of geospatial index commands.</p>"},{"location":"4-data-types/geospatial/#examples","title":"Examples","text":"<p>Suppose you're building a mobile app that lets you find all of the bike rental stations closest to your current location.</p> <p>Add several locations to a geospatial index: {{&lt; clients-example geo_tutorial geoadd &gt;}}</p> <p>GEOADD bikes:rentable -122.27652 37.805186 station:1 (integer) 1 GEOADD bikes:rentable -122.2674626 37.8062344 station:2 (integer) 1 GEOADD bikes:rentable -122.2469854 37.8104049 station:3 (integer) 1 {{&lt; /clients-example &gt;}}</p> <p>Find all locations within a 5 kilometer radius of a given location, and return the distance to each location: {{&lt; clients-example geo_tutorial geosearch &gt;}}</p> <p>GEOSEARCH bikes:rentable FROMLONLAT -122.2612767 37.7936847 BYRADIUS 5 km WITHDIST 1) 1) \"station:1\"    2) \"1.8523\" 2) 1) \"station:2\"    2) \"1.4979\" 3) 1) \"station:3\"    2) \"2.2441\" {{&lt; /clients-example &gt;}}</p>"},{"location":"4-data-types/geospatial/#learn-more","title":"Learn more","text":"<ul> <li>Redis Geospatial Explained introduces geospatial indexes by showing you how to build a map of local park attractions.</li> <li>Redis University's RU101 covers Redis geospatial indexes in detail.</li> </ul>"},{"location":"4-data-types/hashes/","title":"Redis hashes","text":"<p>Redis hashes are record types structured as collections of field-value pairs. You can use hashes to represent basic objects and to store groupings of counters, among other things.</p> <p>{{&lt; clients-example hash_tutorial set_get_all &gt;}}</p> <p>HSET bike:1 model Deimos brand Ergonom type 'Enduro bikes' price 4972 (integer) 4 HGET bike:1 model \"Deimos\" HGET bike:1 price \"4972\" HGETALL bike:1 1) \"model\" 2) \"Deimos\" 3) \"brand\" 4) \"Ergonom\" 5) \"type\" 6) \"Enduro bikes\" 7) \"price\" 8) \"4972\"</p> <p>{{&lt; /clients-example &gt;}}</p> <p>While hashes are handy to represent objects, actually the number of fields you can put inside a hash has no practical limits (other than available memory), so you can use hashes in many different ways inside your application.</p> <p>The command <code>HSET</code> sets multiple fields of the hash, while <code>HGET</code> retrieves a single field. <code>HMGET</code> is similar to <code>HGET</code> but returns an array of values:</p> <p>{{&lt; clients-example hash_tutorial hmget &gt;}}</p> <p>HMGET bike:1 model price no-such-field 1) \"Deimos\" 2) \"4972\" 3) (nil) {{&lt; /clients-example &gt;}}</p> <p>There are commands that are able to perform operations on individual fields as well, like <code>HINCRBY</code>:</p> <p>{{&lt; clients-example hash_tutorial hincrby &gt;}}</p> <p>HINCRBY bike:1 price 100 (integer) 5072 HINCRBY bike:1 price -100 (integer) 4972 {{&lt; /clients-example &gt;}}</p> <p>You can find the full list of hash commands in the documentation.</p> <p>It is worth noting that small hashes (i.e., a few elements with small values) are encoded in special way in memory that make them very memory efficient.</p>"},{"location":"4-data-types/hashes/#basic-commands","title":"Basic commands","text":"<ul> <li><code>HSET</code> sets the value of one or more fields on a hash.</li> <li><code>HGET</code> returns the value at a given field.</li> <li><code>HMGET</code> returns the values at one or more given fields.</li> <li><code>HINCRBY</code> increments the value at a given field by the integer provided.</li> </ul> <p>See the complete list of hash commands.</p>"},{"location":"4-data-types/hashes/#examples","title":"Examples","text":"<ul> <li>Store counters for the number of times bike:1 has been ridden, has crashed, or has changed owners: {{&lt; clients-example hash_tutorial incrby_get_mget &gt;}} <p>HINCRBY bike:1:stats rides 1 (integer) 1 HINCRBY bike:1:stats rides 1 (integer) 2 HINCRBY bike:1:stats rides 1 (integer) 3 HINCRBY bike:1:stats crashes 1 (integer) 1 HINCRBY bike:1:stats owners 1 (integer) 1 HGET bike:1:stats rides \"3\" HMGET bike:1:stats owners crashes 1) \"1\" 2) \"1\" {{&lt; /clients-example &gt;}}</p> </li> </ul>"},{"location":"4-data-types/hashes/#performance","title":"Performance","text":"<p>Most Redis hash commands are O(1).</p> <p>A few commands - such as <code>HKEYS</code>, <code>HVALS</code>, and <code>HGETALL</code> - are O(n), where n is the number of field-value pairs.</p>"},{"location":"4-data-types/hashes/#limits","title":"Limits","text":"<p>Every hash can store up to 4,294,967,295 (2^32 - 1) field-value pairs. In practice, your hashes are limited only by the overall memory on the VMs hosting your Redis deployment.</p>"},{"location":"4-data-types/hashes/#learn-more","title":"Learn more","text":"<ul> <li>Redis Hashes Explained is a short, comprehensive video explainer covering Redis hashes.</li> <li>Redis University's RU101 covers Redis hashes in detail.</li> </ul>"},{"location":"4-data-types/lists/","title":"Redis lists","text":"<p>Redis lists are linked lists of string values. Redis lists are frequently used to:</p> <ul> <li>Implement stacks and queues.</li> <li>Build queue management for background worker systems.</li> </ul>"},{"location":"4-data-types/lists/#basic-commands","title":"Basic commands","text":"<ul> <li><code>LPUSH</code> adds a new element to the head of a list; <code>RPUSH</code> adds to the tail.</li> <li><code>LPOP</code> removes and returns an element from the head of a list; <code>RPOP</code> does the same but from the tails of a list. </li> <li><code>LLEN</code> returns the length of a list.</li> <li><code>LMOVE</code> atomically moves elements from one list to another.</li> <li><code>LTRIM</code> reduces a list to the specified range of elements.</li> </ul>"},{"location":"4-data-types/lists/#blocking-commands","title":"Blocking commands","text":"<p>Lists support several blocking commands. For example:</p> <ul> <li><code>BLPOP</code> removes and returns an element from the head of a list.   If the list is empty, the command blocks until an element becomes available or until the specified timeout is reached.</li> <li><code>BLMOVE</code> atomically moves elements from a source list to a target list.   If the source list is empty, the command will block until a new element becomes available.</li> </ul> <p>See the complete series of list commands.</p>"},{"location":"4-data-types/lists/#examples","title":"Examples","text":"<ul> <li> <p>Treat a list like a queue (first in, first out): {{&lt; clients-example list_tutorial queue &gt;}}</p> <p>LPUSH bikes:repairs bike:1 (integer) 1 LPUSH bikes:repairs bike:2 (integer) 2 RPOP bikes:repairs \"bike:1\" RPOP bikes:repairs \"bike:2\" {{&lt; /clients-example &gt;}}</p> </li> <li> <p>Treat a list like a stack (first in, last out): {{&lt; clients-example list_tutorial stack &gt;}}</p> <p>LPUSH bikes:repairs bike:1 (integer) 1 LPUSH bikes:repairs bike:2 (integer) 2 LPOP bikes:repairs \"bike:2\" LPOP bikes:repairs \"bike:1\" {{&lt; /clients-example &gt;}}</p> </li> <li> <p>Check the length of a list: {{&lt; clients-example list_tutorial llen &gt;}}</p> <p>LLEN bikes:repairs (integer) 0 {{&lt; /clients-example &gt;}}</p> </li> <li> <p>Atomically pop an element from one list and push to another: {{&lt; clients-example list_tutorial lmove_lrange &gt;}}</p> <p>LPUSH bikes:repairs bike:1 (integer) 1 LPUSH bikes:repairs bike:2 (integer) 2 LMOVE bikes:repairs bikes:finished LEFT LEFT \"bike:2\" LRANGE bikes:repairs 0 -1 1) \"bike:1\" LRANGE bikes:finished 0 -1 1) \"bike:2\" {{&lt; /clients-example &gt;}}</p> </li> <li> <p>To limit the length of a list you can call <code>LTRIM</code>: {{&lt; clients-example list_tutorial ltrim.1 &gt;}}</p> <p>RPUSH bikes:repairs bike:1 bike:2 bike:3 bike:4 bike:5 (integer) 5 LTRIM bikes:repairs 0 2 OK LRANGE bikes:repairs 0 -1 1) \"bike:1\" 2) \"bike:2\" 3) \"bike:3\" {{&lt; /clients-example &gt;}}</p> </li> </ul>"},{"location":"4-data-types/lists/#what-are-lists","title":"What are Lists?","text":"<p>To explain the List data type it's better to start with a little bit of theory, as the term List is often used in an improper way by information technology folks. For instance \"Python Lists\" are not what the name may suggest (Linked Lists), but rather Arrays (the same data type is called Array in Ruby actually).</p> <p>From a very general point of view a List is just a sequence of ordered elements: 10,20,1,2,3 is a list. But the properties of a List implemented using an Array are very different from the properties of a List implemented using a Linked List.</p> <p>Redis lists are implemented via Linked Lists. This means that even if you have millions of elements inside a list, the operation of adding a new element in the head or in the tail of the list is performed in constant time. The speed of adding a new element with the <code>LPUSH</code> command to the head of a list with ten elements is the same as adding an element to the head of list with 10 million elements.</p> <p>What's the downside? Accessing an element by index is very fast in lists implemented with an Array (constant time indexed access) and not so fast in lists implemented by linked lists (where the operation requires an amount of work proportional to the index of the accessed element).</p> <p>Redis Lists are implemented with linked lists because for a database system it is crucial to be able to add elements to a very long list in a very fast way. Another strong advantage, as you'll see in a moment, is that Redis Lists can be taken at constant length in constant time.</p> <p>When fast access to the middle of a large collection of elements is important, there is a different data structure that can be used, called sorted sets. Sorted sets are covered in the Sorted sets tutorial page.</p>"},{"location":"4-data-types/lists/#first-steps-with-redis-lists","title":"First steps with Redis Lists","text":"<p>The <code>LPUSH</code> command adds a new element into a list, on the left (at the head), while the <code>RPUSH</code> command adds a new element into a list, on the right (at the tail). Finally the <code>LRANGE</code> command extracts ranges of elements from lists:</p> <p>{{&lt; clients-example list_tutorial lpush_rpush &gt;}}</p> <p>RPUSH bikes:repairs bike:1 (integer) 1 RPUSH bikes:repairs bike:2 (integer) 2 LPUSH bikes:repairs bike:important_bike (integer) 3 LRANGE bikes:repairs 0 -1 1) \"bike:important_bike\" 2) \"bike:1\" 3) \"bike:2\" {{&lt; /clients-example &gt;}}</p> <p>Note that <code>LRANGE</code> takes two indexes, the first and the last element of the range to return. Both the indexes can be negative, telling Redis to start counting from the end: so -1 is the last element, -2 is the penultimate element of the list, and so forth.</p> <p>As you can see <code>RPUSH</code> appended the elements on the right of the list, while the final <code>LPUSH</code> appended the element on the left.</p> <p>Both commands are variadic commands, meaning that you are free to push multiple elements into a list in a single call:</p> <p>{{&lt; clients-example list_tutorial variadic &gt;}}</p> <p>RPUSH bikes:repairs bike:1 bike:2 bike:3 (integer) 3 LPUSH bikes:repairs bike:important_bike bike:very_important_bike LRANGE mylist 0 -1 1) \"bike:very_important_bike\" 2) \"bike:important_bike\" 3) \"bike:1\" 4) \"bike:2\" 5) \"bike:3\" {{&lt; /clients-example &gt;}}</p> <p>An important operation defined on Redis lists is the ability to pop elements. Popping elements is the operation of both retrieving the element from the list, and eliminating it from the list, at the same time. You can pop elements from left and right, similarly to how you can push elements in both sides of the list. We'll add three elements and pop three elements, so at the end of this sequence of commands the list is empty and there are no more elements to pop:</p> <p>{{&lt; clients-example list_tutorial lpop_rpop &gt;}}</p> <p>RPUSH bikes:repairs bike:1 bike:2 bike:3 (integer) 3 RPOP bikes:repairs \"bike:3\" LPOP bikes:repairs \"bike:1\" RPOP bikes:repairs \"bike:2\" RPOP bikes:repairs (nil) {{&lt; /clients-example &gt;}}</p> <p>Redis returned a NULL value to signal that there are no elements in the list.</p>"},{"location":"4-data-types/lists/#common-use-cases-for-lists","title":"Common use cases for lists","text":"<p>Lists are useful for a number of tasks, two very representative use cases are the following:</p> <ul> <li>Remember the latest updates posted by users into a social network.</li> <li>Communication between processes, using a consumer-producer pattern where the producer pushes items into a list, and a consumer (usually a worker) consumes those items and executes actions. Redis has special list commands to make this use case both more reliable and efficient.</li> </ul> <p>For example both the popular Ruby libraries resque and sidekiq use Redis lists under the hood in order to implement background jobs.</p> <p>The popular Twitter social network takes the latest tweets posted by users into Redis lists.</p> <p>To describe a common use case step by step, imagine your home page shows the latest photos published in a photo sharing social network and you want to speedup access.</p> <ul> <li>Every time a user posts a new photo, we add its ID into a list with <code>LPUSH</code>.</li> <li>When users visit the home page, we use <code>LRANGE 0 9</code> in order to get the latest 10 posted items.</li> </ul>"},{"location":"4-data-types/lists/#capped-lists","title":"Capped lists","text":"<p>In many use cases we just want to use lists to store the latest items, whatever they are: social network updates, logs, or anything else.</p> <p>Redis allows us to use lists as a capped collection, only remembering the latest N items and discarding all the oldest items using the <code>LTRIM</code> command.</p> <p>The <code>LTRIM</code> command is similar to <code>LRANGE</code>, but instead of displaying the specified range of elements it sets this range as the new list value. All the elements outside the given range are removed.</p> <p>For example, if you're adding bikes on the end of a list of repairs, but only want to worry about the 3 that have been on the list the longest:</p> <p>{{&lt; clients-example list_tutorial ltrim &gt;}}</p> <p>RPUSH bikes:repairs bike:1 bike:2 bike:3 bike:4 bike:5 (integer) 5 LTRIM bikes:repairs 0 2 OK LRANGE bikes:repairs 0 -1 1) \"bike:1\" 2) \"bike:2\" 3) \"bike:3\" {{&lt; /clients-example &gt;}}</p> <p>The above <code>LTRIM</code> command tells Redis to keep just list elements from index 0 to 2, everything else will be discarded. This allows for a very simple but useful pattern: doing a List push operation + a List trim operation together  to add a new element and discard elements exceeding a limit. Using  <code>LTRIM</code> with negative indexes can then be used to keep only the 3 most recently added:</p> <p>{{&lt; clients-example list_tutorial ltrim_end_of_list &gt;}}</p> <p>RPUSH bikes:repairs bike:1 bike:2 bike:3 bike:4 bike:5 (integer) 5 LTRIM bikes:repairs -3 -1 OK LRANGE bikes:repairs 0 -1 1) \"bike:3\" 2) \"bike:4\" 3) \"bike:5\" {{&lt; /clients-example &gt;}}</p> <p>The above combination adds new elements and keeps only the 3 newest elements into the list. With <code>LRANGE</code> you can access the top items without any need to remember very old data.</p> <p>Note: while <code>LRANGE</code> is technically an O(N) command, accessing small ranges towards the head or the tail of the list is a constant time operation.</p>"},{"location":"4-data-types/lists/#blocking-operations-on-lists","title":"Blocking operations on lists","text":"<p>Lists have a special feature that make them suitable to implement queues, and in general as a building block for inter process communication systems: blocking operations.</p> <p>Imagine you want to push items into a list with one process, and use a different process in order to actually do some kind of work with those items. This is the usual producer / consumer setup, and can be implemented in the following simple way:</p> <ul> <li>To push items into the list, producers call <code>LPUSH</code>.</li> <li>To extract / process items from the list, consumers call <code>RPOP</code>.</li> </ul> <p>However it is possible that sometimes the list is empty and there is nothing to process, so <code>RPOP</code> just returns NULL. In this case a consumer is forced to wait some time and retry again with <code>RPOP</code>. This is called polling, and is not a good idea in this context because it has several drawbacks:</p> <ol> <li>Forces Redis and clients to process useless commands (all the requests when the list is empty will get no actual work done, they'll just return NULL).</li> <li>Adds a delay to the processing of items, since after a worker receives a NULL, it waits some time. To make the delay smaller, we could wait less between calls to <code>RPOP</code>, with the effect of amplifying problem number 1, i.e. more useless calls to Redis.</li> </ol> <p>So Redis implements commands called <code>BRPOP</code> and <code>BLPOP</code> which are versions of <code>RPOP</code> and <code>LPOP</code> able to block if the list is empty: they'll return to the caller only when a new element is added to the list, or when a user-specified timeout is reached.</p> <p>This is an example of a <code>BRPOP</code> call we could use in the worker:</p> <p>{{&lt; clients-example list_tutorial brpop &gt;}}</p> <p>RPUSH bikes:repairs bike:1 bike:2 (integer) 2 BRPOP bikes:repairs 1 1) \"bikes:repairs\" 2) \"bike:2\" BRPOP bikes:repairs 1 1) \"bikes:repairs\" 2) \"bike:1\" BRPOP bikes:repairs 1 (nil) (2.01s) {{&lt; /clients-example &gt;}}</p> <p>It means: \"wait for elements in the list <code>bikes:repairs</code>, but return if after 1 second no element is available\".</p> <p>Note that you can use 0 as timeout to wait for elements forever, and you can also specify multiple lists and not just one, in order to wait on multiple lists at the same time, and get notified when the first list receives an element.</p> <p>A few things to note about <code>BRPOP</code>:</p> <ol> <li>Clients are served in an ordered way: the first client that blocked waiting for a list, is served first when an element is pushed by some other client, and so forth.</li> <li>The return value is different compared to <code>RPOP</code>: it is a two-element array since it also includes the name of the key, because <code>BRPOP</code> and <code>BLPOP</code> are able to block waiting for elements from multiple lists.</li> <li>If the timeout is reached, NULL is returned.</li> </ol> <p>There are more things you should know about lists and blocking ops. We suggest that you read more on the following:</p> <ul> <li>It is possible to build safer queues or rotating queues using <code>LMOVE</code>.</li> <li>There is also a blocking variant of the command, called <code>BLMOVE</code>.</li> </ul>"},{"location":"4-data-types/lists/#automatic-creation-and-removal-of-keys","title":"Automatic creation and removal of keys","text":"<p>So far in our examples we never had to create empty lists before pushing elements, or removing empty lists when they no longer have elements inside. It is Redis' responsibility to delete keys when lists are left empty, or to create an empty list if the key does not exist and we are trying to add elements to it, for example, with <code>LPUSH</code>.</p> <p>This is not specific to lists, it applies to all the Redis data types composed of multiple elements -- Streams, Sets, Sorted Sets and Hashes.</p> <p>Basically we can summarize the behavior with three rules:</p> <ol> <li>When we add an element to an aggregate data type, if the target key does not exist, an empty aggregate data type is created before adding the element.</li> <li>When we remove elements from an aggregate data type, if the value remains empty, the key is automatically destroyed. The Stream data type is the only exception to this rule.</li> <li>Calling a read-only command such as <code>LLEN</code> (which returns the length of the list), or a write command removing elements, with an empty key, always produces the same result as if the key is holding an empty aggregate type of the type the command expects to find.</li> </ol> <p>Examples of rule 1:</p> <p>{{&lt; clients-example list_tutorial rule_1 &gt;}}</p> <p>DEL new_bikes (integer) 0 LPUSH new_bikes bike:1 bike:2 bike:3 (integer) 3 {{&lt; /clients-example &gt;}}</p> <p>However we can't perform operations against the wrong type if the key exists:</p> <p>{{&lt; clients-example list_tutorial rule_1.1 &gt;}}</p> <p>SET new_bikes bike:1 OK TYPE new_bikes string LPUSH new_bikes bike:2 bike:3 (error) WRONGTYPE Operation against a key holding the wrong kind of value {{&lt; /clients-example &gt;}}</p> <p>Example of rule 2:</p> <p>{{&lt; clients-example list_tutorial rule_2 &gt;}}</p> <p>RPUSH bikes:repairs bike:1 bike:2 bike:3 (integer) 3 EXISTS bikes:repairs (integer) 1 LPOP bikes:repairs \"bike:3\" LPOP bikes:repairs \"bike:2\" LPOP bikes:repairs \"bike:1\" EXISTS bikes:repairs (integer) 0 {{&lt; /clients-example &gt;}}</p> <p>The key no longer exists after all the elements are popped.</p> <p>Example of rule 3:</p> <p>{{&lt; clients-example list_tutorial rule_3 &gt;}}</p> <p>DEL bikes:repairs (integer) 0 LLEN bikes:repairs (integer) 0 LPOP bikes:repairs (nil) {{&lt; /clients-example &gt;}}</p>"},{"location":"4-data-types/lists/#limits","title":"Limits","text":"<p>The max length of a Redis list is 2^32 - 1 (4,294,967,295) elements.</p>"},{"location":"4-data-types/lists/#performance","title":"Performance","text":"<p>List operations that access its head or tail are O(1), which means they're highly efficient. However, commands that manipulate elements within a list are usually O(n). Examples of these include <code>LINDEX</code>, <code>LINSERT</code>, and <code>LSET</code>. Exercise caution when running these commands, mainly when operating on large lists.</p>"},{"location":"4-data-types/lists/#alternatives","title":"Alternatives","text":"<p>Consider Redis streams as an alternative to lists when you need to store and process an indeterminate series of events.</p>"},{"location":"4-data-types/lists/#learn-more","title":"Learn more","text":"<ul> <li>Redis Lists Explained is a short, comprehensive video explainer on Redis lists.</li> <li>Redis University's RU101 covers Redis lists in detail.</li> </ul>"},{"location":"4-data-types/sets/","title":"Redis sets","text":"<p>A Redis set is an unordered collection of unique strings (members). You can use Redis sets to efficiently:</p> <ul> <li>Track unique items (e.g., track all unique IP addresses accessing a given blog post).</li> <li>Represent relations (e.g., the set of all users with a given role).</li> <li>Perform common set operations such as intersection, unions, and differences.</li> </ul>"},{"location":"4-data-types/sets/#basic-commands","title":"Basic commands","text":"<ul> <li><code>SADD</code> adds a new member to a set.</li> <li><code>SREM</code> removes the specified member from the set.</li> <li><code>SISMEMBER</code> tests a string for set membership.</li> <li><code>SINTER</code> returns the set of members that two or more sets have in common (i.e., the intersection).</li> <li><code>SCARD</code> returns the size (a.k.a. cardinality) of a set.</li> </ul> <p>See the complete list of set commands.</p>"},{"location":"4-data-types/sets/#examples","title":"Examples","text":"<ul> <li> <p>Store the sets of bikes racing in France and the USA. Note that  if you add a member that already exists, it will be ignored.  {{&lt; clients-example sets_tutorial sadd &gt;}}</p> <p>SADD bikes:racing:france bike:1 (integer) 1 SADD bikes:racing:france bike:1 (integer) 0 SADD bikes:racing:france bike:2 bike:3 (integer) 2 SADD bikes:racing:usa bike:1 bike:4 (integer) 2 {{&lt; /clients-example &gt;}}</p> </li> <li> <p>Check whether bike:1 or bike:2 are racing in the US. {{&lt; clients-example sets_tutorial sismember &gt;}}</p> <p>SISMEMBER bikes:racing:usa bike:1 (integer) 1 SISMEMBER bikes:racing:usa bike:2 (integer) 0 {{&lt; /clients-example &gt;}}</p> </li> <li> <p>Which bikes are competing in both races? {{&lt; clients-example sets_tutorial sinter &gt;}}</p> <p>SINTER bikes:racing:france bikes:racing:usa 1) \"bike:1\" {{&lt; /clients-example &gt;}}</p> </li> <li> <p>How many bikes are racing in France? {{&lt; clients-example sets_tutorial scard &gt;}}</p> <p>SCARD bikes:racing:france (integer) 3 {{&lt; /clients-example &gt;}}</p> </li> </ul>"},{"location":"4-data-types/sets/#tutorial","title":"Tutorial","text":"<p>The <code>SADD</code> command adds new elements to a set. It's also possible to do a number of other operations against sets like testing if a given element already exists, performing the intersection, union or difference between multiple sets, and so forth.</p> <p>{{&lt; clients-example sets_tutorial sadd_smembers &gt;}}</p> <p>SADD bikes:racing:france bike:1 bike:2 bike:3 (integer) 3 SMEMBERS bikes:racing:france 1) bike:3 2) bike:1 3) bike:2 {{&lt; /clients-example &gt;}}</p> <p>Here I've added three elements to my set and told Redis to return all the elements. There is no order guarantee with a set. Redis is free to return the elements in any order at every call.</p> <p>Redis has commands to test for set membership. These commands can be used on single as well as multiple items:</p> <p>{{&lt; clients-example sets_tutorial smismember &gt;}}</p> <p>SISMEMBER bikes:racing:france bike:1 (integer) 1 SMISMEMBER bikes:racing:france bike:2 bike:3 bike:4 1) (integer) 1 2) (integer) 1 3) (integer) 0 {{&lt; /clients-example &gt;}}</p> <p>We can also find the difference between two sets. For instance, we may want to know which bikes are racing in France but not in the USA:</p> <p>{{&lt; clients-example sets_tutorial sdiff &gt;}}</p> <p>SADD bikes:racing:usa bike:1 bike:4 (integer) 2 SDIFF bikes:racing:france bikes:racing:usa 1) \"bike:3\" 2) \"bike:2\" {{&lt; /clients-example &gt;}}</p> <p>There are other non trivial operations that are still easy to implement using the right Redis commands. For instance we may want a list of all the bikes racing in France, the USA, and some other races. We can do this using the <code>SINTER</code> command, which performs the intersection between different sets. In addition to intersection you can also perform unions, difference, and more. For example  if we add a third race we can see some of these commands in action:</p> <p>{{&lt; clients-example sets_tutorial multisets &gt;}}</p> <p>SADD bikes:racing:france bike:1 bike:2 bike:3 (integer) 3 SADD bikes:racing:usa bike:1 bike:4 (integer) 2 SADD bikes:racing:italy bike:1 bike:2 bike:3 bike:4 (integer) 4 SINTER bikes:racing:france bikes:racing:usa bikes:racing:italy 1) \"bike:1\" SUNION bikes:racing:france bikes:racing:usa bikes:racing:italy 1) \"bike:2\" 2) \"bike:1\" 3) \"bike:4\" 4) \"bike:3\" SDIFF bikes:racing:france bikes:racing:usa bikes:racing:italy (empty array) SDIFF bikes:racing:france bikes:racing:usa 1) \"bike:3\" 2) \"bike:2\" SDIFF bikes:racing:usa bikes:racing:france 1) \"bike:4\" {{&lt; /clients-example &gt;}}</p> <p>You'll note that the <code>SDIFF</code> command returns an empty array when the difference between all sets is empty. You'll also note that the order of sets passed to <code>SDIFF</code> matters, since the difference is not commutative.</p> <p>When you want to remove items from a set, you can use the <code>SREM</code> command to remove one or more items from a set, or you can use the <code>SPOP</code> command to remove a random item from a set. You can also return a random item from a set without removing it using the <code>SRANDMEMBER</code> command:</p> <p>{{&lt; clients-example sets_tutorial srem &gt;}}</p> <p>SADD bikes:racing:france bike:1 bike:2 bike:3 bike:4 bike:5 (integer) 5 SREM bikes:racing:france bike:1 (integer) 1 SPOP bikes:racing:france \"bike:3\" SMEMBERS bikes:racing:france 1) \"bike:2\" 2) \"bike:4\" 3) \"bike:5\" SRANDMEMBER bikes:racing:france \"bike:2\" {{&lt; /clients-example &gt;}}</p>"},{"location":"4-data-types/sets/#limits","title":"Limits","text":"<p>The max size of a Redis set is 2^32 - 1 (4,294,967,295) members.</p>"},{"location":"4-data-types/sets/#performance","title":"Performance","text":"<p>Most set operations, including adding, removing, and checking whether an item is a set member, are O(1). This means that they're highly efficient. However, for large sets with hundreds of thousands of members or more, you should exercise caution when running the <code>SMEMBERS</code> command. This command is O(n) and returns the entire set in a single response.  As an alternative, consider the <code>SSCAN</code>, which lets you retrieve all members of a set iteratively.</p>"},{"location":"4-data-types/sets/#alternatives","title":"Alternatives","text":"<p>Sets membership checks on large datasets (or on streaming data) can use a lot of memory. If you're concerned about memory usage and don't need perfect precision, consider a Bloom filter or Cuckoo filter as an alternative to a set.</p> <p>Redis sets are frequently used as a kind of index. If you need to index and query your data, consider the JSON data type and the Search and query features.</p>"},{"location":"4-data-types/sets/#learn-more","title":"Learn more","text":"<ul> <li>Redis Sets Explained and Redis Sets Elaborated are two short but thorough video explainers covering Redis sets.</li> <li>Redis University's RU101 explores Redis sets in detail.</li> </ul>"},{"location":"4-data-types/sorted-sets/","title":"Redis sorted sets","text":"<p>A Redis sorted set is a collection of unique strings (members) ordered by an associated score. When more than one string has the same score, the strings are ordered lexicographically. Some use cases for sorted sets include:</p> <ul> <li>Leaderboards. For example, you can use sorted sets to easily maintain  ordered lists of the highest scores in a massive online game.</li> <li>Rate limiters. In particular, you can use a sorted set to build a sliding-window rate limiter to prevent excessive API requests.</li> </ul> <p>You can think of sorted sets as a mix between a Set and a Hash. Like sets, sorted sets are composed of unique, non-repeating string elements, so in some sense a sorted set is a set as well.</p> <p>However while elements inside sets are not ordered, every element in a sorted set is associated with a floating point value, called the score (this is why the type is also similar to a hash, since every element is mapped to a value).</p> <p>Moreover, elements in a sorted set are taken in order (so they are not ordered on request, order is a peculiarity of the data structure used to represent sorted sets). They are ordered according to the following rule:</p> <ul> <li>If B and A are two elements with a different score, then A &gt; B if A.score is &gt; B.score.</li> <li>If B and A have exactly the same score, then A &gt; B if the A string is lexicographically greater than the B string. B and A strings can't be equal since sorted sets only have unique elements.</li> </ul> <p>Let's start with a simple example, we'll add all our racers and the score they got in the first race:</p> <p>{{&lt; clients-example ss_tutorial zadd &gt;}}</p> <p>ZADD racer_scores 10 \"Norem\" (integer) 1 ZADD racer_scores 12 \"Castilla\" (integer) 1 ZADD racer_scores 8 \"Sam-Bodden\" 10 \"Royce\" 6 \"Ford\" 14 \"Prickett\" (integer) 4 {{&lt; /clients-example &gt;}}</p> <p>As you can see <code>ZADD</code> is similar to <code>SADD</code>, but takes one additional argument (placed before the element to be added) which is the score. <code>ZADD</code> is also variadic, so you are free to specify multiple score-value pairs, even if this is not used in the example above.</p> <p>With sorted sets it is trivial to return a list of hackers sorted by their birth year because actually they are already sorted.</p> <p>Implementation note: Sorted sets are implemented via a dual-ported data structure containing both a skip list and a hash table, so every time we add an element Redis performs an O(log(N)) operation. That's good, but when we ask for sorted elements Redis does not have to do any work at all, it's already sorted. Note that the <code>ZRANGE</code> order is low to high, while the <code>ZREVRANGE</code> order is high to low:</p> <p>{{&lt; clients-example ss_tutorial zrange &gt;}}</p> <p>ZRANGE racer_scores 0 -1 1) \"Ford\" 2) \"Sam-Bodden\" 3) \"Norem\" 4) \"Royce\" 5) \"Castilla\" 6) \"Prickett\" ZREVRANGE racer_scores 0 -1 1) \"Prickett\" 2) \"Castilla\" 3) \"Royce\" 4) \"Norem\" 5) \"Sam-Bodden\" 6) \"Ford\" {{&lt; /clients-example &gt;}}</p> <p>Note: 0 and -1 means from element index 0 to the last element (-1 works here just as it does in the case of the <code>LRANGE</code> command).</p> <p>It is possible to return scores as well, using the <code>WITHSCORES</code> argument:</p> <p>{{&lt; clients-example ss_tutorial zrange_withscores &gt;}}</p> <p>ZRANGE racer_scores 0 -1 withscores  1) \"Ford\"  2) \"6\"  3) \"Sam-Bodden\"  4) \"8\"  5) \"Norem\"  6) \"10\"  7) \"Royce\"  8) \"10\"  9) \"Castilla\" 10) \"12\" 11) \"Prickett\" 12) \"14\" {{&lt; /clients-example &gt;}}</p>"},{"location":"4-data-types/sorted-sets/#operating-on-ranges","title":"Operating on ranges","text":"<p>Sorted sets are more powerful than this. They can operate on ranges. Let's get all the racers with 10 or fewer points. We use the <code>ZRANGEBYSCORE</code> command to do it:</p> <p>{{&lt; clients-example ss_tutorial zrangebyscore &gt;}}</p> <p>ZRANGEBYSCORE racer_scores -inf 10 1) \"Ford\" 2) \"Sam-Bodden\" 3) \"Norem\" 4) \"Royce\" {{&lt; /clients-example &gt;}}</p> <p>We asked Redis to return all the elements with a score between negative infinity and 10 (both extremes are included).</p> <p>To remove an element we'd simply call <code>ZREM</code> with the racer's name.  It's also possible to remove ranges of elements. Let's remove racer Castilla along with all the racers with strictly fewer than 10 points:</p> <p>{{&lt; clients-example ss_tutorial zremrangebyscore &gt;}}</p> <p>ZREM racer_scores \"Castilla\" (integer) 1 ZREMRANGEBYSCORE racer_scores -inf 9 (integer) 2 ZRANGE racer_scores 0 -1 1) \"Norem\" 2) \"Royce\" 3) \"Prickett\" {{&lt; /clients-example &gt;}}</p> <p><code>ZREMRANGEBYSCORE</code> is perhaps not the best command name, but it can be very useful, and returns the number of removed elements.</p> <p>Another extremely useful operation defined for sorted set elements is the get-rank operation. It is possible to ask what is the position of an element in the set of ordered elements.  The <code>ZREVRANK</code> command is also available in order to get the rank, considering the elements sorted in a descending way.</p> <p>{{&lt; clients-example ss_tutorial zrank &gt;}}</p> <p>ZRANK racer_scores \"Norem\" (integer) 0 ZREVRANK racer_scores \"Norem\" (integer) 3 {{&lt; /clients-example &gt;}}</p>"},{"location":"4-data-types/sorted-sets/#lexicographical-scores","title":"Lexicographical scores","text":"<p>In version Redis 2.8, a new feature was introduced that allows getting ranges lexicographically, assuming elements in a sorted set are all inserted with the same identical score (elements are compared with the C <code>memcmp</code> function, so it is guaranteed that there is no collation, and every Redis instance will reply with the same output).</p> <p>The main commands to operate with lexicographical ranges are <code>ZRANGEBYLEX</code>, <code>ZREVRANGEBYLEX</code>, <code>ZREMRANGEBYLEX</code> and <code>ZLEXCOUNT</code>.</p> <p>For example, let's add again our list of famous hackers, but this time using a score of zero for all the elements. We'll see that because of the sorted sets ordering rules, they are already sorted lexicographically. Using <code>ZRANGEBYLEX</code> we can ask for lexicographical ranges:</p> <p>{{&lt; clients-example ss_tutorial zadd_lex &gt;}}</p> <p>ZADD racer_scores 0 \"Norem\" 0 \"Sam-Bodden\" 0 \"Royce\" 0 \"Castilla\" 0 \"Prickett\" 0 \"Ford\" (integer) 3 ZRANGE racer_scores 0 -1 1) \"Castilla\" 2) \"Ford\" 3) \"Norem\" 4) \"Prickett\" 5) \"Royce\" 6) \"Sam-Bodden\" ZRANGEBYLEX racer_scores [A [L 1) \"Castilla\" 2) \"Ford\" {{&lt; /clients-example &gt;}}</p> <p>Ranges can be inclusive or exclusive (depending on the first character), also string infinite and minus infinite are specified respectively with the <code>+</code> and <code>-</code> strings. See the documentation for more information.</p> <p>This feature is important because it allows us to use sorted sets as a generic index. For example, if you want to index elements by a 128-bit unsigned integer argument, all you need to do is to add elements into a sorted set with the same score (for example 0) but with a 16 byte prefix consisting of the 128 bit number in big endian. Since numbers in big endian, when ordered lexicographically (in raw bytes order) are actually ordered numerically as well, you can ask for ranges in the 128 bit space, and get the element's value discarding the prefix.</p> <p>If you want to see the feature in the context of a more serious demo, check the Redis autocomplete demo.</p>"},{"location":"4-data-types/sorted-sets/#updating-the-score-leaderboards","title":"Updating the score: leaderboards","text":"<p>Just a final note about sorted sets before switching to the next topic. Sorted sets' scores can be updated at any time. Just calling <code>ZADD</code> against an element already included in the sorted set will update its score (and position) with O(log(N)) time complexity.  As such, sorted sets are suitable when there are tons of updates.</p> <p>Because of this characteristic a common use case is leaderboards. The typical application is a Facebook game where you combine the ability to take users sorted by their high score, plus the get-rank operation, in order to show the top-N users, and the user rank in the leader board (e.g., \"you are the #4932 best score here\").</p>"},{"location":"4-data-types/sorted-sets/#examples","title":"Examples","text":"<ul> <li>There are two ways we can use a sorted set to represent a leaderbaord. If we know a racer's new score, we can update it directly via the <code>ZADD</code> command. However, if we want to add points to an existing score, we can use the <code>ZINCRBY</code> command. {{&lt; clients-example ss_tutorial leaderboard &gt;}} <p>ZADD racer_scores 100 \"Wood\" (integer) 1 ZADD racer_scores 100 \"Henshaw\" (integer) 1 ZADD racer_scores 150 \"Henshaw\" (integer) 0 ZINCRBY racer_scores 50 \"Wood\" \"150\" ZINCRBY racer_scores 50 \"Henshaw\" \"200\" {{&lt; /clients-example &gt;}}</p> </li> </ul> <p>You'll see that <code>ZADD</code> returns 0 when the member already exists (the score is updated), while <code>ZINCRBY</code> returns the new score. The score for racer Henshaw went from 100, was changed to 150 with no regard for what score was there before, and then was incremented by 50 to 200.</p>"},{"location":"4-data-types/sorted-sets/#basic-commands","title":"Basic commands","text":"<ul> <li><code>ZADD</code> adds a new member and associated score to a sorted set. If the member already exists, the score is updated.</li> <li><code>ZRANGE</code> returns members of a sorted set, sorted within a given range.</li> <li><code>ZRANK</code> returns the rank of the provided member, assuming the sorted is in ascending order.</li> <li><code>ZREVRANK</code> returns the rank of the provided member, assuming the sorted set is in descending order.</li> </ul> <p>See the complete list of sorted set commands.</p>"},{"location":"4-data-types/sorted-sets/#performance","title":"Performance","text":"<p>Most sorted set operations are O(log(n)), where n is the number of members.</p> <p>Exercise some caution when running the <code>ZRANGE</code> command with large returns values (e.g., in the tens of thousands or more). This command's time complexity is O(log(n) + m), where m is the number of results returned. </p>"},{"location":"4-data-types/sorted-sets/#alternatives","title":"Alternatives","text":"<p>Redis sorted sets are sometimes used for indexing other Redis data structures. If you need to index and query your data, consider the JSON data type and the Search and query features.</p>"},{"location":"4-data-types/sorted-sets/#learn-more","title":"Learn more","text":"<ul> <li>Redis Sorted Sets Explained is an entertaining introduction to sorted sets in Redis.</li> <li> <p>Redis University's RU101 explores Redis sorted sets in detail.</p> </li> <li> <p>Redis Sorted Sets Explained is an entertaining introduction to sorted sets in Redis.</p> </li> <li>Redis University's RU101 explores Redis sorted sets in detail.</li> </ul>"},{"location":"4-data-types/streams/","title":"Redis Streams","text":"<p>A Redis stream is a data structure that acts like an append-only log but also implements several operations to overcome some of the limits of a typical append-only log. These include random access in O(1) time and complex consumption strategies, such as consumer groups. You can use streams to record and simultaneously syndicate events in real time. Examples of Redis stream use cases include:</p> <ul> <li>Event sourcing (e.g., tracking user actions, clicks, etc.)</li> <li>Sensor monitoring (e.g., readings from devices in the field) </li> <li>Notifications (e.g., storing a record of each user's notifications in a separate stream)</li> </ul> <p>Redis generates a unique ID for each stream entry. You can use these IDs to retrieve their associated entries later or to read and process all subsequent entries in the stream. Note that because these IDs are related to time, the ones shown here may vary and will be different from the IDs you see in your own Redis instance.</p> <p>Redis streams support several trimming strategies (to prevent streams from growing unbounded) and more than one consumption strategy (see <code>XREAD</code>, <code>XREADGROUP</code>, and <code>XRANGE</code>).</p>"},{"location":"4-data-types/streams/#basic-commands","title":"Basic commands","text":"<ul> <li><code>XADD</code> adds a new entry to a stream.</li> <li><code>XREAD</code> reads one or more entries, starting at a given position and moving forward in time.</li> <li><code>XRANGE</code> returns a range of entries between two supplied entry IDs.</li> <li><code>XLEN</code> returns the length of a stream.</li> </ul> <p>See the complete list of stream commands.</p>"},{"location":"4-data-types/streams/#examples","title":"Examples","text":"<ul> <li> <p>When our racers pass a checkpoint, we add a stream entry for each racer that includes the racer's name, speed, position, and location ID: {{&lt; clients-example stream_tutorial xadd &gt;}}</p> <p>XADD race:france * rider Castilla speed 30.2 position 1 location_id 1 \"1692632086370-0\" XADD race:france * rider Norem speed 28.8 position 3 location_id 1 \"1692632094485-0\" XADD race:france * rider Prickett speed 29.7 position 2 location_id 1 \"1692632102976-0\" {{&lt; /clients-example &gt;}}</p> </li> <li> <p>Read two stream entries starting at ID <code>1692632086370-0</code>: {{&lt; clients-example stream_tutorial xrange &gt;}}</p> <p>XRANGE race:france 1692632086370-0 + COUNT 2 1) 1) \"1692632086370-0\"    2) 1) \"rider\"       2) \"Castilla\"       3) \"speed\"       4) \"30.2\"       5) \"position\"       6) \"1\"       7) \"location_id\"       8) \"1\" 2) 1) \"1692632094485-0\"    2) 1) \"rider\"       2) \"Norem\"       3) \"speed\"       4) \"28.8\"       5) \"position\"       6) \"3\"       7) \"location_id\"       8) \"1\" {{&lt; /clients-example &gt;}}</p> </li> <li> <p>Read up to 100 new stream entries, starting at the end of the stream, and block for up to 300 ms if no entries are being written: {{&lt; clients-example stream_tutorial xread_block &gt;}}</p> <p>XREAD COUNT 100 BLOCK 300 STREAMS race:france $ (nil) {{&lt; /clients-example &gt;}}</p> </li> </ul>"},{"location":"4-data-types/streams/#performance","title":"Performance","text":"<p>Adding an entry to a stream is O(1). Accessing any single entry is O(n), where n is the length of the ID. Since stream IDs are typically short and of a fixed length, this effectively reduces to a constant time lookup. For details on why, note that streams are implemented as radix trees.</p> <p>Simply put, Redis streams provide highly efficient inserts and reads. See each command's time complexity for the details.</p>"},{"location":"4-data-types/streams/#streams-basics","title":"Streams basics","text":"<p>Streams are an append-only data structure. The fundamental write command, called <code>XADD</code>, appends a new entry to the specified stream.</p> <p>Each stream entry consists of one or more field-value pairs, somewhat like a dictionary or a Redis hash:</p> <p>{{&lt; clients-example stream_tutorial xadd_2 &gt;}}</p> <p>XADD race:france * rider Castilla speed 29.9 position 1 location_id 2 \"1692632147973-0\" {{&lt; /clients-example &gt;}}</p> <p>The above call to the <code>XADD</code> command adds an entry <code>rider: Castilla, speed: 29.9, position: 1, location_id: 2</code> to the stream at key <code>race:france</code>, using an auto-generated entry ID, which is the one returned by the command, specifically <code>1692632147973-0</code>. It gets as its first argument the key name <code>race:france</code>, the second argument is the entry ID that identifies every entry inside a stream. However, in this case, we passed <code>*</code> because we want the server to generate a new ID for us. Every new ID will be monotonically increasing, so in more simple terms, every new entry added will have a higher ID compared to all the past entries. Auto-generation of IDs by the server is almost always what you want, and the reasons for specifying an ID explicitly are very rare. We'll talk more about this later. The fact that each Stream entry has an ID is another similarity with log files, where line numbers, or the byte offset inside the file, can be used in order to identify a given entry. Returning back at our <code>XADD</code> example, after the key name and ID, the next arguments are the field-value pairs composing our stream entry.</p> <p>It is possible to get the number of items inside a Stream just using the <code>XLEN</code> command:</p> <p>{{&lt; clients-example stream_tutorial xlen &gt;}}</p> <p>XLEN race:france (integer) 4 {{&lt; /clients-example &gt;}}</p>"},{"location":"4-data-types/streams/#entry-ids","title":"Entry IDs","text":"<p>The entry ID returned by the <code>XADD</code> command, and identifying univocally each entry inside a given stream, is composed of two parts:</p> <pre><code>&lt;millisecondsTime&gt;-&lt;sequenceNumber&gt;\n</code></pre> <p>The milliseconds time part is actually the local time in the local Redis node generating the stream ID, however if the current milliseconds time happens to be smaller than the previous entry time, then the previous entry time is used instead, so if a clock jumps backward the monotonically incrementing ID property still holds. The sequence number is used for entries created in the same millisecond. Since the sequence number is 64 bit wide, in practical terms there is no limit to the number of entries that can be generated within the same millisecond.</p> <p>The format of such IDs may look strange at first, and the gentle reader may wonder why the time is part of the ID. The reason is that Redis streams support range queries by ID. Because the ID is related to the time the entry is generated, this gives the ability to query for time ranges basically for free. We will see this soon while covering the <code>XRANGE</code> command.</p> <p>If for some reason the user needs incremental IDs that are not related to time but are actually associated to another external system ID, as previously mentioned, the <code>XADD</code> command can take an explicit ID instead of the <code>*</code> wildcard ID that triggers auto-generation, like in the following examples:</p> <p>{{&lt; clients-example stream_tutorial xadd_id &gt;}}</p> <p>XADD race:usa 0-1 racer Castilla 0-1 XADD race:usa 0-2 racer Norem 0-2 {{&lt; /clients-example &gt;}}</p> <p>Note that in this case, the minimum ID is 0-1 and that the command will not accept an ID equal or smaller than a previous one:</p> <p>{{&lt; clients-example stream_tutorial xadd_bad_id &gt;}}</p> <p>XADD race:usa 0-1 racer Prickett (error) ERR The ID specified in XADD is equal or smaller than the target stream top item {{&lt; /clients-example &gt;}}</p> <p>If you're running Redis 7 or later, you can also provide an explicit ID consisting of the milliseconds part only. In this case, the sequence portion of the ID will be automatically generated. To do this, use the syntax below:</p> <p>{{&lt; clients-example stream_tutorial xadd_7 &gt;}}</p> <p>XADD race:usa 0-* racer Prickett 0-3 {{&lt; /clients-example &gt;}}</p>"},{"location":"4-data-types/streams/#getting-data-from-streams","title":"Getting data from Streams","text":"<p>Now we are finally able to append entries in our stream via <code>XADD</code>. However, while appending data to a stream is quite obvious, the way streams can be queried in order to extract data is not so obvious. If we continue with the analogy of the log file, one obvious way is to mimic what we normally do with the Unix command <code>tail -f</code>, that is, we may start to listen in order to get the new messages that are appended to the stream. Note that unlike the blocking list operations of Redis, where a given element will reach a single client which is blocking in a pop style operation like <code>BLPOP</code>, with streams we want multiple consumers to see the new messages appended to the stream (the same way many <code>tail -f</code> processes can see what is added to a log). Using the traditional terminology we want the streams to be able to fan out messages to multiple clients.</p> <p>However, this is just one potential access mode. We could also see a stream in quite a different way: not as a messaging system, but as a time series store. In this case, maybe it's also useful to get the new messages appended, but another natural query mode is to get messages by ranges of time, or alternatively to iterate the messages using a cursor to incrementally check all the history. This is definitely another useful access mode.</p> <p>Finally, if we see a stream from the point of view of consumers, we may want to access the stream in yet another way, that is, as a stream of messages that can be partitioned to multiple consumers that are processing such messages, so that groups of consumers can only see a subset of the messages arriving in a single stream. In this way, it is possible to scale the message processing across different consumers, without single consumers having to process all the messages: each consumer will just get different messages to process. This is basically what Kafka (TM) does with consumer groups. Reading messages via consumer groups is yet another interesting mode of reading from a Redis Stream.</p> <p>Redis Streams support all three of the query modes described above via different commands. The next sections will show them all, starting from the simplest and most direct to use: range queries.</p>"},{"location":"4-data-types/streams/#querying-by-range-xrange-and-xrevrange","title":"Querying by range: XRANGE and XREVRANGE","text":"<p>To query the stream by range we are only required to specify two IDs, start and end. The range returned will include the elements having start or end as ID, so the range is inclusive. The two special IDs <code>-</code> and <code>+</code> respectively mean the smallest and the greatest ID possible.</p> <p>{{&lt; clients-example stream_tutorial xrange_all &gt;}}</p> <p>XRANGE race:france - + 1) 1) \"1692632086370-0\"    2) 1) \"rider\"       2) \"Castilla\"       3) \"speed\"       4) \"30.2\"       5) \"position\"       6) \"1\"       7) \"location_id\"       8) \"1\" 2) 1) \"1692632094485-0\"    2) 1) \"rider\"       2) \"Norem\"       3) \"speed\"       4) \"28.8\"       5) \"position\"       6) \"3\"       7) \"location_id\"       8) \"1\" 3) 1) \"1692632102976-0\"    2) 1) \"rider\"       2) \"Prickett\"       3) \"speed\"       4) \"29.7\"       5) \"position\"       6) \"2\"       7) \"location_id\"       8) \"1\" 4) 1) \"1692632147973-0\"    2) 1) \"rider\"       2) \"Castilla\"       3) \"speed\"       4) \"29.9\"       5) \"position\"       6) \"1\"       7) \"location_id\"       8) \"2\" {{&lt; /clients-example &gt;}}</p> <p>Each entry returned is an array of two items: the ID and the list of field-value pairs. We already said that the entry IDs have a relation with the time, because the part at the left of the <code>-</code> character is the Unix time in milliseconds of the local node that created the stream entry, at the moment the entry was created (however note that streams are replicated with fully specified <code>XADD</code> commands, so the replicas will have identical IDs to the master). This means that I could query a range of time using <code>XRANGE</code>. In order to do so, however, I may want to omit the sequence part of the ID: if omitted, in the start of the range it will be assumed to be 0, while in the end part it will be assumed to be the maximum sequence number available. This way, querying using just two milliseconds Unix times, we get all the entries that were generated in that range of time, in an inclusive way. For instance, if I want to query a two milliseconds period I could use:</p> <p>{{&lt; clients-example stream_tutorial xrange_time &gt;}}</p> <p>XRANGE race:france 1692632086369 1692632086371 1) 1) \"1692632086370-0\"    2) 1) \"rider\"       2) \"Castilla\"       3) \"speed\"       4) \"30.2\"       5) \"position\"       6) \"1\"       7) \"location_id\"       8) \"1\" {{&lt; /clients-example &gt;}}</p> <p>I have only a single entry in this range. However in real data sets, I could query for ranges of hours, or there could be many items in just two milliseconds, and the result returned could be huge. For this reason, <code>XRANGE</code> supports an optional COUNT option at the end. By specifying a count, I can just get the first N items. If I want more, I can get the last ID returned, increment the sequence part by one, and query again. Let's see this in the following example. Let's assume that the stream <code>race:france</code> was populated with 4 items. To start my iteration, getting 2 items per command, I start with the full range, but with a count of 2.</p> <p>{{&lt; clients-example stream_tutorial xrange_step_1 &gt;}}</p> <p>XRANGE race:france - + COUNT 2 1) 1) \"1692632086370-0\"    2) 1) \"rider\"       2) \"Castilla\"       3) \"speed\"       4) \"30.2\"       5) \"position\"       6) \"1\"       7) \"location_id\"       8) \"1\" 2) 1) \"1692632094485-0\"    2) 1) \"rider\"       2) \"Norem\"       3) \"speed\"       4) \"28.8\"       5) \"position\"       6) \"3\"       7) \"location_id\"       8) \"1\" {{&lt; /clients-example &gt;}}</p> <p>To continue the iteration with the next two items, I have to pick the last ID returned, that is <code>1692632094485-0</code>, and add the prefix <code>(</code> to it. The resulting exclusive range interval, that is <code>(1692632094485-0</code> in this case, can now be used as the new start argument for the next <code>XRANGE</code> call:</p> <p>{{&lt; clients-example stream_tutorial xrange_step_2 &gt;}}</p> <p>XRANGE race:france (1692632094485-0 + COUNT 2 1) 1) \"1692632102976-0\"    2) 1) \"rider\"       2) \"Prickett\"       3) \"speed\"       4) \"29.7\"       5) \"position\"       6) \"2\"       7) \"location_id\"       8) \"1\" 2) 1) \"1692632147973-0\"    2) 1) \"rider\"       2) \"Castilla\"       3) \"speed\"       4) \"29.9\"       5) \"position\"       6) \"1\"       7) \"location_id\"       8) \"2\" {{&lt; /clients-example &gt;}}</p> <p>Now that we've retrieved 4 items out of a stream that only had 4 entries in it, if we try to retrieve more items, we'll get an empty array:</p> <p>{{&lt; clients-example stream_tutorial xrange_empty &gt;}}</p> <p>XRANGE race:france (1692632147973-0 + COUNT 2 (empty array) {{&lt; /clients-example &gt;}}</p> <p>Since <code>XRANGE</code> complexity is O(log(N)) to seek, and then O(M) to return M elements, with a small count the command has a logarithmic time complexity, which means that each step of the iteration is fast. So <code>XRANGE</code> is also the de facto streams iterator and does not require an XSCAN command.</p> <p>The command <code>XREVRANGE</code> is the equivalent of <code>XRANGE</code> but returning the elements in inverted order, so a practical use for <code>XREVRANGE</code> is to check what is the last item in a Stream:</p> <p>{{&lt; clients-example stream_tutorial xrevrange &gt;}}</p> <p>XREVRANGE race:france + - COUNT 1 1) 1) \"1692632147973-0\"    2) 1) \"rider\"       2) \"Castilla\"       3) \"speed\"       4) \"29.9\"       5) \"position\"       6) \"1\"       7) \"location_id\"       8) \"2\" {{&lt; /clients-example &gt;}}</p> <p>Note that the <code>XREVRANGE</code> command takes the start and stop arguments in reverse order.</p>"},{"location":"4-data-types/streams/#listening-for-new-items-with-xread","title":"Listening for new items with XREAD","text":"<p>When we do not want to access items by a range in a stream, usually what we want instead is to subscribe to new items arriving to the stream. This concept may appear related to Redis Pub/Sub, where you subscribe to a channel, or to Redis blocking lists, where you wait for a key to get new elements to fetch, but there are fundamental differences in the way you consume a stream:</p> <ol> <li>A stream can have multiple clients (consumers) waiting for data. Every new item, by default, will be delivered to every consumer that is waiting for data in a given stream. This behavior is different than blocking lists, where each consumer will get a different element. However, the ability to fan out to multiple consumers is similar to Pub/Sub.</li> <li>While in Pub/Sub messages are fire and forget and are never stored anyway, and while when using blocking lists, when a message is received by the client it is popped (effectively removed) from the list, streams work in a fundamentally different way. All the messages are appended in the stream indefinitely (unless the user explicitly asks to delete entries): different consumers will know what is a new message from its point of view by remembering the ID of the last message received.</li> <li>Streams Consumer Groups provide a level of control that Pub/Sub or blocking lists cannot achieve, with different groups for the same stream, explicit acknowledgment of processed items, ability to inspect the pending items, claiming of unprocessed messages, and coherent history visibility for each single client, that is only able to see its private past history of messages.</li> </ol> <p>The command that provides the ability to listen for new messages arriving into a stream is called <code>XREAD</code>. It's a bit more complex than <code>XRANGE</code>, so we'll start showing simple forms, and later the whole command layout will be provided.</p> <p>{{&lt; clients-example stream_tutorial xread &gt;}}</p> <p>XREAD COUNT 2 STREAMS race:france 0 1) 1) \"race:france\"    2) 1) 1) \"1692632086370-0\"          2) 1) \"rider\"             2) \"Castilla\"             3) \"speed\"             4) \"30.2\"             5) \"position\"             6) \"1\"             7) \"location_id\"             8) \"1\"       2) 1) \"1692632094485-0\"          2) 1) \"rider\"             2) \"Norem\"             3) \"speed\"             4) \"28.8\"             5) \"position\"             6) \"3\"             7) \"location_id\"             8) \"1\" {{&lt; /clients-example &gt;}}</p> <p>The above is the non-blocking form of <code>XREAD</code>. Note that the COUNT option is not mandatory, in fact the only mandatory option of the command is the STREAMS option, that specifies a list of keys together with the corresponding maximum ID already seen for each stream by the calling consumer, so that the command will provide the client only with messages with an ID greater than the one we specified.</p> <p>In the above command we wrote <code>STREAMS race:france 0</code> so we want all the messages in the Stream <code>race:france</code> having an ID greater than <code>0-0</code>. As you can see in the example above, the command returns the key name, because actually it is possible to call this command with more than one key to read from different streams at the same time. I could write, for instance: <code>STREAMS race:france race:italy 0 0</code>. Note how after the STREAMS option we need to provide the key names, and later the IDs. For this reason, the STREAMS option must always be the last option. Any other options must come before the STREAMS option.</p> <p>Apart from the fact that <code>XREAD</code> can access multiple streams at once, and that we are able to specify the last ID we own to just get newer messages, in this simple form the command is not doing something so different compared to <code>XRANGE</code>. However, the interesting part is that we can turn <code>XREAD</code> into a blocking command easily, by specifying the BLOCK argument:</p> <pre><code>&gt; XREAD BLOCK 0 STREAMS race:france $\n</code></pre> <p>Note that in the example above, other than removing COUNT, I specified the new BLOCK option with a timeout of 0 milliseconds (that means to never timeout). Moreover, instead of passing a normal ID for the stream <code>mystream</code> I passed the special ID <code>$</code>. This special ID means that <code>XREAD</code> should use as last ID the maximum ID already stored in the stream <code>mystream</code>, so that we will receive only new messages, starting from the time we started listening. This is similar to the <code>tail -f</code> Unix command in some way.</p> <p>Note that when the BLOCK option is used, we do not have to use the special ID <code>$</code>. We can use any valid ID. If the command is able to serve our request immediately without blocking, it will do so, otherwise it will block. Normally if we want to consume the stream starting from new entries, we start with the ID <code>$</code>, and after that we continue using the ID of the last message received to make the next call, and so forth.</p> <p>The blocking form of <code>XREAD</code> is also able to listen to multiple Streams, just by specifying multiple key names. If the request can be served synchronously because there is at least one stream with elements greater than the corresponding ID we specified, it returns with the results. Otherwise, the command will block and will return the items of the first stream which gets new data (according to the specified ID).</p> <p>Similarly to blocking list operations, blocking stream reads are fair from the point of view of clients waiting for data, since the semantics is FIFO style. The first client that blocked for a given stream will be the first to be unblocked when new items are available.</p> <p><code>XREAD</code> has no other options than COUNT and BLOCK, so it's a pretty basic command with a specific purpose to attach consumers to one or multiple streams. More powerful features to consume streams are available using the consumer groups API, however reading via consumer groups is implemented by a different command called <code>XREADGROUP</code>, covered in the next section of this guide.</p>"},{"location":"4-data-types/streams/#consumer-groups","title":"Consumer groups","text":"<p>When the task at hand is to consume the same stream from different clients, then <code>XREAD</code> already offers a way to fan-out to N clients, potentially also using replicas in order to provide more read scalability. However in certain problems what we want to do is not to provide the same stream of messages to many clients, but to provide a different subset of messages from the same stream to many clients. An obvious case where this is useful is that of messages which are slow to process: the ability to have N different workers that will receive different parts of the stream allows us to scale message processing, by routing different messages to different workers that are ready to do more work.</p> <p>In practical terms, if we imagine having three consumers C1, C2, C3, and a stream that contains the messages 1, 2, 3, 4, 5, 6, 7 then what we want is to serve the messages according to the following diagram:</p> <pre><code>1 -&gt; C1\n2 -&gt; C2\n3 -&gt; C3\n4 -&gt; C1\n5 -&gt; C2\n6 -&gt; C3\n7 -&gt; C1\n</code></pre> <p>In order to achieve this, Redis uses a concept called consumer groups. It is very important to understand that Redis consumer groups have nothing to do, from an implementation standpoint, with Kafka (TM) consumer groups. Yet they are similar in functionality, so I decided to keep Kafka's (TM) terminology, as it originally popularized this idea.</p> <p>A consumer group is like a pseudo consumer that gets data from a stream, and actually serves multiple consumers, providing certain guarantees:</p> <ol> <li>Each message is served to a different consumer so that it is not possible that the same message will be delivered to multiple consumers.</li> <li>Consumers are identified, within a consumer group, by a name, which is a case-sensitive string that the clients implementing consumers must choose. This means that even after a disconnect, the stream consumer group retains all the state, since the client will claim again to be the same consumer. However, this also means that it is up to the client to provide a unique identifier.</li> <li>Each consumer group has the concept of the first ID never consumed so that, when a consumer asks for new messages, it can provide just messages that were not previously delivered.</li> <li>Consuming a message, however, requires an explicit acknowledgment using a specific command. Redis interprets the acknowledgment as: this message was correctly processed so it can be evicted from the consumer group.</li> <li>A consumer group tracks all the messages that are currently pending, that is, messages that were delivered to some consumer of the consumer group, but are yet to be acknowledged as processed. Thanks to this feature, when accessing the message history of a stream, each consumer will only see messages that were delivered to it.</li> </ol> <p>In a way, a consumer group can be imagined as some amount of state about a stream:</p> <pre><code>+----------------------------------------+\n| consumer_group_name: mygroup           |\n| consumer_group_stream: somekey         |\n| last_delivered_id: 1292309234234-92    |\n|                                        |\n| consumers:                             |\n|    \"consumer-1\" with pending messages  |\n|       1292309234234-4                  |\n|       1292309234232-8                  |\n|    \"consumer-42\" with pending messages |\n|       ... (and so forth)               |\n+----------------------------------------+\n</code></pre> <p>If you see this from this point of view, it is very simple to understand what a consumer group can do, how it is able to just provide consumers with their history of pending messages, and how consumers asking for new messages will just be served with message IDs greater than <code>last_delivered_id</code>. At the same time, if you look at the consumer group as an auxiliary data structure for Redis streams, it is obvious that a single stream can have multiple consumer groups, that have a different set of consumers. Actually, it is even possible for the same stream to have clients reading without consumer groups via <code>XREAD</code>, and clients reading via <code>XREADGROUP</code> in different consumer groups.</p> <p>Now it's time to zoom in to see the fundamental consumer group commands. They are the following:</p> <ul> <li><code>XGROUP</code> is used in order to create, destroy and manage consumer groups.</li> <li><code>XREADGROUP</code> is used to read from a stream via a consumer group.</li> <li><code>XACK</code> is the command that allows a consumer to mark a pending message as correctly processed.</li> </ul>"},{"location":"4-data-types/streams/#creating-a-consumer-group","title":"Creating a consumer group","text":"<p>Assuming I have a key <code>race:france</code> of type stream already existing, in order to create a consumer group I just need to do the following:</p> <p>{{&lt; clients-example stream_tutorial xgroup_create &gt;}}</p> <p>XGROUP CREATE race:france france_riders $ OK {{&lt; /clients-example &gt;}}</p> <p>As you can see in the command above when creating the consumer group we have to specify an ID, which in the example is just <code>$</code>. This is needed because the consumer group, among the other states, must have an idea about what message to serve next at the first consumer connecting, that is, what was the last message ID when the group was just created. If we provide <code>$</code> as we did, then only new messages arriving in the stream from now on will be provided to the consumers in the group. If we specify <code>0</code> instead the consumer group will consume all the messages in the stream history to start with. Of course, you can specify any other valid ID. What you know is that the consumer group will start delivering messages that are greater than the ID you specify. Because <code>$</code> means the current greatest ID in the stream, specifying <code>$</code> will have the effect of consuming only new messages.</p> <p><code>XGROUP CREATE</code> also supports creating the stream automatically, if it doesn't exist, using the optional <code>MKSTREAM</code> subcommand as the last argument:</p> <p>{{&lt; clients-example stream_tutorial xgroup_create_mkstream &gt;}}</p> <p>XGROUP CREATE race:italy italy_riders $ MKSTREAM OK {{&lt; /clients-example &gt;}}</p> <p>Now that the consumer group is created we can immediately try to read messages via the consumer group using the <code>XREADGROUP</code> command. We'll read from consumers, that we will call Alice and Bob, to see how the system will return different messages to Alice or Bob.</p> <p><code>XREADGROUP</code> is very similar to <code>XREAD</code> and provides the same BLOCK option, otherwise it is a synchronous command. However there is a mandatory option that must be always specified, which is GROUP and has two arguments: the name of the consumer group, and the name of the consumer that is attempting to read. The option COUNT is also supported and is identical to the one in <code>XREAD</code>.</p> <p>We'll add riders to the race:italy stream and try reading something using the consumer group: Note: here rider is the field name, and the name is the associated value. Remember that stream items are small dictionaries.</p> <p>{{&lt; clients-example stream_tutorial xgroup_read &gt;}}</p> <p>XADD race:italy * rider Castilla \"1692632639151-0\" XADD race:italy * rider Royce \"1692632647899-0\" XADD race:italy * rider Sam-Bodden \"1692632662819-0\" XADD race:italy * rider Prickett \"1692632670501-0\" XADD race:italy * rider Norem \"1692632678249-0\" XREADGROUP GROUP italy_riders Alice COUNT 1 STREAMS race:italy &gt; 1) 1) \"race:italy\"    2) 1) 1) \"1692632639151-0\"          2) 1) \"rider\"             2) \"Castilla\" {{&lt; /clients-example &gt;}}</p> <p><code>XREADGROUP</code> replies are just like <code>XREAD</code> replies. Note however the <code>GROUP &lt;group-name&gt; &lt;consumer-name&gt;</code> provided above. It states that I want to read from the stream using the consumer group <code>mygroup</code> and I'm the consumer <code>Alice</code>. Every time a consumer performs an operation with a consumer group, it must specify its name, uniquely identifying this consumer inside the group.</p> <p>There is another very important detail in the command line above, after the mandatory STREAMS option the ID requested for the key <code>mystream</code> is the special ID <code>&gt;</code>. This special ID is only valid in the context of consumer groups, and it means: messages never delivered to other consumers so far.</p> <p>This is almost always what you want, however it is also possible to specify a real ID, such as <code>0</code> or any other valid ID, in this case, however, what happens is that we request from <code>XREADGROUP</code> to just provide us with the history of pending messages, and in such case, will never see new messages in the group. So basically <code>XREADGROUP</code> has the following behavior based on the ID we specify:</p> <ul> <li>If the ID is the special ID <code>&gt;</code> then the command will return only new messages never delivered to other consumers so far, and as a side effect, will update the consumer group's last ID.</li> <li>If the ID is any other valid numerical ID, then the command will let us access our history of pending messages. That is, the set of messages that were delivered to this specified consumer (identified by the provided name), and never acknowledged so far with <code>XACK</code>.</li> </ul> <p>We can test this behavior immediately specifying an ID of 0, without any COUNT option: we'll just see the only pending message, that is, the one about Castilla:</p> <p>{{&lt; clients-example stream_tutorial xgroup_read_id &gt;}}</p> <p>XREADGROUP GROUP italy_riders Alice STREAMS race:italy 0 1) 1) \"race:italy\"    2) 1) 1) \"1692632639151-0\"          2) 1) \"rider\"             2) \"Castilla\" {{&lt; /clients-example &gt;}}</p> <p>However, if we acknowledge the message as processed, it will no longer be part of the pending messages history, so the system will no longer report anything:</p> <p>{{&lt; clients-example stream_tutorial xack &gt;}}</p> <p>XACK race:italy italy_riders 1692632639151-0 (integer) 1 XREADGROUP GROUP italy_riders Alice STREAMS race:italy 0 1) 1) \"race:italy\"    2) (empty array) {{&lt; /clients-example &gt;}}</p> <p>Don't worry if you yet don't know how <code>XACK</code> works, the idea is just that processed messages are no longer part of the history that we can access.</p> <p>Now it's Bob's turn to read something:</p> <p>{{&lt; clients-example stream_tutorial xgroup_read_bob &gt;}}</p> <p>XREADGROUP GROUP italy_riders Bob COUNT 2 STREAMS race:italy &gt; 1) 1) \"race:italy\"    2) 1) 1) \"1692632647899-0\"          2) 1) \"rider\"             2) \"Royce\"       2) 1) \"1692632662819-0\"          2) 1) \"rider\"             2) \"Sam-Bodden\" {{&lt; /clients-example &gt;}}</p> <p>Bob asked for a maximum of two messages and is reading via the same group <code>mygroup</code>. So what happens is that Redis reports just new messages. As you can see the \"Castilla\" message is not delivered, since it was already delivered to Alice, so Bob gets Royce and Sam-Bodden and so forth.</p> <p>This way Alice, Bob, and any other consumer in the group, are able to read different messages from the same stream, to read their history of yet to process messages, or to mark messages as processed. This allows creating different topologies and semantics for consuming messages from a stream.</p> <p>There are a few things to keep in mind:</p> <ul> <li>Consumers are auto-created the first time they are mentioned, no need for explicit creation.</li> <li>Even with <code>XREADGROUP</code> you can read from multiple keys at the same time, however for this to work, you need to create a consumer group with the same name in every stream. This is not a common need, but it is worth mentioning that the feature is technically available.</li> <li><code>XREADGROUP</code> is a write command because even if it reads from the stream, the consumer group is modified as a side effect of reading, so it can only be called on master instances.</li> </ul> <p>An example of a consumer implementation, using consumer groups, written in the Ruby language could be the following. The Ruby code is aimed to be readable by virtually any experienced programmer, even if they do not know Ruby:</p> <pre><code>require 'redis'\n\nif ARGV.length == 0\n    puts \"Please specify a consumer name\"\n    exit 1\nend\n\nConsumerName = ARGV[0]\nGroupName = \"mygroup\"\nr = Redis.new\n\ndef process_message(id,msg)\n    puts \"[#{ConsumerName}] #{id} = #{msg.inspect}\"\nend\n\n$lastid = '0-0'\n\nputs \"Consumer #{ConsumerName} starting...\"\ncheck_backlog = true\nwhile true\n    # Pick the ID based on the iteration: the first time we want to\n    # read our pending messages, in case we crashed and are recovering.\n    # Once we consumed our history, we can start getting new messages.\n    if check_backlog\n        myid = $lastid\n    else\n        myid = '&gt;'\n    end\n\n    items = r.xreadgroup('GROUP',GroupName,ConsumerName,'BLOCK','2000','COUNT','10','STREAMS',:my_stream_key,myid)\n\n    if items == nil\n        puts \"Timeout!\"\n        next\n    end\n\n    # If we receive an empty reply, it means we were consuming our history\n    # and that the history is now empty. Let's start to consume new messages.\n    check_backlog = false if items[0][1].length == 0\n\n    items[0][1].each{|i|\n        id,fields = i\n\n        # Process the message\n        process_message(id,fields)\n\n        # Acknowledge the message as processed\n        r.xack(:my_stream_key,GroupName,id)\n\n        $lastid = id\n    }\nend\n</code></pre> <p>As you can see the idea here is to start by consuming the history, that is, our list of pending messages. This is useful because the consumer may have crashed before, so in the event of a restart we want to re-read messages that were delivered to us without getting acknowledged. Note that we might process a message multiple times or one time (at least in the case of consumer failures, but there are also the limits of Redis persistence and replication involved, see the specific section about this topic).</p> <p>Once the history was consumed, and we get an empty list of messages, we can switch to using the <code>&gt;</code> special ID in order to consume new messages.</p>"},{"location":"4-data-types/streams/#recovering-from-permanent-failures","title":"Recovering from permanent failures","text":"<p>The example above allows us to write consumers that participate in the same consumer group, each taking a subset of messages to process, and when recovering from failures re-reading the pending messages that were delivered just to them. However in the real world consumers may permanently fail and never recover. What happens to the pending messages of the consumer that never recovers after stopping for any reason?</p> <p>Redis consumer groups offer a feature that is used in these situations in order to claim the pending messages of a given consumer so that such messages will change ownership and will be re-assigned to a different consumer. The feature is very explicit. A consumer has to inspect the list of pending messages, and will have to claim specific messages using a special command, otherwise the server will leave the messages pending forever and assigned to the old consumer. In this way different applications can choose if to use such a feature or not, and exactly how to use it.</p> <p>The first step of this process is just a command that provides observability of pending entries in the consumer group and is called <code>XPENDING</code>. This is a read-only command which is always safe to call and will not change ownership of any message. In its simplest form, the command is called with two arguments, which are the name of the stream and the name of the consumer group.</p> <p>{{&lt; clients-example stream_tutorial xpending &gt;}}</p> <p>XPENDING race:italy italy_riders 1) (integer) 2 2) \"1692632647899-0\" 3) \"1692632662819-0\" 4) 1) 1) \"Bob\"       2) \"2\" {{&lt; /clients-example &gt;}}</p> <p>When called in this way, the command outputs the total number of pending messages in the consumer group (two in this case), the lower and higher message ID among the pending messages, and finally a list of consumers and the number of pending messages they have. We have only Bob with two pending messages because the single message that Alice requested was acknowledged using <code>XACK</code>.</p> <p>We can ask for more information by giving more arguments to <code>XPENDING</code>, because the full command signature is the following:</p> <pre><code>XPENDING &lt;key&gt; &lt;groupname&gt; [[IDLE &lt;min-idle-time&gt;] &lt;start-id&gt; &lt;end-id&gt; &lt;count&gt; [&lt;consumer-name&gt;]]\n</code></pre> <p>By providing a start and end ID (that can be just <code>-</code> and <code>+</code> as in <code>XRANGE</code>) and a count to control the amount of information returned by the command, we are able to know more about the pending messages. The optional final argument, the consumer name, is used if we want to limit the output to just messages pending for a given consumer, but won't use this feature in the following example.</p> <p>{{&lt; clients-example stream_tutorial xpending_plus_minus &gt;}}</p> <p>XPENDING race:italy italy_riders - + 10 1) 1) \"1692632647899-0\"    2) \"Bob\"    3) (integer) 74642    4) (integer) 1 2) 1) \"1692632662819-0\"    2) \"Bob\"    3) (integer) 74642    4) (integer) 1 {{&lt; /clients-example &gt;}}</p> <p>Now we have the details for each message: the ID, the consumer name, the idle time in milliseconds, which is how many milliseconds have passed since the last time the message was delivered to some consumer, and finally the number of times that a given message was delivered. We have two messages from Bob, and they are idle for 60000+ milliseconds, about a minute.</p> <p>Note that nobody prevents us from checking what the first message content was by just using <code>XRANGE</code>.</p> <p>{{&lt; clients-example stream_tutorial xrange_pending &gt;}}</p> <p>XRANGE race:italy 1692632647899-0 1692632647899-0 1) 1) \"1692632647899-0\"    2) 1) \"rider\"       2) \"Royce\" {{&lt; /clients-example &gt;}}</p> <p>We have just to repeat the same ID twice in the arguments. Now that we have some ideas, Alice may decide that after 1 minute of not processing messages, Bob will probably not recover quickly, and it's time to claim such messages and resume the processing in place of Bob. To do so, we use the <code>XCLAIM</code> command.</p> <p>This command is very complex and full of options in its full form, since it is used for replication of consumer groups changes, but we'll use just the arguments that we need normally. In this case it is as simple as:</p> <pre><code>XCLAIM &lt;key&gt; &lt;group&gt; &lt;consumer&gt; &lt;min-idle-time&gt; &lt;ID-1&gt; &lt;ID-2&gt; ... &lt;ID-N&gt;\n</code></pre> <p>Basically we say, for this specific key and group, I want that the message IDs specified will change ownership, and will be assigned to the specified consumer name <code>&lt;consumer&gt;</code>. However, we also provide a minimum idle time, so that the operation will only work if the idle time of the mentioned messages is greater than the specified idle time. This is useful because maybe two clients are retrying to claim a message at the same time:</p> <pre><code>Client 1: XCLAIM race:italy italy_riders Alice 60000 1692632647899-0\nClient 2: XCLAIM race:italy italy_riders Lora 60000 1692632647899-0\n</code></pre> <p>However, as a side effect, claiming a message will reset its idle time and will increment its number of deliveries counter, so the second client will fail claiming it. In this way we avoid trivial re-processing of messages (even if in the general case you cannot obtain exactly once processing).</p> <p>This is the result of the command execution:</p> <p>{{&lt; clients-example stream_tutorial xclaim &gt;}}</p> <p>XCLAIM race:italy italy_riders Alice 60000 1692632647899-0 1) 1) \"1692632647899-0\"    2) 1) \"rider\"       2) \"Royce\" {{&lt; /clients-example &gt;}}</p> <p>The message was successfully claimed by Alice, who can now process the message and acknowledge it, and move things forward even if the original consumer is not recovering.</p> <p>It is clear from the example above that as a side effect of successfully claiming a given message, the <code>XCLAIM</code> command also returns it. However this is not mandatory. The JUSTID option can be used in order to return just the IDs of the message successfully claimed. This is useful if you want to reduce the bandwidth used between the client and the server (and also the performance of the command) and you are not interested in the message because your consumer is implemented in a way that it will rescan the history of pending messages from time to time.</p> <p>Claiming may also be implemented by a separate process: one that just checks the list of pending messages, and assigns idle messages to consumers that appear to be active. Active consumers can be obtained using one of the observability features of Redis streams. This is the topic of the next section.</p>"},{"location":"4-data-types/streams/#automatic-claiming","title":"Automatic claiming","text":"<p>The <code>XAUTOCLAIM</code> command, added in Redis 6.2, implements the claiming process that we've described above. <code>XPENDING</code> and <code>XCLAIM</code> provide the basic building blocks for different types of recovery mechanisms. This command optimizes the generic process by having Redis manage it and offers a simple solution for most recovery needs.</p> <p><code>XAUTOCLAIM</code> identifies idle pending messages and transfers ownership of them to a consumer. The command's signature looks like this:</p> <pre><code>XAUTOCLAIM &lt;key&gt; &lt;group&gt; &lt;consumer&gt; &lt;min-idle-time&gt; &lt;start&gt; [COUNT count] [JUSTID]\n</code></pre> <p>So, in the example above, I could have used automatic claiming to claim a single message like this:</p> <p>{{&lt; clients-example stream_tutorial xautoclaim &gt;}}</p> <p>XAUTOCLAIM race:italy italy_riders Alice 60000 0-0 COUNT 1 1) \"0-0\" 2) 1) 1) \"1692632662819-0\"       2) 1) \"rider\"          2) \"Sam-Bodden\" {{&lt; /clients-example &gt;}}</p> <p>Like <code>XCLAIM</code>, the command replies with an array of the claimed messages, but it also returns a stream ID that allows iterating the pending entries. The stream ID is a cursor, and I can use it in my next call to continue in claiming idle pending messages:</p> <p>{{&lt; clients-example stream_tutorial xautoclaim_cursor &gt;}}</p> <p>XAUTOCLAIM race:italy italy_riders Lora 60000 (1692632662819-0 COUNT 1 1) \"1692632662819-0\" 2) 1) 1) \"1692632647899-0\"       2) 1) \"rider\"          2) \"Royce\" {{&lt; /clients-example &gt;}}</p> <p>When <code>XAUTOCLAIM</code> returns the \"0-0\" stream ID as a cursor, that means that it reached the end of the consumer group pending entries list. That doesn't mean that there are no new idle pending messages, so the process continues by calling <code>XAUTOCLAIM</code> from the beginning of the stream.</p>"},{"location":"4-data-types/streams/#claiming-and-the-delivery-counter","title":"Claiming and the delivery counter","text":"<p>The counter that you observe in the <code>XPENDING</code> output is the number of deliveries of each message. The counter is incremented in two ways: when a message is successfully claimed via <code>XCLAIM</code> or when an <code>XREADGROUP</code> call is used in order to access the history of pending messages.</p> <p>When there are failures, it is normal that messages will be delivered multiple times, but eventually they usually get processed and acknowledged. However there might be a problem processing some specific message, because it is corrupted or crafted in a way that triggers a bug in the processing code. In such a case what happens is that consumers will continuously fail to process this particular message. Because we have the counter of the delivery attempts, we can use that counter to detect messages that for some reason are not processable. So once the deliveries counter reaches a given large number that you chose, it is probably wiser to put such messages in another stream and send a notification to the system administrator. This is basically the way that Redis Streams implements the dead letter concept.</p>"},{"location":"4-data-types/streams/#streams-observability","title":"Streams observability","text":"<p>Messaging systems that lack observability are very hard to work with. Not knowing who is consuming messages, what messages are pending, the set of consumer groups active in a given stream, makes everything opaque. For this reason, Redis Streams and consumer groups have different ways to observe what is happening. We already covered <code>XPENDING</code>, which allows us to inspect the list of messages that are under processing at a given moment, together with their idle time and number of deliveries.</p> <p>However we may want to do more than that, and the <code>XINFO</code> command is an observability interface that can be used with sub-commands in order to get information about streams or consumer groups.</p> <p>This command uses subcommands in order to show different information about the status of the stream and its consumer groups. For instance XINFO STREAM  reports information about the stream itself. <p>{{&lt; clients-example stream_tutorial xinfo &gt;}}</p> <p>XINFO STREAM race:italy  1) \"length\"  2) (integer) 5  3) \"radix-tree-keys\"  4) (integer) 1  5) \"radix-tree-nodes\"  6) (integer) 2  7) \"last-generated-id\"  8) \"1692632678249-0\"  9) \"groups\" 10) (integer) 1 11) \"first-entry\" 12) 1) \"1692632639151-0\"     2) 1) \"rider\"        2) \"Castilla\" 13) \"last-entry\" 14) 1) \"1692632678249-0\"     2) 1) \"rider\"        2) \"Norem\" {{&lt; /clients-example &gt;}}</p> <p>The output shows information about how the stream is encoded internally, and also shows the first and last message in the stream. Another piece of information available is the number of consumer groups associated with this stream. We can dig further asking for more information about the consumer groups.</p> <p>{{&lt; clients-example stream_tutorial xinfo_groups &gt;}}</p> <p>XINFO GROUPS race:italy 1) 1) \"name\"    2) \"italy_riders\"    3) \"consumers\"    4) (integer) 3    5) \"pending\"    6) (integer) 2    7) \"last-delivered-id\"    8) \"1692632662819-0\" {{&lt; /clients-example &gt;}}</p> <p>As you can see in this and in the previous output, the <code>XINFO</code> command outputs a sequence of field-value items. Because it is an observability command this allows the human user to immediately understand what information is reported, and allows the command to report more information in the future by adding more fields without breaking compatibility with older clients. Other commands that must be more bandwidth efficient, like <code>XPENDING</code>, just report the information without the field names.</p> <p>The output of the example above, where the GROUPS subcommand is used, should be clear observing the field names. We can check in more detail the state of a specific consumer group by checking the consumers that are registered in the group.</p> <p>{{&lt; clients-example stream_tutorial xinfo_consumers &gt;}}</p> <p>XINFO CONSUMERS race:italy italy_riders 1) 1) \"name\"    2) \"Alice\"    3) \"pending\"    4) (integer) 1    5) \"idle\"    6) (integer) 177546 2) 1) \"name\"    2) \"Bob\"    3) \"pending\"    4) (integer) 0    5) \"idle\"    6) (integer) 424686 3) 1) \"name\"    2) \"Lora\"    3) \"pending\"    4) (integer) 1    5) \"idle\"    6) (integer) 72241 {{&lt; /clients-example &gt;}}</p> <p>In case you do not remember the syntax of the command, just ask the command itself for help:</p> <pre><code>&gt; XINFO HELP\n1) XINFO &lt;subcommand&gt; [&lt;arg&gt; [value] [opt] ...]. Subcommands are:\n2) CONSUMERS &lt;key&gt; &lt;groupname&gt;\n3)     Show consumers of &lt;groupname&gt;.\n4) GROUPS &lt;key&gt;\n5)     Show the stream consumer groups.\n6) STREAM &lt;key&gt; [FULL [COUNT &lt;count&gt;]\n7)     Show information about the stream.\n8) HELP\n9)     Prints this help.\n</code></pre>"},{"location":"4-data-types/streams/#differences-with-kafka-tm-partitions","title":"Differences with Kafka (TM) partitions","text":"<p>Consumer groups in Redis streams may resemble in some way Kafka (TM) partitioning-based consumer groups, however note that Redis streams are, in practical terms, very different. The partitions are only logical and the messages are just put into a single Redis key, so the way the different clients are served is based on who is ready to process new messages, and not from which partition clients are reading. For instance, if the consumer C3 at some point fails permanently, Redis will continue to serve C1 and C2 all the new messages arriving, as if now there are only two logical partitions.</p> <p>Similarly, if a given consumer is much faster at processing messages than the other consumers, this consumer will receive proportionally more messages in the same unit of time. This is possible since Redis tracks all the unacknowledged messages explicitly, and remembers who received which message and the ID of the first message never delivered to any consumer.</p> <p>However, this also means that in Redis if you really want to partition messages in the same stream into multiple Redis instances, you have to use multiple keys and some sharding system such as Redis Cluster or some other application-specific sharding system. A single Redis stream is not automatically partitioned to multiple instances.</p> <p>We could say that schematically the following is true:</p> <ul> <li>If you use 1 stream -&gt; 1 consumer, you are processing messages in order.</li> <li>If you use N streams with N consumers, so that only a given consumer hits a subset of the N streams, you can scale the above model of 1 stream -&gt; 1 consumer.</li> <li>If you use 1 stream -&gt; N consumers, you are load balancing to N consumers, however in that case, messages about the same logical item may be consumed out of order, because a given consumer may process message 3 faster than another consumer is processing message 4.</li> </ul> <p>So basically Kafka partitions are more similar to using N different Redis keys, while Redis consumer groups are a server-side load balancing system of messages from a given stream to N different consumers.</p>"},{"location":"4-data-types/streams/#capped-streams","title":"Capped Streams","text":"<p>Many applications do not want to collect data into a stream forever. Sometimes it is useful to have at maximum a given number of items inside a stream, other times once a given size is reached, it is useful to move data from Redis to a storage which is not in memory and not as fast but suited to store the history for, potentially, decades to come. Redis streams have some support for this. One is the MAXLEN option of the <code>XADD</code> command. This option is very simple to use:</p> <p>{{&lt; clients-example stream_tutorial maxlen &gt;}}</p> <p>XADD race:italy MAXLEN 2 * rider Jones \"1692633189161-0\" XADD race:italy MAXLEN 2 * rider Wood \"1692633198206-0\" XADD race:italy MAXLEN 2 * rider Henshaw \"1692633208557-0\" XLEN race:italy (integer) 2 XRANGE race:italy - + 1) 1) \"1692633198206-0\"    2) 1) \"rider\"       2) \"Wood\" 2) 1) \"1692633208557-0\"    2) 1) \"rider\"       2) \"Henshaw\" {{&lt; /clients-example &gt;}}</p> <p>Using MAXLEN the old entries are automatically evicted when the specified length is reached, so that the stream is left at a constant size. There is currently no option to tell the stream to just retain items that are not older than a given period, because such command, in order to run consistently, would potentially block for a long time in order to evict items. Imagine for example what happens if there is an insertion spike, then a long pause, and another insertion, all with the same maximum time. The stream would block to evict the data that became too old during the pause. So it is up to the user to do some planning and understand what is the maximum stream length desired. Moreover, while the length of the stream is proportional to the memory used, trimming by time is less simple to control and anticipate: it depends on the insertion rate which often changes over time (and when it does not change, then to just trim by size is trivial).</p> <p>However trimming with MAXLEN can be expensive: streams are represented by macro nodes into a radix tree, in order to be very memory efficient. Altering the single macro node, consisting of a few tens of elements, is not optimal. So it's possible to use the command in the following special form:</p> <pre><code>XADD race:italy MAXLEN ~ 1000 * ... entry fields here ...\n</code></pre> <p>The <code>~</code> argument between the MAXLEN option and the actual count means, I don't really need this to be exactly 1000 items. It can be 1000 or 1010 or 1030, just make sure to save at least 1000 items. With this argument, the trimming is performed only when we can remove a whole node. This makes it much more efficient, and it is usually what you want. You'll note here that the client libraries have various implementations of this. For example, the Python client defaults to approximate and has to be explicitly set to a true length.</p> <p>There is also the <code>XTRIM</code> command, which performs something very similar to what the MAXLEN option does above, except that it can be run by itself:</p> <p>{{&lt; clients-example stream_tutorial xtrim &gt;}}</p> <p>XTRIM race:italy MAXLEN 10 (integer) 0 {{&lt; /clients-example &gt;}}</p> <p>Or, as for the <code>XADD</code> option:</p> <p>{{&lt; clients-example stream_tutorial xtrim2 &gt;}}</p> <p>XTRIM mystream MAXLEN ~ 10 (integer) 0 {{&lt; /clients-example &gt;}}</p> <p>However, <code>XTRIM</code> is designed to accept different trimming strategies. Another trimming strategy is MINID, that evicts entries with IDs lower than the one specified.</p> <p>As <code>XTRIM</code> is an explicit command, the user is expected to know about the possible shortcomings of different trimming strategies.</p> <p>Another useful eviction strategy that may be added to <code>XTRIM</code> in the future, is to remove by a range of IDs to ease use of <code>XRANGE</code> and <code>XTRIM</code> to move data from Redis to other storage systems if needed.</p>"},{"location":"4-data-types/streams/#special-ids-in-the-streams-api","title":"Special IDs in the streams API","text":"<p>You may have noticed that there are several special IDs that can be used in the Redis API. Here is a short recap, so that they can make more sense in the future.</p> <p>The first two special IDs are <code>-</code> and <code>+</code>, and are used in range queries with the <code>XRANGE</code> command. Those two IDs respectively mean the smallest ID possible (that is basically <code>0-1</code>) and the greatest ID possible (that is <code>18446744073709551615-18446744073709551615</code>). As you can see it is a lot cleaner to write <code>-</code> and <code>+</code> instead of those numbers.</p> <p>Then there are APIs where we want to say, the ID of the item with the greatest ID inside the stream. This is what <code>$</code> means. So for instance if I want only new entries with <code>XREADGROUP</code> I use this ID to signify I already have all the existing entries, but not the new ones that will be inserted in the future. Similarly when I create or set the ID of a consumer group, I can set the last delivered item to <code>$</code> in order to just deliver new entries to the consumers in the group.</p> <p>As you can see <code>$</code> does not mean <code>+</code>, they are two different things, as <code>+</code> is the greatest ID possible in every possible stream, while <code>$</code> is the greatest ID in a given stream containing given entries. Moreover APIs will usually only understand <code>+</code> or <code>$</code>, yet it was useful to avoid loading a given symbol with multiple meanings.</p> <p>Another special ID is <code>&gt;</code>, that is a special meaning only related to consumer groups and only when the <code>XREADGROUP</code> command is used. This special ID means that we want only entries that were never delivered to other consumers so far. So basically the <code>&gt;</code> ID is the last delivered ID of a consumer group.</p> <p>Finally the special ID <code>*</code>, that can be used only with the <code>XADD</code> command, means to auto select an ID for us for the new entry.</p> <p>So we have <code>-</code>, <code>+</code>, <code>$</code>, <code>&gt;</code> and <code>*</code>, and all have a different meaning, and most of the time, can be used in different contexts.</p>"},{"location":"4-data-types/streams/#persistence-replication-and-message-safety","title":"Persistence, replication and message safety","text":"<p>A Stream, like any other Redis data structure, is asynchronously replicated to replicas and persisted into AOF and RDB files. However what may not be so obvious is that also the consumer groups full state is propagated to AOF, RDB and replicas, so if a message is pending in the master, also the replica will have the same information. Similarly, after a restart, the AOF will restore the consumer groups' state.</p> <p>However note that Redis streams and consumer groups are persisted and replicated using the Redis default replication, so:</p> <ul> <li>AOF must be used with a strong fsync policy if persistence of messages is important in your application.</li> <li>By default the asynchronous replication will not guarantee that <code>XADD</code> commands or consumer groups state changes are replicated: after a failover something can be missing depending on the ability of replicas to receive the data from the master.</li> <li>The <code>WAIT</code> command may be used in order to force the propagation of the changes to a set of replicas. However note that while this makes it very unlikely that data is lost, the Redis failover process as operated by Sentinel or Redis Cluster performs only a best effort check to failover to the replica which is the most updated, and under certain specific failure conditions may promote a replica that lacks some data.</li> </ul> <p>So when designing an application using Redis streams and consumer groups, make sure to understand the semantical properties your application should have during failures, and configure things accordingly, evaluating whether it is safe enough for your use case.</p>"},{"location":"4-data-types/streams/#removing-single-items-from-a-stream","title":"Removing single items from a stream","text":"<p>Streams also have a special command for removing items from the middle of a stream, just by ID. Normally for an append only data structure this may look like an odd feature, but it is actually useful for applications involving, for instance, privacy regulations. The command is called <code>XDEL</code> and receives the name of the stream followed by the IDs to delete:</p> <p>{{&lt; clients-example stream_tutorial xdel &gt;}}</p> <p>XRANGE race:italy - + COUNT 2 1) 1) \"1692633198206-0\"    2) 1) \"rider\"       2) \"Wood\" 2) 1) \"1692633208557-0\"    2) 1) \"rider\"       2) \"Henshaw\" XDEL race:italy 1692633208557-0 (integer) 1 XRANGE race:italy - + COUNT 2 1) 1) \"1692633198206-0\"    2) 1) \"rider\"       2) \"Wood\" {{&lt; /clients-example &gt;}}</p> <p>However in the current implementation, memory is not really reclaimed until a macro node is completely empty, so you should not abuse this feature.</p>"},{"location":"4-data-types/streams/#zero-length-streams","title":"Zero length streams","text":"<p>A difference between streams and other Redis data structures is that when the other data structures no longer have any elements, as a side effect of calling commands that remove elements, the key itself will be removed. So for instance, a sorted set will be completely removed when a call to <code>ZREM</code> will remove the last element in the sorted set. Streams, on the other hand, are allowed to stay at zero elements, both as a result of using a MAXLEN option with a count of zero (<code>XADD</code> and <code>XTRIM</code> commands), or because <code>XDEL</code> was called.</p> <p>The reason why such an asymmetry exists is because Streams may have associated consumer groups, and we do not want to lose the state that the consumer groups defined just because there are no longer any items in the stream. Currently the stream is not deleted even when it has no associated consumer groups.</p>"},{"location":"4-data-types/streams/#total-latency-of-consuming-a-message","title":"Total latency of consuming a message","text":"<p>Non blocking stream commands like <code>XRANGE</code> and <code>XREAD</code> or <code>XREADGROUP</code> without the BLOCK option are served synchronously like any other Redis command, so to discuss latency of such commands is meaningless: it is more interesting to check the time complexity of the commands in the Redis documentation. It should be enough to say that stream commands are at least as fast as sorted set commands when extracting ranges, and that <code>XADD</code> is very fast and can easily insert from half a million to one million items per second in an average machine if pipelining is used.</p> <p>However latency becomes an interesting parameter if we want to understand the delay of processing a message, in the context of blocking consumers in a consumer group, from the moment the message is produced via <code>XADD</code>, to the moment the message is obtained by the consumer because <code>XREADGROUP</code> returned with the message.</p>"},{"location":"4-data-types/streams/#how-serving-blocked-consumers-works","title":"How serving blocked consumers works","text":"<p>Before providing the results of performed tests, it is interesting to understand what model Redis uses in order to route stream messages (and in general actually how any blocking operation waiting for data is managed).</p> <ul> <li>The blocked client is referenced in a hash table that maps keys for which there is at least one blocking consumer, to a list of consumers that are waiting for such key. This way, given a key that received data, we can resolve all the clients that are waiting for such data.</li> <li>When a write happens, in this case when the <code>XADD</code> command is called, it calls the <code>signalKeyAsReady()</code> function. This function will put the key into a list of keys that need to be processed, because such keys may have new data for blocked consumers. Note that such ready keys will be processed later, so in the course of the same event loop cycle, it is possible that the key will receive other writes.</li> <li>Finally, before returning into the event loop, the ready keys are finally processed. For each key the list of clients waiting for data is scanned, and if applicable, such clients will receive the new data that arrived. In the case of streams the data is the messages in the applicable range requested by the consumer.</li> </ul> <p>As you can see, basically, before returning to the event loop both the client calling <code>XADD</code> and the clients blocked to consume messages, will have their reply in the output buffers, so the caller of <code>XADD</code> should receive the reply from Redis at about the same time the consumers will receive the new messages.</p> <p>This model is push-based, since adding data to the consumers buffers will be performed directly by the action of calling <code>XADD</code>, so the latency tends to be quite predictable.</p>"},{"location":"4-data-types/streams/#latency-tests-results","title":"Latency tests results","text":"<p>In order to check these latency characteristics a test was performed using multiple instances of Ruby programs pushing messages having as an additional field the computer millisecond time, and Ruby programs reading the messages from the consumer group and processing them. The message processing step consisted of comparing the current computer time with the message timestamp, in order to understand the total latency.</p> <p>Results obtained:</p> <pre><code>Processed between 0 and 1 ms -&gt; 74.11%\nProcessed between 1 and 2 ms -&gt; 25.80%\nProcessed between 2 and 3 ms -&gt; 0.06%\nProcessed between 3 and 4 ms -&gt; 0.01%\nProcessed between 4 and 5 ms -&gt; 0.02%\n</code></pre> <p>So 99.9% of requests have a latency &lt;= 2 milliseconds, with the outliers that remain still very close to the average.</p> <p>Adding a few million unacknowledged messages to the stream does not change the gist of the benchmark, with most queries still processed with very short latency.</p> <p>A few remarks:</p> <ul> <li>Here we processed up to 10k messages per iteration, this means that the <code>COUNT</code> parameter of <code>XREADGROUP</code> was set to 10000. This adds a lot of latency but is needed in order to allow the slow consumers to be able to keep with the message flow. So you can expect a real world latency that is a lot smaller.</li> <li>The system used for this benchmark is very slow compared to today's standards.</li> </ul>"},{"location":"4-data-types/streams/#learn-more","title":"Learn more","text":"<ul> <li>The Redis Streams Tutorial explains Redis streams with many examples.</li> <li>Redis Streams Explained is an entertaining introduction to streams in Redis.</li> <li>Redis University's RU202 is a free, online course dedicated to Redis Streams.</li> </ul>"},{"location":"4-data-types/strings/","title":"Redis Strings","text":"<p>Redis strings store sequences of bytes, including text, serialized objects, and binary arrays. As such, strings are the simplest type of value you can associate with a Redis key. They're often used for caching, but they support additional functionality that lets you implement counters and perform bitwise operations, too.</p> <p>Since Redis keys are strings, when we use the string type as a value too, we are mapping a string to another string. The string data type is useful for a number of use cases, like caching HTML fragments or pages.</p> <p>{{&lt; clients-example set_tutorial set_get &gt;}}     &gt; SET bike:1 Deimos     OK     &gt; GET bike:1     \"Deimos\" {{&lt; /clients-example &gt;}}</p> <p>As you can see using the <code>SET</code> and the <code>GET</code> commands are the way we set and retrieve a string value. Note that <code>SET</code> will replace any existing value already stored into the key, in the case that the key already exists, even if the key is associated with a non-string value. So <code>SET</code> performs an assignment.</p> <p>Values can be strings (including binary data) of every kind, for instance you can store a jpeg image inside a value. A value can't be bigger than 512 MB.</p> <p>The <code>SET</code> command has interesting options, that are provided as additional arguments. For example, I may ask <code>SET</code> to fail if the key already exists, or the opposite, that it only succeed if the key already exists:</p> <p>{{&lt; clients-example set_tutorial setnx_xx &gt;}}     &gt; set bike:1 bike nx     (nil)     &gt; set bike:1 bike xx     OK {{&lt; /clients-example &gt;}}</p> <p>There are a number of other commands for operating on strings. For example the <code>GETSET</code> command sets a key to a new value, returning the old value as the result. You can use this command, for example, if you have a system that increments a Redis key using <code>INCR</code> every time your web site receives a new visitor. You may want to collect this information once every hour, without losing a single increment. You can <code>GETSET</code> the key, assigning it the new value of \"0\" and reading the old value back.</p> <p>The ability to set or retrieve the value of multiple keys in a single command is also useful for reduced latency. For this reason there are the <code>MSET</code> and <code>MGET</code> commands:</p> <p>{{&lt; clients-example set_tutorial mset &gt;}}     &gt; mset bike:1 \"Deimos\" bike:2 \"Ares\" bike:3 \"Vanth\"     OK     &gt; mget bike:1 bike:2 bike:3     1) \"Deimos\"     2) \"Ares\"     3) \"Vanth\" {{&lt; /clients-example &gt;}}</p> <p>When <code>MGET</code> is used, Redis returns an array of values.</p>"},{"location":"4-data-types/strings/#strings-as-counters","title":"Strings as counters","text":"<p>Even if strings are the basic values of Redis, there are interesting operations you can perform with them. For instance, one is atomic increment:</p> <p>{{&lt; clients-example set_tutorial incr &gt;}}     &gt; set total_crashes 0     OK     &gt; incr total_crashes     (integer) 1     &gt; incrby total_crashes 10     (integer) 11 {{&lt; /clients-example &gt;}}</p> <p>The <code>INCR</code> command parses the string value as an integer, increments it by one, and finally sets the obtained value as the new value. There are other similar commands like <code>INCRBY</code>, <code>DECR</code> and <code>DECRBY</code>. Internally it's always the same command, acting in a slightly different way.</p> <p>What does it mean that INCR is atomic? That even multiple clients issuing INCR against the same key will never enter into a race condition. For instance, it will never happen that client 1 reads \"10\", client 2 reads \"10\" at the same time, both increment to 11, and set the new value to 11. The final value will always be 12 and the read-increment-set operation is performed while all the other clients are not executing a command at the same time.</p>"},{"location":"4-data-types/strings/#limits","title":"Limits","text":"<p>By default, a single Redis string can be a maximum of 512 MB.</p>"},{"location":"4-data-types/strings/#basic-commands","title":"Basic commands","text":""},{"location":"4-data-types/strings/#getting-and-setting-strings","title":"Getting and setting Strings","text":"<ul> <li><code>SET</code> stores a string value.</li> <li><code>SETNX</code> stores a string value only if the key doesn't already exist. Useful for implementing locks.</li> <li><code>GET</code> retrieves a string value.</li> <li><code>MGET</code> retrieves multiple string values in a single operation.</li> </ul>"},{"location":"4-data-types/strings/#managing-counters","title":"Managing counters","text":"<ul> <li><code>INCRBY</code> atomically increments (and decrements when passing a negative number) counters stored at a given key.</li> <li>Another command exists for floating point counters: <code>INCRBYFLOAT</code>.</li> </ul>"},{"location":"4-data-types/strings/#bitwise-operations","title":"Bitwise operations","text":"<p>To perform bitwise operations on a string, see the bitmaps data type docs.</p> <p>See the complete list of string commands.</p>"},{"location":"4-data-types/strings/#performance","title":"Performance","text":"<p>Most string operations are O(1), which means they're highly efficient. However, be careful with the <code>SUBSTR</code>, <code>GETRANGE</code>, and <code>SETRANGE</code> commands, which can be O(n). These random-access string commands may cause performance issues when dealing with large strings.</p>"},{"location":"4-data-types/strings/#alternatives","title":"Alternatives","text":"<p>If you're storing structured data as a serialized string, you may also want to consider Redis hashes or JSON.</p>"},{"location":"4-data-types/strings/#learn-more","title":"Learn more","text":"<ul> <li>Redis Strings Explained is a short, comprehensive video explainer on Redis strings.</li> <li>Redis University's RU101 covers Redis strings in detail.</li> </ul>"},{"location":"4-data-types/probabilistic/hyperloglogs/","title":"HyperLogLog","text":"<p>HyperLogLog is a probabilistic data structure that estimates the cardinality of a set. As a probabilistic data structure, HyperLogLog trades perfect accuracy for efficient space utilization.</p> <p>The Redis HyperLogLog implementation uses up to 12 KB and provides a standard error of 0.81%.</p> <p>Counting unique items usually requires an amount of memory proportional to the number of items you want to count, because you need to remember the elements you have already seen in the past in order to avoid counting them multiple times. However, a set of algorithms exist that trade  memory for precision: they return an estimated measure with a standard error,  which, in the case of the Redis implementation for HyperLogLog, is less than 1%. The magic of this algorithm is that you no longer need to use an amount of memory proportional to the number of items counted, and instead can use a constant amount of memory; 12k bytes in the worst case, or a lot less if your HyperLogLog (We'll just call them HLL from now) has seen very few elements.</p> <p>HLLs in Redis, while technically a different data structure, are encoded as a Redis string, so you can call <code>GET</code> to serialize a HLL, and <code>SET</code> to deserialize it back to the server.</p> <p>Conceptually the HLL API is like using Sets to do the same task. You would <code>SADD</code> every observed element into a set, and would use <code>SCARD</code> to check the number of elements inside the set, which are unique since <code>SADD</code> will not re-add an existing element.</p> <p>While you don't really add items into an HLL, because the data structure only contains a state that does not include actual elements, the API is the same:</p> <ul> <li>Every time you see a new element, you add it to the count with <code>PFADD</code>.</li> <li>When you want to retrieve the current approximation of unique elements added using the <code>PFADD</code> command, you can use the <code>PFCOUNT</code> command. If you need to merge two different HLLs, the <code>PFMERGE</code> command is available. Since HLLs provide approximate counts of unique elements, the result of the merge will give you an approximation of the number of unique elements across both source HLLs.</li> </ul> <p>{{&lt; clients-example hll_tutorial pfadd &gt;}}</p> <p>PFADD bikes Hyperion Deimos Phoebe Quaoar (integer) 1 PFCOUNT bikes (integer) 4 PFADD commuter_bikes Salacia Mimas Quaoar (integer) 1 PFMERGE all_bikes bikes commuter_bikes OK PFCOUNT all_bikes (integer) 6 {{&lt; /clients-example &gt;}}</p> <p>Some examples of use cases for this data structure is counting unique queries performed by users in a search form every day, number of unique visitors to a web page and other similar cases.</p> <p>Redis is also able to perform the union of HLLs, please check the full documentation for more information.</p>"},{"location":"4-data-types/probabilistic/hyperloglogs/#use-cases","title":"Use cases","text":"<p>Anonymous unique visits of a web page (SaaS, analytics tools) </p> <p>This application answers these questions: </p> <ul> <li>How many unique visits has this page had on this day? </li> <li>How many unique users have played this song? </li> <li>How many unique users have viewed this video? </li> </ul> <p>{{% alert title=\"Note\" color=\"warning\" %}}</p> <p>Storing the IP address or any other kind of personal identifier is against the law in some countries, which makes it impossible to get unique visitor statistics on your website.</p> <p>{{% /alert %}}</p> <p>One HyperLogLog is created per page (video/song) per period, and every IP/identifier is added to it on every visit.</p>"},{"location":"4-data-types/probabilistic/hyperloglogs/#basic-commands","title":"Basic commands","text":"<ul> <li><code>PFADD</code> adds an item to a HyperLogLog.</li> <li><code>PFCOUNT</code> returns an estimate of the number of items in the set.</li> <li><code>PFMERGE</code> combines two or more HyperLogLogs into one.</li> </ul> <p>See the complete list of HyperLogLog commands.</p>"},{"location":"4-data-types/probabilistic/hyperloglogs/#performance","title":"Performance","text":"<p>Writing (<code>PFADD</code>) to and reading from (<code>PFCOUNT</code>) the HyperLogLog is done in constant time and space. Merging HLLs is O(n), where n is the number of sketches.</p>"},{"location":"4-data-types/probabilistic/hyperloglogs/#limits","title":"Limits","text":"<p>The HyperLogLog can estimate the cardinality of sets with up to 18,446,744,073,709,551,616 (2^64) members.</p>"},{"location":"4-data-types/probabilistic/hyperloglogs/#learn-more","title":"Learn more","text":"<ul> <li>Redis new data structure: the HyperLogLog has a lot of details about the data structure and its implementation in Redis.</li> <li>Redis HyperLogLog Explained shows you how to use Redis HyperLogLog data structures to build a traffic heat map.</li> </ul>"},{"location":"5-interact/_index/","title":"index","text":"<p>title: \"Interact with data in Redis\" linkTitle: \"Interact with data\"</p> <p>weight: 40</p> <p>description: &gt;     How to interact with data in Redis, including searching, querying, triggered functions, transactions, and pub/sub.</p>"},{"location":"5-interact/pubsub/","title":"Redis Pub/Sub","text":"<p><code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code> and <code>PUBLISH</code> implement the Publish/Subscribe messaging paradigm where (citing Wikipedia) senders (publishers) are not programmed to send their messages to specific receivers (subscribers). Rather, published messages are characterized into channels, without knowledge of what (if any) subscribers there may be. Subscribers express interest in one or more channels and only receive messages that are of interest, without knowledge of what (if any) publishers there are. This decoupling of publishers and subscribers allows for greater scalability and a more dynamic network topology.</p> <p>For instance, to subscribe to channels \"channel11\" and \"ch:00\" the client issues a <code>SUBSCRIBE</code> providing the names of the channels:</p> <pre><code>SUBSCRIBE channel11 ch:00\n</code></pre> <p>Messages sent by other clients to these channels will be pushed by Redis to all the subscribed clients. Subscribers receive the messages in the order that the messages are published.</p> <p>A client subscribed to one or more channels shouldn't issue commands, although it can <code>SUBSCRIBE</code> and <code>UNSUBSCRIBE</code> to and from other channels. The replies to subscription and unsubscribing operations are sent in the form of messages so that the client can just read a coherent stream of messages where the first element indicates the type of message. The commands that are allowed in the context of a subscribed RESP2 client are:</p> <ul> <li><code>PING</code></li> <li><code>PSUBSCRIBE</code></li> <li><code>PUNSUBSCRIBE</code></li> <li><code>QUIT</code></li> <li><code>RESET</code></li> <li><code>SSUBSCRIBE</code></li> <li><code>SUBSCRIBE</code></li> <li><code>SUNSUBSCRIBE</code></li> <li><code>UNSUBSCRIBE</code></li> </ul> <p>However, if RESP3 is used (see <code>HELLO</code>), a client can issue any commands while in the subscribed state.</p> <p>Please note that when using <code>redis-cli</code>, in subscribed mode commands such as <code>UNSUBSCRIBE</code> and <code>PUNSUBSCRIBE</code> cannot be used because <code>redis-cli</code> will not accept any commands and can only quit the mode with <code>Ctrl-C</code>.</p>"},{"location":"5-interact/pubsub/#delivery-semantics","title":"Delivery semantics","text":"<p>Redis' Pub/Sub exhibits at-most-once message delivery semantics. As the name suggests, it means that a message will be delivered once if at all. Once the message is sent by the Redis server, there's no chance of it being sent again. If the subscriber is unable to handle the message (for example, due to an error or a network disconnect) the message is forever lost.</p> <p>If your application requires stronger delivery guarantees, you may want to learn about Redis Streams. Messages in streams are persisted, and support both at-most-once as well as at-least-once delivery semantics.</p>"},{"location":"5-interact/pubsub/#format-of-pushed-messages","title":"Format of pushed messages","text":"<p>A message is an array-reply with three elements.</p> <p>The first element is the kind of message:</p> <ul> <li> <p><code>subscribe</code>: means that we successfully subscribed to the channel given as the second element in the reply.   The third argument represents the number of channels we are currently subscribed to.</p> </li> <li> <p><code>unsubscribe</code>: means that we successfully unsubscribed from the channel given as second element in the reply.   The third argument represents the number of channels we are currently subscribed to.   When the last argument is zero, we are no longer subscribed to any channel, and the client can issue any kind of Redis command as we are outside the Pub/Sub state.</p> </li> <li> <p><code>message</code>: it is a message received as a result of a <code>PUBLISH</code> command issued by another client.   The second element is the name of the originating channel, and the third argument is the actual message payload.</p> </li> </ul>"},{"location":"5-interact/pubsub/#database-scoping","title":"Database &amp; Scoping","text":"<p>Pub/Sub has no relation to the key space. It was made to not interfere with it on any level, including database numbers.</p> <p>Publishing on db 10, will be heard by a subscriber on db 1.</p> <p>If you need scoping of some kind, prefix the channels with the name of the environment (test, staging, production...).</p>"},{"location":"5-interact/pubsub/#wire-protocol-example","title":"Wire protocol example","text":"<pre><code>SUBSCRIBE first second\n*3\n$9\nsubscribe\n$5\nfirst\n:1\n*3\n$9\nsubscribe\n$6\nsecond\n:2\n</code></pre> <p>At this point, from another client we issue a <code>PUBLISH</code> operation against the channel named <code>second</code>:</p> <pre><code>&gt; PUBLISH second Hello\n</code></pre> <p>This is what the first client receives:</p> <pre><code>*3\n$7\nmessage\n$6\nsecond\n$5\nHello\n</code></pre> <p>Now the client unsubscribes itself from all the channels using the <code>UNSUBSCRIBE</code> command without additional arguments:</p> <pre><code>UNSUBSCRIBE\n*3\n$11\nunsubscribe\n$6\nsecond\n:1\n*3\n$11\nunsubscribe\n$5\nfirst\n:0\n</code></pre>"},{"location":"5-interact/pubsub/#pattern-matching-subscriptions","title":"Pattern-matching subscriptions","text":"<p>The Redis Pub/Sub implementation supports pattern matching. Clients may subscribe to glob-style patterns to receive all the messages sent to channel names matching a given pattern.</p> <p>For instance:</p> <pre><code>PSUBSCRIBE news.*\n</code></pre> <p>Will receive all the messages sent to the channel <code>news.art.figurative</code>, <code>news.music.jazz</code>, etc. All the glob-style patterns are valid, so multiple wildcards are supported.</p> <pre><code>PUNSUBSCRIBE news.*\n</code></pre> <p>Will then unsubscribe the client from that pattern. No other subscriptions will be affected by this call.</p> <p>Messages received as a result of pattern matching are sent in a different format:</p> <ul> <li>The type of the message is <code>pmessage</code>: it is a message received as a result from a <code>PUBLISH</code> command issued by another client, matching a pattern-matching subscription.    The second element is the original pattern matched, the third element is the name of the originating channel, and the last element is the actual message payload.</li> </ul> <p>Similarly to <code>SUBSCRIBE</code> and <code>UNSUBSCRIBE</code>, <code>PSUBSCRIBE</code> and <code>PUNSUBSCRIBE</code> commands are acknowledged by the system sending a message of type <code>psubscribe</code> and <code>punsubscribe</code> using the same format as the <code>subscribe</code> and <code>unsubscribe</code> message format.</p>"},{"location":"5-interact/pubsub/#messages-matching-both-a-pattern-and-a-channel-subscription","title":"Messages matching both a pattern and a channel subscription","text":"<p>A client may receive a single message multiple times if it's subscribed to multiple patterns matching a published message, or if it is subscribed to both patterns and channels matching the message.  This is shown by the following example:</p> <pre><code>SUBSCRIBE foo\nPSUBSCRIBE f*\n</code></pre> <p>In the above example, if a message is sent to channel <code>foo</code>, the client will receive two messages: one of type <code>message</code> and one of type <code>pmessage</code>.</p>"},{"location":"5-interact/pubsub/#the-meaning-of-the-subscription-count-with-pattern-matching","title":"The meaning of the subscription count with pattern matching","text":"<p>In <code>subscribe</code>, <code>unsubscribe</code>, <code>psubscribe</code> and <code>punsubscribe</code> message types, the last argument is the count of subscriptions still active.  This number is the total number of channels and patterns the client is still subscribed to.  So the client will exit the Pub/Sub state only when this count drops to zero as a result of unsubscribing from all the channels and patterns.</p>"},{"location":"5-interact/pubsub/#sharded-pubsub","title":"Sharded Pub/Sub","text":"<p>From Redis 7.0, sharded Pub/Sub is introduced in which shard channels are assigned to slots by the same algorithm used to assign keys to slots.  A shard message must be sent to a node that owns the slot the shard channel is hashed to.  The cluster makes sure the published shard messages are forwarded to all nodes in the shard, so clients can subscribe to a shard channel by connecting to either the master responsible for the slot, or to any of its replicas. <code>SSUBSCRIBE</code>, <code>SUNSUBSCRIBE</code> and <code>SPUBLISH</code> are used to implement sharded Pub/Sub.</p> <p>Sharded Pub/Sub helps to scale the usage of Pub/Sub in cluster mode.  It restricts the propagation of messages to be within the shard of a cluster.  Hence, the amount of data passing through the cluster bus is limited in comparison to global Pub/Sub where each message propagates to each node in the cluster. This allows users to horizontally scale the Pub/Sub usage by adding more shards.</p>"},{"location":"5-interact/pubsub/#programming-example","title":"Programming example","text":"<p>Pieter Noordhuis provided a great example using EventMachine and Redis to create a multi user high performance web chat.</p>"},{"location":"5-interact/pubsub/#client-library-implementation-hints","title":"Client library implementation hints","text":"<p>Because all the messages received contain the original subscription causing the message delivery (the channel in the case of message type, and the original pattern in the case of pmessage type) client libraries may bind the original subscription to callbacks (that can be anonymous functions, blocks, function pointers), using a hash table.</p> <p>When a message is received an O(1) lookup can be done to deliver the message to the registered callback.</p>"},{"location":"5-interact/transactions/","title":"Transactions","text":"<p>Redis Transactions allow the execution of a group of commands in a single step, they are centered around the commands  <code>MULTI</code>, <code>EXEC</code>, <code>DISCARD</code> and <code>WATCH</code>. Redis Transactions make two important guarantees:</p> <ul> <li> <p>All the commands in a transaction are serialized and executed sequentially. A request sent by another client will never be served in the middle of the execution of a Redis Transaction. This guarantees that the commands are executed as a single isolated operation.</p> </li> <li> <p>The <code>EXEC</code> command triggers the execution of all the commands in the transaction, so if a client loses the connection to the server in the context of a transaction before calling the <code>EXEC</code> command none of the operations are performed, instead if the <code>EXEC</code> command is called, all the operations are performed. When using the append-only file Redis makes sure to use a single write(2) syscall to write the transaction on disk. However if the Redis server crashes or is killed by the system administrator in some hard way it is possible that only a partial number of operations are registered. Redis will detect this condition at restart, and will exit with an error. Using the <code>redis-check-aof</code> tool it is possible to fix the append only file that will remove the partial transaction so that the server can start again.</p> </li> </ul> <p>Starting with version 2.2, Redis allows for an extra guarantee to the above two, in the form of optimistic locking in a way very similar to a check-and-set (CAS) operation. This is documented later on this page.</p>"},{"location":"5-interact/transactions/#usage","title":"Usage","text":"<p>A Redis Transaction is entered using the <code>MULTI</code> command. The command always replies with <code>OK</code>. At this point the user can issue multiple commands. Instead of executing these commands, Redis will queue them. All the commands are executed once <code>EXEC</code> is called.</p> <p>Calling <code>DISCARD</code> instead will flush the transaction queue and will exit the transaction.</p> <p>The following example increments keys <code>foo</code> and <code>bar</code> atomically.</p> <pre><code>&gt; MULTI\nOK\n&gt; INCR foo\nQUEUED\n&gt; INCR bar\nQUEUED\n&gt; EXEC\n1) (integer) 1\n2) (integer) 1\n</code></pre> <p>As is clear from the session above, <code>EXEC</code> returns an array of replies, where every element is the reply of a single command in the transaction, in the same order the commands were issued.</p> <p>When a Redis connection is in the context of a <code>MULTI</code> request, all commands will reply with the string <code>QUEUED</code> (sent as a Status Reply from the point of view of the Redis protocol). A queued command is simply scheduled for execution when <code>EXEC</code> is called.</p>"},{"location":"5-interact/transactions/#errors-inside-a-transaction","title":"Errors inside a transaction","text":"<p>During a transaction it is possible to encounter two kind of command errors:</p> <ul> <li>A command may fail to be queued, so there may be an error before <code>EXEC</code> is called. For instance the command may be syntactically wrong (wrong number of arguments, wrong command name, ...), or there may be some critical condition like an out of memory condition (if the server is configured to have a memory limit using the <code>maxmemory</code> directive).</li> <li>A command may fail after <code>EXEC</code> is called, for instance since we performed an operation against a key with the wrong value (like calling a list operation against a string value).</li> </ul> <p>Starting with Redis 2.6.5, the server will detect an error during the accumulation of commands. It will then refuse to execute the transaction returning an error during <code>EXEC</code>, discarding the transaction.</p> <p>Note for Redis &lt; 2.6.5: Prior to Redis 2.6.5 clients needed to detect errors occurring prior to <code>EXEC</code> by checking the return value of the queued command: if the command replies with QUEUED it was queued correctly, otherwise Redis returns an error. If there is an error while queueing a command, most clients will abort and discard the transaction. Otherwise, if the client elected to proceed with the transaction the <code>EXEC</code> command would execute all commands queued successfully regardless of previous errors.</p> <p>Errors happening after <code>EXEC</code> instead are not handled in a special way: all the other commands will be executed even if some command fails during the transaction.</p> <p>This is more clear on the protocol level. In the following example one command will fail when executed even if the syntax is right:</p> <pre><code>Trying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\nMULTI\n+OK\nSET a abc\n+QUEUED\nLPOP a\n+QUEUED\nEXEC\n*2\n+OK\n-WRONGTYPE Operation against a key holding the wrong kind of value\n</code></pre> <p><code>EXEC</code> returned two-element bulk string reply where one is an <code>OK</code> code and the other an error reply. It's up to the client library to find a sensible way to provide the error to the user.</p> <p>It's important to note that even when a command fails, all the other commands in the queue are processed \u2013 Redis will not stop the processing of commands.</p> <p>Another example, again using the wire protocol with <code>telnet</code>, shows how syntax errors are reported ASAP instead:</p> <pre><code>MULTI\n+OK\nINCR a b c\n-ERR wrong number of arguments for 'incr' command\n</code></pre> <p>This time due to the syntax error the bad <code>INCR</code> command is not queued at all.</p>"},{"location":"5-interact/transactions/#what-about-rollbacks","title":"What about rollbacks?","text":"<p>Redis does not support rollbacks of transactions since supporting rollbacks would have a significant impact on the simplicity and performance of Redis.</p>"},{"location":"5-interact/transactions/#discarding-the-command-queue","title":"Discarding the command queue","text":"<p><code>DISCARD</code> can be used in order to abort a transaction. In this case, no commands are executed and the state of the connection is restored to normal.</p> <p><pre><code>&gt; SET foo 1\nOK\n&gt; MULTI\nOK\n&gt; INCR foo\nQUEUED\n&gt; DISCARD\nOK\n&gt; GET foo\n\"1\"\n</code></pre> </p>"},{"location":"5-interact/transactions/#optimistic-locking-using-check-and-set","title":"Optimistic locking using check-and-set","text":"<p><code>WATCH</code> is used to provide a check-and-set (CAS) behavior to Redis transactions.</p> <p><code>WATCH</code>ed keys are monitored in order to detect changes against them. If at least one watched key is modified before the <code>EXEC</code> command, the whole transaction aborts, and <code>EXEC</code> returns a Null reply to notify that the transaction failed.</p> <p>For example, imagine we have the need to atomically increment the value of a key by 1 (let's suppose Redis doesn't have <code>INCR</code>).</p> <p>The first try may be the following:</p> <pre><code>val = GET mykey\nval = val + 1\nSET mykey $val\n</code></pre> <p>This will work reliably only if we have a single client performing the operation in a given time. If multiple clients try to increment the key at about the same time there will be a race condition. For instance, client A and B will read the old value, for instance, 10. The value will be incremented to 11 by both the clients, and finally <code>SET</code> as the value of the key. So the final value will be 11 instead of 12.</p> <p>Thanks to <code>WATCH</code> we are able to model the problem very well:</p> <pre><code>WATCH mykey\nval = GET mykey\nval = val + 1\nMULTI\nSET mykey $val\nEXEC\n</code></pre> <p>Using the above code, if there are race conditions and another client modifies the result of <code>val</code> in the time between our call to <code>WATCH</code> and our call to <code>EXEC</code>, the transaction will fail.</p> <p>We just have to repeat the operation hoping this time we'll not get a new race. This form of locking is called optimistic locking. In many use cases, multiple clients will be accessing different keys, so collisions are unlikely \u2013 usually there's no need to repeat the operation.</p>"},{"location":"5-interact/transactions/#watch-explained","title":"WATCH explained","text":"<p>So what is <code>WATCH</code> really about? It is a command that will make the <code>EXEC</code> conditional: we are asking Redis to perform the transaction only if none of the <code>WATCH</code>ed keys were modified. This includes modifications made by the client, like write commands, and by Redis itself, like expiration or eviction. If keys were modified between when they were <code>WATCH</code>ed and when the <code>EXEC</code> was received, the entire transaction will be aborted instead.</p> <p>NOTE * In Redis versions before 6.0.9, an expired key would not cause a transaction to be aborted. More on this * Commands within a transaction won't trigger the <code>WATCH</code> condition since they are only queued until the <code>EXEC</code> is sent.</p> <p><code>WATCH</code> can be called multiple times. Simply all the <code>WATCH</code> calls will have the effects to watch for changes starting from the call, up to the moment <code>EXEC</code> is called. You can also send any number of keys to a single <code>WATCH</code> call.</p> <p>When <code>EXEC</code> is called, all keys are <code>UNWATCH</code>ed, regardless of whether the transaction was aborted or not.  Also when a client connection is closed, everything gets <code>UNWATCH</code>ed.</p> <p>It is also possible to use the <code>UNWATCH</code> command (without arguments) in order to flush all the watched keys. Sometimes this is useful as we optimistically lock a few keys, since possibly we need to perform a transaction to alter those keys, but after reading the current content of the keys we don't want to proceed.  When this happens we just call <code>UNWATCH</code> so that the connection can already be used freely for new transactions.</p>"},{"location":"5-interact/transactions/#using-watch-to-implement-zpop","title":"Using WATCH to implement ZPOP","text":"<p>A good example to illustrate how <code>WATCH</code> can be used to create new atomic operations otherwise not supported by Redis is to implement ZPOP (<code>ZPOPMIN</code>, <code>ZPOPMAX</code> and their blocking variants have only been added in version 5.0), that is a command that pops the element with the lower score from a sorted set in an atomic way. This is the simplest implementation:</p> <pre><code>WATCH zset\nelement = ZRANGE zset 0 0\nMULTI\nZREM zset element\nEXEC\n</code></pre> <p>If <code>EXEC</code> fails (i.e. returns a Null reply) we just repeat the operation.</p>"},{"location":"5-interact/transactions/#redis-scripting-and-transactions","title":"Redis scripting and transactions","text":"<p>Something else to consider for transaction like operations in redis are redis scripts which are transactional. Everything you can do with a Redis Transaction, you can also do with a script, and usually the script will be both simpler and faster.</p>"},{"location":"5-interact/programmability/_index/","title":"Redis programmability","text":"<p>Redis provides a programming interface that lets you execute custom scripts on the server itself. In Redis 7 and beyond, you can use Redis Functions to manage and run your scripts. In Redis 6.2 and below, you use Lua scripting with the EVAL command to program the server.</p>"},{"location":"5-interact/programmability/_index/#background","title":"Background","text":"<p>Redis is, by definition, a \"domain-specific language for abstract data types\". The language that Redis speaks consists of its commands. Most the commands specialize at manipulating core data types in different ways. In many cases, these commands provide all the functionality that a developer requires for managing application data in Redis.</p> <p>The term programmability in Redis means having the ability to execute arbitrary user-defined logic by the server. We refer to such pieces of logic as scripts. In our case, scripts enable processing the data where it lives, a.k.a data locality. Furthermore, the responsible embedding of programmatic workflows in the Redis server can help in reducing network traffic and improving overall performance. Developers can use this capability for implementing robust, application-specific APIs. Such APIs can encapsulate business logic and maintain a data model across multiple keys and different data structures.</p> <p>User scripts are executed in Redis by an embedded, sandboxed scripting engine. Presently, Redis supports a single scripting engine, the Lua 5.1 interpreter.</p> <p>Please refer to the Redis Lua API Reference page for complete documentation.</p>"},{"location":"5-interact/programmability/_index/#running-scripts","title":"Running scripts","text":"<p>Redis provides two means for running scripts.</p> <p>Firstly, and ever since Redis 2.6.0, the <code>EVAL</code> command enables running server-side scripts. Eval scripts provide a quick and straightforward way to have Redis run your scripts ad-hoc. However, using them means that the scripted logic is a part of your application (not an extension of the Redis server). Every applicative instance that runs a script must have the script's source code readily available for loading at any time. That is because scripts are only cached by the server and are volatile. As your application grows, this approach can become harder to develop and maintain.</p> <p>Secondly, added in v7.0, Redis Functions are essentially scripts that are first-class database elements. As such, functions decouple scripting from application logic and enable independent development, testing, and deployment of scripts. To use functions, they need to be loaded first, and then they are available for use by all connected clients. In this case, loading a function to the database becomes an administrative deployment task (such as loading a Redis module, for example), which separates the script from the application.</p> <p>Please refer to the following pages for more information:</p> <ul> <li>Redis Eval Scripts</li> <li>Redis Functions</li> </ul> <p>When running a script or a function, Redis guarantees its atomic execution. The script's execution blocks all server activities during its entire time, similarly to the semantics of transactions. These semantics mean that all of the script's effects either have yet to happen or had already happened. The blocking semantics of an executed script apply to all connected clients at all times.</p> <p>Note that the potential downside of this blocking approach is that executing slow scripts is not a good idea. It is not hard to create fast scripts because scripting's overhead is very low. However, if you intend to use a slow script in your application, be aware that all other clients are blocked and can't execute any command while it is running.</p>"},{"location":"5-interact/programmability/_index/#read-only-scripts","title":"Read-only scripts","text":"<p>A read-only script is a script that only executes commands that don't modify any keys within Redis. Read-only scripts can be executed either by adding the <code>no-writes</code> flag to the script or by executing the script with one of the read-only script command variants: <code>EVAL_RO</code>, <code>EVALSHA_RO</code>, or <code>FCALL_RO</code>. They have the following properties:</p> <ul> <li>They can always be executed on replicas.</li> <li>They can always be killed by the <code>SCRIPT KILL</code> command. </li> <li>They never fail with OOM error when redis is over the memory limit.</li> <li>They are not blocked during write pauses, such as those that occur during coordinated failovers.</li> <li>They cannot execute any command that may modify the data set.</li> <li>Currently <code>PUBLISH</code>, <code>SPUBLISH</code> and <code>PFCOUNT</code> are also considered write commands in scripts, because they could attempt to propagate commands to replicas and AOF file.</li> </ul> <p>In addition to the benefits provided by all read-only scripts, the read-only script commands have the following advantages:</p> <ul> <li>They can be used to configure an ACL user to only be able to execute read-only scripts.</li> <li>Many clients also better support routing the read-only script commands to replicas for applications that want to use replicas for read scaling.</li> </ul>"},{"location":"5-interact/programmability/_index/#read-only-script-history","title":"Read-only script history","text":"<p>Read-only scripts and read-only script commands were introduced in Redis 7.0</p> <ul> <li>Before Redis 7.0.1 <code>PUBLISH</code>, <code>SPUBLISH</code> and <code>PFCOUNT</code> were not considered write commands in scripts</li> <li>Before Redis 7.0.1 the <code>no-writes</code> flag did not imply <code>allow-oom</code></li> <li>Before Redis 7.0.1 the <code>no-writes</code> flag did not permit the script to run during write pauses.</li> </ul> <p>The recommended approach is to use the standard scripting commands with the <code>no-writes</code> flag unless you need one of the previously mentioned features.</p>"},{"location":"5-interact/programmability/_index/#sandboxed-script-context","title":"Sandboxed script context","text":"<p>Redis places the engine that executes user scripts inside a sandbox. The sandbox attempts to prevent accidental misuse and reduce potential threats from the server's environment.</p> <p>Scripts should never try to access the Redis server's underlying host systems, such as the file system, network, or attempt to perform any other system call other than those supported by the API.</p> <p>Scripts should operate solely on data stored in Redis and data provided as arguments to their execution.</p>"},{"location":"5-interact/programmability/_index/#maximum-execution-time","title":"Maximum execution time","text":"<p>Scripts are subject to a maximum execution time (set by default to five seconds). This default timeout is enormous since a script usually runs in less than a millisecond. The limit is in place to handle accidental infinite loops created during development.</p> <p>It is possible to modify the maximum time a script can be executed with millisecond precision, either via <code>redis.conf</code> or by using the <code>CONFIG SET</code> command. The configuration parameter affecting max execution time is called <code>busy-reply-threshold</code>.</p> <p>When a script reaches the timeout threshold, it isn't terminated by Redis automatically. Doing so would violate the contract between Redis and the scripting engine that ensures that scripts are atomic. Interrupting the execution of a script has the potential of leaving the dataset with half-written changes.</p> <p>Therefore, when a script executes longer than the configured timeout, the following happens:</p> <ul> <li>Redis logs that a script is running for too long.</li> <li>It starts accepting commands again from other clients but will reply with a BUSY error to all the clients sending normal commands. The only commands allowed in this state are <code>SCRIPT KILL</code>, <code>FUNCTION KILL</code>, and <code>SHUTDOWN NOSAVE</code>.</li> <li>It is possible to terminate a script that only executes read-only commands using the <code>SCRIPT KILL</code> and <code>FUNCTION KILL</code> commands. These commands do not violate the scripting semantic as no data was written to the dataset by the script yet.</li> <li>If the script had already performed even a single write operation, the only command allowed is <code>SHUTDOWN NOSAVE</code> that stops the server without saving the current data set on disk (basically, the server is aborted).</li> </ul>"},{"location":"5-interact/programmability/eval-intro/","title":"Scripting with Lua","text":"<p>Redis lets users upload and execute Lua scripts on the server. Scripts can employ programmatic control structures and use most of the commands while executing to access the database. Because scripts execute in the server, reading and writing data from scripts is very efficient.</p> <p>Redis guarantees the script's atomic execution. While executing the script, all server activities are blocked during its entire runtime. These semantics mean that all of the script's effects either have yet to happen or had already happened.</p> <p>Scripting offers several properties that can be valuable in many cases. These include:</p> <ul> <li>Providing locality by executing logic where data lives. Data locality reduces overall latency and saves networking resources.</li> <li>Blocking semantics that ensure the script's atomic execution.</li> <li>Enabling the composition of simple capabilities that are either missing from Redis or are too niche to be a part of it.</li> </ul> <p>Lua lets you run part of your application logic inside Redis. Such scripts can perform conditional updates across multiple keys, possibly combining several different data types atomically.</p> <p>Scripts are executed in Redis by an embedded execution engine. Presently, Redis supports a single scripting engine, the Lua 5.1 interpreter. Please refer to the Redis Lua API Reference page for complete documentation.</p> <p>Although the server executes them, Eval scripts are regarded as a part of the client-side application, which is why they're not named, versioned, or persisted. So all scripts may need to be reloaded by the application at any time if missing (after a server restart, fail-over to a replica, etc.). As of version 7.0, Redis Functions offer an alternative approach to programmability which allow the server itself to be extended with additional programmed logic.</p>"},{"location":"5-interact/programmability/eval-intro/#getting-started","title":"Getting started","text":"<p>We'll start scripting with Redis by using the <code>EVAL</code> command.</p> <p>Here's our first example:</p> <pre><code>&gt; EVAL \"return 'Hello, scripting!'\" 0\n\"Hello, scripting!\"\n</code></pre> <p>In this example, <code>EVAL</code> takes two arguments. The first argument is a string that consists of the script's Lua source code. The script doesn't need to include any definitions of Lua function. It is just a Lua program that will run in the Redis engine's context.</p> <p>The second argument is the number of arguments that follow the script's body, starting from the third argument, representing Redis key names. In this example, we used the value 0 because we didn't provide the script with any arguments, whether the names of keys or not.</p>"},{"location":"5-interact/programmability/eval-intro/#script-parameterization","title":"Script parameterization","text":"<p>It is possible, although highly ill-advised, to have the application dynamically generate script source code per its needs. For example, the application could send these two entirely different, but at the same time perfectly identical scripts:</p> <pre><code>redis&gt; EVAL \"return 'Hello'\" 0\n\"Hello\"\nredis&gt; EVAL \"return 'Scripting!'\" 0\n\"Scripting!\"\n</code></pre> <p>Although this mode of operation isn't blocked by Redis, it is an anti-pattern due to script cache considerations (more on the topic below). Instead of having your application generate subtle variations of the same scripts, you can parametrize them and pass any arguments needed for to execute them.</p> <p>The following example demonstrates how to achieve the same effects as above, but via parameterization:</p> <pre><code>redis&gt; EVAL \"return ARGV[1]\" 0 Hello\n\"Hello\"\nredis&gt; EVAL \"return ARGV[1]\" 0 Parameterization!\n\"Parameterization!\"\n</code></pre> <p>At this point, it is essential to understand the distinction Redis makes between input arguments that are names of keys and those that aren't.</p> <p>While key names in Redis are just strings, unlike any other string values, these represent keys in the database. The name of a key is a fundamental concept in Redis and is the basis for operating the Redis Cluster.</p> <p>Important: to ensure the correct execution of scripts, both in standalone and clustered deployments, all names of keys that a script accesses must be explicitly provided as input key arguments. The script should only access keys whose names are given as input arguments. Scripts should never access keys with programmatically-generated names or based on the contents of data structures stored in the database.</p> <p>Any input to the function that isn't the name of a key is a regular input argument.</p> <p>In the example above, both Hello and Parameterization! regular input arguments for the script. Because the script doesn't touch any keys, we use the numerical argument 0 to specify there are no key name arguments. The execution context makes arguments available to the script through KEYS and ARGV global runtime variables. The KEYS table is pre-populated with all key name arguments provided to the script before its execution, whereas the ARGV table serves a similar purpose but for regular arguments.</p> <p>The following attempts to demonstrate the distribution of input arguments between the scripts KEYS and ARGV runtime global variables:</p> <pre><code>redis&gt; EVAL \"return { KEYS[1], KEYS[2], ARGV[1], ARGV[2], ARGV[3] }\" 2 key1 key2 arg1 arg2 arg3\n1) \"key1\"\n2) \"key2\"\n3) \"arg1\"\n4) \"arg2\"\n5) \"arg3\"\n</code></pre> <p>Note: as can been seen above, Lua's table arrays are returned as RESP2 array replies, so it is likely that your client's library will convert it to the native array data type in your programming language. Please refer to the rules that govern data type conversion for more pertinent information.</p>"},{"location":"5-interact/programmability/eval-intro/#interacting-with-redis-from-a-script","title":"Interacting with Redis from a script","text":"<p>It is possible to call Redis commands from a Lua script either via <code>redis.call()</code> or <code>redis.pcall()</code>.</p> <p>The two are nearly identical. Both execute a Redis command along with its provided arguments, if these represent a well-formed command. However, the difference between the two functions lies in the manner in which runtime errors (such as syntax errors, for example) are handled. Errors raised from calling <code>redis.call()</code> function are returned directly to the client that had executed it. Conversely, errors encountered when calling the <code>redis.pcall()</code> function are returned to the script's execution context instead for possible handling.</p> <p>For example, consider the following:</p> <p><pre><code>&gt; EVAL \"return redis.call('SET', KEYS[1], ARGV[1])\" 1 foo bar\nOK\n</code></pre> The above script accepts one key name and one value as its input arguments. When executed, the script calls the <code>SET</code> command to set the input key, foo, with the string value \"bar\".</p>"},{"location":"5-interact/programmability/eval-intro/#script-cache","title":"Script cache","text":"<p>Until this point, we've used the <code>EVAL</code> command to run our script.</p> <p>Whenever we call <code>EVAL</code>, we also include the script's source code with the request. Repeatedly calling <code>EVAL</code> to execute the same set of parameterized scripts, wastes both network bandwidth and also has some overheads in Redis. Naturally, saving on network and compute resources is key, so, instead, Redis provides a caching mechanism for scripts.</p> <p>Every script you execute with <code>EVAL</code> is stored in a dedicated cache that the server keeps. The cache's contents are organized by the scripts' SHA1 digest sums, so the SHA1 digest sum of a script uniquely identifies it in the cache. You can verify this behavior by running <code>EVAL</code> and calling <code>INFO</code> afterward. You'll notice that the used_memory_scripts_eval and number_of_cached_scripts metrics grow with every new script that's executed.</p> <p>As mentioned above, dynamically-generated scripts are an anti-pattern. Generating scripts during the application's runtime may, and probably will, exhaust the host's memory resources for caching them. Instead, scripts should be as generic as possible and provide customized execution via their arguments.</p> <p>A script is loaded to the server's cache by calling the <code>SCRIPT LOAD</code> command and providing its source code. The server doesn't execute the script, but instead just compiles and loads it to the server's cache. Once loaded, you can execute the cached script with the SHA1 digest returned from the server.</p> <p>Here's an example of loading and then executing a cached script:</p> <pre><code>redis&gt; SCRIPT LOAD \"return 'Immabe a cached script'\"\n\"c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f\"\nredis&gt; EVALSHA c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f 0\n\"Immabe a cached script\"\n</code></pre>"},{"location":"5-interact/programmability/eval-intro/#cache-volatility","title":"Cache volatility","text":"<p>The Redis script cache is always volatile. It isn't considered as a part of the database and is not persisted. The cache may be cleared when the server restarts, during fail-over when a replica assumes the master role, or explicitly by <code>SCRIPT FLUSH</code>. That means that cached scripts are ephemeral, and the cache's contents can be lost at any time.</p> <p>Applications that use scripts should always call <code>EVALSHA</code> to execute them. The server returns an error if the script's SHA1 digest is not in the cache. For example:</p> <pre><code>redis&gt; EVALSHA ffffffffffffffffffffffffffffffffffffffff 0\n(error) NOSCRIPT No matching script\n</code></pre> <p>In this case, the application should first load it with <code>SCRIPT LOAD</code> and then call <code>EVALSHA</code> once more to run the cached script by its SHA1 sum. Most of Redis' clients already provide utility APIs for doing that automatically. Please consult your client's documentation regarding the specific details.</p>"},{"location":"5-interact/programmability/eval-intro/#evalsha-in-the-context-of-pipelining","title":"<code>!EVALSHA</code> in the context of pipelining","text":"<p>Special care should be given executing <code>EVALSHA</code> in the context of a pipelined request. The commands in a pipelined request run in the order they are sent, but other clients' commands may be interleaved for execution between these. Because of that, the <code>NOSCRIPT</code> error can return from a pipelined request but can't be handled.</p> <p>Therefore, a client library's implementation should revert to using plain <code>EVAL</code> of parameterized in the context of a pipeline.</p>"},{"location":"5-interact/programmability/eval-intro/#script-cache-semantics","title":"Script cache semantics","text":"<p>During normal operation, an application's scripts are meant to stay indefinitely in the cache (that is, until the server is restarted or the cache being flushed). The underlying reasoning is that the script cache contents of a well-written application are unlikely to grow continuously. Even large applications that use hundreds of cached scripts shouldn't be an issue in terms of cache memory usage. </p> <p>The only way to flush the script cache is by explicitly calling the <code>SCRIPT FLUSH</code> command. Running the command will completely flush the scripts cache, removing all the scripts executed so far. Typically, this is only needed when the instance is going to be instantiated for another customer or application in a cloud environment.</p> <p>Also, as already mentioned, restarting a Redis instance flushes the non-persistent script cache. However, from the point of view of the Redis client, there are only two ways to make sure that a Redis instance was not restarted between two different commands:</p> <ul> <li>The connection we have with the server is persistent and was never closed so far.</li> <li>The client explicitly checks the <code>run_id</code> field in the <code>INFO</code> command to ensure the server was not restarted and is still the same process.</li> </ul> <p>Practically speaking, it is much simpler for the client to assume that in the context of a given connection, cached scripts are guaranteed to be there unless the administrator explicitly invoked the <code>SCRIPT FLUSH</code> command. The fact that the user can count on Redis to retain cached scripts is semantically helpful in the context of pipelining.</p>"},{"location":"5-interact/programmability/eval-intro/#the-script-command","title":"The <code>!SCRIPT</code> command","text":"<p>The Redis <code>SCRIPT</code> provides several ways for controlling the scripting subsystem. These are:</p> <ul> <li> <p><code>SCRIPT FLUSH</code>: this command is the only way to force Redis to flush the scripts cache.   It is most useful in environments where the same Redis instance is reassigned to different uses.   It is also helpful for testing client libraries' implementations of the scripting feature.</p> </li> <li> <p><code>SCRIPT EXISTS</code>: given one or more SHA1 digests as arguments, this command returns an array of 1's and 0's.   1 means the specific SHA1 is recognized as a script already present in the scripting cache. 0's meaning is that a script with this SHA1 wasn't loaded before (or at least never since the latest call to <code>SCRIPT FLUSH</code>).</p> </li> <li> <p><code>SCRIPT LOAD script</code>: this command registers the specified script in the Redis script cache.    It is a useful command in all the contexts where we want to ensure that <code>EVALSHA</code> doesn't not fail (for instance, in a pipeline or when called from a <code>MULTI</code>/<code>EXEC</code> transaction), without the need to execute the script.</p> </li> <li> <p><code>SCRIPT KILL</code>: this command is the only way to interrupt a long-running script (a.k.a slow script), short of shutting down the server.   A script is deemed as slow once its execution's duration exceeds the configured maximum execution time threshold.   The <code>SCRIPT KILL</code> command can be used only with scripts that did not modify the dataset during their execution (since stopping a read-only script does not violate the scripting engine's guaranteed atomicity).</p> </li> <li> <p><code>SCRIPT DEBUG</code>: controls use of the built-in Redis Lua scripts debugger.</p> </li> </ul>"},{"location":"5-interact/programmability/eval-intro/#script-replication","title":"Script replication","text":"<p>In standalone deployments, a single Redis instance called master manages the entire database. A clustered deployment has at least three masters managing the sharded database. Redis uses replication to maintain one or more replicas, or exact copies, for any given master.</p> <p>Because scripts can modify the data, Redis ensures all write operations performed by a script are also sent to replicas to maintain consistency. There are two conceptual approaches when it comes to script replication:</p> <ol> <li>Verbatim replication: the master sends the script's source code to the replicas.    Replicas then execute the script and apply the write effects.    This mode can save on replication bandwidth in cases where short scripts generate many commands (for example, a for loop).    However, this replication mode means that replicas redo the same work done by the master, which is wasteful.    More importantly, it also requires all write scripts to be deterministic.</li> <li>Effects replication: only the script's data-modifying commands are replicated.    Replicas then run the commands without executing any scripts.    While potentially lengthier in terms of network traffic, this replication mode is deterministic by definition and therefore doesn't require special consideration.</li> </ol> <p>Verbatim script replication was the only mode supported until Redis 3.2, in which effects replication was added. The lua-replicate-commands configuration directive and <code>redis.replicate_commands()</code> Lua API can be used to enable it.</p> <p>In Redis 5.0, effects replication became the default mode. As of Redis 7.0, verbatim replication is no longer supported.</p>"},{"location":"5-interact/programmability/eval-intro/#replicating-commands-instead-of-scripts","title":"Replicating commands instead of scripts","text":"<p>Starting with Redis 3.2, it is possible to select an alternative replication method. Instead of replicating whole scripts, we can replicate the write commands generated by the script. We call this script effects replication.</p> <p>Note: starting with Redis 5.0, script effects replication is the default mode and does not need to be explicitly enabled.</p> <p>In this replication mode, while Lua scripts are executed, Redis collects all the commands executed by the Lua scripting engine that actually modify the dataset. When the script execution finishes, the sequence of commands that the script generated are wrapped into a <code>MULTI</code>/<code>EXEC</code> transaction and are sent to the replicas and AOF.</p> <p>This is useful in several ways depending on the use case:</p> <ul> <li>When the script is slow to compute, but the effects can be summarized by a few write commands, it is a shame to re-compute the script on the replicas or when reloading the AOF.   In this case, it is much better to replicate just the effects of the script.</li> <li>When script effects replication is enabled, the restrictions on non-deterministic functions are removed.   You can, for example, use the <code>TIME</code> or <code>SRANDMEMBER</code> commands inside your scripts freely at any place.</li> <li>The Lua PRNG in this mode is seeded randomly on every call.</li> </ul> <p>Unless already enabled by the server's configuration or defaults (before Redis 7.0), you need to issue the following Lua command before the script performs a write:</p> <pre><code>redis.replicate_commands()\n</code></pre> <p>The <code>redis.replicate_commands()</code> function returns true) if script effects replication was enabled; otherwise, if the function was called after the script already called a write command, it returns _false, and normal whole script replication is used.</p> <p>This function is deprecated as of Redis 7.0, and while you can still call it, it will always succeed. </p>"},{"location":"5-interact/programmability/eval-intro/#scripts-with-deterministic-writes","title":"Scripts with deterministic writes","text":"<p>Note: Starting with Redis 5.0, script replication is by default effect-based rather than verbatim. In Redis 7.0, verbatim script replication had been removed entirely. The following section only applies to versions lower than Redis 7.0 when not using effect-based script replication.</p> <p>An important part of scripting is writing scripts that only change the database in a deterministic way. Scripts executed in a Redis instance are, by default until version 5.0, propagated to replicas and to the AOF file by sending the script itself -- not the resulting commands. Since the script will be re-run on the remote host (or when reloading the AOF file), its changes to the database must be reproducible.</p> <p>The reason for sending the script is that it is often much faster than sending the multiple commands that the script generates. If the client is sending many scripts to the master, converting the scripts into individual commands for the replica / AOF would result in too much bandwidth for the replication link or the Append Only File (and also too much CPU since dispatching a command received via the network is a lot more work for Redis compared to dispatching a command invoked by Lua scripts).</p> <p>Normally replicating scripts instead of the effects of the scripts makes sense, however not in all the cases. So starting with Redis 3.2, the scripting engine is able to, alternatively, replicate the sequence of write commands resulting from the script execution, instead of replication the script itself.</p> <p>In this section, we'll assume that scripts are replicated verbatim by sending the whole script. Let's call this replication mode verbatim scripts replication.</p> <p>The main drawback with the whole scripts replication approach is that scripts are required to have the following property: the script always must execute the same Redis write commands with the same arguments given the same input data set. Operations performed by the script can't depend on any hidden (non-explicit) information or state that may change as the script execution proceeds or between different executions of the script. Nor can it depend on any external input from I/O devices.</p> <p>Acts such as using the system time, calling Redis commands that return random values (e.g., <code>RANDOMKEY</code>), or using Lua's random number generator, could result in scripts that will not evaluate consistently.</p> <p>To enforce the deterministic behavior of scripts, Redis does the following:</p> <ul> <li>Lua does not export commands to access the system time or other external states.</li> <li>Redis will block the script with an error if a script calls a Redis command able to alter the data set after a Redis random command like <code>RANDOMKEY</code>, <code>SRANDMEMBER</code>, <code>TIME</code>.   That means that read-only scripts that don't modify the dataset can call those commands.   Note that a random command does not necessarily mean a command that uses random numbers: any non-deterministic command is considered as a random command (the best example in this regard is the <code>TIME</code> command).</li> <li>In Redis version 4.0, commands that may return elements in random order, such as <code>SMEMBERS</code> (because Redis Sets are unordered), exhibit a different behavior when called from Lua, and undergo a silent lexicographical sorting filter before returning data to Lua scripts.   So <code>redis.call(\"SMEMBERS\",KEYS[1])</code> will always return the Set elements in the same order, while the same command invoked by normal clients may return different results even if the key contains exactly the same elements.   However, starting with Redis 5.0, this ordering is no longer performed because replicating effects circumvents this type of non-determinism.   In general, even when developing for Redis 4.0, never assume that certain commands in Lua will be ordered, but instead rely on the documentation of the original command you call to see the properties it provides.</li> <li>Lua's pseudo-random number generation function <code>math.random</code> is modified and always uses the same seed for every execution.   This means that calling <code>math.random</code> will always generate the same sequence of numbers every time a script is executed (unless <code>math.randomseed</code> is used).</li> </ul> <p>All that said, you can still use commands that write and random behavior with a simple trick. Imagine that you want to write a Redis script that will populate a list with N random integers.</p> <p>The initial implementation in Ruby could look like this:</p> <pre><code>require 'rubygems'\nrequire 'redis'\n\nr = Redis.new\n\nRandomPushScript = &lt;&lt;EOF\n    local i = tonumber(ARGV[1])\n    local res\n    while (i &gt; 0) do\n        res = redis.call('LPUSH',KEYS[1],math.random())\n        i = i-1\n    end\n    return res\nEOF\n\nr.del(:mylist)\nputs r.eval(RandomPushScript,[:mylist],[10,rand(2**32)])\n</code></pre> <p>Every time this code runs, the resulting list will have exactly the following elements:</p> <pre><code>redis&gt; LRANGE mylist 0 -1\n 1) \"0.74509509873814\"\n 2) \"0.87390407681181\"\n 3) \"0.36876626981831\"\n 4) \"0.6921941534114\"\n 5) \"0.7857992587545\"\n 6) \"0.57730350670279\"\n 7) \"0.87046522734243\"\n 8) \"0.09637165539729\"\n 9) \"0.74990198051087\"\n10) \"0.17082803611217\"\n</code></pre> <p>To make the script both deterministic and still have it produce different random elements, we can add an extra argument to the script that's the seed to Lua's pseudo-random number generator. The new script is as follows:</p> <pre><code>RandomPushScript = &lt;&lt;EOF\n    local i = tonumber(ARGV[1])\n    local res\n    math.randomseed(tonumber(ARGV[2]))\n    while (i &gt; 0) do\n        res = redis.call('LPUSH',KEYS[1],math.random())\n        i = i-1\n    end\n    return res\nEOF\n\nr.del(:mylist)\nputs r.eval(RandomPushScript,1,:mylist,10,rand(2**32))\n</code></pre> <p>What we are doing here is sending the seed of the PRNG as one of the arguments. The script output will always be the same given the same arguments (our requirement) but we are changing one of the arguments at every invocation, generating the random seed client-side. The seed will be propagated as one of the arguments both in the replication link and in the Append Only File, guaranteeing that the same changes will be generated when the AOF is reloaded or when the replica processes the script.</p> <p>Note: an important part of this behavior is that the PRNG that Redis implements as <code>math.random</code> and <code>math.randomseed</code> is guaranteed to have the same output regardless of the architecture of the system running Redis. 32-bit, 64-bit, big-endian and little-endian systems will all produce the same output.</p>"},{"location":"5-interact/programmability/eval-intro/#debugging-eval-scripts","title":"Debugging Eval scripts","text":"<p>Starting with Redis 3.2, Redis has support for native Lua debugging. The Redis Lua debugger is a remote debugger consisting of a server, which is Redis itself, and a client, which is by default <code>redis-cli</code>.</p> <p>The Lua debugger is described in the Lua scripts debugging section of the Redis documentation.</p>"},{"location":"5-interact/programmability/eval-intro/#execution-under-low-memory-conditions","title":"Execution under low memory conditions","text":"<p>When memory usage in Redis exceeds the <code>maxmemory</code> limit, the first write command encountered in the script that uses additional memory will cause the script to abort (unless <code>redis.pcall</code> was used).</p> <p>However, an exception to the above is when the script's first write command does not use additional memory, as is the case with  (for example, <code>DEL</code> and <code>LREM</code>). In this case, Redis will allow all commands in the script to run to ensure atomicity. If subsequent writes in the script consume additional memory, Redis' memory usage can exceed the threshold set by the <code>maxmemory</code> configuration directive.</p> <p>Another scenario in which a script can cause memory usage to cross the <code>maxmemory</code> threshold is when the execution begins when Redis is slightly below <code>maxmemory</code>, so the script's first write command is allowed. As the script executes, subsequent write commands consume more memory leading to the server using more RAM than the configured <code>maxmemory</code> directive.</p> <p>In those scenarios, you should consider setting the <code>maxmemory-policy</code> configuration directive to any values other than <code>noeviction</code>. In addition, Lua scripts should be as fast as possible so that eviction can kick in between executions.</p> <p>Note that you can change this behaviour by using flags</p>"},{"location":"5-interact/programmability/eval-intro/#eval-flags","title":"Eval flags","text":"<p>Normally, when you run an Eval script, the server does not know how it accesses the database. By default, Redis assumes that all scripts read and write data. However, starting with Redis 7.0, there's a way to declare flags when creating a script in order to tell Redis how it should behave.</p> <p>The way to do that is by using a Shebang statement on the first line of the script like so:</p> <pre><code>#!lua flags=no-writes,allow-stale\nlocal x = redis.call('get','x')\nreturn x\n</code></pre> <p>Note that as soon as Redis sees the <code>#!</code> comment, it'll treat the script as if it declares flags, even if no flags are defined, it still has a different set of defaults compared to a script without a <code>#!</code> line.</p> <p>Another difference is that scripts without <code>#!</code> can run commands that access keys belonging to different cluster hash slots, but ones with <code>#!</code> inherit the default flags, so they cannot.</p> <p>Please refer to Script flags to learn about the various scripts and the defaults.</p>"},{"location":"5-interact/programmability/functions-intro/","title":"Redis functions","text":"<p>Redis Functions is an API for managing code to be executed on the server. This feature, which became available in Redis 7, supersedes the use of EVAL in prior versions of Redis.</p>"},{"location":"5-interact/programmability/functions-intro/#prologue-or-whats-wrong-with-eval-scripts","title":"Prologue (or, what's wrong with Eval Scripts?)","text":"<p>Prior versions of Redis made scripting available only via the <code>EVAL</code> command, which allows a Lua script to be sent for execution by the server. The core use cases for Eval Scripts is executing part of your application logic inside Redis, efficiently and atomically. Such script can perform conditional updates across multiple keys, possibly combining several different data types.</p> <p>Using <code>EVAL</code> requires that the application sends the entire script for execution every time. Because this results in network and script compilation overheads, Redis provides an optimization in the form of the <code>EVALSHA</code> command. By first calling <code>SCRIPT LOAD</code> to obtain the script's SHA1, the application can invoke it repeatedly afterward with its digest alone.</p> <p>By design, Redis only caches the loaded scripts. That means that the script cache can become lost at any time, such as after calling <code>SCRIPT FLUSH</code>, after restarting the server, or when failing over to a replica. The application is responsible for reloading scripts during runtime if any are missing. The underlying assumption is that scripts are a part of the application and not maintained by the Redis server.</p> <p>This approach suits many light-weight scripting use cases, but introduces several difficulties once an application becomes complex and relies more heavily on scripting, namely:</p> <ol> <li>All client application instances must maintain a copy of all scripts. That means having some mechanism that applies script updates to all of the application's instances.</li> <li>Calling cached scripts within the context of a transaction increases the probability of the transaction failing because of a missing script. Being more likely to fail makes using cached scripts as building blocks of workflows less attractive.</li> <li>SHA1 digests are meaningless, making debugging the system extremely hard (e.g., in a <code>MONITOR</code> session).</li> <li>When used naively, <code>EVAL</code> promotes an anti-pattern in which scripts the client application renders verbatim scripts instead of responsibly using the <code>!KEYS</code> and <code>ARGV</code> Lua APIs.</li> <li>Because they are ephemeral, a script can't call another script. This makes sharing and reusing code between scripts nearly impossible, short of client-side preprocessing (see the first point).</li> </ol> <p>To address these needs while avoiding breaking changes to already-established and well-liked ephemeral scripts, Redis v7.0 introduces Redis Functions.</p>"},{"location":"5-interact/programmability/functions-intro/#what-are-redis-functions","title":"What are Redis Functions?","text":"<p>Redis functions are an evolutionary step from ephemeral scripting.</p> <p>Functions provide the same core functionality as scripts but are first-class software artifacts of the database. Redis manages functions as an integral part of the database and ensures their availability via data persistence and replication. Because functions are part of the database and therefore declared before use, applications aren't required to load them during runtime nor risk aborted transactions. An application that uses functions depends only on their APIs rather than on the embedded script logic in the database.</p> <p>Whereas ephemeral scripts are considered a part of the application's domain, functions extend the database server itself with user-provided logic. They can be used to expose a richer API composed of core Redis commands, similar to modules, developed once, loaded at startup, and used repeatedly by various applications / clients. Every function has a unique user-defined name, making it much easier to call and trace its execution.</p> <p>The design of Redis Functions also attempts to demarcate between the programming language used for writing functions and their management by the server. Lua, the only language interpreter that Redis presently support as an embedded execution engine, is meant to be simple and easy to learn. However, the choice of Lua as a language still presents many Redis users with a challenge.</p> <p>The Redis Functions feature makes no assumptions about the implementation's language. An execution engine that is part of the definition of the function handles running it. An engine can theoretically execute functions in any language as long as it respects several rules (such as the ability to terminate an executing function).</p> <p>Presently, as noted above, Redis ships with a single embedded Lua 5.1 engine. There are plans to support additional engines in the future. Redis functions can use all of Lua's available capabilities to ephemeral scripts, with the only exception being the Redis Lua scripts debugger.</p> <p>Functions also simplify development by enabling code sharing. Every function belongs to a single library, and any given library can consist of multiple functions. The library's contents are immutable, and selective updates of its functions aren't allowed. Instead, libraries are updated as a whole with all of their functions together in one operation. This allows calling functions from other functions within the same library, or sharing code between functions by using a common code in library-internal methods, that can also take language native arguments.</p> <p>Functions are intended to better support the use case of maintaining a consistent view for data entities through a logical schema, as mentioned above. As such, functions are stored alongside the data itself. Functions are also persisted to the AOF file and replicated from master to replicas, so they are as durable as the data itself. When Redis is used as an ephemeral cache, additional mechanisms (described below) are required to make functions more durable.</p> <p>Like all other operations in Redis, the execution of a function is atomic. A function's execution blocks all server activities during its entire time, similarly to the semantics of transactions. These semantics mean that all of the script's effects either have yet to happen or had already happened. The blocking semantics of an executed function apply to all connected clients at all times. Because running a function blocks the Redis server, functions are meant to finish executing quickly, so you should avoid using long-running functions.</p>"},{"location":"5-interact/programmability/functions-intro/#loading-libraries-and-functions","title":"Loading libraries and functions","text":"<p>Let's explore Redis Functions via some tangible examples and Lua snippets.</p> <p>At this point, if you're unfamiliar with Lua in general and specifically in Redis, you may benefit from reviewing some of the examples in Introduction to Eval Scripts and Lua API pages for a better grasp of the language.</p> <p>Every Redis function belongs to a single library that's loaded to Redis. Loading a library to the database is done with the <code>FUNCTION LOAD</code> command. The command gets the library payload as input, the library payload must start with Shebang statement that provides a metadata about the library (like the engine to use and the library name). The Shebang format is: <pre><code>#!&lt;engine name&gt; name=&lt;library name&gt;\n</code></pre></p> <p>Let's try loading an empty library:</p> <pre><code>redis&gt; FUNCTION LOAD \"#!lua name=mylib\\n\"\n(error) ERR No functions registered\n</code></pre> <p>The error is expected, as there are no functions in the loaded library. Every library needs to include at least one registered function to load successfully. A registered function is named and acts as an entry point to the library. When the target execution engine handles the <code>FUNCTION LOAD</code> command, it registers the library's functions.</p> <p>The Lua engine compiles and evaluates the library source code when loaded, and expects functions to be registered by calling the <code>redis.register_function()</code> API.</p> <p>The following snippet demonstrates a simple library registering a single function named knockknock, returning a string reply:</p> <pre><code>#!lua name=mylib\nredis.register_function(\n  'knockknock',\n  function() return 'Who\\'s there?' end\n)\n</code></pre> <p>In the example above, we provide two arguments about the function to Lua's <code>redis.register_function()</code> API: its registered name and a callback.</p> <p>We can load our library and use <code>FCALL</code> to call the registered function:</p> <pre><code>redis&gt; FUNCTION LOAD \"#!lua name=mylib\\nredis.register_function('knockknock', function() return 'Who\\\\'s there?' end)\"\nmylib\nredis&gt; FCALL knockknock 0\n\"Who's there?\"\n</code></pre> <p>Notice that the <code>FUNCTION LOAD</code> command returns the name of the loaded library, this name can later be used <code>FUNCTION LIST</code> and <code>FUNCTION DELETE</code>.</p> <p>We've provided <code>FCALL</code> with two arguments: the function's registered name and the numeric value <code>0</code>. This numeric value indicates the number of key names that follow it (the same way <code>EVAL</code> and <code>EVALSHA</code> work).</p> <p>We'll explain immediately how key names and additional arguments are available to the function. As this simple example doesn't involve keys, we simply use 0 for now.</p>"},{"location":"5-interact/programmability/functions-intro/#input-keys-and-regular-arguments","title":"Input keys and regular arguments","text":"<p>Before we move to the following example, it is vital to understand the distinction Redis makes between arguments that are names of keys and those that aren't.</p> <p>While key names in Redis are just strings, unlike any other string values, these represent keys in the database. The name of a key is a fundamental concept in Redis and is the basis for operating the Redis Cluster.</p> <p>Important: To ensure the correct execution of Redis Functions, both in standalone and clustered deployments, all names of keys that a function accesses must be explicitly provided as input key arguments.</p> <p>Any input to the function that isn't the name of a key is a regular input argument.</p> <p>Now, let's pretend that our application stores some of its data in Redis Hashes. We want an <code>HSET</code>-like way to set and update fields in said Hashes and store the last modification time in a new field named <code>_last_modified_</code>. We can implement a function to do all that.</p> <p>Our function will call <code>TIME</code> to get the server's clock reading and update the target Hash with the new fields' values and the modification's timestamp. The function we'll implement accepts the following input arguments: the Hash's key name and the field-value pairs to update.</p> <p>The Lua API for Redis Functions makes these inputs accessible as the first and second arguments to the function's callback. The callback's first argument is a Lua table populated with all key names inputs to the function. Similarly, the callback's second argument consists of all regular arguments.</p> <p>The following is a possible implementation for our function and its library registration:</p> <pre><code>#!lua name=mylib\n\nlocal function my_hset(keys, args)\n  local hash = keys[1]\n  local time = redis.call('TIME')[1]\n  return redis.call('HSET', hash, '_last_modified_', time, unpack(args))\nend\n\nredis.register_function('my_hset', my_hset)\n</code></pre> <p>If we create a new file named mylib.lua that consists of the library's definition, we can load it like so (without stripping the source code of helpful whitespaces):</p> <pre><code>$ cat mylib.lua | redis-cli -x FUNCTION LOAD REPLACE\n</code></pre> <p>We've added the <code>REPLACE</code> modifier to the call to <code>FUNCTION LOAD</code> to tell Redis that we want to overwrite the existing library definition. Otherwise, we would have gotten an error from Redis complaining that the library already exists.</p> <p>Now that the library's updated code is loaded to Redis, we can proceed and call our function:</p> <pre><code>redis&gt; FCALL my_hset 1 myhash myfield \"some value\" another_field \"another value\"\n(integer) 3\nredis&gt; HGETALL myhash\n1) \"_last_modified_\"\n2) \"1640772721\"\n3) \"myfield\"\n4) \"some value\"\n5) \"another_field\"\n6) \"another value\"\n</code></pre> <p>In this case, we had invoked <code>FCALL</code> with 1 as the number of key name arguments. That means that the function's first input argument is a name of a key (and is therefore included in the callback's <code>keys</code> table). After that first argument, all following input arguments are considered regular arguments and constitute the <code>args</code> table passed to the callback as its second argument.</p>"},{"location":"5-interact/programmability/functions-intro/#expanding-the-library","title":"Expanding the library","text":"<p>We can add more functions to our library to benefit our application. The additional metadata field we've added to the Hash shouldn't be included in responses when accessing the Hash's data. On the other hand, we do want to provide the means to obtain the modification timestamp for a given Hash key.</p> <p>We'll add two new functions to our library to accomplish these objectives:</p> <ol> <li>The <code>my_hgetall</code> Redis Function will return all fields and their respective values from a given Hash key name, excluding the metadata (i.e., the <code>_last_modified_</code> field).</li> <li>The <code>my_hlastmodified</code> Redis Function will return the modification timestamp for a given Hash key name.</li> </ol> <p>The library's source code could look something like the following:</p> <pre><code>#!lua name=mylib\n\nlocal function my_hset(keys, args)\n  local hash = keys[1]\n  local time = redis.call('TIME')[1]\n  return redis.call('HSET', hash, '_last_modified_', time, unpack(args))\nend\n\nlocal function my_hgetall(keys, args)\n  redis.setresp(3)\n  local hash = keys[1]\n  local res = redis.call('HGETALL', hash)\n  res['map']['_last_modified_'] = nil\n  return res\nend\n\nlocal function my_hlastmodified(keys, args)\n  local hash = keys[1]\n  return redis.call('HGET', hash, '_last_modified_')\nend\n\nredis.register_function('my_hset', my_hset)\nredis.register_function('my_hgetall', my_hgetall)\nredis.register_function('my_hlastmodified', my_hlastmodified)\n</code></pre> <p>While all of the above should be straightforward, note that the <code>my_hgetall</code> also calls <code>redis.setresp(3)</code>. That means that the function expects RESP3 replies after calling <code>redis.call()</code>, which, unlike the default RESP2 protocol, provides dictionary (associative arrays) replies. Doing so allows the function to delete (or set to <code>nil</code> as is the case with Lua tables) specific fields from the reply, and in our case, the <code>_last_modified_</code> field.</p> <p>Assuming you've saved the library's implementation in the mylib.lua file, you can replace it with:</p> <pre><code>$ cat mylib.lua | redis-cli -x FUNCTION LOAD REPLACE\n</code></pre> <p>Once loaded, you can call the library's functions with <code>FCALL</code>:</p> <pre><code>redis&gt; FCALL my_hgetall 1 myhash\n1) \"myfield\"\n2) \"some value\"\n3) \"another_field\"\n4) \"another value\"\nredis&gt; FCALL my_hlastmodified 1 myhash\n\"1640772721\"\n</code></pre> <p>You can also get the library's details with the <code>FUNCTION LIST</code> command:</p> <pre><code>redis&gt; FUNCTION LIST\n1) 1) \"library_name\"\n   2) \"mylib\"\n   3) \"engine\"\n   4) \"LUA\"\n   5) \"functions\"\n   6) 1) 1) \"name\"\n         2) \"my_hset\"\n         3) \"description\"\n         4) (nil)\n      2) 1) \"name\"\n         2) \"my_hgetall\"\n         3) \"description\"\n         4) (nil)\n      3) 1) \"name\"\n         2) \"my_hlastmodified\"\n         3) \"description\"\n         4) (nil)\n</code></pre> <p>You can see that it is easy to update our library with new capabilities.</p>"},{"location":"5-interact/programmability/functions-intro/#reusing-code-in-the-library","title":"Reusing code in the library","text":"<p>On top of bundling functions together into database-managed software artifacts, libraries also facilitate code sharing. We can add to our library an error handling helper function called from other functions. The helper function <code>check_keys()</code> verifies that the input keys table has a single key. Upon success it returns <code>nil</code>, otherwise it returns an error reply.</p> <p>The updated library's source code would be:</p> <pre><code>#!lua name=mylib\n\nlocal function check_keys(keys)\n  local error = nil\n  local nkeys = table.getn(keys)\n  if nkeys == 0 then\n    error = 'Hash key name not provided'\n  elseif nkeys &gt; 1 then\n    error = 'Only one key name is allowed'\n  end\n\n  if error ~= nil then\n    redis.log(redis.LOG_WARNING, error);\n    return redis.error_reply(error)\n  end\n  return nil\nend\n\nlocal function my_hset(keys, args)\n  local error = check_keys(keys)\n  if error ~= nil then\n    return error\n  end\n\n  local hash = keys[1]\n  local time = redis.call('TIME')[1]\n  return redis.call('HSET', hash, '_last_modified_', time, unpack(args))\nend\n\nlocal function my_hgetall(keys, args)\n  local error = check_keys(keys)\n  if error ~= nil then\n    return error\n  end\n\n  redis.setresp(3)\n  local hash = keys[1]\n  local res = redis.call('HGETALL', hash)\n  res['map']['_last_modified_'] = nil\n  return res\nend\n\nlocal function my_hlastmodified(keys, args)\n  local error = check_keys(keys)\n  if error ~= nil then\n    return error\n  end\n\n  local hash = keys[1]\n  return redis.call('HGET', keys[1], '_last_modified_')\nend\n\nredis.register_function('my_hset', my_hset)\nredis.register_function('my_hgetall', my_hgetall)\nredis.register_function('my_hlastmodified', my_hlastmodified)\n</code></pre> <p>After you've replaced the library in Redis with the above, you can immediately try out the new error handling mechanism:</p> <pre><code>127.0.0.1:6379&gt; FCALL my_hset 0 myhash nope nope\n(error) Hash key name not provided\n127.0.0.1:6379&gt; FCALL my_hgetall 2 myhash anotherone\n(error) Only one key name is allowed\n</code></pre> <p>And your Redis log file should have lines in it that are similar to:</p> <pre><code>...\n20075:M 1 Jan 2022 16:53:57.688 # Hash key name not provided\n20075:M 1 Jan 2022 16:54:01.309 # Only one key name is allowed\n</code></pre>"},{"location":"5-interact/programmability/functions-intro/#functions-in-cluster","title":"Functions in cluster","text":"<p>As noted above, Redis automatically handles propagation of loaded functions to replicas. In a Redis Cluster, it is also necessary to load functions to all cluster nodes. This is not handled automatically by Redis Cluster, and needs to be handled by the cluster administrator (like module loading, configuration setting, etc.).</p> <p>As one of the goals of functions is to live separately from the client application, this should not be part of the Redis client library responsibilities. Instead, <code>redis-cli --cluster-only-masters --cluster call host:port FUNCTION LOAD ...</code> can be used to execute the load command on all master nodes.</p> <p>Also, note that <code>redis-cli --cluster add-node</code> automatically takes care to propagate the loaded functions from one of the existing nodes to the new node.</p>"},{"location":"5-interact/programmability/functions-intro/#functions-and-ephemeral-redis-instances","title":"Functions and ephemeral Redis instances","text":"<p>In some cases there may be a need to start a fresh Redis server with a set of functions pre-loaded. Common reasons for that could be:</p> <ul> <li>Starting Redis in a new environment</li> <li>Re-starting an ephemeral (cache-only) Redis, that uses functions</li> </ul> <p>In such cases, we need to make sure that the pre-loaded functions are available before Redis accepts inbound user connections and commands.</p> <p>To do that, it is possible to use <code>redis-cli --functions-rdb</code> to extract the functions from an existing server. This generates an RDB file that can be loaded by Redis at startup.</p>"},{"location":"5-interact/programmability/functions-intro/#function-flags","title":"Function flags","text":"<p>Redis needs to have some information about how a function is going to behave when executed, in order to properly enforce resource usage policies and maintain data consistency.</p> <p>For example, Redis needs to know that a certain function is read-only before permitting it to execute using <code>FCALL_RO</code> on a read-only replica.</p> <p>By default, Redis assumes that all functions may perform arbitrary read or write operations. Function Flags make it possible to declare more specific function behavior at the time of registration. Let's see how this works.</p> <p>In our previous example, we defined two functions that only read data. We can try executing them using <code>FCALL_RO</code> against a read-only replica.</p> <pre><code>redis &gt; FCALL_RO my_hgetall 1 myhash\n(error) ERR Can not execute a function with write flag using fcall_ro.\n</code></pre> <p>Redis returns this error because a function can, in theory, perform both read and write operations on the database. As a safeguard and by default, Redis assumes that the function does both, so it blocks its execution. The server will reply with this error in the following cases:</p> <ol> <li>Executing a function with <code>FCALL</code> against a read-only replica.</li> <li>Using <code>FCALL_RO</code> to execute a function.</li> <li>A disk error was detected (Redis is unable to persist so it rejects writes).</li> </ol> <p>In these cases, you can add the <code>no-writes</code> flag to the function's registration, disable the safeguard and allow them to run. To register a function with flags use the named arguments variant of <code>redis.register_function</code>.</p> <p>The updated registration code snippet from the library looks like this:</p> <pre><code>redis.register_function('my_hset', my_hset)\nredis.register_function{\n  function_name='my_hgetall',\n  callback=my_hgetall,\n  flags={ 'no-writes' }\n}\nredis.register_function{\n  function_name='my_hlastmodified',\n  callback=my_hlastmodified,\n  flags={ 'no-writes' }\n}\n</code></pre> <p>Once we've replaced the library, Redis allows running both <code>my_hgetall</code> and <code>my_hlastmodified</code> with <code>FCALL_RO</code> against a read-only replica:</p> <pre><code>redis&gt; FCALL_RO my_hgetall 1 myhash\n1) \"myfield\"\n2) \"some value\"\n3) \"another_field\"\n4) \"another value\"\nredis&gt; FCALL_RO my_hlastmodified 1 myhash\n\"1640772721\"\n</code></pre> <p>For the complete documentation flags, please refer to Script flags.</p>"},{"location":"5-interact/programmability/lua-api/","title":"Redis Lua API reference","text":"<p>Redis includes an embedded Lua 5.1 interpreter. The interpreter runs user-defined ephemeral scripts and functions. Scripts run in a sandboxed context and can only access specific Lua packages. This page describes the packages and APIs available inside the execution's context.</p>"},{"location":"5-interact/programmability/lua-api/#sandbox-context","title":"Sandbox context","text":"<p>The sandboxed Lua context attempts to prevent accidental misuse and reduce potential threats from the server's environment.</p> <p>Scripts should never try to access the Redis server's underlying host systems. That includes the file system, network, and any other attempt to perform a system call other than those supported by the API.</p> <p>Scripts should operate solely on data stored in Redis and data provided as arguments to their execution.</p>"},{"location":"5-interact/programmability/lua-api/#global-variables-and-functions","title":"Global variables and functions","text":"<p>The sandboxed Lua execution context blocks the declaration of global variables and functions. The blocking of global variables is in place to ensure that scripts and functions don't attempt to maintain any runtime context other than the data stored in Redis. In the (somewhat uncommon) use case that a context needs to be maintain between executions, you should store the context in Redis' keyspace.</p> <p>Redis will return a \"Script attempted to create global variable 'my_global_variable\" error when trying to execute the following snippet:</p> <pre><code>my_global_variable = 'some value'\n</code></pre> <p>And similarly for the following global function declaration:</p> <pre><code>function my_global_function()\n  -- Do something amazing\nend\n</code></pre> <p>You'll also get a similar error when your script attempts to access any global variables that are undefined in the runtime's context:</p> <pre><code>-- The following will surely raise an error\nreturn an_undefined_global_variable\n</code></pre> <p>Instead, all variable and function definitions are required to be declared as local. To do so, you'll need to prepend the local keyword to your declarations. For example, the following snippet will be considered perfectly valid by Redis:</p> <pre><code>local my_local_variable = 'some value'\n\nlocal function my_local_function()\n  -- Do something else, but equally amazing\nend\n</code></pre> <p>Note: the sandbox attempts to prevent the use of globals. Using Lua's debugging functionality or other approaches such as altering the meta table used for implementing the globals' protection to circumvent the sandbox isn't hard. However, it is difficult to circumvent the protection by accident. If the user messes with the Lua global state, the consistency of AOF and replication can't be guaranteed. In other words, just don't do it.</p>"},{"location":"5-interact/programmability/lua-api/#imported-lua-modules","title":"Imported Lua modules","text":"<p>Using imported Lua modules is not supported inside the sandboxed execution context. The sandboxed execution context prevents the loading modules by disabling Lua's <code>require</code> function.</p> <p>The only libraries that Redis ships with and that you can use in scripts are listed under the Runtime libraries section.</p>"},{"location":"5-interact/programmability/lua-api/#runtime-globals","title":"Runtime globals","text":"<p>While the sandbox prevents users from declaring globals, the execution context is pre-populated with several of these.</p>"},{"location":"5-interact/programmability/lua-api/#the-redis-singleton","title":"The redis singleton","text":"<p>The redis singleton is an object instance that's accessible from all scripts. It provides the API to interact with Redis from scripts. Its description follows below.</p>"},{"location":"5-interact/programmability/lua-api/#the-keys-global-variable","title":"The KEYS global variable","text":"<ul> <li>Since version: 2.6.0</li> <li>Available in scripts: yes</li> <li>Available in functions: no</li> </ul> <p>Important: to ensure the correct execution of scripts, both in standalone and clustered deployments, all names of keys that a function accesses must be explicitly provided as input key arguments. The script should only access keys whose names are given as input arguments. Scripts should never access keys with programmatically-generated names or based on the contents of data structures stored in the database.</p> <p>The KEYS global variable is available only for ephemeral scripts. It is pre-populated with all key name input arguments.</p>"},{"location":"5-interact/programmability/lua-api/#the-argv-global-variable","title":"The ARGV global variable","text":"<ul> <li>Since version: 2.6.0</li> <li>Available in scripts: yes</li> <li>Available in functions: no</li> </ul> <p>The ARGV global variable is available only in ephemeral scripts. It is pre-populated with all regular input arguments.</p>"},{"location":"5-interact/programmability/lua-api/#redis-object","title":"redis object","text":"<ul> <li>Since version: 2.6.0</li> <li>Available in scripts: yes</li> <li>Available in functions: yes</li> </ul> <p>The Redis Lua execution context always provides a singleton instance of an object named redis. The redis instance enables the script to interact with the Redis server that's running it. Following is the API provided by the redis object instance.</p>"},{"location":"5-interact/programmability/lua-api/#rediscallcommand-arg","title":"<code>redis.call(command [,arg...])</code>","text":"<ul> <li>Since version: 2.6.0</li> <li>Available in scripts: yes</li> <li>Available in functions: yes</li> </ul> <p>The <code>redis.call()</code> function calls a given Redis command and returns its reply. Its inputs are the command and arguments, and once called, it executes the command in Redis and returns the reply.</p> <p>For example, we can call the <code>ECHO</code> command from a script and return its reply like so:</p> <pre><code>return redis.call('ECHO', 'Echo, echo... eco... o...')\n</code></pre> <p>If and when <code>redis.call()</code> triggers a runtime exception, the raw exception is raised back to the user as an error, automatically. Therefore, attempting to execute the following ephemeral script will fail and generate a runtime exception because <code>ECHO</code> accepts exactly one argument:</p> <pre><code>redis&gt; EVAL \"return redis.call('ECHO', 'Echo,', 'echo... ', 'eco... ', 'o...')\" 0\n(error) ERR Wrong number of args calling Redis command from script script: b0345693f4b77517a711221050e76d24ae60b7f7, on @user_script:1.\n</code></pre> <p>Note that the call can fail due to various reasons, see Execution under low memory conditions and Script flags</p> <p>To handle Redis runtime errors use <code>redis.pcall()</code> instead.</p>"},{"location":"5-interact/programmability/lua-api/#redispcallcommand-arg","title":"<code>redis.pcall(command [,arg...])</code>","text":"<ul> <li>Since version: 2.6.0</li> <li>Available in scripts: yes</li> <li>Available in functions: yes</li> </ul> <p>This function enables handling runtime errors raised by the Redis server. The <code>redis.pcall()</code> function  behaves exactly like <code>redis.call()</code>, except that it:</p> <ul> <li>Always returns a reply.</li> <li>Never throws a runtime exception, and returns in its stead a <code>redis.error_reply</code> in case that a runtime exception is thrown by the server.</li> </ul> <p>The following demonstrates how to use <code>redis.pcall()</code> to intercept and handle runtime exceptions from within the context of an ephemeral script.</p> <pre><code>local reply = redis.pcall('ECHO', unpack(ARGV))\nif reply['err'] ~= nil then\n  -- Handle the error sometime, but for now just log it\n  redis.log(redis.LOG_WARNING, reply['err'])\n  reply['err'] = 'ERR Something is wrong, but no worries, everything is under control'\nend\nreturn reply\n</code></pre> <p>Evaluating this script with more than one argument will return:</p> <pre><code>redis&gt; EVAL \"...\" 0 hello world\n(error) ERR Something is wrong, but no worries, everything is under control\n</code></pre>"},{"location":"5-interact/programmability/lua-api/#rediserror_replyx","title":"<code>redis.error_reply(x)</code>","text":"<ul> <li>Since version: 2.6.0</li> <li>Available in scripts: yes</li> <li>Available in functions: yes</li> </ul> <p>This is a helper function that returns an error reply. The helper accepts a single string argument and returns a Lua table with the err field set to that string.</p> <p>The outcome of the following code is that error1 and error2 are identical for all intents and purposes:</p> <pre><code>local text = 'ERR My very special error'\nlocal reply1 = { err = text }\nlocal reply2 = redis.error_reply(text)\n</code></pre> <p>Therefore, both forms are valid as means for returning an error reply from scripts:</p> <pre><code>redis&gt; EVAL \"return { err = 'ERR My very special table error' }\" 0\n(error) ERR My very special table error\nredis&gt; EVAL \"return redis.error_reply('ERR My very special reply error')\" 0\n(error) ERR My very special reply error\n</code></pre> <p>For returning Redis status replies refer to <code>redis.status_reply()</code>. Refer to the Data type conversion for returning other response types.</p> <p>Note: By convention, Redis uses the first word of an error string as a unique error code for specific errors or <code>ERR</code> for general-purpose errors. Scripts are advised to follow this convention, as shown in the example above, but this is not mandatory.</p>"},{"location":"5-interact/programmability/lua-api/#redisstatus_replyx","title":"<code>redis.status_reply(x)</code>","text":"<ul> <li>Since version: 2.6.0</li> <li>Available in scripts: yes</li> <li>Available in functions: yes</li> </ul> <p>This is a helper function that returns a simple string reply. \"OK\" is an example of a standard Redis status reply. The Lua API represents status replies as tables with a single field, ok, set with a simple status string.</p> <p>The outcome of the following code is that status1 and status2 are identical for all intents and purposes:</p> <pre><code>local text = 'Frosty'\nlocal status1 = { ok = text }\nlocal status2 = redis.status_reply(text)\n</code></pre> <p>Therefore, both forms are valid as means for returning status replies from scripts:</p> <pre><code>redis&gt; EVAL \"return { ok = 'TICK' }\" 0\nTICK\nredis&gt; EVAL \"return redis.status_reply('TOCK')\" 0\nTOCK\n</code></pre> <p>For returning Redis error replies refer to <code>redis.error_reply()</code>. Refer to the Data type conversion for returning other response types.</p>"},{"location":"5-interact/programmability/lua-api/#redissha1hexx","title":"<code>redis.sha1hex(x)</code>","text":"<ul> <li>Since version: 2.6.0</li> <li>Available in scripts: yes</li> <li>Available in functions: yes</li> </ul> <p>This function returns the SHA1 hexadecimal digest of its single string argument.</p> <p>You can, for example, obtain the empty string's SHA1 digest:</p> <pre><code>redis&gt; EVAL \"return redis.sha1hex('')\" 0\n\"da39a3ee5e6b4b0d3255bfef95601890afd80709\"\n</code></pre>"},{"location":"5-interact/programmability/lua-api/#redisloglevel-message","title":"<code>redis.log(level, message)</code>","text":"<ul> <li>Since version: 2.6.0</li> <li>Available in scripts: yes</li> <li>Available in functions: yes</li> </ul> <p>This function writes to the Redis server log.</p> <p>It expects two input arguments: the log level and a message. The message is a string to write to the log file. Log level can be on of these:</p> <ul> <li><code>redis.LOG_DEBUG</code></li> <li><code>redis.LOG_VERBOSE</code></li> <li><code>redis.LOG_NOTICE</code></li> <li><code>redis.LOG_WARNING</code></li> </ul> <p>These levels map to the server's log levels. The log only records messages equal or greater in level than the server's <code>loglevel</code> configuration directive.</p> <p>The following snippet:</p> <pre><code>redis.log(redis.LOG_WARNING, 'Something is terribly wrong')\n</code></pre> <p>will produce a line similar to the following in your server's log:</p> <pre><code>[32343] 22 Mar 15:21:39 # Something is terribly wrong\n</code></pre>"},{"location":"5-interact/programmability/lua-api/#redissetrespx","title":"<code>redis.setresp(x)</code>","text":"<ul> <li>Since version: 6.0.0</li> <li>Available in scripts: yes</li> <li>Available in functions: yes</li> </ul> <p>This function allows the executing script to switch between Redis Serialization Protocol (RESP) versions for the replies returned by <code>redis.call()</code> and <code>redis.pcall()</code>. It expects a single numerical argument as the protocol's version. The default protocol version is 2, but it can be switched to version 3.</p> <p>Here's an example of switching to RESP3 replies:</p> <pre><code>redis.setresp(3)\n</code></pre> <p>Please refer to the Data type conversion for more information about type conversions.</p>"},{"location":"5-interact/programmability/lua-api/#redisset_replx","title":"<code>redis.set_repl(x)</code>","text":"<ul> <li>Since version: 3.2.0</li> <li>Available in scripts: yes</li> <li>Available in functions: no</li> </ul> <p>Note: this feature is only available when script effects replication is employed. Calling it when using verbatim script replication will result in an error. As of Redis version 2.6.0, scripts were replicated verbatim, meaning that the scripts' source code was sent for execution by replicas and stored in the AOF. An alternative replication mode added in version 3.2.0 allows replicating only the scripts' effects. As of Redis version 7.0, script replication is no longer supported, and the only replication mode available is script effects replication.</p> <p>Warning: this is an advanced feature. Misuse can cause damage by violating the contract that binds the Redis master, its replicas, and AOF contents to hold the same logical content.</p> <p>This function allows a script to assert control over how its effects are propagated to replicas and the AOF afterward. A script's effects are the Redis write commands that it calls.</p> <p>By default, all write commands that a script executes are replicated. Sometimes, however, better control over this behavior can be helpful. This can be the case, for example, when storing intermediate values in the master alone.</p> <p>Consider a script that intersects two sets and stores the result in a temporary key with <code>SUNIONSTORE</code>. It then picks five random elements (<code>SRANDMEMBER</code>) from the intersection and stores (<code>SADD</code>) them in another set. Finally, before returning, it deletes the temporary key that stores the intersection of the two source sets.</p> <p>In this case, only the new set with its five randomly-chosen elements needs to be replicated. Replicating the <code>SUNIONSTORE</code> command and the <code>DEL</code>ition of the temporary key is unnecessary and wasteful.</p> <p>The <code>redis.set_repl()</code> function instructs the server how to treat subsequent write commands in terms of replication. It accepts a single input argument that only be one of the following:</p> <ul> <li><code>redis.REPL_ALL</code>: replicates the effects to the AOF and replicas.</li> <li><code>redis.REPL_AOF</code>: replicates the effects to the AOF alone.</li> <li><code>redis.REPL_REPLICA</code>: replicates the effects to the replicas alone.</li> <li><code>redis.REPL_SLAVE</code>: same as <code>REPL_REPLICA</code>, maintained for backward compatibility.</li> <li><code>redis.REPL_NONE</code>: disables effect replication entirely.</li> </ul> <p>By default, the scripting engine is initialized to the <code>redis.REPL_ALL</code> setting when a script begins its execution. You can call the <code>redis.set_repl()</code> function at any time during the script's execution to switch between the different replication modes.</p> <p>A simple example follows:</p> <pre><code>redis.replicate_commands() -- Enable effects replication in versions lower than Redis v7.0\nredis.call('SET', KEYS[1], ARGV[1])\nredis.set_repl(redis.REPL_NONE)\nredis.call('SET', KEYS[2], ARGV[2])\nredis.set_repl(redis.REPL_ALL)\nredis.call('SET', KEYS[3], ARGV[3])\n</code></pre> <p>If you run this script by calling <code>EVAL \"...\" 3 A B C 1 2 3</code>, the result will be that only the keys A and C are created on the replicas and AOF.</p>"},{"location":"5-interact/programmability/lua-api/#redisreplicate_commands","title":"<code>redis.replicate_commands()</code>","text":"<ul> <li>Since version: 3.2.0</li> <li>Until version: 7.0.0</li> <li>Available in scripts: yes</li> <li>Available in functions: no</li> </ul> <p>This function switches the script's replication mode from verbatim replication to effects replication. You can use it to override the default verbatim script replication mode used by Redis until version 7.0.</p> <p>Note: as of Redis v7.0, verbatim script replication is no longer supported. The default, and only script replication mode supported, is script effects' replication. For more information, please refer to <code>Replicating commands instead of scripts</code></p>"},{"location":"5-interact/programmability/lua-api/#redisbreakpoint","title":"<code>redis.breakpoint()</code>","text":"<ul> <li>Since version: 3.2.0</li> <li>Available in scripts: yes</li> <li>Available in functions: no</li> </ul> <p>This function triggers a breakpoint when using the Redis Lua debugger.</p>"},{"location":"5-interact/programmability/lua-api/#redisdebugx","title":"<code>redis.debug(x)</code>","text":"<ul> <li>Since version: 3.2.0</li> <li>Available in scripts: yes</li> <li>Available in functions: no</li> </ul> <p>This function prints its argument in the Redis Lua debugger console.</p>"},{"location":"5-interact/programmability/lua-api/#redisacl_check_cmdcommand-arg","title":"<code>redis.acl_check_cmd(command [,arg...])</code>","text":"<ul> <li>Since version: 7.0.0</li> <li>Available in scripts: yes</li> <li>Available in functions: yes</li> </ul> <p>This function is used for checking if the current user running the script has ACL permissions to execute the given command with the given arguments.</p> <p>The return value is a boolean <code>true</code> in case the current user has permissions to execute the command (via a call to redis.call or redis.pcall) or <code>false</code> in case they don't.</p> <p>The function will raise an error if the passed command or its arguments are invalid.</p>"},{"location":"5-interact/programmability/lua-api/#redisregister_function","title":"<code>redis.register_function</code>","text":"<ul> <li>Since version: 7.0.0</li> <li>Available in scripts: no</li> <li>Available in functions: yes</li> </ul> <p>This function is only available from the context of the <code>FUNCTION LOAD</code> command. When called, it registers a function to the loaded library. The function can be called either with positional or named arguments.</p>"},{"location":"5-interact/programmability/lua-api/#positional-arguments-redisregister_functionname-callback","title":"positional arguments: <code>redis.register_function(name, callback)</code>","text":"<p>The first argument to <code>redis.register_function</code> is a Lua string representing the function name. The second argument to <code>redis.register_function</code> is a Lua function.</p> <p>Usage example:</p> <pre><code>redis&gt; FUNCTION LOAD \"#!lua name=mylib\\n redis.register_function('noop', function() end)\"\n</code></pre>"},{"location":"5-interact/programmability/lua-api/#named-arguments-redisregister_functionfunction_namename-callbackcallback-flagsflag1-flag2-descriptiondescription","title":"Named arguments:  <code>redis.register_function{function_name=name, callback=callback, flags={flag1, flag2, ..}, description=description}</code>","text":"<p>The named arguments variant accepts the following arguments:</p> <ul> <li>function_name: the function's name.</li> <li>callback: the function's callback.</li> <li>flags: an array of strings, each a function flag (optional).</li> <li>description: function's description (optional).</li> </ul> <p>Both function_name and callback are mandatory.</p> <p>Usage example:</p> <pre><code>redis&gt; FUNCTION LOAD \"#!lua name=mylib\\n redis.register_function{function_name='noop', callback=function() end, flags={ 'no-writes' }, description='Does nothing'}\"\n</code></pre>"},{"location":"5-interact/programmability/lua-api/#script-flags","title":"Script flags","text":"<p>Important: Use script flags with care, which may negatively impact if misused. Note that the default for Eval scripts are different than the default for functions that are mentioned below, see Eval Flags</p> <p>When you register a function or load an Eval script, the server does not know how it accesses the database. By default, Redis assumes that all scripts read and write data. This results in the following behavior:</p> <ol> <li>They can read and write data.</li> <li>They can run in cluster mode, and are not able to run commands accessing keys of different hash slots.</li> <li>Execution against a stale replica is denied to avoid inconsistent reads.</li> <li>Execution under low memory is denied to avoid exceeding the configured threshold.</li> </ol> <p>You can use the following flags and instruct the server to treat the scripts' execution differently:</p> <ul> <li> <p><code>no-writes</code>: this flag indicates that the script only reads data but never writes.</p> <p>By default, Redis will deny the execution of flagged scripts (Functions and Eval scripts with shebang) against read-only replicas, as they may attempt to perform writes. Similarly, the server will not allow calling scripts with <code>FCALL_RO</code> / <code>EVAL_RO</code>. Lastly, when data persistence is at risk due to a disk error, execution is blocked as well.</p> <p>Using this flag allows executing the script: 1. With <code>FCALL_RO</code> / <code>EVAL_RO</code> 2. On read-only replicas. 3. Even if there's a disk error (Redis is unable to persist so it rejects writes). 4. When over the memory limit since it implies the script doesn't increase memory consumption (see <code>allow-oom</code> below)</p> <p>However, note that the server will return an error if the script attempts to call a write command. Also note that currently <code>PUBLISH</code>, <code>SPUBLISH</code> and <code>PFCOUNT</code> are also considered write commands in scripts, because they could attempt to propagate commands to replicas and AOF file.</p> <p>For more information please refer to Read-only scripts</p> </li> <li> <p><code>allow-oom</code>: use this flag to allow a script to execute when the server is out of memory (OOM).</p> <p>Unless used, Redis will deny the execution of flagged scripts (Functions and Eval scripts with shebang) when in an OOM state. Furthermore, when you use this flag, the script can call any Redis command, including commands that aren't usually allowed in this state. Specifying <code>no-writes</code> or using <code>FCALL_RO</code> / <code>EVAL_RO</code> also implies the script can run in OOM state (without specifying <code>allow-oom</code>)</p> </li> <li> <p><code>allow-stale</code>: a flag that enables running the flagged scripts (Functions and Eval scripts with shebang) against a stale replica when the <code>replica-serve-stale-data</code> config is set to <code>no</code> .</p> <p>Redis can be set to prevent data consistency problems from using old data by having stale replicas return a runtime error. For scripts that do not access the data, this flag can be set to allow stale Redis replicas to run the script. Note however that the script will still be unable to execute any command that accesses stale data.</p> </li> <li> <p><code>no-cluster</code>: the flag causes the script to return an error in Redis cluster mode.</p> <p>Redis allows scripts to be executed both in standalone and cluster modes. Setting this flag prevents executing the script against nodes in the cluster.</p> </li> <li> <p><code>allow-cross-slot-keys</code>: The flag that allows a script to access keys from multiple slots.</p> <p>Redis typically prevents any single command from accessing keys that hash to multiple slots. This flag allows scripts to break this rule and access keys within the script that access multiple slots. Declared keys to the script are still always required to hash to a single slot. Accessing keys from multiple slots is discouraged as applications should be designed to only access keys from a single slot at a time, allowing slots to move between Redis servers.</p> <p>This flag has no effect when cluster mode is disabled.</p> </li> </ul> <p>Please refer to Function Flags and Eval Flags for a detailed example.</p>"},{"location":"5-interact/programmability/lua-api/#redisredis_version","title":"<code>redis.REDIS_VERSION</code>","text":"<ul> <li>Since version: 7.0.0</li> <li>Available in scripts: yes</li> <li>Available in functions: yes</li> </ul> <p>Returns the current Redis server version as a Lua string. The reply's format is <code>MM.mm.PP</code>, where:</p> <ul> <li>MM: is the major version.</li> <li>mm: is the minor version.</li> <li>PP: is the patch level.</li> </ul>"},{"location":"5-interact/programmability/lua-api/#redisredis_version_num","title":"<code>redis.REDIS_VERSION_NUM</code>","text":"<ul> <li>Since version: 7.0.0</li> <li>Available in scripts: yes</li> <li>Available in functions: yes</li> </ul> <p>Returns the current Redis server version as a number. The reply is a hexadecimal value structured as <code>0x00MMmmPP</code>, where:</p> <ul> <li>MM: is the major version.</li> <li>mm: is the minor version.</li> <li>PP: is the patch level.</li> </ul>"},{"location":"5-interact/programmability/lua-api/#data-type-conversion","title":"Data type conversion","text":"<p>Unless a runtime exception is raised, <code>redis.call()</code> and <code>redis.pcall()</code> return the reply from the executed command to the Lua script. Redis' replies from these functions are converted automatically into Lua's native data types.</p> <p>Similarly, when a Lua script returns a reply with the <code>return</code> keyword, that reply is automatically converted to Redis' protocol.</p> <p>Put differently; there's a one-to-one mapping between Redis' replies and Lua's data types and a one-to-one mapping between Lua's data types and the Redis Protocol data types. The underlying design is such that if a Redis type is converted into a Lua type and converted back into a Redis type, the result is the same as the initial value.</p> <p>Type conversion from Redis protocol replies (i.e., the replies from <code>redis.call()</code> and <code>redis.pcall()</code>) to Lua data types depends on the Redis Serialization Protocol version used by the script. The default protocol version during script executions is RESP2. The script may switch the replies' protocol versions by calling the <code>redis.setresp()</code> function.</p> <p>Type conversion from a script's returned Lua data type depends on the user's choice of protocol (see the <code>HELLO</code> command).</p> <p>The following sections describe the type conversion rules between Lua and Redis per the protocol's version.</p>"},{"location":"5-interact/programmability/lua-api/#resp2-to-lua-type-conversion","title":"RESP2 to Lua type conversion","text":"<p>The following type conversion rules apply to the execution's context by default as well as after calling <code>redis.setresp(2)</code>:</p> <ul> <li>RESP2 integer reply -&gt; Lua number</li> <li>RESP2 bulk string reply -&gt; Lua string</li> <li>RESP2 array reply -&gt; Lua table (may have other Redis data types nested)</li> <li>RESP2 status reply -&gt; Lua table with a single ok field containing the status string</li> <li>RESP2 error reply -&gt; Lua table with a single err field containing the error string</li> <li>RESP2 null bulk reply and null multi bulk reply -&gt; Lua false boolean type</li> </ul>"},{"location":"5-interact/programmability/lua-api/#lua-to-resp2-type-conversion","title":"Lua to RESP2 type conversion","text":"<p>The following type conversion rules apply by default as well as after the user had called <code>HELLO 2</code>:</p> <ul> <li>Lua number -&gt; RESP2 integer reply (the number is converted into an integer)</li> <li>Lua string -&gt; RESP bulk string reply</li> <li>Lua table (indexed, non-associative array) -&gt; RESP2 array reply (truncated at the first Lua <code>nil</code> value encountered in the table, if any)</li> <li>Lua table with a single ok field -&gt; RESP2 status reply</li> <li>Lua table with a single err field -&gt; RESP2 error reply</li> <li>Lua boolean false -&gt; RESP2 null bulk reply</li> </ul> <p>There is an additional Lua-to-Redis conversion rule that has no corresponding Redis-to-Lua conversion rule:</p> <ul> <li>Lua Boolean <code>true</code> -&gt; RESP2 integer reply with value of 1.</li> </ul> <p>There are three additional rules to note about converting Lua to Redis data types:</p> <ul> <li>Lua has a single numerical type, Lua numbers.    There is no distinction between integers and floats.   So we always convert Lua numbers into integer replies, removing the decimal part of the number, if any.   If you want to return a Lua float, it should be returned as a string,   exactly like Redis itself does (see, for instance, the <code>ZSCORE</code> command).</li> <li>There's no simple way to have nils inside Lua arrays due    to Lua's table semantics.   Therefore, when Redis converts a Lua array to RESP, the conversion stops when it encounters a Lua <code>nil</code> value.</li> <li>When a Lua table is an associative array that contains keys and their respective values, the converted Redis reply will not include them.</li> </ul> <p>Lua to RESP2 type conversion examples:</p> <pre><code>redis&gt; EVAL \"return 10\" 0\n(integer) 10\n\nredis&gt; EVAL \"return { 1, 2, { 3, 'Hello World!' } }\" 0\n1) (integer) 1\n2) (integer) 2\n3) 1) (integer) 3\n   1) \"Hello World!\"\n\nredis&gt; EVAL \"return redis.call('get','foo')\" 0\n\"bar\"\n</code></pre> <p>The last example demonstrates receiving and returning the exact return value of <code>redis.call()</code> (or <code>redis.pcall()</code>) in Lua as it would be returned if the command had been called directly.</p> <p>The following example shows how floats and arrays that cont nils and keys are handled:</p> <pre><code>redis&gt; EVAL \"return { 1, 2, 3.3333, somekey = 'somevalue', 'foo', nil , 'bar' }\" 0\n1) (integer) 1\n2) (integer) 2\n3) (integer) 3\n4) \"foo\"\n</code></pre> <p>As you can see, the float value of 3.333 gets converted to an integer 3, the somekey key and its value are omitted, and the string \"bar\" isn't returned as there is a <code>nil</code> value that precedes it.</p>"},{"location":"5-interact/programmability/lua-api/#resp3-to-lua-type-conversion","title":"RESP3 to Lua type conversion","text":"<p>RESP3 is a newer version of the Redis Serialization Protocol. It is available as an opt-in choice as of Redis v6.0.</p> <p>An executing script may call the <code>redis.setresp</code> function during its execution and switch the protocol version that's used for returning replies from Redis' commands (that can be invoked via <code>redis.call()</code> or <code>redis.pcall()</code>).</p> <p>Once Redis' replies are in RESP3 protocol, all of the RESP2 to Lua conversion rules apply, with the following additions:</p> <ul> <li>RESP3 map reply -&gt; Lua table with a single map field containing a Lua table representing the fields and values of the map.</li> <li>RESP set reply -&gt; Lua table with a single set field containing a Lua table representing the elements of the set as fields, each with the Lua Boolean value of <code>true</code>.</li> <li>RESP3 null -&gt; Lua <code>nil</code>.</li> <li>RESP3 true reply -&gt; Lua true boolean value.</li> <li>RESP3 false reply -&gt; Lua false boolean value.</li> <li>RESP3 double reply -&gt; Lua table with a single double field containing a Lua number representing the double value.</li> <li>RESP3 big number reply -&gt; Lua table with a single big_number field containing a Lua string representing the big number value.</li> <li>Redis verbatim string reply -&gt; Lua table with a single verbatim_string field containing a Lua table with two fields, string and format, representing the verbatim string and its format, respectively.</li> </ul> <p>Note: the RESP3 big number and verbatim strings replies are only supported as of Redis v7.0 and greater.  Also, presently, RESP3's attributes, streamed strings and streamed aggregate data types are not supported by the Redis Lua API.</p>"},{"location":"5-interact/programmability/lua-api/#lua-to-resp3-type-conversion","title":"Lua to RESP3 type conversion","text":"<p>Regardless of the script's choice of protocol version set for replies with the [<code>redis.setresp()</code> function] when it calls <code>redis.call()</code> or <code>redis.pcall()</code>, the user may opt-in to using RESP3 (with the <code>HELLO 3</code> command) for the connection. Although the default protocol for incoming client connections is RESP2, the script should honor the user's preference and return adequately-typed RESP3 replies, so the following rules apply on top of those specified in the Lua to RESP2 type conversion section when that is the case.</p> <ul> <li>Lua Boolean -&gt; RESP3 Boolean reply (note that this is a change compared to the RESP2, in which returning a Boolean Lua <code>true</code> returned the number 1 to the Redis client, and returning a <code>false</code> used to return a <code>null</code>.</li> <li>Lua table with a single map field set to an associative Lua table -&gt; RESP3 map reply.</li> <li>Lua table with a single set field set to an associative Lua table -&gt; RESP3 set reply. Values can be set to anything and are discarded anyway.</li> <li>Lua table with a single double field to an associative Lua table -&gt; RESP3 double reply.</li> <li>Lua nil -&gt; RESP3 null.</li> </ul> <p>However, if the connection is set use the RESP2 protocol, and even if the script replies with RESP3-typed responses, Redis will automatically perform a RESP3 to RESP2 conversion of the reply as is the case for regular commands. That means, for example, that returning the RESP3 map type to a RESP2 connection will result in the reply being converted to a flat RESP2 array that consists of alternating field names and their values, rather than a RESP3 map.</p>"},{"location":"5-interact/programmability/lua-api/#additional-notes-about-scripting","title":"Additional notes about scripting","text":""},{"location":"5-interact/programmability/lua-api/#using-select-inside-scripts","title":"Using <code>SELECT</code> inside scripts","text":"<p>You can call the <code>SELECT</code> command from your Lua scripts, like you can with any normal client connection. However, one subtle aspect of the behavior changed between Redis versions 2.8.11 and 2.8.12. Prior to Redis version 2.8.12, the database selected by the Lua script was set as the current database for the client connection that had called it. As of Redis version 2.8.12, the database selected by the Lua script only affects the execution context of the script, and does not modify the database that's selected by the client calling the script. This semantic change between patch level releases was required since the old behavior was inherently incompatible with Redis' replication and introduced bugs.</p>"},{"location":"5-interact/programmability/lua-api/#runtime-libraries","title":"Runtime libraries","text":"<p>The Redis Lua runtime context always comes with several pre-imported libraries.</p> <p>The following standard Lua libraries are available to use:</p> <ul> <li>The String Manipulation (string) library</li> <li>The Table Manipulation (table) library</li> <li>The Mathematical Functions (math) library</li> </ul> <p>In addition, the following external libraries are loaded and accessible to scripts:</p> <ul> <li>The struct library</li> <li>The cjson library</li> <li>The cmsgpack library</li> <li>The bitop library</li> </ul>"},{"location":"5-interact/programmability/lua-api/#struct-library","title":"struct library","text":"<ul> <li>Since version: 2.6.0</li> <li>Available in scripts: yes</li> <li>Available in functions: yes</li> </ul> <p>struct is a library for packing and unpacking C-like structures in Lua. It provides the following functions:</p> <ul> <li><code>struct.pack()</code></li> <li><code>struct.unpack()</code></li> <li><code>struct.size()</code></li> </ul> <p>All of struct's functions expect their first argument to be a format string.</p>"},{"location":"5-interact/programmability/lua-api/#struct-formats","title":"struct formats","text":"<p>The following are valid format strings for struct's functions:</p> <ul> <li><code>&gt;</code>: big endian</li> <li><code>&lt;</code>: little endian</li> <li><code>![num]</code>: alignment</li> <li><code>x</code>: padding</li> <li><code>b/B</code>: signed/unsigned byte</li> <li><code>h/H</code>: signed/unsigned short</li> <li><code>l/L</code>: signed/unsigned long</li> <li><code>T</code>: size_t</li> <li><code>i/In</code>: signed/unsigned integer with size n (defaults to the size of int)</li> <li><code>cn</code>: sequence of n chars (from/to a string); when packing, n == 0 means the   whole string; when unpacking, n == 0 means use the previously read number as   the string's length.</li> <li><code>s</code>: zero-terminated string</li> <li><code>f</code>: float</li> <li><code>d</code>: double</li> <li><code></code> (space): ignored</li> </ul>"},{"location":"5-interact/programmability/lua-api/#structpackx","title":"<code>struct.pack(x)</code>","text":"<p>This function returns a struct-encoded string from values. It accepts a struct format string as its first argument, followed by the values that are to be encoded.</p> <p>Usage example:</p> <pre><code>redis&gt; EVAL \"return struct.pack('HH', 1, 2)\" 0\n\"\\x01\\x00\\x02\\x00\"\n</code></pre>"},{"location":"5-interact/programmability/lua-api/#structunpackx","title":"<code>struct.unpack(x)</code>","text":"<p>This function returns the decoded values from a struct. It accepts a struct format string as its first argument, followed by encoded struct's string.</p> <p>Usage example:</p> <pre><code>redis&gt; EVAL \"return { struct.unpack('HH', ARGV[1]) }\" 0 \"\\x01\\x00\\x02\\x00\"\n1) (integer) 1\n2) (integer) 2\n3) (integer) 5\n</code></pre>"},{"location":"5-interact/programmability/lua-api/#structsizex","title":"<code>struct.size(x)</code>","text":"<p>This function returns the size, in bytes, of a struct. It accepts a struct format string as its only argument.</p> <p>Usage example:</p> <pre><code>redis&gt; EVAL \"return struct.size('HH')\" 0\n(integer) 4\n</code></pre>"},{"location":"5-interact/programmability/lua-api/#cjson-library","title":"cjson library","text":"<ul> <li>Since version: 2.6.0</li> <li>Available in scripts: yes</li> <li>Available in functions: yes</li> </ul> <p>The cjson library provides fast JSON encoding and decoding from Lua. It provides these functions.</p>"},{"location":"5-interact/programmability/lua-api/#cjsonencodex","title":"<code>cjson.encode(x)</code>","text":"<p>This function returns a JSON-encoded string for the Lua data type provided as its argument.</p> <p>Usage example:</p> <pre><code>redis&gt; EVAL \"return cjson.encode({ ['foo'] = 'bar' })\" 0\n\"{\\\"foo\\\":\\\"bar\\\"}\"\n</code></pre>"},{"location":"5-interact/programmability/lua-api/#cjsondecodex","title":"<code>cjson.decode(x)</code>","text":"<p>This function returns a Lua data type from the JSON-encoded string provided as its argument.</p> <p>Usage example:</p> <pre><code>redis&gt; EVAL \"return cjson.decode(ARGV[1])['foo']\" 0 '{\"foo\":\"bar\"}'\n\"bar\"\n</code></pre>"},{"location":"5-interact/programmability/lua-api/#cmsgpack-library","title":"cmsgpack library","text":"<ul> <li>Since version: 2.6.0</li> <li>Available in scripts: yes</li> <li>Available in functions: yes</li> </ul> <p>The cmsgpack library provides fast MessagePack encoding and decoding from Lua. It provides these functions.</p>"},{"location":"5-interact/programmability/lua-api/#cmsgpackpackx","title":"<code>cmsgpack.pack(x)</code>","text":"<p>This function returns the packed string encoding of the Lua data type it is given as an argument.</p> <p>Usage example:</p> <pre><code>redis&gt; EVAL \"return cmsgpack.pack({'foo', 'bar', 'baz'})\" 0\n\"\\x93\\xa3foo\\xa3bar\\xa3baz\"\n</code></pre>"},{"location":"5-interact/programmability/lua-api/#cmsgpackunpackx","title":"<code>cmsgpack.unpack(x)</code>","text":"<p>This function returns the unpacked values from decoding its input string argument.</p> <p>Usage example:</p> <pre><code>redis&gt; EVAL \"return cmsgpack.unpack(ARGV[1])\" 0 \"\\x93\\xa3foo\\xa3bar\\xa3baz\"\n1) \"foo\"\n2) \"bar\"\n3) \"baz\"\n</code></pre>"},{"location":"5-interact/programmability/lua-api/#bit-library","title":"bit library","text":"<ul> <li>Since version: 2.8.18</li> <li>Available in scripts: yes</li> <li>Available in functions: yes</li> </ul> <p>The bit library provides bitwise operations on numbers. Its documentation resides at Lua BitOp documentation It provides the following functions.</p>"},{"location":"5-interact/programmability/lua-api/#bittobitx","title":"<code>bit.tobit(x)</code>","text":"<p>Normalizes a number to the numeric range for bit operations and returns it.</p> <p>Usage example:</p> <pre><code>redis&gt; EVAL 'return bit.tobit(1)' 0\n(integer) 1\n</code></pre>"},{"location":"5-interact/programmability/lua-api/#bittohexx-n","title":"<code>bit.tohex(x [,n])</code>","text":"<p>Converts its first argument to a hex string. The number of hex digits is given by the absolute value of the optional second argument.</p> <p>Usage example:</p> <pre><code>redis&gt; EVAL 'return bit.tohex(422342)' 0\n\"000671c6\"\n</code></pre>"},{"location":"5-interact/programmability/lua-api/#bitbnotx","title":"<code>bit.bnot(x)</code>","text":"<p>Returns the bitwise not of its argument.</p>"},{"location":"5-interact/programmability/lua-api/#bitbnotx-bitborx1-x2-bitbandx1-x2-and-bitbxorx1-x2","title":"<code>bit.bnot(x)</code> <code>bit.bor(x1 [,x2...])</code>, <code>bit.band(x1 [,x2...])</code> and <code>bit.bxor(x1 [,x2...])</code>","text":"<p>Returns either the bitwise or, bitwise and, or bitwise xor of all of its arguments. Note that more than two arguments are allowed.</p> <p>Usage example:</p> <pre><code>redis&gt; EVAL 'return bit.bor(1,2,4,8,16,32,64,128)' 0\n(integer) 255\n</code></pre>"},{"location":"5-interact/programmability/lua-api/#bitlshiftx-n-bitrshiftx-n-and-bitarshiftx-n","title":"<code>bit.lshift(x, n)</code>, <code>bit.rshift(x, n)</code> and <code>bit.arshift(x, n)</code>","text":"<p>Returns either the bitwise logical left-shift, bitwise logical right-shift, or bitwise arithmetic right-shift of its first argument by the number of bits given by the second argument.</p>"},{"location":"5-interact/programmability/lua-api/#bitrolx-n-and-bitrorx-n","title":"<code>bit.rol(x, n)</code> and <code>bit.ror(x, n)</code>","text":"<p>Returns either the bitwise left rotation, or bitwise right rotation of its first argument by the number of bits given by the second argument. Bits shifted out on one side are shifted back in on the other side.</p>"},{"location":"5-interact/programmability/lua-api/#bitbswapx","title":"<code>bit.bswap(x)</code>","text":"<p>Swaps the bytes of its argument and returns it. This can be used to convert little-endian 32-bit numbers to big-endian 32-bit numbers and vice versa.</p>"},{"location":"5-interact/programmability/lua-debugging/","title":"Debugging Lua scripts in Redis","text":"<p>Starting with version 3.2 Redis includes a complete Lua debugger, that can be used in order to make the task of writing complex Redis scripts much simpler.</p> <p>The Redis Lua debugger, codenamed LDB, has the following important features:</p> <ul> <li>It uses a server-client model, so it's a remote debugger. The Redis server acts as the debugging server, while the default client is <code>redis-cli</code>.  However other clients can be developed by following the simple protocol implemented by the server.</li> <li>By default every new debugging session is a forked session. It means that while the Redis Lua script is being debugged, the server does not block and is usable for development or in order to execute multiple debugging sessions in parallel. This also means that changes are rolled back after the script debugging session finished, so that's possible to restart a new debugging session again, using exactly the same Redis data set as the previous debugging session.</li> <li>An alternative synchronous (non forked) debugging model is available on demand, so that changes to the dataset can be retained. In this mode the server blocks for the time the debugging session is active.</li> <li>Support for step by step execution.</li> <li>Support for static and dynamic breakpoints.</li> <li>Support from logging the debugged script into the debugger console.</li> <li>Inspection of Lua variables.</li> <li>Tracing of Redis commands executed by the script.</li> <li>Pretty printing of Redis and Lua values.</li> <li>Infinite loops and long execution detection, which simulates a breakpoint.</li> </ul>"},{"location":"5-interact/programmability/lua-debugging/#quick-start","title":"Quick start","text":"<p>A simple way to get started with the Lua debugger is to watch this video introduction:</p> <p>Important Note:  please make sure to avoid debugging Lua scripts using your Redis production server. Use a development server instead. Also note that using the synchronous debugging mode (which is NOT the default) results in the Redis server blocking for all the time the debugging session lasts.</p> <p>To start a new debugging session using <code>redis-cli</code> do the following:</p> <ol> <li>Create your script in some file with your preferred editor. Let's assume you are editing your Redis Lua script located at <code>/tmp/script.lua</code>.</li> <li> <p>Start a debugging session with:</p> <p>./redis-cli --ldb --eval /tmp/script.lua</p> </li> </ol> <p>Note that with the <code>--eval</code> option of <code>redis-cli</code> you can pass key names and arguments to the script, separated by a comma, like in the following example:</p> <pre><code>./redis-cli --ldb --eval /tmp/script.lua mykey somekey , arg1 arg2\n</code></pre> <p>You'll enter a special mode where <code>redis-cli</code> no longer accepts its normal commands, but instead prints a help screen and passes the unmodified debugging commands directly to Redis.</p> <p>The only commands which are not passed to the Redis debugger are:</p> <ul> <li><code>quit</code> -- this will terminate the debugging session. It's like removing all the breakpoints and using the <code>continue</code> debugging command. Moreover the command will exit from <code>redis-cli</code>.</li> <li><code>restart</code> -- the debugging session will restart from scratch, reloading the new version of the script from the file. So a normal debugging cycle involves modifying the script after some debugging, and calling <code>restart</code> in order to start debugging again with the new script changes.</li> <li><code>help</code> -- this command is passed to the Redis Lua debugger, that will print a list of commands like the following:</li> </ul> <pre><code>lua debugger&gt; help\nRedis Lua debugger help:\n[h]elp               Show this help.\n[s]tep               Run current line and stop again.\n[n]ext               Alias for step.\n[c]ontinue           Run till next breakpoint.\n[l]ist               List source code around current line.\n[l]ist [line]        List source code around [line].\n                     line = 0 means: current position.\n[l]ist [line] [ctx]  In this form [ctx] specifies how many lines\n                     to show before/after [line].\n[w]hole              List all source code. Alias for 'list 1 1000000'.\n[p]rint              Show all the local variables.\n[p]rint &lt;var&gt;        Show the value of the specified variable.\n                     Can also show global vars KEYS and ARGV.\n[b]reak              Show all breakpoints.\n[b]reak &lt;line&gt;       Add a breakpoint to the specified line.\n[b]reak -&lt;line&gt;      Remove breakpoint from the specified line.\n[b]reak 0            Remove all breakpoints.\n[t]race              Show a backtrace.\n[e]val &lt;code&gt;        Execute some Lua code (in a different callframe).\n[r]edis &lt;cmd&gt;        Execute a Redis command.\n[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len.\n                     Specifying zero as &lt;len&gt; means unlimited.\n[a]bort              Stop the execution of the script. In sync\n                     mode dataset changes will be retained.\n\nDebugger functions you can call from Lua scripts:\nredis.debug()        Produce logs in the debugger console.\nredis.breakpoint()   Stop execution as if there was a breakpoint in the\n                     next line of code.\n</code></pre> <p>Note that when you start the debugger it will start in stepping mode. It will stop at the first line of the script that actually does something before executing it.</p> <p>From this point you usually call <code>step</code> in order to execute the line and go to the next line. While you step Redis will show all the commands executed by the server like in the following example:</p> <pre><code>* Stopped at 1, stop reason = step over\n-&gt; 1   redis.call('ping')\nlua debugger&gt; step\n&lt;redis&gt; ping\n&lt;reply&gt; \"+PONG\"\n* Stopped at 2, stop reason = step over\n</code></pre> <p>The <code>&lt;redis&gt;</code> and <code>&lt;reply&gt;</code> lines show the command executed by the line just executed, and the reply from the server. Note that this happens only in stepping mode. If you use <code>continue</code> in order to execute the script till the next breakpoint, commands will not be dumped on the screen to prevent too much output.</p>"},{"location":"5-interact/programmability/lua-debugging/#termination-of-the-debugging-session","title":"Termination of the debugging session","text":"<p>When the scripts terminates naturally, the debugging session ends and <code>redis-cli</code> returns in its normal non-debugging mode. You can restart the session using the <code>restart</code> command as usual.</p> <p>Another way to stop a debugging session is just interrupting <code>redis-cli</code> manually by pressing <code>Ctrl+C</code>. Note that also any event breaking the connection between <code>redis-cli</code> and the <code>redis-server</code> will interrupt the debugging session.</p> <p>All the forked debugging sessions are terminated when the server is shut down.</p>"},{"location":"5-interact/programmability/lua-debugging/#abbreviating-debugging-commands","title":"Abbreviating debugging commands","text":"<p>Debugging can be a very repetitive task. For this reason every Redis debugger command starts with a different character, and you can use the single initial character in order to refer to the command.</p> <p>So for example instead of typing <code>step</code> you can just type <code>s</code>.</p>"},{"location":"5-interact/programmability/lua-debugging/#breakpoints","title":"Breakpoints","text":"<p>Adding and removing breakpoints is trivial as described in the online help. Just use <code>b 1 2 3 4</code> to add a breakpoint in line 1, 2, 3, 4. The command <code>b 0</code> removes all the breakpoints. Selected breakpoints can be removed using as argument the line where the breakpoint we want to remove is, but prefixed by a minus sign.  So for example <code>b -3</code> removes the breakpoint from line 3.</p> <p>Note that adding breakpoints to lines that Lua never executes, like declaration of local variables or comments, will not work. The breakpoint will be added but since this part of the script will never be executed, the program will never stop.</p>"},{"location":"5-interact/programmability/lua-debugging/#dynamic-breakpoints","title":"Dynamic breakpoints","text":"<p>Using the <code>breakpoint</code> command it is possible to add breakpoints into specific lines. However sometimes we want to stop the execution of the program only when something special happens. In order to do so, you can use the <code>redis.breakpoint()</code> function inside your Lua script. When called it simulates a breakpoint in the next line that will be executed.</p> <p><pre><code>if counter &gt; 10 then redis.breakpoint() end\n</code></pre> This feature is extremely useful when debugging, so that we can avoid continuing the script execution manually multiple times until a given condition is encountered.</p>"},{"location":"5-interact/programmability/lua-debugging/#synchronous-mode","title":"Synchronous mode","text":"<p>As explained previously, but default LDB uses forked sessions with rollback of all the data changes operated by the script while it has being debugged. Determinism is usually a good thing to have during debugging, so that successive debugging sessions can be started without having to reset the database content to its original state.</p> <p>However for tracking certain bugs, you may want to retain the changes performed to the key space by each debugging session. When this is a good idea you should start the debugger using a special option, <code>ldb-sync-mode</code>, in <code>redis-cli</code>.</p> <pre><code>./redis-cli --ldb-sync-mode --eval /tmp/script.lua\n</code></pre> <p>Note: Redis server will be unreachable during the debugging session in this mode, so use with care.</p> <p>In this special mode, the <code>abort</code> command can stop the script half-way taking the changes operated to the dataset. Note that this is different compared to ending the debugging session normally.  If you just interrupt <code>redis-cli</code> the script will be fully executed and then the session terminated. Instead with <code>abort</code> you can interrupt the script execution in the middle and start a new debugging session if needed.</p>"},{"location":"5-interact/programmability/lua-debugging/#logging-from-scripts","title":"Logging from scripts","text":"<p>The <code>redis.debug()</code> command is a powerful debugging facility that can be called inside the Redis Lua script in order to log things into the debug console:</p> <pre><code>lua debugger&gt; list\n-&gt; 1   local a = {1,2,3}\n   2   local b = false\n   3   redis.debug(a,b)\nlua debugger&gt; continue\n&lt;debug&gt; line 3: {1; 2; 3}, false\n</code></pre> <p>If the script is executed outside of a debugging session, <code>redis.debug()</code> has no effects at all. Note that the function accepts multiple arguments, that are separated by a comma and a space in the output.</p> <p>Tables and nested tables are displayed correctly in order to make values simple to observe for the programmer debugging the script.</p>"},{"location":"5-interact/programmability/lua-debugging/#inspecting-the-program-state-with-print-and-eval","title":"Inspecting the program state with <code>print</code> and <code>eval</code>","text":"<p>While the <code>redis.debug()</code> function can be used in order to print values directly from within the Lua script, often it is useful to observe the local variables of a program while stepping or when stopped into a breakpoint.</p> <p>The <code>print</code> command does just that, and performs lookup in the call frames starting from the current one back to the previous ones, up to top-level. This means that even if we are into a nested function inside a Lua script, we can still use <code>print foo</code> to look at the value of <code>foo</code> in the context of the calling function. When called without a variable name, <code>print</code> will print all variables and their respective values.</p> <p>The <code>eval</code> command executes small pieces of Lua scripts outside the context of the current call frame (evaluating inside the context of the current call frame is not possible with the current Lua internals). However you can use this command in order to test Lua functions.</p> <pre><code>lua debugger&gt; e redis.sha1hex('foo')\n&lt;retval&gt; \"0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33\"\n</code></pre>"},{"location":"5-interact/programmability/lua-debugging/#debugging-clients","title":"Debugging clients","text":"<p>LDB uses the client-server model where the Redis server acts as a debugging server that communicates using RESP. While <code>redis-cli</code> is the default debug client, any client can be used for debugging as long as it meets one of the following conditions:</p> <ol> <li>The client provides a native interface for setting the debug mode and controlling the debug session.</li> <li>The client provides an interface for sending arbitrary commands over RESP.</li> <li>The client allows sending raw messages to the Redis server.</li> </ol> <p>For example, the Redis plugin for ZeroBrane Studio integrates with LDB using redis-lua. The following Lua code is a simplified example of how the plugin achieves that:</p> <pre><code>local redis = require 'redis'\n\n-- add LDB's Continue command\nredis.commands['ldbcontinue'] = redis.command('C')\n\n-- script to be debugged\nlocal script = [[\n  local x, y = tonumber(ARGV[1]), tonumber(ARGV[2])\n  local result = x * y\n  return result\n]]\n\nlocal client = redis.connect('127.0.0.1', 6379)\nclient:script(\"DEBUG\", \"YES\")\nprint(unpack(client:eval(script, 0, 6, 9)))\nclient:ldbcontinue()\n</code></pre>"},{"location":"6-manual/client-side-caching/","title":"Client-side caching in Redis","text":"<p>Client-side caching is a technique used to create high performance services. It exploits the memory available on application servers, servers that are usually distinct computers compared to the database nodes, to store some subset of the database information directly in the application side.</p> <p>Normally when data is required, the application servers ask the database about such information, like in the following diagram:</p> <pre><code>+-------------+                                +----------+\n|             | ------- GET user:1234 -------&gt; |          |\n| Application |                                | Database |\n|             | &lt;---- username = Alice ------- |          |\n+-------------+                                +----------+\n</code></pre> <p>When client-side caching is used, the application will store the reply of popular queries directly inside the application memory, so that it can reuse such replies later, without contacting the database again:</p> <pre><code>+-------------+                                +----------+\n|             |                                |          |\n| Application |       ( No chat needed )       | Database |\n|             |                                |          |\n+-------------+                                +----------+\n| Local cache |\n|             |\n| user:1234 = |\n| username    |\n| Alice       |\n+-------------+\n</code></pre> <p>While the application memory used for the local cache may not be very big, the time needed in order to access the local computer memory is orders of magnitude smaller compared to accessing a networked service like a database. Since often the same small percentage of data are accessed frequently, this pattern can greatly reduce the latency for the application to get data and, at the same time, the load in the database side.</p> <p>Moreover there are many datasets where items change very infrequently. For instance, most user posts in a social network are either immutable or rarely edited by the user. Adding to this the fact that usually a small percentage of the posts are very popular, either because a small set of users have a lot of followers and/or because recent posts have a lot more visibility, it is clear why such a pattern can be very useful.</p> <p>Usually the two key advantages of client-side caching are:</p> <ol> <li>Data is available with a very small latency.</li> <li>The database system receives less queries, allowing it to serve the same dataset with a smaller number of nodes.</li> </ol>"},{"location":"6-manual/client-side-caching/#there-are-two-hard-problems-in-computer-science","title":"There are two hard problems in computer science...","text":"<p>A problem with the above pattern is how to invalidate the information that the application is holding, in order to avoid presenting stale data to the user. For example after the application above locally cached the information for user:1234, Alice may update her username to Flora. Yet the application may continue to serve the old username for user:1234.</p> <p>Sometimes, depending on the exact application we are modeling, this isn't a big deal, so the client will just use a fixed maximum \"time to live\" for the cached information. Once a given amount of time has elapsed, the information will no longer be considered valid. More complex patterns, when using Redis, leverage the Pub/Sub system in order to send invalidation messages to listening clients. This can be made to work but is tricky and costly from the point of view of the bandwidth used, because often such patterns involve sending the invalidation messages to every client in the application, even if certain clients may not have any copy of the invalidated data. Moreover every application query altering the data requires to use the <code>PUBLISH</code> command, costing the database more CPU time to process this command.</p> <p>Regardless of what schema is used, there is a simple fact: many very large applications implement some form of client-side caching, because it is the next logical step to having a fast store or a fast cache server. For this reason Redis 6 implements direct support for client-side caching, in order to make this pattern much simpler to implement, more accessible, reliable, and efficient.</p>"},{"location":"6-manual/client-side-caching/#the-redis-implementation-of-client-side-caching","title":"The Redis implementation of client-side caching","text":"<p>The Redis client-side caching support is called Tracking, and has two modes:</p> <ul> <li>In the default mode, the server remembers what keys a given client accessed, and sends invalidation messages when the same keys are modified. This costs memory in the server side, but sends invalidation messages only for the set of keys that the client might have in memory.</li> <li>In the broadcasting mode, the server does not attempt to remember what keys a given client accessed, so this mode costs no memory at all in the server side. Instead clients subscribe to key prefixes such as <code>object:</code> or <code>user:</code>, and receive a notification message every time a key matching a subscribed prefix is touched.</li> </ul> <p>To recap, for now let's forget for a moment about the broadcasting mode, to focus on the first mode. We'll describe broadcasting in more detail later.</p> <ol> <li>Clients can enable tracking if they want. Connections start without tracking enabled.</li> <li>When tracking is enabled, the server remembers what keys each client requested during the connection lifetime (by sending read commands about such keys).</li> <li>When a key is modified by some client, or is evicted because it has an associated expire time, or evicted because of a maxmemory policy, all the clients with tracking enabled that may have the key cached, are notified with an invalidation message.</li> <li>When clients receive invalidation messages, they are required to remove the corresponding keys, in order to avoid serving stale data.</li> </ol> <p>This is an example of the protocol:</p> <ul> <li>Client 1 <code>-&gt;</code> Server: CLIENT TRACKING ON</li> <li>Client 1 <code>-&gt;</code> Server: GET foo</li> <li>(The server remembers that Client 1 may have the key \"foo\" cached)</li> <li>(Client 1 may remember the value of \"foo\" inside its local memory)</li> <li>Client 2 <code>-&gt;</code> Server: SET foo SomeOtherValue</li> <li>Server <code>-&gt;</code> Client 1: INVALIDATE \"foo\"</li> </ul> <p>This looks great superficially, but if you imagine 10k connected clients all asking for millions of keys over long living connection, the server ends up storing too much information. For this reason Redis uses two key ideas in order to limit the amount of memory used server-side and the CPU cost of handling the data structures implementing the feature:</p> <ul> <li>The server remembers the list of clients that may have cached a given key in a single global table. This table is called the Invalidation Table. The invalidation table can contain a maximum number of entries. If a new key is inserted, the server may evict an older entry by pretending that such key was modified (even if it was not), and sending an invalidation message to the clients. Doing so, it can reclaim the memory used for this key, even if this will force the clients having a local copy of the key to evict it.</li> <li>Inside the invalidation table we don't really need to store pointers to clients' structures, that would force a garbage collection procedure when the client disconnects: instead what we do is just store client IDs (each Redis client has a unique numerical ID). If a client disconnects, the information will be incrementally garbage collected as caching slots are invalidated.</li> <li>There is a single keys namespace, not divided by database numbers. So if a client is caching the key <code>foo</code> in database 2, and some other client changes the value of the key <code>foo</code> in database 3, an invalidation message will still be sent. This way we can ignore database numbers reducing both the memory usage and the implementation complexity.</li> </ul>"},{"location":"6-manual/client-side-caching/#two-connections-mode","title":"Two connections mode","text":"<p>Using the new version of the Redis protocol, RESP3, supported by Redis 6, it is possible to run the data queries and receive the invalidation messages in the same connection. However many client implementations may prefer to implement client-side caching using two separated connections: one for data, and one for invalidation messages. For this reason when a client enables tracking, it can specify to redirect the invalidation messages to another connection by specifying the \"client ID\" of a different connection. Many data connections can redirect invalidation messages to the same connection, this is useful for clients implementing connection pooling. The two connections model is the only one that is also supported for RESP2 (which lacks the ability to multiplex different kind of information in the same connection).</p> <p>Here's an example of a complete session using the Redis protocol in the old RESP2 mode involving the following steps: enabling tracking redirecting to another connection, asking for a key, and getting an invalidation message once the key gets modified.</p> <p>To start, the client opens a first connection that will be used for invalidations, requests the connection ID, and subscribes via Pub/Sub to the special channel that is used to get invalidation messages when in RESP2 modes (remember that RESP2 is the usual Redis protocol, and not the more advanced protocol that you can use, optionally, with Redis 6 using the <code>HELLO</code> command):</p> <pre><code>(Connection 1 -- used for invalidations)\nCLIENT ID\n:4\nSUBSCRIBE __redis__:invalidate\n*3\n$9\nsubscribe\n$20\n__redis__:invalidate\n:1\n</code></pre> <p>Now we can enable tracking from the data connection:</p> <pre><code>(Connection 2 -- data connection)\nCLIENT TRACKING on REDIRECT 4\n+OK\n\nGET foo\n$3\nbar\n</code></pre> <p>The client may decide to cache <code>\"foo\" =&gt; \"bar\"</code> in the local memory.</p> <p>A different client will now modify the value of the \"foo\" key:</p> <pre><code>(Some other unrelated connection)\nSET foo bar\n+OK\n</code></pre> <p>As a result, the invalidations connection will receive a message that invalidates the specified key.</p> <p><pre><code>(Connection 1 -- used for invalidations)\n*3\n$7\nmessage\n$20\n__redis__:invalidate\n*1\n$3\nfoo\n</code></pre> The client will check if there are cached keys in this caching slot, and will evict the information that is no longer valid.</p> <p>Note that the third element of the Pub/Sub message is not a single key but is a Redis array with just a single element. Since we send an array, if there are groups of keys to invalidate, we can do that in a single message. In case of a flush (<code>FLUSHALL</code> or <code>FLUSHDB</code>), a <code>null</code> message will be sent.</p> <p>A very important thing to understand about client-side caching used with RESP2 and a Pub/Sub connection in order to read the invalidation messages, is that using Pub/Sub is entirely a trick in order to reuse old client implementations, but actually the message is not really sent to a channel and received by all the clients subscribed to it. Only the connection we specified in the <code>REDIRECT</code> argument of the <code>CLIENT</code> command will actually receive the Pub/Sub message, making the feature a lot more scalable.</p> <p>When RESP3 is used instead, invalidation messages are sent (either in the same connection, or in the secondary connection when redirection is used) as <code>push</code> messages (read the RESP3 specification for more information).</p>"},{"location":"6-manual/client-side-caching/#what-tracking-tracks","title":"What tracking tracks","text":"<p>As you can see clients do not need, by default, to tell the server what keys they are caching. Every key that is mentioned in the context of a read-only command is tracked by the server, because it could be cached.</p> <p>This has the obvious advantage of not requiring the client to tell the server what it is caching. Moreover in many clients implementations, this is what you want, because a good solution could be to just cache everything that is not already cached, using a first-in first-out approach: we may want to cache a fixed number of objects, every new data we retrieve, we could cache it, discarding the oldest cached object. More advanced implementations may instead drop the least used object or alike.</p> <p>Note that anyway if there is write traffic on the server, caching slots will get invalidated during the course of the time. In general when the server assumes that what we get we also cache, we are making a tradeoff:</p> <ol> <li>It is more efficient when the client tends to cache many things with a policy that welcomes new objects.</li> <li>The server will be forced to retain more data about the client keys.</li> <li>The client will receive useless invalidation messages about objects it did not cache.</li> </ol> <p>So there is an alternative described in the next section.</p>"},{"location":"6-manual/client-side-caching/#opt-in-caching","title":"Opt-in caching","text":"<p>Clients implementations may want to cache only selected keys, and communicate explicitly to the server what they'll cache and what they will not. This will require more bandwidth when caching new objects, but at the same time reduces the amount of data that the server has to remember and the amount of invalidation messages received by the client.</p> <p>In order to do this, tracking must be enabled using the OPTIN option:</p> <pre><code>CLIENT TRACKING on REDIRECT 1234 OPTIN\n</code></pre> <p>In this mode, by default, keys mentioned in read queries are not supposed to be cached, instead when a client wants to cache something, it must send a special command immediately before the actual command to retrieve the data:</p> <pre><code>CLIENT CACHING YES\n+OK\nGET foo\n\"bar\"\n</code></pre> <p>The <code>CACHING</code> command affects the command executed immediately after it, however in case the next command is <code>MULTI</code>, all the commands in the transaction will be tracked. Similarly in case of Lua scripts, all the commands executed by the script will be tracked.</p>"},{"location":"6-manual/client-side-caching/#broadcasting-mode","title":"Broadcasting mode","text":"<p>So far we described the first client-side caching model that Redis implements. There is another one, called broadcasting, that sees the problem from the point of view of a different tradeoff, does not consume any memory on the server side, but instead sends more invalidation messages to clients. In this mode we have the following main behaviors:</p> <ul> <li>Clients enable client-side caching using the <code>BCAST</code> option, specifying one or more prefixes using the <code>PREFIX</code> option. For instance: <code>CLIENT TRACKING on REDIRECT 10 BCAST PREFIX object: PREFIX user:</code>. If no prefix is specified at all, the prefix is assumed to be the empty string, so the client will receive invalidation messages for every key that gets modified. Instead if one or more prefixes are used, only keys matching one of the specified prefixes will be sent in the invalidation messages.</li> <li>The server does not store anything in the invalidation table. Instead it uses a different Prefixes Table, where each prefix is associated to a list of clients.</li> <li>No two prefixes can track overlapping parts of the keyspace. For instance, having the prefix \"foo\" and \"foob\" would not be allowed, since they would both trigger an invalidation for the key \"foobar\". However, just using the prefix \"foo\" is sufficient.</li> <li>Every time a key matching any of the prefixes is modified, all the clients subscribed to that prefix, will receive the invalidation message.</li> <li>The server will consume CPU proportional to the number of registered prefixes. If you have just a few, it is hard to see any difference. With a big number of prefixes the CPU cost can become quite large.</li> <li>In this mode the server can perform the optimization of creating a single reply for all the clients subscribed to a given prefix, and send the same reply to all. This helps to lower the CPU usage.</li> </ul>"},{"location":"6-manual/client-side-caching/#the-noloop-option","title":"The NOLOOP option","text":"<p>By default client-side tracking will send invalidation messages to the client that modified the key. Sometimes clients want this, since they implement very basic logic that does not involve automatically caching writes locally. However, more advanced clients may want to cache even the writes they are doing in the local in-memory table. In such case receiving an invalidation message immediately after the write is a problem, since it will force the client to evict the value it just cached.</p> <p>In this case it is possible to use the <code>NOLOOP</code> option: it works both in normal and broadcasting mode. Using this option, clients are able to tell the server they don't want to receive invalidation messages for keys that they modified.</p>"},{"location":"6-manual/client-side-caching/#avoiding-race-conditions","title":"Avoiding race conditions","text":"<p>When implementing client-side caching redirecting the invalidation messages to a different connection, you should be aware that there is a possible race condition. See the following example interaction, where we'll call the data connection \"D\" and the invalidation connection \"I\":</p> <pre><code>[D] client -&gt; server: GET foo\n[I] server -&gt; client: Invalidate foo (somebody else touched it)\n[D] server -&gt; client: \"bar\" (the reply of \"GET foo\")\n</code></pre> <p>As you can see, because the reply to the GET was slower to reach the client, we received the invalidation message before the actual data that is already no longer valid. So we'll keep serving a stale version of the foo key. To avoid this problem, it is a good idea to populate the cache when we send the command with a placeholder:</p> <pre><code>Client cache: set the local copy of \"foo\" to \"caching-in-progress\"\n[D] client-&gt; server: GET foo.\n[I] server -&gt; client: Invalidate foo (somebody else touched it)\nClient cache: delete \"foo\" from the local cache.\n[D] server -&gt; client: \"bar\" (the reply of \"GET foo\")\nClient cache: don't set \"bar\" since the entry for \"foo\" is missing.\n</code></pre> <p>Such a race condition is not possible when using a single connection for both data and invalidation messages, since the order of the messages is always known in that case.</p>"},{"location":"6-manual/client-side-caching/#what-to-do-when-losing-connection-with-the-server","title":"What to do when losing connection with the server","text":"<p>Similarly, if we lost the connection with the socket we use in order to get the invalidation messages, we may end with stale data. In order to avoid this problem, we need to do the following things:</p> <ol> <li>Make sure that if the connection is lost, the local cache is flushed.</li> <li>Both when using RESP2 with Pub/Sub, or RESP3, ping the invalidation channel periodically (you can send PING commands even when the connection is in Pub/Sub mode!). If the connection looks broken and we are not able to receive ping backs, after a maximum amount of time, close the connection and flush the cache.</li> </ol>"},{"location":"6-manual/client-side-caching/#what-to-cache","title":"What to cache","text":"<p>Clients may want to run internal statistics about the number of times a given cached key was actually served in a request, to understand in the future what is good to cache. In general:</p> <ul> <li>We don't want to cache many keys that change continuously.</li> <li>We don't want to cache many keys that are requested very rarely.</li> <li>We want to cache keys that are requested often and change at a reasonable rate. For an example of key not changing at a reasonable rate, think of a global counter that is continuously <code>INCR</code>emented.</li> </ul> <p>However simpler clients may just evict data using some random sampling just remembering the last time a given cached value was served, trying to evict keys that were not served recently.</p>"},{"location":"6-manual/client-side-caching/#other-hints-for-implementing-client-libraries","title":"Other hints for implementing client libraries","text":"<ul> <li>Handling TTLs: make sure you also request the key TTL and set the TTL in the local cache if you want to support caching keys with a TTL.</li> <li>Putting a max TTL on every key is a good idea, even if it has no TTL. This protects against bugs or connection issues that would make the client have old data in the local copy.</li> <li>Limiting the amount of memory used by clients is absolutely needed. There must be a way to evict old keys when new ones are added.</li> </ul>"},{"location":"6-manual/client-side-caching/#limiting-the-amount-of-memory-used-by-redis","title":"Limiting the amount of memory used by Redis","text":"<p>Be sure to configure a suitable value for the maximum number of keys remembered by Redis or alternatively use the BCAST mode that consumes no memory at all on the Redis side. Note that the memory consumed by Redis when BCAST is not used, is proportional both to the number of keys tracked and the number of clients requesting such keys.</p>"},{"location":"6-manual/keyspace-notifications/","title":"Redis keyspace notifications","text":"<p>Keyspace notifications allow clients to subscribe to Pub/Sub channels in order to receive events affecting the Redis data set in some way.</p> <p>Examples of events that can be received are:</p> <ul> <li>All the commands affecting a given key.</li> <li>All the keys receiving an LPUSH operation.</li> <li>All the keys expiring in the database 0.</li> </ul> <p>Note: Redis Pub/Sub is fire and forget that is, if your Pub/Sub client disconnects, and reconnects later, all the events delivered during the time the client was disconnected are lost.</p>"},{"location":"6-manual/keyspace-notifications/#type-of-events","title":"Type of events","text":"<p>Keyspace notifications are implemented by sending two distinct types of events for every operation affecting the Redis data space. For instance a <code>DEL</code> operation targeting the key named <code>mykey</code> in database <code>0</code> will trigger the delivering of two messages, exactly equivalent to the following two <code>PUBLISH</code> commands:</p> <pre><code>PUBLISH __keyspace@0__:mykey del\nPUBLISH __keyevent@0__:del mykey\n</code></pre> <p>The first channel listens to all the events targeting the key <code>mykey</code> and the other channel listens only to <code>del</code> operation events on the key <code>mykey</code></p> <p>The first kind of event, with <code>keyspace</code> prefix in the channel is called a Key-space notification, while the second, with the <code>keyevent</code> prefix, is called a Key-event notification.</p> <p>In the previous example a <code>del</code> event was generated for the key <code>mykey</code> resulting in two messages:</p> <ul> <li>The Key-space channel receives as message the name of the event.</li> <li>The Key-event channel receives as message the name of the key.</li> </ul> <p>It is possible to enable only one kind of notification in order to deliver just the subset of events we are interested in.</p>"},{"location":"6-manual/keyspace-notifications/#configuration","title":"Configuration","text":"<p>By default keyspace event notifications are disabled because while not very sensible the feature uses some CPU power. Notifications are enabled using the <code>notify-keyspace-events</code> of redis.conf or via the CONFIG SET.</p> <p>Setting the parameter to the empty string disables notifications. In order to enable the feature a non-empty string is used, composed of multiple characters, where every character has a special meaning according to the following table:</p> <pre><code>K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.\nE     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.\ng     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...\n$     String commands\nl     List commands\ns     Set commands\nh     Hash commands\nz     Sorted set commands\nt     Stream commands\nd     Module key type events\nx     Expired events (events generated every time a key expires)\ne     Evicted events (events generated when a key is evicted for maxmemory)\nm     Key miss events (events generated when a key that doesn't exist is accessed)\nn     New key events (Note: not included in the 'A' class)\nA     Alias for \"g$lshztxed\", so that the \"AKE\" string means all the events except \"m\" and \"n\".\n</code></pre> <p>At least <code>K</code> or <code>E</code> should be present in the string, otherwise no event will be delivered regardless of the rest of the string.</p> <p>For instance to enable just Key-space events for lists, the configuration parameter must be set to <code>Kl</code>, and so forth.</p> <p>You can use the string <code>KEA</code> to enable most types of events.</p>"},{"location":"6-manual/keyspace-notifications/#events-generated-by-different-commands","title":"Events generated by different commands","text":"<p>Different commands generate different kind of events according to the following list.</p> <ul> <li><code>DEL</code> generates a <code>del</code> event for every deleted key.</li> <li><code>RENAME</code> generates two events, a <code>rename_from</code> event for the source key, and a <code>rename_to</code> event for the destination key.</li> <li><code>MOVE</code> generates two events, a <code>move_from</code> event for the source key, and a <code>move_to</code> event for the destination key.</li> <li><code>COPY</code> generates a <code>copy_to</code> event.</li> <li><code>MIGRATE</code> generates a <code>del</code> event if the source key is removed.</li> <li><code>RESTORE</code> generates a <code>restore</code> event for the key.</li> <li><code>EXPIRE</code> and all its variants (<code>PEXPIRE</code>, <code>EXPIREAT</code>, <code>PEXPIREAT</code>) generate an <code>expire</code> event when called with a positive timeout (or a future timestamp). Note that when these commands are called with a negative timeout value or timestamp in the past, the key is deleted and only a <code>del</code> event is generated instead.</li> <li><code>SORT</code> generates a <code>sortstore</code> event when <code>STORE</code> is used to set a new key. If the resulting list is empty, and the <code>STORE</code> option is used, and there was already an existing key with that name, the result is that the key is deleted, so a <code>del</code> event is generated in this condition.</li> <li><code>SET</code> and all its variants (<code>SETEX</code>, <code>SETNX</code>,<code>GETSET</code>) generate <code>set</code> events. However <code>SETEX</code> will also generate an <code>expire</code> events.</li> <li><code>MSET</code> generates a separate <code>set</code> event for every key.</li> <li><code>SETRANGE</code> generates a <code>setrange</code> event.</li> <li><code>INCR</code>, <code>DECR</code>, <code>INCRBY</code>, <code>DECRBY</code> commands all generate <code>incrby</code> events.</li> <li><code>INCRBYFLOAT</code> generates an <code>incrbyfloat</code> events.</li> <li><code>APPEND</code> generates an <code>append</code> event.</li> <li><code>LPUSH</code> and <code>LPUSHX</code> generates a single <code>lpush</code> event, even in the variadic case.</li> <li><code>RPUSH</code> and <code>RPUSHX</code> generates a single <code>rpush</code> event, even in the variadic case.</li> <li><code>RPOP</code> generates an <code>rpop</code> event. Additionally a <code>del</code> event is generated if the key is removed because the last element from the list was popped.</li> <li><code>LPOP</code> generates an <code>lpop</code> event. Additionally a <code>del</code> event is generated if the key is removed because the last element from the list was popped.</li> <li><code>LINSERT</code> generates an <code>linsert</code> event.</li> <li><code>LSET</code> generates an <code>lset</code> event.</li> <li><code>LREM</code> generates an <code>lrem</code> event, and additionally a <code>del</code> event if the resulting list is empty and the key is removed.</li> <li><code>LTRIM</code> generates an <code>ltrim</code> event, and additionally a <code>del</code> event if the resulting list is empty and the key is removed.</li> <li><code>RPOPLPUSH</code> and <code>BRPOPLPUSH</code> generate an <code>rpop</code> event and an <code>lpush</code> event. In both cases the order is guaranteed (the <code>lpush</code> event will always be delivered after the <code>rpop</code> event). Additionally a <code>del</code> event will be generated if the resulting list is zero length and the key is removed.</li> <li><code>LMOVE</code> and <code>BLMOVE</code> generate an <code>lpop</code>/<code>rpop</code> event (depending on the wherefrom argument) and an <code>lpush</code>/<code>rpush</code> event (depending on the whereto argument). In both cases the order is guaranteed (the <code>lpush</code>/<code>rpush</code> event will always be delivered after the <code>lpop</code>/<code>rpop</code> event). Additionally a <code>del</code> event will be generated if the resulting list is zero length and the key is removed.</li> <li><code>HSET</code>, <code>HSETNX</code> and <code>HMSET</code> all generate a single <code>hset</code> event.</li> <li><code>HINCRBY</code> generates an <code>hincrby</code> event.</li> <li><code>HINCRBYFLOAT</code> generates an <code>hincrbyfloat</code> event.</li> <li><code>HDEL</code> generates a single <code>hdel</code> event, and an additional <code>del</code> event if the resulting hash is empty and the key is removed.</li> <li><code>SADD</code> generates a single <code>sadd</code> event, even in the variadic case.</li> <li><code>SREM</code> generates a single <code>srem</code> event, and an additional <code>del</code> event if the resulting set is empty and the key is removed.</li> <li><code>SMOVE</code> generates an <code>srem</code> event for the source key, and an <code>sadd</code> event for the destination key.</li> <li><code>SPOP</code> generates an <code>spop</code> event, and an additional <code>del</code> event if the resulting set is empty and the key is removed.</li> <li><code>SINTERSTORE</code>, <code>SUNIONSTORE</code>, <code>SDIFFSTORE</code> generate <code>sinterstore</code>, <code>sunionstore</code>, <code>sdiffstore</code> events respectively. In the special case the resulting set is empty, and the key where the result is stored already exists, a <code>del</code> event is generated since the key is removed.</li> <li><code>ZINCR</code> generates a <code>zincr</code> event.</li> <li><code>ZADD</code> generates a single <code>zadd</code> event even when multiple elements are added.</li> <li><code>ZREM</code> generates a single <code>zrem</code> event even when multiple elements are deleted. When the resulting sorted set is empty and the key is generated, an additional <code>del</code> event is generated.</li> <li><code>ZREMBYSCORE</code> generates a single <code>zrembyscore</code> event. When the resulting sorted set is empty and the key is generated, an additional <code>del</code> event is generated.</li> <li><code>ZREMBYRANK</code> generates a single <code>zrembyrank</code> event. When the resulting sorted set is empty and the key is generated, an additional <code>del</code> event is generated.</li> <li><code>ZDIFFSTORE</code>, <code>ZINTERSTORE</code> and <code>ZUNIONSTORE</code> respectively generate <code>zdiffstore</code>, <code>zinterstore</code> and <code>zunionstore</code> events. In the special case the resulting sorted set is empty, and the key where the result is stored already exists, a <code>del</code> event is generated since the key is removed.</li> <li><code>XADD</code> generates an <code>xadd</code> event, possibly followed an <code>xtrim</code> event when used with the <code>MAXLEN</code> subcommand.</li> <li><code>XDEL</code> generates a single <code>xdel</code> event even when multiple entries are deleted.</li> <li><code>XGROUP CREATE</code> generates an <code>xgroup-create</code> event.</li> <li><code>XGROUP CREATECONSUMER</code> generates an <code>xgroup-createconsumer</code> event.</li> <li><code>XGROUP DELCONSUMER</code> generates an <code>xgroup-delconsumer</code> event.</li> <li><code>XGROUP DESTROY</code> generates an <code>xgroup-destroy</code> event.</li> <li><code>XGROUP SETID</code> generates an <code>xgroup-setid</code> event.</li> <li><code>XSETID</code> generates an <code>xsetid</code> event.</li> <li><code>XTRIM</code> generates an <code>xtrim</code> event.</li> <li><code>PERSIST</code> generates a <code>persist</code> event if the expiry time associated with key has been successfully deleted.</li> <li>Every time a key with a time to live associated is removed from the data set because it expired, an <code>expired</code> event is generated.</li> <li>Every time a key is evicted from the data set in order to free memory as a result of the <code>maxmemory</code> policy, an <code>evicted</code> event is generated.</li> <li>Every time a new key is added to the data set, a <code>new</code> event is generated.</li> </ul> <p>IMPORTANT all the commands generate events only if the target key is really modified. For instance an <code>SREM</code> deleting a non-existing element from a Set will not actually change the value of the key, so no event will be generated.</p> <p>If in doubt about how events are generated for a given command, the simplest thing to do is to watch yourself:</p> <pre><code>$ redis-cli config set notify-keyspace-events KEA\n$ redis-cli --csv psubscribe '__key*__:*'\nReading messages... (press Ctrl-C to quit)\n\"psubscribe\",\"__key*__:*\",1\n</code></pre> <p>At this point use <code>redis-cli</code> in another terminal to send commands to the Redis server and watch the events generated:</p> <pre><code>\"pmessage\",\"__key*__:*\",\"__keyspace@0__:foo\",\"set\"\n\"pmessage\",\"__key*__:*\",\"__keyevent@0__:set\",\"foo\"\n...\n</code></pre>"},{"location":"6-manual/keyspace-notifications/#timing-of-expired-events","title":"Timing of expired events","text":"<p>Keys with a time to live associated are expired by Redis in two ways:</p> <ul> <li>When the key is accessed by a command and is found to be expired.</li> <li>Via a background system that looks for expired keys in the background, incrementally, in order to be able to also collect keys that are never accessed.</li> </ul> <p>The <code>expired</code> events are generated when a key is accessed and is found to be expired by one of the above systems, as a result there are no guarantees that the Redis server will be able to generate the <code>expired</code> event at the time the key time to live reaches the value of zero.</p> <p>If no command targets the key constantly, and there are many keys with a TTL associated, there can be a significant delay between the time the key time to live drops to zero, and the time the <code>expired</code> event is generated.</p> <p>Basically <code>expired</code> events are generated when the Redis server deletes the key and not when the time to live theoretically reaches the value of zero.</p>"},{"location":"6-manual/keyspace-notifications/#events-in-a-cluster","title":"Events in a cluster","text":"<p>Every node of a Redis cluster generates events about its own subset of the keyspace as described above. However, unlike regular Pub/Sub communication in a cluster, events' notifications are not broadcasted to all nodes. Put differently, keyspace events are node-specific. This means that to receive all keyspace events of a cluster, clients need to subscribe to each of the nodes.</p> <p>@history</p> <ul> <li><code>&gt;= 6.0</code>: Key miss events were added.</li> <li><code>&gt;= 7.0</code>: Event type <code>new</code> added</li> </ul>"},{"location":"6-manual/keyspace/","title":"Keyspace","text":"<p>Redis keys are binary safe; this means that you can use any binary sequence as a key, from a string like \"foo\" to the content of a JPEG file. The empty string is also a valid key.</p> <p>A few other rules about keys: </p> <ul> <li>Very long keys are not a good idea. For instance a key of 1024 bytes is a bad   idea not only memory-wise, but also because the lookup of the key in the   dataset may require several costly key-comparisons. Even when the task at hand   is to match the existence of a large value, hashing it (for example   with SHA1) is a better idea, especially from the perspective of memory   and bandwidth.</li> <li>Very short keys are often not a good idea. There is little point in writing   \"u1000flw\" as a key if you can instead write \"user:1000:followers\".  The latter   is more readable and the added space is minor compared to the space used by   the key object itself and the value object. While short keys will obviously   consume a bit less memory, your job is to find the right balance.</li> <li>Try to stick with a schema. For instance \"object-type:id\" is a good   idea, as in \"user:1000\". Dots or dashes are often used for multi-word   fields, as in \"comment:4321:reply.to\" or \"comment:4321:reply-to\".</li> <li>The maximum allowed key size is 512 MB.</li> </ul>"},{"location":"6-manual/keyspace/#altering-and-querying-the-key-space","title":"Altering and querying the key space","text":"<p>There are commands that are not defined on particular types, but are useful in order to interact with the space of keys, and thus, can be used with keys of any type.</p> <p>For example the <code>EXISTS</code> command returns 1 or 0 to signal if a given key exists or not in the database, while the <code>DEL</code> command deletes a key and associated value, whatever the value is.</p> <pre><code>&gt; set mykey hello\nOK\n&gt; exists mykey\n(integer) 1\n&gt; del mykey\n(integer) 1\n&gt; exists mykey\n(integer) 0\n</code></pre> <p>From the examples you can also see how <code>DEL</code> itself returns 1 or 0 depending on whether the key was removed (it existed) or not (there was no such key with that name).</p> <p>There are many key space related commands, but the above two are the essential ones together with the <code>TYPE</code> command, which returns the kind of value stored at the specified key:</p> <pre><code>&gt; set mykey x\nOK\n&gt; type mykey\nstring\n&gt; del mykey\n(integer) 1\n&gt; type mykey\nnone\n</code></pre>"},{"location":"6-manual/keyspace/#key-expiration","title":"Key expiration","text":"<p>Before moving on, we should look at an important Redis feature that works regardless of the type of value you're storing: key expiration. Key expiration lets you set a timeout for a key, also known as a \"time to live\", or \"TTL\". When the time to live elapses, the key is automatically destroyed. </p> <p>A few important notes about key expiration:</p> <ul> <li>They can be set both using seconds or milliseconds precision.</li> <li>However the expire time resolution is always 1 millisecond.</li> <li>Information about expires are replicated and persisted on disk, the time virtually passes when your Redis server remains stopped (this means that Redis saves the date at which a key will expire).</li> </ul> <p>Use the <code>EXPIRE</code> command to set a key's expiration:</p> <pre><code>&gt; set key some-value\nOK\n&gt; expire key 5\n(integer) 1\n&gt; get key (immediately)\n\"some-value\"\n&gt; get key (after some time)\n(nil)\n</code></pre> <p>The key vanished between the two <code>GET</code> calls, since the second call was delayed more than 5 seconds. In the example above we used <code>EXPIRE</code> in order to set the expire (it can also be used in order to set a different expire to a key already having one, like <code>PERSIST</code> can be used in order to remove the expire and make the key persistent forever). However we can also create keys with expires using other Redis commands. For example using <code>SET</code> options:</p> <pre><code>&gt; set key 100 ex 10\nOK\n&gt; ttl key\n(integer) 9\n</code></pre> <p>The example above sets a key with the string value <code>100</code>, having an expire of ten seconds. Later the <code>TTL</code> command is called in order to check the remaining time to live for the key.</p> <p>In order to set and check expires in milliseconds, check the <code>PEXPIRE</code> and the <code>PTTL</code> commands, and the full list of <code>SET</code> options.</p>"},{"location":"6-manual/keyspace/#navigating-the-keyspace","title":"Navigating the keyspace","text":""},{"location":"6-manual/keyspace/#scan","title":"Scan","text":"<p>To incrementally  iterate over the keys in a Redis database in an efficient manner, you can use the <code>SCAN</code> command.</p> <p>Since <code>SCAN</code> allows for incremental iteration, returning only a small number of elements per call, it can be used in production without the downside of commands like <code>KEYS</code> or <code>SMEMBERS</code> that may block the server for a long time (even several seconds) when called against big collections of keys or elements.</p> <p>However while blocking commands like <code>SMEMBERS</code> are able to provide all the elements that are part of a Set in a given moment. The <code>SCAN</code> family of commands only offer limited guarantees about the returned elements since the collection that we incrementally iterate can change during the iteration process.</p>"},{"location":"6-manual/keyspace/#keys","title":"Keys","text":"<p>Another way to iterate over the keyspace is to use the <code>KEYS</code> command, but this approach should be used with care, since <code>KEYS</code> will block the Redis server until all keys are returned.</p> <p>Warning: consider <code>KEYS</code> as a command that should only be used in production environments with extreme care.</p> <p><code>KEYS</code> may ruin performance when it is executed against large databases. This command is intended for debugging and special operations, such as changing your keyspace layout. Don't use <code>KEYS</code> in your regular application code. If you're looking for a way to find keys in a subset of your keyspace, consider using <code>SCAN</code> or sets.</p> <p>Supported glob-style patterns:</p> <ul> <li><code>h?llo</code> matches <code>hello</code>, <code>hallo</code> and <code>hxllo</code></li> <li><code>h*llo</code> matches <code>hllo</code> and <code>heeeello</code></li> <li><code>h[ae]llo</code> matches <code>hello</code> and <code>hallo,</code> but not <code>hillo</code></li> <li><code>h[^e]llo</code> matches <code>hallo</code>, <code>hbllo</code>, ... but not <code>hello</code></li> <li><code>h[a-b]llo</code> matches <code>hallo</code> and <code>hbllo</code></li> </ul> <p>Use <code>\\</code> to escape special characters if you want to match them verbatim.</p>"},{"location":"6-manual/patterns/_index/","title":"Redis programming patterns","text":"<p>The following documents describe some novel development patterns you can use with Redis.</p>"},{"location":"6-manual/patterns/bulk-loading/","title":"Bulk loading","text":"<p>Bulk loading is the process of loading Redis with a large amount of pre-existing data. Ideally, you want to perform this operation quickly and efficiently. This document describes some strategies for bulk loading data in Redis.</p>"},{"location":"6-manual/patterns/bulk-loading/#bulk-loading-using-the-redis-protocol","title":"Bulk loading using the Redis protocol","text":"<p>Using a normal Redis client to perform bulk loading is not a good idea for a few reasons: the naive approach of sending one command after the other is slow because you have to pay for the round trip time for every command. It is possible to use pipelining, but for bulk loading of many records you need to write new commands while you read replies at the same time to make sure you are inserting as fast as possible.</p> <p>Only a small percentage of clients support non-blocking I/O, and not all the clients are able to parse the replies in an efficient way in order to maximize throughput. For all of these reasons the preferred way to mass import data into Redis is to generate a text file containing the Redis protocol, in raw format, in order to call the commands needed to insert the required data.</p> <p>For instance if I need to generate a large data set where there are billions of keys in the form: `keyN -&gt; ValueN' I will create a file containing the following commands in the Redis protocol format:</p> <pre><code>SET Key0 Value0\nSET Key1 Value1\n...\nSET KeyN ValueN\n</code></pre> <p>Once this file is created, the remaining action is to feed it to Redis as fast as possible. In the past the way to do this was to use the <code>netcat</code> with the following command:</p> <pre><code>(cat data.txt; sleep 10) | nc localhost 6379 &gt; /dev/null\n</code></pre> <p>However this is not a very reliable way to perform mass import because netcat does not really know when all the data was transferred and can't check for errors. In 2.6 or later versions of Redis the <code>redis-cli</code> utility supports a new mode called pipe mode that was designed in order to perform bulk loading.</p> <p>Using the pipe mode the command to run looks like the following:</p> <pre><code>cat data.txt | redis-cli --pipe\n</code></pre> <p>That will produce an output similar to this:</p> <pre><code>All data transferred. Waiting for the last reply...\nLast reply received from server.\nerrors: 0, replies: 1000000\n</code></pre> <p>The redis-cli utility will also make sure to only redirect errors received from the Redis instance to the standard output.</p>"},{"location":"6-manual/patterns/bulk-loading/#generating-redis-protocol","title":"Generating Redis Protocol","text":"<p>The Redis protocol is extremely simple to generate and parse, and is Documented here. However in order to generate protocol for the goal of bulk loading you don't need to understand every detail of the protocol, but just that every command is represented in the following way:</p> <pre><code>*&lt;args&gt;&lt;cr&gt;&lt;lf&gt;\n$&lt;len&gt;&lt;cr&gt;&lt;lf&gt;\n&lt;arg0&gt;&lt;cr&gt;&lt;lf&gt;\n&lt;arg1&gt;&lt;cr&gt;&lt;lf&gt;\n...\n&lt;argN&gt;&lt;cr&gt;&lt;lf&gt;\n</code></pre> <p>Where <code>&lt;cr&gt;</code> means \"\\r\" (or ASCII character 13) and <code>&lt;lf&gt;</code> means \"\\n\" (or ASCII character 10).</p> <p>For instance the command SET key value is represented by the following protocol:</p> <pre><code>*3&lt;cr&gt;&lt;lf&gt;\n$3&lt;cr&gt;&lt;lf&gt;\nSET&lt;cr&gt;&lt;lf&gt;\n$3&lt;cr&gt;&lt;lf&gt;\nkey&lt;cr&gt;&lt;lf&gt;\n$5&lt;cr&gt;&lt;lf&gt;\nvalue&lt;cr&gt;&lt;lf&gt;\n</code></pre> <p>Or represented as a quoted string:</p> <pre><code>\"*3\\r\\n$3\\r\\nSET\\r\\n$3\\r\\nkey\\r\\n$5\\r\\nvalue\\r\\n\"\n</code></pre> <p>The file you need to generate for bulk loading is just composed of commands represented in the above way, one after the other.</p> <p>The following Ruby function generates valid protocol:</p> <pre><code>def gen_redis_proto(*cmd)\n    proto = \"\"\n    proto &lt;&lt; \"*\"+cmd.length.to_s+\"\\r\\n\"\n    cmd.each{|arg|\n        proto &lt;&lt; \"$\"+arg.to_s.bytesize.to_s+\"\\r\\n\"\n        proto &lt;&lt; arg.to_s+\"\\r\\n\"\n    }\n    proto\nend\n\nputs gen_redis_proto(\"SET\",\"mykey\",\"Hello World!\").inspect\n</code></pre> <p>Using the above function it is possible to easily generate the key value pairs in the above example, with this program:</p> <pre><code>(0...1000).each{|n|\n    STDOUT.write(gen_redis_proto(\"SET\",\"Key#{n}\",\"Value#{n}\"))\n}\n</code></pre> <p>We can run the program directly in pipe to redis-cli in order to perform our first mass import session.</p> <pre><code>$ ruby proto.rb | redis-cli --pipe\nAll data transferred. Waiting for the last reply...\nLast reply received from server.\nerrors: 0, replies: 1000\n</code></pre>"},{"location":"6-manual/patterns/bulk-loading/#how-the-pipe-mode-works-under-the-hood","title":"How the pipe mode works under the hood","text":"<p>The magic needed inside the pipe mode of redis-cli is to be as fast as netcat and still be able to understand when the last reply was sent by the server at the same time.</p> <p>This is obtained in the following way:</p> <ul> <li>redis-cli --pipe tries to send data as fast as possible to the server.</li> <li>At the same time it reads data when available, trying to parse it.</li> <li>Once there is no more data to read from stdin, it sends a special ECHO command with a random 20 byte string: we are sure this is the latest command sent, and we are sure we can match the reply checking if we receive the same 20 bytes as a bulk reply.</li> <li>Once this special final command is sent, the code receiving replies starts to match replies with these 20 bytes. When the matching reply is reached it can exit with success.</li> </ul> <p>Using this trick we don't need to parse the protocol we send to the server in order to understand how many commands we are sending, but just the replies.</p> <p>However while parsing the replies we take a counter of all the replies parsed so that at the end we are able to tell the user the amount of commands transferred to the server by the mass insert session.</p>"},{"location":"6-manual/patterns/distributed-locks/","title":"Distributed Locks with Redis","text":"<p>Distributed locks are a very useful primitive in many environments where different processes must operate with shared resources in a mutually exclusive way.</p> <p>There are a number of libraries and blog posts describing how to implement a DLM (Distributed Lock Manager) with Redis, but every library uses a different approach, and many use a simple approach with lower guarantees compared to what can be achieved with slightly more complex designs.</p> <p>This page describes a more canonical algorithm to implement distributed locks with Redis. We propose an algorithm, called Redlock, which implements a DLM which we believe to be safer than the vanilla single instance approach. We hope that the community will analyze it, provide feedback, and use it as a starting point for the implementations or more complex or alternative designs.</p>"},{"location":"6-manual/patterns/distributed-locks/#implementations","title":"Implementations","text":"<p>Before describing the algorithm, here are a few links to implementations already available that can be used for reference.</p> <ul> <li>Redlock-rb (Ruby implementation). There is also a fork of Redlock-rb that adds a gem for easy distribution.</li> <li>Redlock-py (Python implementation).</li> <li>Pottery (Python implementation).</li> <li>Aioredlock (Asyncio Python implementation).</li> <li>Redlock-php (PHP implementation).</li> <li>PHPRedisMutex (further PHP implementation).</li> <li>cheprasov/php-redis-lock (PHP library for locks).</li> <li>rtckit/react-redlock (Async PHP implementation).</li> <li>Redsync (Go implementation).</li> <li>Redisson (Java implementation).</li> <li>Redis::DistLock (Perl implementation).</li> <li>Redlock-cpp (C++ implementation).</li> <li>Redis-plus-plus (C++ implementation).</li> <li>Redlock-cs (C#/.NET implementation).</li> <li>RedLock.net (C#/.NET implementation). Includes async and lock extension support.</li> <li>ScarletLock (C# .NET implementation with configurable datastore).</li> <li>Redlock4Net (C# .NET implementation).</li> <li>node-redlock (NodeJS implementation). Includes support for lock extension.</li> <li>Deno DLM (Deno implementation)</li> <li>Rslock (Rust implementation). Includes async and lock extension support.</li> </ul>"},{"location":"6-manual/patterns/distributed-locks/#safety-and-liveness-guarantees","title":"Safety and Liveness Guarantees","text":"<p>We are going to model our design with just three properties that, from our point of view, are the minimum guarantees needed to use distributed locks in an effective way.</p> <ol> <li>Safety property: Mutual exclusion. At any given moment, only one client can hold a lock.</li> <li>Liveness property A: Deadlock free. Eventually it is always possible to acquire a lock, even if the client that locked a resource crashes or gets partitioned.</li> <li>Liveness property B: Fault tolerance. As long as the majority of Redis nodes are up, clients are able to acquire and release locks.</li> </ol>"},{"location":"6-manual/patterns/distributed-locks/#why-failover-based-implementations-are-not-enough","title":"Why Failover-based Implementations Are Not Enough","text":"<p>To understand what we want to improve, let\u2019s analyze the current state of affairs with most Redis-based distributed lock libraries.</p> <p>The simplest way to use Redis to lock a resource is to create a key in an instance. The key is usually created with a limited time to live, using the Redis expires feature, so that eventually it will get released (property 2 in our list). When the client needs to release the resource, it deletes the key.</p> <p>Superficially this works well, but there is a problem: this is a single point of failure in our architecture. What happens if the Redis master goes down? Well, let\u2019s add a replica! And use it if the master is unavailable. This is unfortunately not viable. By doing so we can\u2019t implement our safety property of mutual exclusion, because Redis replication is asynchronous.</p> <p>There is a race condition with this model:</p> <ol> <li>Client A acquires the lock in the master.</li> <li>The master crashes before the write to the key is transmitted to the replica.</li> <li>The replica gets promoted to master.</li> <li>Client B acquires the lock to the same resource A already holds a lock for. SAFETY VIOLATION!</li> </ol> <p>Sometimes it is perfectly fine that, under special circumstances, for example during a failure, multiple clients can hold the lock at the same time. If this is the case, you can use your replication based solution. Otherwise we suggest to implement the solution described in this document.</p>"},{"location":"6-manual/patterns/distributed-locks/#correct-implementation-with-a-single-instance","title":"Correct Implementation with a Single Instance","text":"<p>Before trying to overcome the limitation of the single instance setup described above, let\u2019s check how to do it correctly in this simple case, since this is actually a viable solution in applications where a race condition from time to time is acceptable, and because locking into a single instance is the foundation we\u2019ll use for the distributed algorithm described here.</p> <p>To acquire the lock, the way to go is the following:</p> <pre><code>    SET resource_name my_random_value NX PX 30000\n</code></pre> <p>The command will set the key only if it does not already exist (<code>NX</code> option), with an expire of 30000 milliseconds (<code>PX</code> option). The key is set to a value \u201cmy_random_value\u201d. This value must be unique across all clients and all lock requests.</p> <p>Basically the random value is used in order to release the lock in a safe way, with a script that tells Redis: remove the key only if it exists and the value stored at the key is exactly the one I expect to be. This is accomplished by the following Lua script:</p> <pre><code>if redis.call(\"get\",KEYS[1]) == ARGV[1] then\n    return redis.call(\"del\",KEYS[1])\nelse\n    return 0\nend\n</code></pre> <p>This is important in order to avoid removing a lock that was created by another client. For example a client may acquire the lock, get blocked performing some operation for longer than the lock validity time (the time at which the key will expire), and later remove the lock, that was already acquired by some other client. Using just <code>DEL</code> is not safe as a client may remove another client's lock. With the above script instead every lock is \u201csigned\u201d with a random string, so the lock will be removed only if it is still the one that was set by the client trying to remove it.</p> <p>What should this random string be? We assume it\u2019s 20 bytes from <code>/dev/urandom</code>, but you can find cheaper ways to make it unique enough for your tasks. For example a safe pick is to seed RC4 with <code>/dev/urandom</code>, and generate a pseudo random stream from that. A simpler solution is to use a UNIX timestamp with microsecond precision, concatenating the timestamp with a client ID. It is not as safe, but probably sufficient for most environments.</p> <p>The \"lock validity time\" is the time we use as the key's time to live. It is both the auto release time, and the time the client has in order to perform the operation required before another client may be able to acquire the lock again, without technically violating the mutual exclusion guarantee, which is only limited to a given window of time from the moment the lock is acquired.</p> <p>So now we have a good way to acquire and release the lock. With this system, reasoning about a non-distributed system composed of a single, always available, instance, is safe. Let\u2019s extend the concept to a distributed system where we don\u2019t have such guarantees.</p>"},{"location":"6-manual/patterns/distributed-locks/#the-redlock-algorithm","title":"The Redlock Algorithm","text":"<p>In the distributed version of the algorithm we assume we have N Redis masters. Those nodes are totally independent, so we don\u2019t use replication or any other implicit coordination system. We already described how to acquire and release the lock safely in a single instance. We take for granted that the algorithm will use this method to acquire and release the lock in a single instance. In our examples we set N=5, which is a reasonable value, so we need to run 5 Redis masters on different computers or virtual machines in order to ensure that they\u2019ll fail in a mostly independent way.</p> <p>In order to acquire the lock, the client performs the following operations:</p> <ol> <li>It gets the current time in milliseconds.</li> <li>It tries to acquire the lock in all the N instances sequentially, using the same key name and random value in all the instances. During step 2, when setting the lock in each instance, the client uses a timeout which is small compared to the total lock auto-release time in order to acquire it. For example if the auto-release time is 10 seconds, the timeout could be in the ~ 5-50 milliseconds range. This prevents the client from remaining blocked for a long time trying to talk with a Redis node which is down: if an instance is not available, we should try to talk with the next instance ASAP.</li> <li>The client computes how much time elapsed in order to acquire the lock, by subtracting from the current time the timestamp obtained in step 1. If and only if the client was able to acquire the lock in the majority of the instances (at least 3), and the total time elapsed to acquire the lock is less than lock validity time, the lock is considered to be acquired.</li> <li>If the lock was acquired, its validity time is considered to be the initial validity time minus the time elapsed, as computed in step 3.</li> <li>If the client failed to acquire the lock for some reason (either it was not able to lock N/2+1 instances or the validity time is negative), it will try to unlock all the instances (even the instances it believed it was not able to lock).</li> </ol>"},{"location":"6-manual/patterns/distributed-locks/#is-the-algorithm-asynchronous","title":"Is the Algorithm Asynchronous?","text":"<p>The algorithm relies on the assumption that while there is no synchronized clock across the processes, the local time in every process updates at approximately at the same rate, with a small margin of error compared to the auto-release time of the lock. This assumption closely resembles a real-world computer: every computer has a local clock and we can usually rely on different computers to have a clock drift which is small.</p> <p>At this point we need to better specify our mutual exclusion rule: it is guaranteed only as long as the client holding the lock terminates its work within the lock validity time (as obtained in step 3), minus some time (just a few milliseconds in order to compensate for clock drift between processes).</p> <p>This paper contains more information about similar systems requiring a bound clock drift: Leases: an efficient fault-tolerant mechanism for distributed file cache consistency.</p>"},{"location":"6-manual/patterns/distributed-locks/#retry-on-failure","title":"Retry on Failure","text":"<p>When a client is unable to acquire the lock, it should try again after a random delay in order to try to desynchronize multiple clients trying to acquire the lock for the same resource at the same time (this may result in a split brain condition where nobody wins). Also the faster a client tries to acquire the lock in the majority of Redis instances, the smaller the window for a split brain condition (and the need for a retry), so ideally the client should try to send the <code>SET</code> commands to the N instances at the same time using multiplexing.</p> <p>It is worth stressing how important it is for clients that fail to acquire the majority of locks, to release the (partially) acquired locks ASAP, so that there is no need to wait for key expiry in order for the lock to be acquired again (however if a network partition happens and the client is no longer able to communicate with the Redis instances, there is an availability penalty to pay as it waits for key expiration).</p>"},{"location":"6-manual/patterns/distributed-locks/#releasing-the-lock","title":"Releasing the Lock","text":"<p>Releasing the lock is simple, and can be performed whether or not the client believes it was able to successfully lock a given instance.</p>"},{"location":"6-manual/patterns/distributed-locks/#safety-arguments","title":"Safety Arguments","text":"<p>Is the algorithm safe? Let's examine what happens in different scenarios.</p> <p>To start let\u2019s assume that a client is able to acquire the lock in the majority of instances. All the instances will contain a key with the same time to live. However, the key was set at different times, so the keys will also expire at different times. But if the first key was set at worst at time T1 (the time we sample before contacting the first server) and the last key was set at worst at time T2 (the time we obtained the reply from the last server), we are sure that the first key to expire in the set will exist for at least <code>MIN_VALIDITY=TTL-(T2-T1)-CLOCK_DRIFT</code>. All the other keys will expire later, so we are sure that the keys will be simultaneously set for at least this time.</p> <p>During the time that the majority of keys are set, another client will not be able to acquire the lock, since N/2+1 SET NX operations can\u2019t succeed if N/2+1 keys already exist. So if a lock was acquired, it is not possible to re-acquire it at the same time (violating the mutual exclusion property).</p> <p>However we want to also make sure that multiple clients trying to acquire the lock at the same time can\u2019t simultaneously succeed.</p> <p>If a client locked the majority of instances using a time near, or greater, than the lock maximum validity time (the TTL we use for SET basically), it will consider the lock invalid and will unlock the instances, so we only need to consider the case where a client was able to lock the majority of instances in a time which is less than the validity time. In this case for the argument already expressed above, for <code>MIN_VALIDITY</code> no client should be able to re-acquire the lock. So multiple clients will be able to lock N/2+1 instances at the same time (with \"time\" being the end of Step 2) only when the time to lock the majority was greater than the TTL time, making the lock invalid.</p>"},{"location":"6-manual/patterns/distributed-locks/#liveness-arguments","title":"Liveness Arguments","text":"<p>The system liveness is based on three main features:</p> <ol> <li>The auto release of the lock (since keys expire): eventually keys are available again to be locked.</li> <li>The fact that clients, usually, will cooperate removing the locks when the lock was not acquired, or when the lock was acquired and the work terminated, making it likely that we don\u2019t have to wait for keys to expire to re-acquire the lock.</li> <li>The fact that when a client needs to retry a lock, it waits a time which is comparably greater than the time needed to acquire the majority of locks, in order to probabilistically make split brain conditions during resource contention unlikely.</li> </ol> <p>However, we pay an availability penalty equal to <code>TTL</code> time on network partitions, so if there are continuous partitions, we can pay this penalty indefinitely. This happens every time a client acquires a lock and gets partitioned away before being able to remove the lock.</p> <p>Basically if there are infinite continuous network partitions, the system may become not available for an infinite amount of time.</p>"},{"location":"6-manual/patterns/distributed-locks/#performance-crash-recovery-and-fsync","title":"Performance, Crash Recovery and fsync","text":"<p>Many users using Redis as a lock server need high performance in terms of both latency to acquire and release a lock, and number of acquire / release operations that it is possible to perform per second. In order to meet this requirement, the strategy to talk with the N Redis servers to reduce latency is definitely multiplexing (putting the socket in non-blocking mode, send all the commands, and read all the commands later, assuming that the RTT between the client and each instance is similar).</p> <p>However there is another consideration around persistence if we want to target a crash-recovery system model.</p> <p>Basically to see the problem here, let\u2019s assume we configure Redis without persistence at all. A client acquires the lock in 3 of 5 instances. One of the instances where the client was able to acquire the lock is restarted, at this point there are again 3 instances that we can lock for the same resource, and another client can lock it again, violating the safety property of exclusivity of lock.</p> <p>If we enable AOF persistence, things will improve quite a bit. For example we can upgrade a server by sending it a <code>SHUTDOWN</code> command and restarting it. Because Redis expires are semantically implemented so that time still elapses when the server is off, all our requirements are fine. However everything is fine as long as it is a clean shutdown. What about a power outage? If Redis is configured, as by default, to fsync on disk every second, it is possible that after a restart our key is missing. In theory, if we want to guarantee the lock safety in the face of any kind of instance restart, we need to enable <code>fsync=always</code> in the persistence settings. This will affect performance due to the additional sync overhead.</p> <p>However things are better than they look like at a first glance. Basically, the algorithm safety is retained as long as when an instance restarts after a crash, it no longer participates to any currently active lock.  This means that the set of currently active locks when the instance restarts were all obtained by locking instances other than the one which is rejoining the system.</p> <p>To guarantee this we just need to make an instance, after a crash, unavailable for at least a bit more than the max <code>TTL</code> we use.  This is the time needed for all the keys about the locks that existed when the instance crashed to become invalid and be automatically released.</p> <p>Using delayed restarts it is basically possible to achieve safety even without any kind of Redis persistence available, however note that this may translate into an availability penalty. For example if a majority of instances crash, the system will become globally unavailable for <code>TTL</code> (here globally means that no resource at all will be lockable during this time).</p>"},{"location":"6-manual/patterns/distributed-locks/#making-the-algorithm-more-reliable-extending-the-lock","title":"Making the algorithm more reliable: Extending the lock","text":"<p>If the work performed by clients consists of small steps, it is possible to use smaller lock validity times by default, and extend the algorithm implementing a lock extension mechanism. Basically the client, if in the middle of the computation while the lock validity is approaching a low value, may extend the lock by sending a Lua script to all the instances that extends the TTL of the key if the key exists and its value is still the random value the client assigned when the lock was acquired.</p> <p>The client should only consider the lock re-acquired if it was able to extend the lock into the majority of instances, and within the validity time (basically the algorithm to use is very similar to the one used when acquiring the lock).</p> <p>However this does not technically change the algorithm, so the maximum number of lock reacquisition attempts should be limited, otherwise one of the liveness properties is violated.</p>"},{"location":"6-manual/patterns/distributed-locks/#disclaimer-about-consistency","title":"Disclaimer about consistency","text":"<p>Please consider thoroughly reviewing the Analysis of Redlock section at the end of this page. Martin Kleppman's article and antirez's answer to it are very relevant. If you are concerned about consistency and correctness, you should pay attention to the following topics:</p> <ol> <li>You should implement fencing tokens.   This is especially important for processes that can take significant time and applies to any distributed locking system.   Extending locks' lifetime is also an option, but don\u00b4t assume that a lock is retained as long as the process that had acquired it is alive.</li> <li>Redis is not using monotonic clock for TTL expiration mechanism.   That means that a wall-clock shift may result in a lock being acquired by more than one process.   Even though the problem can be mitigated by preventing admins from manually setting the server's time and setting up NTP properly, there's still a chance of this issue occurring in real life and compromising consistency.</li> </ol>"},{"location":"6-manual/patterns/distributed-locks/#want-to-help","title":"Want to help?","text":"<p>If you are into distributed systems, it would be great to have your opinion / analysis. Also reference implementations in other languages could be great.</p> <p>Thanks in advance!</p>"},{"location":"6-manual/patterns/distributed-locks/#analysis-of-redlock","title":"Analysis of Redlock","text":"<ol> <li>Martin Kleppmann analyzed Redlock here. A counterpoint to this analysis can be found here.</li> </ol>"},{"location":"6-manual/patterns/twitter-clone/","title":"Redis patterns example","text":"<p>This article describes the design and implementation of a very simple Twitter clone written using PHP with Redis as the only database. The programming community has traditionally considered key-value stores as a special purpose database that couldn't be used as a drop-in replacement for a relational database for the development of web applications. This article will try to show that Redis data structures on top of a key-value layer are an effective data model to implement many kinds of applications.</p> <p>Note: the original version of this article was written in 2009 when Redis was released. It was not exactly clear at that time that the Redis data model was suitable to write entire applications. Now after 5 years there are many cases of applications using Redis as their main store, so the goal of the article today is to be a tutorial for Redis newcomers. You'll learn how to design a simple data layout using Redis, and how to apply different data structures.</p> <p>Our Twitter clone, called Retwis, is structurally simple, has very good performance, and can be distributed among any number of web and Redis servers with little efforts. View the Retwis source code.</p> <p>I used PHP for the example because of its universal readability. The same (or better) results can be obtained using Ruby, Python, Erlang, and so on. A few clones exist (however not all the clones use the same data layout as the current version of this tutorial, so please, stick with the official PHP implementation for the sake of following the article better).</p> <ul> <li>Retwis-RB is a port of Retwis to Ruby and Sinatra written by Daniel Lucraft.</li> <li>Retwis-J is a port of Retwis to Java, using the Spring Data Framework, written by Costin Leau. Its source code can be found on GitHub, and there is comprehensive documentation available at springsource.org.</li> </ul>"},{"location":"6-manual/patterns/twitter-clone/#what-is-a-key-value-store","title":"What is a key-value store?","text":"<p>The essence of a key-value store is the ability to store some data, called a value, inside a key. The value can be retrieved later only if we know the specific key it was stored in. There is no direct way to search for a key by value. In some sense, it is like a very large hash/dictionary, but it is persistent, i.e. when your application ends, the data doesn't go away. So, for example, I can use the command <code>SET</code> to store the value bar in the key foo:</p> <pre><code>SET foo bar\n</code></pre> <p>Redis stores data permanently, so if I later ask \"What is the value stored in key foo?\" Redis will reply with bar:</p> <pre><code>GET foo =&gt; bar\n</code></pre> <p>Other common operations provided by key-value stores are <code>DEL</code>, to delete a given key and its associated value, SET-if-not-exists (called <code>SETNX</code> on Redis), to assign a value to a key only if the key does not already exist, and <code>INCR</code>, to atomically increment a number stored in a given key:</p> <pre><code>SET foo 10\nINCR foo =&gt; 11\nINCR foo =&gt; 12\nINCR foo =&gt; 13\n</code></pre>"},{"location":"6-manual/patterns/twitter-clone/#atomic-operations","title":"Atomic operations","text":"<p>There is something special about <code>INCR</code>. You may wonder why Redis provides such an operation if we can do it ourselves with a bit of code? After all, it is as simple as:</p> <pre><code>x = GET foo\nx = x + 1\nSET foo x\n</code></pre> <p>The problem is that incrementing this way will work as long as there is only one client working with the key foo at one time. See what happens if two clients are accessing this key at the same time:</p> <pre><code>x = GET foo (yields 10)\ny = GET foo (yields 10)\nx = x + 1 (x is now 11)\ny = y + 1 (y is now 11)\nSET foo x (foo is now 11)\nSET foo y (foo is now 11)\n</code></pre> <p>Something is wrong! We incremented the value two times, but instead of going from 10 to 12, our key holds 11. This is because the increment done with <code>GET / increment / SET</code> is not an atomic operation. Instead the INCR provided by Redis, Memcached, ..., are atomic implementations, and the server will take care of protecting the key during the time needed to complete the increment in order to prevent simultaneous accesses.</p> <p>What makes Redis different from other key-value stores is that it provides other operations similar to INCR that can be used to model complex problems. This is why you can use Redis to write whole web applications without using another database like an SQL database, and without going crazy.</p>"},{"location":"6-manual/patterns/twitter-clone/#beyond-key-value-stores-lists","title":"Beyond key-value stores: lists","text":"<p>In this section we will see which Redis features we need to build our Twitter clone. The first thing to know is that Redis values can be more than strings. Redis supports Lists, Sets, Hashes, Sorted Sets, Bitmaps, and HyperLogLog types as values, and there are atomic operations to operate on them so we are safe even with multiple accesses to the same key. Let's start with Lists:</p> <pre><code>LPUSH mylist a (now mylist holds 'a')\nLPUSH mylist b (now mylist holds 'b','a')\nLPUSH mylist c (now mylist holds 'c','b','a')\n</code></pre> <p><code>LPUSH</code> means Left Push, that is, add an element to the left (or to the head) of the list stored in mylist. If the key mylist does not exist it is automatically created as an empty list before the PUSH operation. As you can imagine, there is also an <code>RPUSH</code> operation that adds the element to the right of the list (on the tail). This is very useful for our Twitter clone. User updates can be added to a list stored in <code>username:updates</code>, for instance.</p> <p>There are operations to get data from Lists, of course. For instance, LRANGE returns a range from the list, or the whole list.</p> <pre><code>LRANGE mylist 0 1 =&gt; c,b\n</code></pre> <p>LRANGE uses zero-based indexes - that is the first element is 0, the second 1, and so on. The command arguments are <code>LRANGE key first-index last-index</code>. The last-index argument can be negative, with a special meaning: -1 is the last element of the list, -2 the penultimate, and so on. So, to get the whole list use:</p> <pre><code>LRANGE mylist 0 -1 =&gt; c,b,a\n</code></pre> <p>Other important operations are LLEN that returns the number of elements in the list, and LTRIM that is like LRANGE but instead of returning the specified range trims the list, so it is like Get range from mylist, Set this range as new value but does so atomically.</p>"},{"location":"6-manual/patterns/twitter-clone/#the-set-data-type","title":"The Set data type","text":"<p>Currently we don't use the Set type in this tutorial, but since we use Sorted Sets, which are kind of a more capable version of Sets, it is better to start introducing Sets first (which are a very useful data structure per se), and later Sorted Sets.</p> <p>There are more data types than just Lists. Redis also supports Sets, which are unsorted collections of elements. It is possible to add, remove, and test for existence of members, and perform the intersection between different Sets. Of course it is possible to get the elements of a Set. Some examples will make it more clear. Keep in mind that <code>SADD</code> is the add to set operation, <code>SREM</code> is the remove from set operation, <code>SISMEMBER</code> is the test if member operation, and <code>SINTER</code> is the perform intersection operation. Other operations are <code>SCARD</code> to get the cardinality (the number of elements) of a Set, and <code>SMEMBERS</code> to return all the members of a Set.</p> <pre><code>SADD myset a\nSADD myset b\nSADD myset foo\nSADD myset bar\nSCARD myset =&gt; 4\nSMEMBERS myset =&gt; bar,a,foo,b\n</code></pre> <p>Note that <code>SMEMBERS</code> does not return the elements in the same order we added them since Sets are unsorted collections of elements. When you want to store in order it is better to use Lists instead. Some more operations against Sets:</p> <pre><code>SADD mynewset b\nSADD mynewset foo\nSADD mynewset hello\nSINTER myset mynewset =&gt; foo,b\n</code></pre> <p><code>SINTER</code> can return the intersection between Sets but it is not limited to two Sets. You may ask for the intersection of 4,5, or 10000 Sets. Finally let's check how <code>SISMEMBER</code> works:</p> <pre><code>SISMEMBER myset foo =&gt; 1\nSISMEMBER myset notamember =&gt; 0\n</code></pre>"},{"location":"6-manual/patterns/twitter-clone/#the-sorted-set-data-type","title":"The Sorted Set data type","text":"<p>Sorted Sets are similar to Sets: collection of elements. However in Sorted Sets each element is associated with a floating point value, called the element score. Because of the score, elements inside a Sorted Set are ordered, since we can always compare two elements by score (and if the score happens to be the same, we compare the two elements as strings).</p> <p>Like Sets in Sorted Sets it is not possible to add repeated elements, every element is unique. However it is possible to update an element's score.</p> <p>Sorted Set commands are prefixed with <code>Z</code>. The following is an example of Sorted Sets usage:</p> <pre><code>ZADD zset 10 a\nZADD zset 5 b\nZADD zset 12.55 c\nZRANGE zset 0 -1 =&gt; b,a,c\n</code></pre> <p>In the above example we added a few elements with <code>ZADD</code>, and later retrieved the elements with <code>ZRANGE</code>. As you can see the elements are returned in order according to their score. In order to check if a given element exists, and also to retrieve its score if it exists, we use the <code>ZSCORE</code> command:</p> <pre><code>ZSCORE zset a =&gt; 10\nZSCORE zset non_existing_element =&gt; NULL\n</code></pre> <p>Sorted Sets are a very powerful data structure, you can query elements by score range, lexicographically, in reverse order, and so forth. To know more please check the Sorted Set sections in the official Redis commands documentation.</p>"},{"location":"6-manual/patterns/twitter-clone/#the-hash-data-type","title":"The Hash data type","text":"<p>This is the last data structure we use in our program, and is extremely easy to grasp since there is an equivalent in almost every programming language out there: Hashes. Redis Hashes are basically like Ruby or Python hashes, a collection of fields associated with values:</p> <pre><code>HMSET myuser name Salvatore surname Sanfilippo country Italy\nHGET myuser surname =&gt; Sanfilippo\n</code></pre> <p><code>HMSET</code> can be used to set fields in the hash, that can be retrieved with <code>HGET</code> later. It is possible to check if a field exists with <code>HEXISTS</code>, or to increment a hash field with <code>HINCRBY</code> and so forth.</p> <p>Hashes are the ideal data structure to represent objects. For example we use Hashes in order to represent Users and Updates in our Twitter clone.</p> <p>Okay, we just exposed the basics of the Redis main data structures, we are ready to start coding!</p>"},{"location":"6-manual/patterns/twitter-clone/#prerequisites","title":"Prerequisites","text":"<p>If you haven't downloaded the Retwis source code already please grab it now. It contains a few PHP files, and also a copy of Predis, the PHP client library we use in this example.</p> <p>Another thing you probably want is a working Redis server. Just get the source, build with <code>make</code>, run with <code>./redis-server</code>, and you're ready to go. No configuration is required at all in order to play with or run Retwis on your computer.</p>"},{"location":"6-manual/patterns/twitter-clone/#data-layout","title":"Data layout","text":"<p>When working with a relational database, a database schema must be designed so that we'd know the tables, indexes, and so on that the database will contain. We don't have tables in Redis, so what do we need to design? We need to identify what keys are needed to represent our objects and what kind of values these keys need to hold.</p> <p>Let's start with Users. We need to represent users, of course, with their username, userid, password, the set of users following a given user, the set of users a given user follows, and so on. The first question is, how should we identify a user? Like in a relational DB, a good solution is to identify different users with different numbers, so we can associate a unique ID with every user. Every other reference to this user will be done by id. Creating unique IDs is very simple to do by using our atomic <code>INCR</code> operation. When we create a new user we can do something like this, assuming the user is called \"antirez\":</p> <pre><code>INCR next_user_id =&gt; 1000\nHMSET user:1000 username antirez password p1pp0\n</code></pre> <p>Note: you should use a hashed password in a real application, for simplicity we store the password in clear text.</p> <p>We use the <code>next_user_id</code> key in order to always get a unique ID for every new user. Then we use this unique ID to name the key holding a Hash with user's data. This is a common design pattern with key-values stores! Keep it in mind. Besides the fields already defined, we need some more stuff in order to fully define a User. For example, sometimes it can be useful to be able to get the user ID from the username, so every time we add a user, we also populate the <code>users</code> key, which is a Hash, with the username as field, and its ID as value.</p> <pre><code>HSET users antirez 1000\n</code></pre> <p>This may appear strange at first, but remember that we are only able to access data in a direct way, without secondary indexes. It's not possible to tell Redis to return the key that holds a specific value. This is also our strength. This new paradigm is forcing us to organize data so that everything is accessible by primary key, speaking in relational DB terms.</p>"},{"location":"6-manual/patterns/twitter-clone/#followers-following-and-updates","title":"Followers, following, and updates","text":"<p>There is another central need in our system. A user might have users who follow them, which we'll call their followers. A user might follow other users, which we'll call a following. We have a perfect data structure for this. That is... Sets. The uniqueness of Sets elements, and the fact we can test in constant time for existence, are two interesting features. However what about also remembering the time at which a given user started following another one? In an enhanced version of our simple Twitter clone this may be useful, so instead of using a simple Set, we use a Sorted Set, using the user ID of the following or follower user as element, and the unix time at which the relation between the users was created, as our score.</p> <p>So let's define our keys:</p> <pre><code>followers:1000 =&gt; Sorted Set of uids of all the followers users\nfollowing:1000 =&gt; Sorted Set of uids of all the following users\n</code></pre> <p>We can add new followers with:</p> <pre><code>ZADD followers:1000 1401267618 1234 =&gt; Add user 1234 with time 1401267618\n</code></pre> <p>Another important thing we need is a place where we can add the updates to display in the user's home page. We'll need to access this data in chronological order later, from the most recent update to the oldest, so the perfect kind of data structure for this is a List. Basically every new update will be <code>LPUSH</code>ed in the user updates key, and thanks to <code>LRANGE</code>, we can implement pagination and so on. Note that we use the words updates and posts interchangeably, since updates are actually \"little posts\" in some way.</p> <pre><code>posts:1000 =&gt; a List of post ids - every new post is LPUSHed here.\n</code></pre> <p>This list is basically the User timeline. We'll push the IDs of her/his own posts, and, the IDs of all the posts of created by the following users. Basically, we'll implement a write fanout.</p>"},{"location":"6-manual/patterns/twitter-clone/#authentication","title":"Authentication","text":"<p>OK, we have more or less everything about the user except for authentication. We'll handle authentication in a simple but robust way: we don't want to use PHP sessions, as our system must be ready to be distributed among different web servers easily, so we'll keep the whole state in our Redis database. All we need is a random unguessable string to set as the cookie of an authenticated user, and a key that will contain the user ID of the client holding the string.</p> <p>We need two things in order to make this thing work in a robust way. First: the current authentication secret (the random unguessable string) should be part of the User object, so when the user is created we also set an <code>auth</code> field in its Hash:</p> <pre><code>HSET user:1000 auth fea5e81ac8ca77622bed1c2132a021f9\n</code></pre> <p>Moreover, we need a way to map authentication secrets to user IDs, so we also take an <code>auths</code> key, which has as value a Hash type mapping authentication secrets to user IDs.</p> <pre><code>HSET auths fea5e81ac8ca77622bed1c2132a021f9 1000\n</code></pre> <p>In order to authenticate a user we'll do these simple steps (see the <code>login.php</code> file in the Retwis source code):</p> <ul> <li>Get the username and password via the login form.</li> <li>Check if the <code>username</code> field actually exists in the <code>users</code> Hash.</li> <li>If it exists we have the user id, (i.e. 1000).</li> <li>Check if user:1000 password matches, if not, return an error message.</li> <li>Ok authenticated! Set \"fea5e81ac8ca77622bed1c2132a021f9\" (the value of user:1000 <code>auth</code> field) as the \"auth\" cookie.</li> </ul> <p>This is the actual code:</p> <pre><code>include(\"retwis.php\");\n\n# Form sanity checks\nif (!gt(\"username\") || !gt(\"password\"))\n    goback(\"You need to enter both username and password to login.\");\n\n# The form is ok, check if the username is available\n$username = gt(\"username\");\n$password = gt(\"password\");\n$r = redisLink();\n$userid = $r-&gt;hget(\"users\",$username);\nif (!$userid)\n    goback(\"Wrong username or password\");\n$realpassword = $r-&gt;hget(\"user:$userid\",\"password\");\nif ($realpassword != $password)\n    goback(\"Wrong username or password\");\n\n# Username / password OK, set the cookie and redirect to index.php\n$authsecret = $r-&gt;hget(\"user:$userid\",\"auth\");\nsetcookie(\"auth\",$authsecret,time()+3600*24*365);\nheader(\"Location: index.php\");\n</code></pre> <p>This happens every time a user logs in, but we also need a function <code>isLoggedIn</code> in order to check if a given user is already authenticated or not. These are the logical steps preformed by the <code>isLoggedIn</code> function:</p> <ul> <li>Get the \"auth\" cookie from the user. If there is no cookie, the user is not logged in, of course. Let's call the value of the cookie <code>&lt;authcookie&gt;</code>.</li> <li>Check if <code>&lt;authcookie&gt;</code> field in the <code>auths</code> Hash exists, and what the value (the user ID) is (1000 in the example).</li> <li>In order for the system to be more robust, also verify that user:1000 auth field also matches.</li> <li>OK the user is authenticated, and we loaded a bit of information in the <code>$User</code> global variable.</li> </ul> <p>The code is simpler than the description, possibly:</p> <pre><code>function isLoggedIn() {\n    global $User, $_COOKIE;\n\n    if (isset($User)) return true;\n\n    if (isset($_COOKIE['auth'])) {\n        $r = redisLink();\n        $authcookie = $_COOKIE['auth'];\n        if ($userid = $r-&gt;hget(\"auths\",$authcookie)) {\n            if ($r-&gt;hget(\"user:$userid\",\"auth\") != $authcookie) return false;\n            loadUserInfo($userid);\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction loadUserInfo($userid) {\n    global $User;\n\n    $r = redisLink();\n    $User['id'] = $userid;\n    $User['username'] = $r-&gt;hget(\"user:$userid\",\"username\");\n    return true;\n}\n</code></pre> <p>Having <code>loadUserInfo</code> as a separate function is overkill for our application, but it's a good approach in a complex application. The only thing that's missing from all the authentication is the logout. What do we do on logout? That's simple, we'll just change the random string in user:1000 <code>auth</code> field, remove the old authentication secret from the <code>auths</code> Hash, and add the new one.</p> <p>Important: the logout procedure explains why we don't just authenticate the user after looking up the authentication secret in the <code>auths</code> Hash, but double check it against user:1000 <code>auth</code> field. The true authentication string is the latter, while the <code>auths</code> Hash is just an authentication field that may even be volatile, or, if there are bugs in the program or a script gets interrupted, we may even end with multiple entries in the <code>auths</code> key pointing to the same user ID. The logout code is the following (<code>logout.php</code>):</p> <pre><code>include(\"retwis.php\");\n\nif (!isLoggedIn()) {\n    header(\"Location: index.php\");\n    exit;\n}\n\n$r = redisLink();\n$newauthsecret = getrand();\n$userid = $User['id'];\n$oldauthsecret = $r-&gt;hget(\"user:$userid\",\"auth\");\n\n$r-&gt;hset(\"user:$userid\",\"auth\",$newauthsecret);\n$r-&gt;hset(\"auths\",$newauthsecret,$userid);\n$r-&gt;hdel(\"auths\",$oldauthsecret);\n\nheader(\"Location: index.php\");\n</code></pre> <p>That is just what we described and should be simple to understand.</p>"},{"location":"6-manual/patterns/twitter-clone/#updates","title":"Updates","text":"<p>Updates, also known as posts, are even simpler. In order to create a new post in the database we do something like this:</p> <pre><code>INCR next_post_id =&gt; 10343\nHMSET post:10343 user_id $owner_id time $time body \"I'm having fun with Retwis\"\n</code></pre> <p>As you can see each post is just represented by a Hash with three fields. The ID of the user owning the post, the time at which the post was published, and finally, the body of the post, which is, the actual status message.</p> <p>After we create a post and we obtain the post ID, we need to LPUSH the ID in the timeline of every user that is following the author of the post, and of course in the list of posts of the author itself (everybody is virtually following herself/himself). This is the file <code>post.php</code> that shows how this is performed:</p> <pre><code>include(\"retwis.php\");\n\nif (!isLoggedIn() || !gt(\"status\")) {\n    header(\"Location:index.php\");\n    exit;\n}\n\n$r = redisLink();\n$postid = $r-&gt;incr(\"next_post_id\");\n$status = str_replace(\"\\n\",\" \",gt(\"status\"));\n$r-&gt;hmset(\"post:$postid\",\"user_id\",$User['id'],\"time\",time(),\"body\",$status);\n$followers = $r-&gt;zrange(\"followers:\".$User['id'],0,-1);\n$followers[] = $User['id']; /* Add the post to our own posts too */\n\nforeach($followers as $fid) {\n    $r-&gt;lpush(\"posts:$fid\",$postid);\n}\n# Push the post on the timeline, and trim the timeline to the\n# newest 1000 elements.\n$r-&gt;lpush(\"timeline\",$postid);\n$r-&gt;ltrim(\"timeline\",0,1000);\n\nheader(\"Location: index.php\");\n</code></pre> <p>The core of the function is the <code>foreach</code> loop. We use <code>ZRANGE</code> to get all the followers of the current user, then the loop will <code>LPUSH</code> the push the post in every follower timeline List.</p> <p>Note that we also maintain a global timeline for all the posts, so that in the Retwis home page we can show everybody's updates easily. This requires just doing an <code>LPUSH</code> to the <code>timeline</code> List. Let's face it, aren't you starting to think it was a bit strange to have to sort things added in chronological order using <code>ORDER BY</code> with SQL? I think so.</p> <p>There is an interesting thing to notice in the code above: we used a new command called <code>LTRIM</code> after we perform the <code>LPUSH</code> operation in the global timeline. This is used in order to trim the list to just 1000 elements. The global timeline is actually only used in order to show a few posts in the home page, there is no need to have the full history of all the posts.</p> <p>Basically <code>LTRIM</code> + <code>LPUSH</code> is a way to create a capped collection in Redis.</p>"},{"location":"6-manual/patterns/twitter-clone/#paginating-updates","title":"Paginating updates","text":"<p>Now it should be pretty clear how we can use <code>LRANGE</code> in order to get ranges of posts, and render these posts on the screen. The code is simple:</p> <pre><code>function showPost($id) {\n    $r = redisLink();\n    $post = $r-&gt;hgetall(\"post:$id\");\n    if (empty($post)) return false;\n\n    $userid = $post['user_id'];\n    $username = $r-&gt;hget(\"user:$userid\",\"username\");\n    $elapsed = strElapsed($post['time']);\n    $userlink = \"&lt;a class=\\\"username\\\" href=\\\"profile.php?u=\".urlencode($username).\"\\\"&gt;\".utf8entities($username).\"&lt;/a&gt;\";\n\n    echo('&lt;div class=\"post\"&gt;'.$userlink.' '.utf8entities($post['body']).\"&lt;br&gt;\");\n    echo('&lt;i&gt;posted '.$elapsed.' ago via web&lt;/i&gt;&lt;/div&gt;');\n    return true;\n}\n\nfunction showUserPosts($userid,$start,$count) {\n    $r = redisLink();\n    $key = ($userid == -1) ? \"timeline\" : \"posts:$userid\";\n    $posts = $r-&gt;lrange($key,$start,$start+$count);\n    $c = 0;\n    foreach($posts as $p) {\n        if (showPost($p)) $c++;\n        if ($c == $count) break;\n    }\n    return count($posts) == $count+1;\n}\n</code></pre> <p><code>showPost</code> will simply convert and print a Post in HTML while <code>showUserPosts</code> gets a range of posts and then passes them to <code>showPosts</code>.</p> <p>Note: <code>LRANGE</code> is not very efficient if the list of posts start to be very big, and we want to access elements which are in the middle of the list, since Redis Lists are backed by linked lists. If a system is designed for deep pagination of million of items, it is better to resort to Sorted Sets instead.</p>"},{"location":"6-manual/patterns/twitter-clone/#following-users","title":"Following users","text":"<p>It is not hard, but we did not yet check how we create following / follower relationships. If user ID 1000 (antirez) wants to follow user ID 5000 (pippo), we need to create both a following and a follower relationship. We just need to <code>ZADD</code> calls:</p> <pre><code>    ZADD following:1000 5000\n    ZADD followers:5000 1000\n</code></pre> <p>Note the same pattern again and again. In theory with a relational database, the list of following and followers would be contained in a single table with fields like <code>following_id</code> and <code>follower_id</code>. You can extract the followers or following of every user using an SQL query. With a key-value DB things are a bit different since we need to set both the <code>1000 is following 5000</code> and <code>5000 is followed by 1000</code> relations. This is the price to pay, but on the other hand accessing the data is simpler and extremely fast. Having these things as separate sets allows us to do interesting stuff. For example, using <code>ZINTERSTORE</code> we can have the intersection of <code>following</code> of two different users, so we may add a feature to our Twitter clone so that it is able to tell you very quickly when you visit somebody else's profile, \"you and Alice have 34 followers in common\", and things like that.</p> <p>You can find the code that sets or removes a following / follower relation in the <code>follow.php</code> file.</p>"},{"location":"6-manual/patterns/twitter-clone/#making-it-horizontally-scalable","title":"Making it horizontally scalable","text":"<p>Gentle reader, if you read till this point you are already a hero. Thank you. Before talking about scaling horizontally it is worth checking performance on a single server. Retwis is extremely fast, without any kind of cache. On a very slow and loaded server, an Apache benchmark with 100 parallel clients issuing 100000 requests measured the average pageview to take 5 milliseconds. This means you can serve millions of users every day with just a single Linux box, and this one was monkey ass slow... Imagine the results with more recent hardware.</p> <p>However you can't go with a single server forever, how do you scale a key-value store?</p> <p>Retwis does not perform any multi-keys operation, so making it scalable is simple: you may use client-side sharding, or something like a sharding proxy like Twemproxy, or the upcoming Redis Cluster.</p> <p>To know more about those topics please read our documentation about sharding. However, the point here to stress is that in a key-value store, if you design with care, the data set is split among many independent small keys. To distribute those keys to multiple nodes is more straightforward and predictable compared to using a semantically more complex database system.</p>"},{"location":"6-manual/patterns/indexes/","title":"Secondary indexing","text":"<p>Redis is not exactly a key-value store, since values can be complex data structures. However it has an external key-value shell: at API level data is addressed by the key name. It is fair to say that, natively, Redis only offers primary key access. However since Redis is a data structures server, its capabilities can be used for indexing, in order to create secondary indexes of different kinds, including composite (multi-column) indexes.</p> <p>This document explains how it is possible to create indexes in Redis using the following data structures:</p> <ul> <li>Sorted sets to create secondary indexes by ID or other numerical fields.</li> <li>Sorted sets with lexicographical ranges for creating more advanced secondary indexes, composite indexes and graph traversal indexes.</li> <li>Sets for creating random indexes.</li> <li>Lists for creating simple iterable indexes and last N items indexes.</li> </ul> <p>Implementing and maintaining indexes with Redis is an advanced topic, so most users that need to perform complex queries on data should understand if they are better served by a relational store. However often, especially in caching scenarios, there is the explicit need to store indexed data into Redis in order to speedup common queries which require some form of indexing in order to be executed.</p>"},{"location":"6-manual/patterns/indexes/#simple-numerical-indexes-with-sorted-sets","title":"Simple numerical indexes with sorted sets","text":"<p>The simplest secondary index you can create with Redis is by using the sorted set data type, which is a data structure representing a set of elements ordered by a floating point number which is the score of each element. Elements are ordered from the smallest to the highest score.</p> <p>Since the score is a double precision float, indexes you can build with vanilla sorted sets are limited to things where the indexing field is a number within a given range.</p> <p>The two commands to build these kind of indexes are <code>ZADD</code> and <code>ZRANGE</code> with the <code>BYSCORE</code> argument to respectively add items and retrieve items within a specified range.</p> <p>For instance, it is possible to index a set of person names by their age by adding element to a sorted set. The element will be the name of the person and the score will be the age.</p> <pre><code>ZADD myindex 25 Manuel\nZADD myindex 18 Anna\nZADD myindex 35 Jon\nZADD myindex 67 Helen\n</code></pre> <p>In order to retrieve all persons with an age between 20 and 40, the following command can be used:</p> <pre><code>ZRANGE myindex 20 40 BYSCORE\n1) \"Manuel\"\n2) \"Jon\"\n</code></pre> <p>By using the WITHSCORES option of <code>ZRANGE</code> it is also possible to obtain the scores associated with the returned elements.</p> <p>The <code>ZCOUNT</code> command can be used in order to retrieve the number of elements within a given range, without actually fetching the elements, which is also useful, especially given the fact the operation is executed in logarithmic time regardless of the size of the range.</p> <p>Ranges can be inclusive or exclusive, please refer to the <code>ZRANGE</code> command documentation for more information.</p> <p>Note: Using the <code>ZRANGE</code> with the <code>BYSCORE</code> and <code>REV</code> arguments, it is possible to query a range in reversed order, which is often useful when data is indexed in a given direction (ascending or descending) but we want to retrieve information the other way around.</p>"},{"location":"6-manual/patterns/indexes/#using-objects-ids-as-associated-values","title":"Using objects IDs as associated values","text":"<p>In the above example we associated names to ages. However in general we may want to index some field of an object which is stored elsewhere. Instead of using the sorted set value directly to store the data associated with the indexed field, it is possible to store just the ID of the object.</p> <p>For example I may have Redis hashes representing users. Each user is represented by a single key, directly accessible by ID:</p> <pre><code>HMSET user:1 id 1 username antirez ctime 1444809424 age 38\nHMSET user:2 id 2 username maria ctime 1444808132 age 42\nHMSET user:3 id 3 username jballard ctime 1443246218 age 33\n</code></pre> <p>If I want to create an index in order to query users by their age, I could do:</p> <pre><code>ZADD user.age.index 38 1\nZADD user.age.index 42 2\nZADD user.age.index 33 3\n</code></pre> <p>This time the value associated with the score in the sorted set is the ID of the object. So once I query the index with <code>ZRANGE</code> with the <code>BYSCORE</code> argument, I'll also have to retrieve the information I need with <code>HGETALL</code> or similar commands. The obvious advantage is that objects can change without touching the index, as long as we don't change the indexed field.</p> <p>In the next examples we'll almost always use IDs as values associated with the index, since this is usually the more sounding design, with a few exceptions.</p>"},{"location":"6-manual/patterns/indexes/#updating-simple-sorted-set-indexes","title":"Updating simple sorted set indexes","text":"<p>Often we index things which change over time. In the above example, the age of the user changes every year. In such a case it would make sense to use the birth date as index instead of the age itself, but there are other cases where we simply want some field to change from time to time, and the index to reflect this change.</p> <p>The <code>ZADD</code> command makes updating simple indexes a very trivial operation since re-adding back an element with a different score and the same value will simply update the score and move the element at the right position, so if the user <code>antirez</code> turned 39 years old, in order to update the data in the hash representing the user, and in the index as well, we need to execute the following two commands:</p> <pre><code>HSET user:1 age 39\nZADD user.age.index 39 1\n</code></pre> <p>The operation may be wrapped in a <code>MULTI</code>/<code>EXEC</code> transaction in order to make sure both fields are updated or none.</p>"},{"location":"6-manual/patterns/indexes/#turning-multi-dimensional-data-into-linear-data","title":"Turning multi dimensional data into linear data","text":"<p>Indexes created with sorted sets are able to index only a single numerical value. Because of this you may think it is impossible to index something which has multiple dimensions using this kind of indexes, but actually this is not always true. If you can efficiently represent something multi-dimensional in a linear way, they it is often possible to use a simple sorted set for indexing.</p> <p>For example the Redis geo indexing API uses a sorted set to index places by latitude and longitude using a technique called Geo hash. The sorted set score represents alternating bits of longitude and latitude, so that we map the linear score of a sorted set to many small squares in the earth surface. By doing an 8+1 style center plus neighborhoods search it is possible to retrieve elements by radius.</p>"},{"location":"6-manual/patterns/indexes/#limits-of-the-score","title":"Limits of the score","text":"<p>Sorted set elements scores are double precision floats. It means that they can represent different decimal or integer values with different errors, because they use an exponential representation internally. However what is interesting for indexing purposes is that the score is always able to represent without any error numbers between -9007199254740992 and 9007199254740992, which is <code>-/+ 2^53</code>.</p> <p>When representing much larger numbers, you need a different form of indexing that is able to index numbers at any precision, called a lexicographical index.</p>"},{"location":"6-manual/patterns/indexes/#lexicographical-indexes","title":"Lexicographical indexes","text":"<p>Redis sorted sets have an interesting property. When elements are added with the same score, they are sorted lexicographically, comparing the strings as binary data with the <code>memcmp()</code> function.</p> <p>For people that don't know the C language nor the <code>memcmp</code> function, what it means is that elements with the same score are sorted comparing the raw values of their bytes, byte after byte. If the first byte is the same, the second is checked and so forth. If the common prefix of two strings is the same then the longer string is considered the greater of the two, so \"foobar\" is greater than \"foo\".</p> <p>There are commands such as <code>ZRANGE</code> and <code>ZLEXCOUNT</code> that are able to query and count ranges in a lexicographically fashion, assuming they are used with sorted sets where all the elements have the same score.</p> <p>This Redis feature is basically equivalent to a <code>b-tree</code> data structure which is often used in order to implement indexes with traditional databases. As you can guess, because of this, it is possible to use this Redis data structure in order to implement pretty fancy indexes.</p> <p>Before we dive into using lexicographical indexes, let's check how sorted sets behave in this special mode of operation. Since we need to add elements with the same score, we'll always use the special score of zero.</p> <pre><code>ZADD myindex 0 baaa\nZADD myindex 0 abbb\nZADD myindex 0 aaaa\nZADD myindex 0 bbbb\n</code></pre> <p>Fetching all the elements from the sorted set immediately reveals that they are ordered lexicographically.</p> <pre><code>ZRANGE myindex 0 -1\n1) \"aaaa\"\n2) \"abbb\"\n3) \"baaa\"\n4) \"bbbb\"\n</code></pre> <p>Now we can use <code>ZRANGE</code> with the <code>BYLEX</code> argument in order to perform range queries.</p> <pre><code>ZRANGE myindex [a (b BYLEX\n1) \"aaaa\"\n2) \"abbb\"\n</code></pre> <p>Note that in the range queries we prefixed the <code>min</code> and <code>max</code> elements identifying the range with the special characters <code>[</code> and <code>(</code>. This prefixes are mandatory, and they specify if the elements of the range are inclusive or exclusive. So the range <code>[a (b</code> means give me all the elements lexicographically between <code>a</code> inclusive and <code>b</code> exclusive, which are all the elements starting with <code>a</code>.</p> <p>There are also two more special characters indicating the infinitely negative string and the infinitely positive string, which are <code>-</code> and <code>+</code>.</p> <pre><code>ZRANGE myindex [b + BYLEX\n1) \"baaa\"\n2) \"bbbb\"\n</code></pre> <p>That's it basically. Let's see how to use these features to build indexes.</p>"},{"location":"6-manual/patterns/indexes/#a-first-example-completion","title":"A first example: completion","text":"<p>An interesting application of indexing is completion. Completion is what happens when you start typing your query into a search engine: the user interface will anticipate what you are likely typing, providing common queries that start with the same characters.</p> <p>A naive approach to completion is to just add every single query we get from the user into the index. For example if the user searches <code>banana</code> we'll just do:</p> <pre><code>ZADD myindex 0 banana\n</code></pre> <p>And so forth for each search query ever encountered. Then when we want to complete the user input, we execute a range query using <code>ZRANGE</code> with the <code>BYLEX</code> argument. Imagine the user is typing \"bit\" inside the search form, and we want to offer possible search keywords starting for \"bit\". We send Redis a command like that:</p> <pre><code>ZRANGE myindex \"[bit\" \"[bit\\xff\" BYLEX\n</code></pre> <p>Basically we create a range using the string the user is typing right now as start, and the same string plus a trailing byte set to 255, which is <code>\\xff</code> in the example, as the end of the range. This way we get all the strings that start for the string the user is typing.</p> <p>Note that we don't want too many items returned, so we may use the LIMIT option in order to reduce the number of results.</p>"},{"location":"6-manual/patterns/indexes/#adding-frequency-into-the-mix","title":"Adding frequency into the mix","text":"<p>The above approach is a bit naive, because all the user searches are the same in this way. In a real system we want to complete strings according to their frequency: very popular searches will be proposed with a higher probability compared to search strings typed very rarely.</p> <p>In order to implement something which depends on the frequency, and at the same time automatically adapts to future inputs, by purging searches that are no longer popular, we can use a very simple streaming algorithm.</p> <p>To start, we modify our index in order to store not just the search term, but also the frequency the term is associated with. So instead of just adding <code>banana</code> we add <code>banana:1</code>, where 1 is the frequency.</p> <pre><code>ZADD myindex 0 banana:1\n</code></pre> <p>We also need logic in order to increment the index if the search term already exists in the index, so what we'll actually do is something like that:</p> <pre><code>ZRANGE myindex \"[banana:\" + BYLEX LIMIT 0 1\n1) \"banana:1\"\n</code></pre> <p>This will return the single entry of <code>banana</code> if it exists. Then we can increment the associated frequency and send the following two commands:</p> <pre><code>ZREM myindex 0 banana:1\nZADD myindex 0 banana:2\n</code></pre> <p>Note that because it is possible that there are concurrent updates, the above three commands should be send via a Lua script instead, so that the Lua script will atomically get the old count and re-add the item with incremented score.</p> <p>So the result will be that, every time a user searches for <code>banana</code> we'll get our entry updated.</p> <p>There is more: our goal is to just have items searched very frequently. So we need some form of purging. When we actually query the index in order to complete the user input, we may see something like that:</p> <pre><code>ZRANGE myindex \"[banana:\" + BYLEX LIMIT 0 10\n1) \"banana:123\"\n2) \"banaooo:1\"\n3) \"banned user:49\"\n4) \"banning:89\"\n</code></pre> <p>Apparently nobody searches for \"banaooo\", for example, but the query was performed a single time, so we end presenting it to the user.</p> <p>This is what we can do. Out of the returned items, we pick a random one, decrement its score by one, and re-add it with the new score. However if the score reaches 0, we simply remove the item from the list. You can use much more advanced systems, but the idea is that the index in the long run will contain top searches, and if top searches will change over the time it will adapt automatically.</p> <p>A refinement to this algorithm is to pick entries in the list according to their weight: the higher the score, the less likely entries are picked in order to decrement its score, or evict them.</p>"},{"location":"6-manual/patterns/indexes/#normalizing-strings-for-case-and-accents","title":"Normalizing strings for case and accents","text":"<p>In the completion examples we always used lowercase strings. However reality is much more complex than that: languages have capitalized names, accents, and so forth.</p> <p>One simple way do deal with this issues is to actually normalize the string the user searches. Whatever the user searches for \"Banana\", \"BANANA\" or \"Ba'nana\" we may always turn it into \"banana\".</p> <p>However sometimes we may like to present the user with the original item typed, even if we normalize the string for indexing. In order to do this, what we do is to change the format of the index so that instead of just storing <code>term:frequency</code> we store <code>normalized:frequency:original</code> like in the following example:</p> <pre><code>ZADD myindex 0 banana:273:Banana\n</code></pre> <p>Basically we add another field that we'll extract and use only for visualization. Ranges will always be computed using the normalized strings instead. This is a common trick which has multiple applications.</p>"},{"location":"6-manual/patterns/indexes/#adding-auxiliary-information-in-the-index","title":"Adding auxiliary information in the index","text":"<p>When using a sorted set in a direct way, we have two different attributes for each object: the score, which we use as an index, and an associated value. When using lexicographical indexes instead, the score is always set to 0 and basically not used at all. We are left with a single string, which is the element itself.</p> <p>Like we did in the previous completion examples, we are still able to store associated data using separators. For example we used the colon in order to add the frequency and the original word for completion.</p> <p>In general we can add any kind of associated value to our indexing key. In order to use a lexicographical index to implement a simple key-value store we just store the entry as <code>key:value</code>:</p> <pre><code>ZADD myindex 0 mykey:myvalue\n</code></pre> <p>And search for the key with:</p> <pre><code>ZRANGE myindex [mykey: + BYLEX LIMIT 0 1\n1) \"mykey:myvalue\"\n</code></pre> <p>Then we extract the part after the colon to retrieve the value. However a problem to solve in this case is collisions. The colon character may be part of the key itself, so it must be chosen in order to never collide with the key we add.</p> <p>Since lexicographical ranges in Redis are binary safe you can use any byte or any sequence of bytes. However if you receive untrusted user input, it is better to use some form of escaping in order to guarantee that the separator will never happen to be part of the key.</p> <p>For example if you use two null bytes as separator <code>\"\\0\\0\"</code>, you may want to always escape null bytes into two bytes sequences in your strings.</p>"},{"location":"6-manual/patterns/indexes/#numerical-padding","title":"Numerical padding","text":"<p>Lexicographical indexes may look like good only when the problem at hand is to index strings. Actually it is very simple to use this kind of index in order to perform indexing of arbitrary precision numbers.</p> <p>In the ASCII character set, digits appear in the order from 0 to 9, so if we left-pad numbers with leading zeroes, the result is that comparing them as strings will order them by their numerical value.</p> <pre><code>ZADD myindex 0 00324823481:foo\nZADD myindex 0 12838349234:bar\nZADD myindex 0 00000000111:zap\n\nZRANGE myindex 0 -1\n1) \"00000000111:zap\"\n2) \"00324823481:foo\"\n3) \"12838349234:bar\"\n</code></pre> <p>We effectively created an index using a numerical field which can be as big as we want. This also works with floating point numbers of any precision by making sure we left pad the numerical part with leading zeroes and the decimal part with trailing zeroes like in the following list of numbers:</p> <pre><code>    01000000000000.11000000000000\n    01000000000000.02200000000000\n    00000002121241.34893482930000\n    00999999999999.00000000000000\n</code></pre>"},{"location":"6-manual/patterns/indexes/#using-numbers-in-binary-form","title":"Using numbers in binary form","text":"<p>Storing numbers in decimal may use too much memory. An alternative approach is just to store numbers, for example 128 bit integers, directly in their binary form. However for this to work, you need to store the numbers in big endian format, so that the most significant bytes are stored before the least significant bytes. This way when Redis compares the strings with <code>memcmp()</code>, it will effectively sort the numbers by their value.</p> <p>Keep in mind that data stored in binary format is less observable for debugging, harder to parse and export. So it is definitely a trade off.</p>"},{"location":"6-manual/patterns/indexes/#composite-indexes","title":"Composite indexes","text":"<p>So far we explored ways to index single fields. However we all know that SQL stores are able to create indexes using multiple fields. For example I may index products in a very large store by room number and price.</p> <p>I need to run queries in order to retrieve all the products in a given room having a given price range. What I can do is to index each product in the following way:</p> <pre><code>ZADD myindex 0 0056:0028.44:90\nZADD myindex 0 0034:0011.00:832\n</code></pre> <p>Here the fields are <code>room:price:product_id</code>. I used just four digits padding in the example for simplicity. The auxiliary data (the product ID) does not need any padding.</p> <p>With an index like that, to get all the products in room 56 having a price between 10 and 30 dollars is very easy. We can just run the following command:</p> <pre><code>ZRANGE myindex [0056:0010.00 [0056:0030.00 BYLEX\n</code></pre> <p>The above is called a composed index. Its effectiveness depends on the order of the fields and the queries I want to run. For example the above index cannot be used efficiently in order to get all the products having a specific price range regardless of the room number. However I can use the primary key in order to run queries regardless of the price, like give me all the products in room 44.</p> <p>Composite indexes are very powerful, and are used in traditional stores in order to optimize complex queries. In Redis they could be useful both to implement a very fast in-memory Redis index of something stored into a traditional data store, or in order to directly index Redis data.</p>"},{"location":"6-manual/patterns/indexes/#updating-lexicographical-indexes","title":"Updating lexicographical indexes","text":"<p>The value of the index in a lexicographical index can get pretty fancy and hard or slow to rebuild from what we store about the object. So one approach to simplify the handling of the index, at the cost of using more memory, is to also take alongside to the sorted set representing the index a hash mapping the object ID to the current index value.</p> <p>So for example, when we index we also add to a hash:</p> <pre><code>MULTI\nZADD myindex 0 0056:0028.44:90\nHSET index.content 90 0056:0028.44:90\nEXEC\n</code></pre> <p>This is not always needed, but simplifies the operations of updating the index. In order to remove the old information we indexed for the object ID 90, regardless of the current fields values of the object, we just have to retrieve the hash value by object ID and <code>ZREM</code> it in the sorted set view.</p>"},{"location":"6-manual/patterns/indexes/#representing-and-querying-graphs-using-a-hexastore","title":"Representing and querying graphs using a hexastore","text":"<p>One cool thing about composite indexes is that they are handy in order to represent graphs, using a data structure which is called Hexastore.</p> <p>The hexastore provides a representation for relations between objects, formed by a subject, a predicate and an object. A simple relation between objects could be:</p> <pre><code>antirez is-friend-of matteocollina\n</code></pre> <p>In order to represent this relation I can store the following element in my lexicographical index:</p> <pre><code>ZADD myindex 0 spo:antirez:is-friend-of:matteocollina\n</code></pre> <p>Note that I prefixed my item with the string spo. It means that the item represents a subject,predicate,object relation.</p> <p>In can add 5 more entries for the same relation, but in a different order:</p> <pre><code>ZADD myindex 0 sop:antirez:matteocollina:is-friend-of\nZADD myindex 0 ops:matteocollina:is-friend-of:antirez\nZADD myindex 0 osp:matteocollina:antirez:is-friend-of\nZADD myindex 0 pso:is-friend-of:antirez:matteocollina\nZADD myindex 0 pos:is-friend-of:matteocollina:antirez\n</code></pre> <p>Now things start to be interesting, and I can query the graph in many different ways. For example, who are all the people <code>antirez</code> is friend of?</p> <pre><code>ZRANGE myindex \"[spo:antirez:is-friend-of:\" \"[spo:antirez:is-friend-of:\\xff\" BYLEX\n1) \"spo:antirez:is-friend-of:matteocollina\"\n2) \"spo:antirez:is-friend-of:wonderwoman\"\n3) \"spo:antirez:is-friend-of:spiderman\"\n</code></pre> <p>Or, what are all the relationships <code>antirez</code> and <code>matteocollina</code> have where the first is the subject and the second is the object?</p> <pre><code>ZRANGE myindex \"[sop:antirez:matteocollina:\" \"[sop:antirez:matteocollina:\\xff\" BYLEX\n1) \"sop:antirez:matteocollina:is-friend-of\"\n2) \"sop:antirez:matteocollina:was-at-conference-with\"\n3) \"sop:antirez:matteocollina:talked-with\"\n</code></pre> <p>By combining different queries, I can ask fancy questions. For example: Who are all my friends that, like beer, live in Barcelona, and matteocollina consider friends as well? To get this information I start with an <code>spo</code> query to find all the people I'm friend with. Then for each result I get I perform an <code>spo</code> query to check if they like beer, removing the ones for which I can't find this relation. I do it again to filter by city. Finally I perform an <code>ops</code> query to find, of the list I obtained, who is considered friend by matteocollina.</p> <p>Make sure to check Matteo Collina's slides about Levelgraph in order to better understand these ideas.</p>"},{"location":"6-manual/patterns/indexes/#multi-dimensional-indexes","title":"Multi dimensional indexes","text":"<p>A more complex type of index is an index that allows you to perform queries where two or more variables are queried at the same time for specific ranges. For example I may have a data set representing persons age and salary, and I want to retrieve all the people between 50 and 55 years old having a salary between 70000 and 85000.</p> <p>This query may be performed with a multi column index, but this requires us to select the first variable and then scan the second, which means we may do a lot more work than needed. It is possible to perform these kinds of queries involving multiple variables using different data structures. For example, multi-dimensional trees such as k-d trees or r-trees are sometimes used. Here we'll describe a different way to index data into multiple dimensions, using a representation trick that allows us to perform the query in a very efficient way using Redis lexicographical ranges.</p> <p>Let's say we have points in the space, which represent our data samples, where <code>x</code> and <code>y</code> are our coordinates. The max value of both variables is 400.</p> <p>In the next figure, the blue box represents our query. We want all the points where <code>x</code> is between 50 and 100, and where <code>y</code> is between 100 and 300.</p> <p></p> <p>In order to represent data that makes these kinds of queries fast to perform, we start by padding our numbers with 0. So for example imagine we want to add the point 10,25 (x,y) to our index. Given that the maximum range in the example is 400 we can just pad to three digits, so we obtain:</p> <pre><code>x = 010\ny = 025\n</code></pre> <p>Now what we do is to interleave the digits, taking the leftmost digit in x, and the leftmost digit in y, and so forth, in order to create a single number:</p> <pre><code>001205\n</code></pre> <p>This is our index, however in order to more easily reconstruct the original representation, if we want (at the cost of space), we may also add the original values as additional columns:</p> <pre><code>001205:10:25\n</code></pre> <p>Now, let's reason about this representation and why it is useful in the context of range queries. For example let's take the center of our blue box, which is at <code>x=75</code> and <code>y=200</code>. We can encode this number as we did earlier by interleaving the digits, obtaining:</p> <pre><code>027050\n</code></pre> <p>What happens if we substitute the last two digits respectively with 00 and 99? We obtain a range which is lexicographically continuous:</p> <pre><code>027000 to 027099\n</code></pre> <p>What this maps to is to a square representing all values where the <code>x</code> variable is between 70 and 79, and the <code>y</code> variable is between 200 and 209. To identify this specific area, we can write random points in that interval.</p> <p></p> <p>So the above lexicographic query allows us to easily query for points in a specific square in the picture. However the square may be too small for the box we are searching, so that too many queries are needed. So we can do the same but instead of replacing the last two digits with 00 and 99, we can do it for the last four digits, obtaining the following range:</p> <pre><code>020000 029999\n</code></pre> <p>This time the range represents all the points where <code>x</code> is between 0 and 99 and <code>y</code> is between 200 and 299. Drawing random points in this interval shows us this larger area.</p> <p></p> <p>So now our area is too big for our query, and still our search box is not completely included. We need more granularity, but we can easily obtain it by representing our numbers in binary form. This time, when we replace digits instead of getting squares which are ten times bigger, we get squares which are just two times bigger.</p> <p>Our numbers in binary form, assuming we need just 9 bits for each variable (in order to represent numbers up to 400 in value) would be:</p> <pre><code>x = 75  -&gt; 001001011\ny = 200 -&gt; 011001000\n</code></pre> <p>So by interleaving digits, our representation in the index would be:</p> <pre><code>000111000011001010:75:200\n</code></pre> <p>Let's see what are our ranges as we substitute the last 2, 4, 6, 8, ... bits with 0s ad 1s in the interleaved representation:</p> <pre><code>2 bits: x between 74 and 75, y between 200 and 201 (range=2)\n4 bits: x between 72 and 75, y between 200 and 203 (range=4)\n6 bits: x between 72 and 79, y between 200 and 207 (range=8)\n8 bits: x between 64 and 79, y between 192 and 207 (range=16)\n</code></pre> <p>And so forth. Now we have definitely better granularity! As you can see substituting N bits from the index gives us search boxes of side <code>2^(N/2)</code>.</p> <p>So what we do is check the dimension where our search box is smaller, and check the nearest power of two to this number. Our search box was 50,100 to 100,300, so it has a width of 50 and a height of 200. We take the smaller of the two, 50, and check the nearest power of two which is 64. 64 is 2^6, so we would work with indexes obtained replacing the latest 12 bits from the interleaved representation (so that we end replacing just 6 bits of each variable).</p> <p>However single squares may not cover all our search, so we may need more. What we do is to start with the left bottom corner of our search box, which is 50,100, and find the first range by substituting the last 6 bits in each number with 0. Then we do the same with the right top corner.</p> <p>With two trivial nested for loops where we increment only the significant bits, we can find all the squares between these two. For each square we convert the two numbers into our interleaved representation, and create the range using the converted representation as our start, and the same representation but with the latest 12 bits turned on as end range.</p> <p>For each square found we perform our query and get the elements inside, removing the elements which are outside our search box.</p> <p>Turning this into code is simple. Here is a Ruby example:</p> <pre><code>def spacequery(x0,y0,x1,y1,exp)\n    bits=exp*2\n    x_start = x0/(2**exp)\n    x_end = x1/(2**exp)\n    y_start = y0/(2**exp)\n    y_end = y1/(2**exp)\n    (x_start..x_end).each{|x|\n        (y_start..y_end).each{|y|\n            x_range_start = x*(2**exp)\n            x_range_end = x_range_start | ((2**exp)-1)\n            y_range_start = y*(2**exp)\n            y_range_end = y_range_start | ((2**exp)-1)\n            puts \"#{x},#{y} x from #{x_range_start} to #{x_range_end}, y from #{y_range_start} to #{y_range_end}\"\n\n            # Turn it into interleaved form for ZRANGE query.\n            # We assume we need 9 bits for each integer, so the final\n            # interleaved representation will be 18 bits.\n            xbin = x_range_start.to_s(2).rjust(9,'0')\n            ybin = y_range_start.to_s(2).rjust(9,'0')\n            s = xbin.split(\"\").zip(ybin.split(\"\")).flatten.compact.join(\"\")\n            # Now that we have the start of the range, calculate the end\n            # by replacing the specified number of bits from 0 to 1.\n            e = s[0..-(bits+1)]+(\"1\"*bits)\n            puts \"ZRANGE myindex [#{s} [#{e} BYLEX\"\n        }\n    }\nend\n\nspacequery(50,100,100,300,6)\n</code></pre> <p>While non immediately trivial this is a very useful indexing strategy that in the future may be implemented in Redis in a native way. For now, the good thing is that the complexity may be easily encapsulated inside a library that can be used in order to perform indexing and queries. One example of such library is Redimension, a proof of concept Ruby library which indexes N-dimensional data inside Redis using the technique described here.</p>"},{"location":"6-manual/patterns/indexes/#multi-dimensional-indexes-with-negative-or-floating-point-numbers","title":"Multi dimensional indexes with negative or floating point numbers","text":"<p>The simplest way to represent negative values is just to work with unsigned integers and represent them using an offset, so that when you index, before translating numbers in the indexed representation, you add the absolute value of your smaller negative integer.</p> <p>For floating point numbers, the simplest approach is probably to convert them to integers by multiplying the integer for a power of ten proportional to the number of digits after the dot you want to retain.</p>"},{"location":"6-manual/patterns/indexes/#non-range-indexes","title":"Non range indexes","text":"<p>So far we checked indexes which are useful to query by range or by single item. However other Redis data structures such as Sets or Lists can be used in order to build other kind of indexes. They are very commonly used but maybe we don't always realize they are actually a form of indexing.</p> <p>For instance I can index object IDs into a Set data type in order to use the get random elements operation via <code>SRANDMEMBER</code> in order to retrieve a set of random objects. Sets can also be used to check for existence when all I need is to test if a given item exists or not or has a single boolean property or not.</p> <p>Similarly lists can be used in order to index items into a fixed order. I can add all my items into a Redis list and rotate the list with <code>RPOPLPUSH</code> using the same key name as source and destination. This is useful when I want to process a given set of items again and again forever in the same order. Think of an RSS feed system that needs to refresh the local copy periodically.</p> <p>Another popular index often used with Redis is a capped list, where items are added with <code>LPUSH</code> and trimmed with <code>LTRIM</code>, in order to create a view with just the latest N items encountered, in the same order they were seen.</p>"},{"location":"6-manual/patterns/indexes/#index-inconsistency","title":"Index inconsistency","text":"<p>Keeping the index updated may be challenging, in the course of months or years it is possible that inconsistencies are added because of software bugs, network partitions or other events.</p> <p>Different strategies could be used. If the index data is outside Redis read repair can be a solution, where data is fixed in a lazy way when it is requested. When we index data which is stored in Redis itself the <code>SCAN</code> family of commands can be used in order to verify, update or rebuild the index from scratch, incrementally.</p>"},{"location":"6-manual/pipelining/","title":"Redis pipelining","text":"<p>Redis pipelining is a technique for improving performance by issuing multiple commands at once without waiting for the response to each individual command. Pipelining is supported by most Redis clients. This document describes the problem that pipelining is designed to solve and how pipelining works in Redis.</p>"},{"location":"6-manual/pipelining/#requestresponse-protocols-and-round-trip-time-rtt","title":"Request/Response protocols and round-trip time (RTT)","text":"<p>Redis is a TCP server using the client-server model and what is called a Request/Response protocol.</p> <p>This means that usually a request is accomplished with the following steps:</p> <ul> <li>The client sends a query to the server, and reads from the socket, usually in a blocking way, for the server response.</li> <li>The server processes the command and sends the response back to the client.</li> </ul> <p>So for instance a four commands sequence is something like this:</p> <ul> <li>Client: INCR X</li> <li>Server: 1</li> <li>Client: INCR X</li> <li>Server: 2</li> <li>Client: INCR X</li> <li>Server: 3</li> <li>Client: INCR X</li> <li>Server: 4</li> </ul> <p>Clients and Servers are connected via a network link. Such a link can be very fast (a loopback interface) or very slow (a connection established over the Internet with many hops between the two hosts). Whatever the network latency is, it takes time for the packets to travel from the client to the server, and back from the server to the client to carry the reply.</p> <p>This time is called RTT (Round Trip Time). It's easy to see how this can affect performance when a client needs to perform many requests in a row (for instance adding many elements to the same list, or populating a database with many keys). For instance if the RTT time is 250 milliseconds (in the case of a very slow link over the Internet), even if the server is able to process 100k requests per second, we'll be able to process at max four requests per second.</p> <p>If the interface used is a loopback interface, the RTT is much shorter, typically sub-millisecond, but even this will add up to a lot if you need to perform many writes in a row.</p> <p>Fortunately there is a way to improve this use case.</p>"},{"location":"6-manual/pipelining/#redis-pipelining","title":"Redis Pipelining","text":"<p>A Request/Response server can be implemented so that it is able to process new requests even if the client hasn't already read the old responses. This way it is possible to send multiple commands to the server without waiting for the replies at all, and finally read the replies in a single step.</p> <p>This is called pipelining, and is a technique widely in use for many decades. For instance many POP3 protocol implementations already support this feature, dramatically speeding up the process of downloading new emails from the server.</p> <p>Redis has supported pipelining since its early days, so whatever version you are running, you can use pipelining with Redis. This is an example using the raw netcat utility:</p> <pre><code>$ (printf \"PING\\r\\nPING\\r\\nPING\\r\\n\"; sleep 1) | nc localhost 6379\n+PONG\n+PONG\n+PONG\n</code></pre> <p>This time we don't pay the cost of RTT for every call, but just once for the three commands.</p> <p>To be explicit, with pipelining the order of operations of our very first example will be the following:</p> <ul> <li>Client: INCR X</li> <li>Client: INCR X</li> <li>Client: INCR X</li> <li>Client: INCR X</li> <li>Server: 1</li> <li>Server: 2</li> <li>Server: 3</li> <li>Server: 4</li> </ul> <p>IMPORTANT NOTE: While the client sends commands using pipelining, the server will be forced to queue the replies, using memory. So if you need to send a lot of commands with pipelining, it is better to send them as batches each containing a reasonable number, for instance 10k commands, read the replies, and then send another 10k commands again, and so forth. The speed will be nearly the same, but the additional memory used will be at most the amount needed to queue the replies for these 10k commands.</p>"},{"location":"6-manual/pipelining/#its-not-just-a-matter-of-rtt","title":"It's not just a matter of RTT","text":"<p>Pipelining is not just a way to reduce the latency cost associated with the round trip time, it actually greatly improves the number of operations you can perform per second in a given Redis server. This is because without using pipelining, serving each command is very cheap from the point of view of accessing the data structures and producing the reply, but it is very costly from the point of view of doing the socket I/O. This involves calling the <code>read()</code> and <code>write()</code> syscall, that means going from user land to kernel land. The context switch is a huge speed penalty.</p> <p>When pipelining is used, many commands are usually read with a single <code>read()</code> system call, and multiple replies are delivered with a single <code>write()</code> system call. Consequently, the number of total queries performed per second initially increases almost linearly with longer pipelines, and eventually reaches 10 times the baseline obtained without pipelining, as shown in this figure.</p> <p></p>"},{"location":"6-manual/pipelining/#a-real-world-code-example","title":"A real world code example","text":"<p>In the following benchmark we'll use the Redis Ruby client, supporting pipelining, to test the speed improvement due to pipelining:</p> <pre><code>require 'rubygems'\nrequire 'redis'\n\ndef bench(descr)\n  start = Time.now\n  yield\n  puts \"#{descr} #{Time.now - start} seconds\"\nend\n\ndef without_pipelining\n  r = Redis.new\n  10_000.times do\n    r.ping\n  end\nend\n\ndef with_pipelining\n  r = Redis.new\n  r.pipelined do\n    10_000.times do\n      r.ping\n    end\n  end\nend\n\nbench('without pipelining') do\n  without_pipelining\nend\nbench('with pipelining') do\n  with_pipelining\nend\n</code></pre> <p>Running the above simple script yields the following figures on my Mac OS X system, running over the loopback interface, where pipelining will provide the smallest improvement as the RTT is already pretty low:</p> <p><pre><code>without pipelining 1.185238 seconds\nwith pipelining 0.250783 seconds\n</code></pre> As you can see, using pipelining, we improved the transfer by a factor of five.</p>"},{"location":"6-manual/pipelining/#pipelining-vs-scripting","title":"Pipelining vs Scripting","text":"<p>Using Redis scripting, available since Redis 2.6, a number of use cases for pipelining can be addressed more efficiently using scripts that perform a lot of the work needed at the server side. A big advantage of scripting is that it is able to both read and write data with minimal latency, making operations like read, compute, write very fast (pipelining can't help in this scenario since the client needs the reply of the read command before it can call the write command).</p> <p>Sometimes the application may also want to send <code>EVAL</code> or <code>EVALSHA</code> commands in a pipeline.  This is entirely possible and Redis explicitly supports it with the SCRIPT LOAD command (it guarantees that <code>EVALSHA</code> can be called without the risk of failing).</p>"},{"location":"6-manual/pipelining/#appendix-why-are-busy-loops-slow-even-on-the-loopback-interface","title":"Appendix: Why are busy loops slow even on the loopback interface?","text":"<p>Even with all the background covered in this page, you may still wonder why a Redis benchmark like the following (in pseudo code), is slow even when executed in the loopback interface, when the server and the client are running in the same physical machine:</p> <pre><code>FOR-ONE-SECOND:\n    Redis.SET(\"foo\",\"bar\")\nEND\n</code></pre> <p>After all, if both the Redis process and the benchmark are running in the same box, isn't it just copying messages in memory from one place to another without any actual latency or networking involved?</p> <p>The reason is that processes in a system are not always running, actually it is the kernel scheduler that lets the process run.  So, for instance, when the benchmark is allowed to run, it reads the reply from the Redis server (related to the last command executed), and writes a new command. The command is now in the loopback interface buffer, but in order to be read by the server, the kernel should schedule the server process (currently blocked in a system call) to run, and so forth. So in practical terms the loopback interface still involves network-like latency, because of how the kernel scheduler works.</p> <p>Basically a busy loop benchmark is the silliest thing that can be done when metering performances on a networked server. The wise thing is just avoiding benchmarking in this way.</p>"},{"location":"7-management/admin/","title":"Redis administration","text":""},{"location":"7-management/admin/#redis-setup-tips","title":"Redis setup tips","text":""},{"location":"7-management/admin/#linux","title":"Linux","text":"<ul> <li> <p>Deploy Redis using the Linux operating system. Redis is also tested on OS X, and from time to time on FreeBSD and OpenBSD systems. However, Linux is where most of the stress testing is performed, and where most production deployments are run.</p> </li> <li> <p>Set the Linux kernel overcommit memory setting to 1. Add <code>vm.overcommit_memory = 1</code> to <code>/etc/sysctl.conf</code>. Then, reboot or run the command <code>sysctl vm.overcommit_memory=1</code> to activate the setting. See FAQ: Background saving fails with a fork() error on Linux? for details. </p> </li> <li> <p>To ensure the Linux kernel feature Transparent Huge Pages does not impact Redis memory usage and latency, run the command: <code>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</code> to disable it. See Latency Diagnosis - Latency induced by transparent huge pages for additional context. </p> </li> </ul>"},{"location":"7-management/admin/#memory","title":"Memory","text":"<ul> <li> <p>Ensured that swap is enabled and that your swap file size is equal to amount of memory on your system. If Linux does not have swap set up, and your Redis instance accidentally consumes too much memory, Redis can crash when it is out of memory, or the Linux kernel OOM killer can kill the Redis process. When swapping is enabled, you can detect latency spikes and act on them.</p> </li> <li> <p>Set an explicit <code>maxmemory</code> option limit in your instance to make sure that it will report errors instead of failing when the system memory limit is near to be reached. Note that <code>maxmemory</code> should be set by calculating the overhead for Redis, other than data, and the fragmentation overhead. So if you think you have 10 GB of free memory, set it to 8 or 9.</p> </li> <li> <p>If you are using Redis in a write-heavy application, while saving an RDB file on disk or rewriting the AOF log, Redis can use up to 2 times the memory normally used. The additional memory used is proportional to the number of memory pages modified by writes during the saving process, so it is often proportional to the number of keys (or aggregate types items) touched during this time. Make sure to size your memory accordingly.</p> </li> <li> <p>See the <code>LATENCY DOCTOR</code> and <code>MEMORY DOCTOR</code> commands to assist in troubleshooting.</p> </li> </ul>"},{"location":"7-management/admin/#imaging","title":"Imaging","text":"<ul> <li>When running under daemontools, use <code>daemonize no</code>.</li> </ul>"},{"location":"7-management/admin/#replication","title":"Replication","text":"<ul> <li> <p>Set up a non-trivial replication backlog in proportion to the amount of memory Redis is using. The backlog allows replicas to sync with the primary (master) instance much more easily.</p> </li> <li> <p>If you use replication, Redis performs RDB saves even if persistence is disabled. (This does not apply to diskless replication.) If you don't have disk usage on the master, enable diskless replication.</p> </li> <li> <p>If you are using replication, ensure that either your master has persistence enabled, or that it does not automatically restart on crashes. Replicas will try to maintain an exact copy of the master, so if a master restarts with an empty data set, replicas will be wiped as well.</p> </li> </ul>"},{"location":"7-management/admin/#security","title":"Security","text":"<ul> <li>By default, Redis does not require any authentication and listens to all the network interfaces. This is a big security issue if you leave Redis exposed on the internet or other places where attackers can reach it. See for example this attack to see how dangerous it can be. Please check our security page and the quick start for information about how to secure Redis.</li> </ul>"},{"location":"7-management/admin/#running-redis-on-ec2","title":"Running Redis on EC2","text":"<ul> <li>Use HVM based instances, not PV based instances.</li> <li>Do not use old instance families. For example, use m3.medium with HVM instead of m1.medium with PV.</li> <li>The use of Redis persistence with EC2 EBS volumes needs to be handled with care because sometimes EBS volumes have high latency characteristics.</li> <li>You may want to try the new diskless replication if you have issues when replicas are synchronizing with the master.</li> </ul>"},{"location":"7-management/admin/#upgrading-or-restarting-a-redis-instance-without-downtime","title":"Upgrading or restarting a Redis instance without downtime","text":"<p>Redis is designed to be a long-running process in your server. You can modify many configuration options without a restart using the <code>CONFIG SET</code> command. You can also switch from AOF to RDB snapshots persistence, or the other way around, without restarting Redis. Check the output of the <code>CONFIG GET *</code> command for more information.</p> <p>From time to time, a restart is required, for example, to upgrade the Redis process to a newer version, or when you need to modify a configuration parameter that is currently not supported by the <code>CONFIG</code> command.</p> <p>Follow these steps to avoid downtime.</p> <ul> <li> <p>Set up your new Redis instance as a replica for your current Redis instance. In order to do so, you need a different server, or a server that has enough RAM to keep two instances of Redis running at the same time.</p> </li> <li> <p>If you use a single server, ensure that the replica is started on a different port than the master instance, otherwise the replica cannot start.</p> </li> <li> <p>Wait for the replication initial synchronization to complete. Check the replica's log file.</p> </li> <li> <p>Using <code>INFO</code>, ensure the master and replica have the same number of keys. Use <code>redis-cli</code> to check that the replica is working as expected and is replying to your commands.</p> </li> <li> <p>Allow writes to the replica using <code>CONFIG SET slave-read-only no</code>.</p> </li> <li> <p>Configure all your clients to use the new instance (the replica). Note that you may want to use the <code>CLIENT PAUSE</code> command to ensure that no client can write to the old master during the switch.</p> </li> <li> <p>Once you confirm that the master is no longer receiving any queries (you can check this using the <code>MONITOR</code> command), elect the replica to master using the <code>REPLICAOF NO ONE</code> command, and then shut down your master.</p> </li> </ul> <p>If you are using Redis Sentinel or Redis Cluster, the simplest way to upgrade to newer versions is to upgrade one replica after the other. Then you can perform a manual failover to promote one of the upgraded replicas to master, and finally promote the last replica.</p> <p>NOTE </p> <p>Redis Cluster 4.0 is not compatible with Redis Cluster 3.2 at cluster bus protocol level, so a mass restart is needed in this case. However, Redis 5 cluster bus is backward compatible with Redis 4.</p>"},{"location":"7-management/config-file/","title":"Redis configuration file example","text":"<p>Note: this file is generated from the unstable redis.conf during the website's build.</p>"},{"location":"7-management/config/","title":"Redis configuration","text":"<p>Redis is able to start without a configuration file using a built-in default configuration, however this setup is only recommended for testing and development purposes.</p> <p>The proper way to configure Redis is by providing a Redis configuration file, usually called <code>redis.conf</code>.</p> <p>The <code>redis.conf</code> file contains a number of directives that have a very simple format:</p> <pre><code>keyword argument1 argument2 ... argumentN\n</code></pre> <p>This is an example of a configuration directive:</p> <pre><code>replicaof 127.0.0.1 6380\n</code></pre> <p>It is possible to provide strings containing spaces as arguments using (double or single) quotes, as in the following example:</p> <pre><code>requirepass \"hello world\"\n</code></pre> <p>Single-quoted string can contain characters escaped by backslashes, and double-quoted strings can additionally include any ASCII symbols encoded using backslashed hexadecimal notation \"\\xff\".</p> <p>The list of configuration directives, and their meaning and intended usage is available in the self documented example redis.conf shipped into the Redis distribution.</p> <ul> <li>The self documented redis.conf for Redis 7.2.</li> <li>The self documented redis.conf for Redis 7.0.</li> <li>The self documented redis.conf for Redis 6.2.</li> <li>The self documented redis.conf for Redis 6.0.</li> <li>The self documented redis.conf for Redis 5.0.</li> <li>The self documented redis.conf for Redis 4.0.</li> <li>The self documented redis.conf for Redis 3.2.</li> <li>The self documented redis.conf for Redis 3.0.</li> <li>The self documented redis.conf for Redis 2.8.</li> <li>The self documented redis.conf for Redis 2.6.</li> <li>The self documented redis.conf for Redis 2.4.</li> </ul>"},{"location":"7-management/config/#passing-arguments-via-the-command-line","title":"Passing arguments via the command line","text":"<p>You can also pass Redis configuration parameters using the command line directly. This is very useful for testing purposes. The following is an example that starts a new Redis instance using port 6380 as a replica of the instance running at 127.0.0.1 port 6379.</p> <pre><code>./redis-server --port 6380 --replicaof 127.0.0.1 6379\n</code></pre> <p>The format of the arguments passed via the command line is exactly the same as the one used in the redis.conf file, with the exception that the keyword is prefixed with <code>--</code>.</p> <p>Note that internally this generates an in-memory temporary config file (possibly concatenating the config file passed by the user, if any) where arguments are translated into the format of redis.conf.</p>"},{"location":"7-management/config/#changing-redis-configuration-while-the-server-is-running","title":"Changing Redis configuration while the server is running","text":"<p>It is possible to reconfigure Redis on the fly without stopping and restarting the service, or querying the current configuration programmatically using the special commands <code>CONFIG SET</code> and <code>CONFIG GET</code>.</p> <p>Not all of the configuration directives are supported in this way, but most are supported as expected. Please refer to the <code>CONFIG SET</code> and <code>CONFIG GET</code> pages for more information.</p> <p>Note that modifying the configuration on the fly has no effects on the redis.conf file so at the next restart of Redis the old configuration will be used instead.</p> <p>Make sure to also modify the <code>redis.conf</code> file accordingly to the configuration you set using <code>CONFIG SET</code>. You can do it manually, or you can use <code>CONFIG REWRITE</code>, which will automatically scan your <code>redis.conf</code> file and update the fields which don't match the current configuration value. Fields non existing but set to the default value are not added. Comments inside your configuration file are retained.</p>"},{"location":"7-management/config/#configuring-redis-as-a-cache","title":"Configuring Redis as a cache","text":"<p>If you plan to use Redis as a cache where every key will have an expire set, you may consider using the following configuration instead (assuming a max memory limit of 2 megabytes as an example):</p> <pre><code>maxmemory 2mb\nmaxmemory-policy allkeys-lru\n</code></pre> <p>In this configuration there is no need for the application to set a time to live for keys using the <code>EXPIRE</code> command (or equivalent) since all the keys will be evicted using an approximated LRU algorithm as long as we hit the 2 megabyte memory limit.</p> <p>Basically, in this configuration Redis acts in a similar way to memcached. We have more extensive documentation about using Redis as an LRU cache here.</p>"},{"location":"7-management/debugging/","title":"Debugging","text":"<p>Redis is developed with an emphasis on stability. We do our best with every release to make sure you'll experience a stable product with no crashes. However, if you ever need to debug the Redis process itself, read on.</p> <p>When Redis crashes, it produces a detailed report of what happened. However, sometimes looking at the crash report is not enough, nor is it possible for the Redis core team to reproduce the issue independently. In this scenario, we need help from the user who can reproduce the issue.</p> <p>This guide shows how to use GDB to provide the information the Redis developers will need to track the bug more easily.</p>"},{"location":"7-management/debugging/#what-is-gdb","title":"What is GDB?","text":"<p>GDB is the Gnu Debugger: a program that is able to inspect the internal state of another program. Usually tracking and fixing a bug is an exercise in gathering more information about the state of the program at the moment the bug happens, so GDB is an extremely useful tool.</p> <p>GDB can be used in two ways:</p> <ul> <li>It can attach to a running program and inspect the state of it at runtime.</li> <li>It can inspect the state of a program that already terminated using what is called a core file, that is, the image of the memory at the time the program was running.</li> </ul> <p>From the point of view of investigating Redis bugs we need to use both of these GDB modes. The user able to reproduce the bug attaches GDB to their running Redis instance, and when the crash happens, they create the <code>core</code> file that in turn the developer will use to inspect the Redis internals at the time of the crash.</p> <p>This way the developer can perform all the inspections in his or her computer without the help of the user, and the user is free to restart Redis in their production environment.</p>"},{"location":"7-management/debugging/#compiling-redis-without-optimizations","title":"Compiling Redis without optimizations","text":"<p>By default Redis is compiled with the <code>-O2</code> switch, this means that compiler optimizations are enabled. This makes the Redis executable faster, but at the same time it makes Redis (like any other program) harder to inspect using GDB.</p> <p>It is better to attach GDB to Redis compiled without optimizations using the <code>make noopt</code> command (instead of just using the plain <code>make</code> command). However, if you have an already running Redis in production there is no need to recompile and restart it if this is going to create problems on your side. GDB still works against executables compiled with optimizations.</p> <p>You should not be overly concerned at the loss of performance from compiling Redis without optimizations. It is unlikely that this will cause problems in your environment as Redis is not very CPU-bound.</p>"},{"location":"7-management/debugging/#attaching-gdb-to-a-running-process","title":"Attaching GDB to a running process","text":"<p>If you have an already running Redis server, you can attach GDB to it, so that if Redis crashes it will be possible to both inspect the internals and generate a <code>core dump</code> file.</p> <p>After you attach GDB to the Redis process it will continue running as usual without any loss of performance, so this is not a dangerous procedure.</p> <p>In order to attach GDB the first thing you need is the process ID of the running Redis instance (the pid of the process). You can easily obtain it using <code>redis-cli</code>:</p> <pre><code>$ redis-cli info | grep process_id\nprocess_id:58414\n</code></pre> <p>In the above example the process ID is 58414.</p> <p>Login into your Redis server.</p> <p>(Optional but recommended) Start screen or tmux or any other program that will make sure that your GDB session will not be closed if your ssh connection times out. You can learn more about screen in this article.</p> <p>Attach GDB to the running Redis server by typing:</p> <pre><code>$ gdb &lt;path-to-redis-executable&gt; &lt;pid&gt;\n</code></pre> <p>For example:</p> <pre><code>$ gdb /usr/local/bin/redis-server 58414\n</code></pre> <p>GDB will start and will attach to the running server printing something like the following:</p> <pre><code>Reading symbols for shared libraries + done\n0x00007fff8d4797e6 in epoll_wait ()\n(gdb)\n</code></pre> <p>At this point GDB is attached but your Redis instance is blocked by GDB. In order to let the Redis instance continue the execution just type continue at the GDB prompt, and press enter.</p> <pre><code>(gdb) continue\nContinuing.\n</code></pre> <p>Done! Now your Redis instance has GDB attached. Now you can wait for the next crash. :)</p> <p>Now it's time to detach your screen/tmux session, if you are running GDB using it, by pressing Ctrl-a a key combination.</p>"},{"location":"7-management/debugging/#after-the-crash","title":"After the crash","text":"<p>Redis has a command to simulate a segmentation fault (in other words a bad crash) using the <code>DEBUG SEGFAULT</code> command (don't use it against a real production instance of course! So I'll use this command to crash my instance to show what happens in the GDB side:</p> <pre><code>(gdb) continue\nContinuing.\n\nProgram received signal EXC_BAD_ACCESS, Could not access memory.\nReason: KERN_INVALID_ADDRESS at address: 0xffffffffffffffff\ndebugCommand (c=0x7ffc32005000) at debug.c:220\n220         *((char*)-1) = 'x';\n</code></pre> <p>As you can see GDB detected that Redis crashed, and was even able to show me the file name and line number causing the crash. This is already much better than the Redis crash report back trace (containing just function names and binary offsets).</p>"},{"location":"7-management/debugging/#obtaining-the-stack-trace","title":"Obtaining the stack trace","text":"<p>The first thing to do is to obtain a full stack trace with GDB. This is as simple as using the bt command:</p> <pre><code>(gdb) bt\n#0  debugCommand (c=0x7ffc32005000) at debug.c:220\n#1  0x000000010d246d63 in call (c=0x7ffc32005000) at redis.c:1163\n#2  0x000000010d247290 in processCommand (c=0x7ffc32005000) at redis.c:1305\n#3  0x000000010d251660 in processInputBuffer (c=0x7ffc32005000) at networking.c:959\n#4  0x000000010d251872 in readQueryFromClient (el=0x0, fd=5, privdata=0x7fff76f1c0b0, mask=220924512) at networking.c:1021\n#5  0x000000010d243523 in aeProcessEvents (eventLoop=0x7fff6ce408d0, flags=220829559) at ae.c:352\n#6  0x000000010d24373b in aeMain (eventLoop=0x10d429ef0) at ae.c:397\n#7  0x000000010d2494ff in main (argc=1, argv=0x10d2b2900) at redis.c:2046\n</code></pre> <p>This shows the backtrace, but we also want to dump the processor registers using the info registers command:</p> <pre><code>(gdb) info registers\nrax            0x0  0\nrbx            0x7ffc32005000   140721147367424\nrcx            0x10d2b0a60  4515891808\nrdx            0x7fff76f1c0b0   140735188943024\nrsi            0x10d299777  4515796855\nrdi            0x0  0\nrbp            0x7fff6ce40730   0x7fff6ce40730\nrsp            0x7fff6ce40650   0x7fff6ce40650\nr8             0x4f26b3f7   1327936503\nr9             0x7fff6ce40718   140735020271384\nr10            0x81 129\nr11            0x10d430398  4517462936\nr12            0x4b7c04f8babc0  1327936503000000\nr13            0x10d3350a0  4516434080\nr14            0x10d42d9f0  4517452272\nr15            0x10d430398  4517462936\nrip            0x10d26cfd4  0x10d26cfd4 &lt;debugCommand+68&gt;\neflags         0x10246  66118\ncs             0x2b 43\nss             0x0  0\nds             0x0  0\nes             0x0  0\nfs             0x0  0\ngs             0x0  0\n</code></pre> <p>Please make sure to include both of these outputs in your bug report.</p>"},{"location":"7-management/debugging/#obtaining-the-core-file","title":"Obtaining the core file","text":"<p>The next step is to generate the core dump, that is the image of the memory of the running Redis process. This is done using the <code>gcore</code> command:</p> <pre><code>(gdb) gcore\nSaved corefile core.58414\n</code></pre> <p>Now you have the core dump to send to the Redis developer, but it is important to understand that this happens to contain all the data that was inside the Redis instance at the time of the crash; Redis developers will make sure not to share the content with anyone else, and will delete the file as soon as it is no longer used for debugging purposes, but you are warned that by sending the core file you are sending your data.</p>"},{"location":"7-management/debugging/#what-to-send-to-developers","title":"What to send to developers","text":"<p>Finally you can send everything to the Redis core team:</p> <ul> <li>The Redis executable you are using.</li> <li>The stack trace produced by the bt command, and the registers dump.</li> <li>The core file you generated with gdb.</li> <li>Information about the operating system and GCC version, and Redis version you are using.</li> </ul>"},{"location":"7-management/debugging/#thank-you","title":"Thank you","text":"<p>Your help is extremely important! Many issues can only be tracked this way. So thanks!</p>"},{"location":"7-management/persistence/","title":"Redis persistence","text":"<p>Persistence refers to the writing of data to durable storage, such as a solid-state disk (SSD). Redis provides a range of persistence options. These include:</p> <ul> <li>RDB (Redis Database): RDB persistence performs point-in-time snapshots of your dataset at specified intervals.</li> <li>AOF (Append Only File): AOF persistence logs every write operation received by the server. These operations can then be replayed again at server startup, reconstructing the original dataset. Commands are logged using the same format as the Redis protocol itself.</li> <li>No persistence: You can disable persistence completely. This is sometimes used when caching.</li> <li>RDB + AOF: You can also combine both AOF and RDB in the same instance.</li> </ul> <p>If you'd rather not think about the tradeoffs between these different persistence strategies, you may want to consider Redis Enterprise's persistence options, which can be pre-configured using a UI.</p> <p>To learn more about how to evaluate your Redis persistence strategy, read on.</p>"},{"location":"7-management/persistence/#rdb-advantages","title":"RDB advantages","text":"<ul> <li>RDB is a very compact single-file point-in-time representation of your Redis data. RDB files are perfect for backups. For instance you may want to archive your RDB files every hour for the latest 24 hours, and to save an RDB snapshot every day for 30 days. This allows you to easily restore different versions of the data set in case of disasters.</li> <li>RDB is very good for disaster recovery, being a single compact file that can be transferred to far data centers, or onto Amazon S3 (possibly encrypted).</li> <li>RDB maximizes Redis performances since the only work the Redis parent process needs to do in order to persist is forking a child that will do all the rest. The parent process will never perform disk I/O or alike.</li> <li>RDB allows faster restarts with big datasets compared to AOF.</li> <li>On replicas, RDB supports partial resynchronizations after restarts and failovers.</li> </ul>"},{"location":"7-management/persistence/#rdb-disadvantages","title":"RDB disadvantages","text":"<ul> <li>RDB is NOT good if you need to minimize the chance of data loss in case Redis stops working (for example after a power outage). You can configure different save points where an RDB is produced (for instance after at least five minutes and 100 writes against the data set, you can have multiple save points). However you'll usually create an RDB snapshot every five minutes or more, so in case of Redis stopping working without a correct shutdown for any reason you should be prepared to lose the latest minutes of data.</li> <li>RDB needs to fork() often in order to persist on disk using a child process. fork() can be time consuming if the dataset is big, and may result in Redis stopping serving clients for some milliseconds or even for one second if the dataset is very big and the CPU performance is not great. AOF also needs to fork() but less frequently and you can tune how often you want to rewrite your logs without any trade-off on durability.</li> </ul>"},{"location":"7-management/persistence/#aof-advantages","title":"AOF advantages","text":"<ul> <li>Using AOF Redis is much more durable: you can have different fsync policies: no fsync at all, fsync every second, fsync at every query. With the default policy of fsync every second, write performance is still great. fsync is performed using a background thread and the main thread will try hard to perform writes when no fsync is in progress, so you can only lose one second worth of writes.</li> <li>The AOF log is an append-only log, so there are no seeks, nor corruption problems if there is a power outage. Even if the log ends with a half-written command for some reason (disk full or other reasons) the redis-check-aof tool is able to fix it easily.</li> <li>Redis is able to automatically rewrite the AOF in background when it gets too big. The rewrite is completely safe as while Redis continues appending to the old file, a completely new one is produced with the minimal set of operations needed to create the current data set, and once this second file is ready Redis switches the two and starts appending to the new one.</li> <li>AOF contains a log of all the operations one after the other in an easy to understand and parse format. You can even easily export an AOF file. For instance even if you've accidentally flushed everything using the <code>FLUSHALL</code> command, as long as no rewrite of the log was performed in the meantime, you can still save your data set just by stopping the server, removing the latest command, and restarting Redis again.</li> </ul>"},{"location":"7-management/persistence/#aof-disadvantages","title":"AOF disadvantages","text":"<ul> <li>AOF files are usually bigger than the equivalent RDB files for the same dataset.</li> <li>AOF can be slower than RDB depending on the exact fsync policy. In general with fsync set to every second performance is still very high, and with fsync disabled it should be exactly as fast as RDB even under high load. Still RDB is able to provide more guarantees about the maximum latency even in the case of a huge write load.</li> </ul> <p>Redis &lt; 7.0</p> <ul> <li>AOF can use a lot of memory if there are writes to the database during a rewrite (these are buffered in memory and written to the new AOF at the end).</li> <li>All write commands that arrive during rewrite are written to disk twice.</li> <li>Redis could freeze writing and fsyncing these write commands to the new AOF file at the end of the rewrite.</li> </ul>"},{"location":"7-management/persistence/#ok-so-what-should-i-use","title":"Ok, so what should I use?","text":"<p>The general indication you should use both persistence methods is if you want a degree of data safety comparable to what PostgreSQL can provide you.</p> <p>If you care a lot about your data, but still can live with a few minutes of data loss in case of disasters, you can simply use RDB alone.</p> <p>There are many users using AOF alone, but we discourage it since to have an RDB snapshot from time to time is a great idea for doing database backups, for faster restarts, and in the event of bugs in the AOF engine.</p> <p>The following sections will illustrate a few more details about the two persistence models.</p>"},{"location":"7-management/persistence/#snapshotting","title":"Snapshotting","text":"<p>By default Redis saves snapshots of the dataset on disk, in a binary file called <code>dump.rdb</code>. You can configure Redis to have it save the dataset every N seconds if there are at least M changes in the dataset, or you can manually call the <code>SAVE</code> or <code>BGSAVE</code> commands.</p> <p>For example, this configuration will make Redis automatically dump the dataset to disk every 60 seconds if at least 1000 keys changed:</p> <pre><code>save 60 1000\n</code></pre> <p>This strategy is known as snapshotting.</p>"},{"location":"7-management/persistence/#how-it-works","title":"How it works","text":"<p>Whenever Redis needs to dump the dataset to disk, this is what happens:</p> <ul> <li> <p>Redis forks. We now have a child and a parent process.</p> </li> <li> <p>The child starts to write the dataset to a temporary RDB file.</p> </li> <li> <p>When the child is done writing the new RDB file, it replaces the old one.</p> </li> </ul> <p>This method allows Redis to benefit from copy-on-write semantics.</p>"},{"location":"7-management/persistence/#append-only-file","title":"Append-only file","text":"<p>Snapshotting is not very durable. If your computer running Redis stops, your power line fails, or you accidentally <code>kill -9</code> your instance, the latest data written to Redis will be lost.  While this may not be a big deal for some applications, there are use cases for full durability, and in these cases Redis snapshotting alone is not a viable option.</p> <p>The append-only file is an alternative, fully-durable strategy for Redis.  It became available in version 1.1.</p> <p>You can turn on the AOF in your configuration file:</p> <pre><code>appendonly yes\n</code></pre> <p>From now on, every time Redis receives a command that changes the dataset (e.g. <code>SET</code>) it will append it to the AOF.  When you restart Redis it will re-play the AOF to rebuild the state.</p> <p>Since Redis 7.0.0, Redis uses a multi part AOF mechanism. That is, the original single AOF file is split into base file (at most one) and incremental files (there may be more than one). The base file represents an initial (RDB or AOF format) snapshot of the data present when the AOF is rewritten. The incremental files contains incremental changes since the last base AOF file was created. All these files are put in a separate directory and are tracked by a manifest file.</p>"},{"location":"7-management/persistence/#log-rewriting","title":"Log rewriting","text":"<p>The AOF gets bigger and bigger as write operations are performed.  For example, if you are incrementing a counter 100 times, you'll end up with a single key in your dataset containing the final value, but 100 entries in your AOF. 99 of those entries are not needed to rebuild the current state.</p> <p>The rewrite is completely safe. While Redis continues appending to the old file, a completely new one is produced with the minimal set of operations needed to create the current data set, and once this second file is ready Redis switches the two and starts appending to the new one.</p> <p>So Redis supports an interesting feature: it is able to rebuild the AOF in the background without interrupting service to clients. Whenever you issue a <code>BGREWRITEAOF</code>, Redis will write the shortest sequence of commands needed to rebuild the current dataset in memory.  If you're using the AOF with Redis 2.2 you'll need to run <code>BGREWRITEAOF</code> from time to time. Since Redis 2.4 is able to trigger log rewriting automatically (see the example configuration file for more information).</p> <p>Since Redis 7.0.0, when an AOF rewrite is scheduled, the Redis parent process opens a new incremental AOF file to continue writing. The child process executes the rewrite logic and generates a new base AOF. Redis will use a temporary manifest file to track the newly generated base file and incremental file. When they are ready, Redis will perform an atomic replacement operation to make this temporary manifest file take effect. In order to avoid the problem of creating many incremental files in case of repeated failures and retries of an AOF rewrite, Redis introduces an AOF rewrite limiting mechanism to ensure that failed AOF rewrites are retried at a slower and slower rate.</p>"},{"location":"7-management/persistence/#how-durable-is-the-append-only-file","title":"How durable is the append only file?","text":"<p>You can configure how many times Redis will <code>fsync</code> data on disk. There are three options:</p> <ul> <li><code>appendfsync always</code>: <code>fsync</code> every time new commands are appended to the AOF. Very very slow, very safe. Note that the commands are appended to the AOF after a batch of commands from multiple clients or a pipeline are executed, so it means a single write and a single fsync (before sending the replies).</li> <li><code>appendfsync everysec</code>: <code>fsync</code> every second. Fast enough (since version 2.4 likely to be as fast as snapshotting), and you may lose 1 second of data if there is a disaster.</li> <li><code>appendfsync no</code>: Never <code>fsync</code>, just put your data in the hands of the Operating System. The faster and less safe method. Normally Linux will flush data every 30 seconds with this configuration, but it's up to the kernel's exact tuning.</li> </ul> <p>The suggested (and default) policy is to <code>fsync</code> every second. It is both fast and relatively safe. The <code>always</code> policy is very slow in practice, but it supports group commit, so if there are multiple parallel writes Redis will try to perform a single <code>fsync</code> operation.</p>"},{"location":"7-management/persistence/#what-should-i-do-if-my-aof-gets-truncated","title":"What should I do if my AOF gets truncated?","text":"<p>It is possible the server crashed while writing the AOF file, or the volume where the AOF file is stored was full at the time of writing. When this happens the AOF still contains consistent data representing a given point-in-time version of the dataset (that may be old up to one second with the default AOF fsync policy), but the last command in the AOF could be truncated. The latest major versions of Redis will be able to load the AOF anyway, just discarding the last non well formed command in the file. In this case the server will emit a log like the following:</p> <pre><code>* Reading RDB preamble from AOF file...\n* Reading the remaining AOF tail...\n# !!! Warning: short read while loading the AOF file !!!\n# !!! Truncating the AOF at offset 439 !!!\n# AOF loaded anyway because aof-load-truncated is enabled\n</code></pre> <p>You can change the default configuration to force Redis to stop in such cases if you want, but the default configuration is to continue regardless of the fact the last command in the file is not well-formed, in order to guarantee availability after a restart.</p> <p>Older versions of Redis may not recover, and may require the following steps:</p> <ul> <li>Make a backup copy of your AOF file.</li> <li> <p>Fix the original file using the <code>redis-check-aof</code> tool that ships with Redis:</p> <p>$ redis-check-aof --fix  <li> <p>Optionally use <code>diff -u</code> to check what is the difference between two files.</p> </li> <li>Restart the server with the fixed file.</li>"},{"location":"7-management/persistence/#what-should-i-do-if-my-aof-gets-corrupted","title":"What should I do if my AOF gets corrupted?","text":"<p>If the AOF file is not just truncated, but corrupted with invalid byte sequences in the middle, things are more complex. Redis will complain at startup and will abort:</p> <pre><code>* Reading the remaining AOF tail...\n# Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;\n</code></pre> <p>The best thing to do is to run the <code>redis-check-aof</code> utility, initially without the <code>--fix</code> option, then understand the problem, jump to the given offset in the file, and see if it is possible to manually repair the file: The AOF uses the same format of the Redis protocol and is quite simple to fix manually. Otherwise it is possible to let the utility fix the file for us, but in that case all the AOF portion from the invalid part to the end of the file may be discarded, leading to a massive amount of data loss if the corruption happened to be in the initial part of the file.</p>"},{"location":"7-management/persistence/#how-it-works_1","title":"How it works","text":"<p>Log rewriting uses the same copy-on-write trick already in use for snapshotting.  This is how it works:</p> <p>Redis &gt;= 7.0</p> <ul> <li> <p>Redis forks, so now we have a child and a parent process.</p> </li> <li> <p>The child starts writing the new base AOF in a temporary file.</p> </li> <li> <p>The parent opens a new increments AOF file to continue writing updates.   If the rewriting fails, the old base and increment files (if there are any) plus this newly opened increment file represent the complete updated dataset,   so we are safe.</p> </li> <li> <p>When the child is done rewriting the base file, the parent gets a signal, and uses the newly opened increment file and child generated base file to build a temp manifest, and persist it.</p> </li> <li> <p>Profit! Now Redis does an atomic exchange of the manifest files so that the result of this AOF rewrite takes effect. Redis also cleans up the old base file and any unused increment files.</p> </li> </ul> <p>Redis &lt; 7.0</p> <ul> <li> <p>Redis forks, so now we have a child and a parent process.</p> </li> <li> <p>The child starts writing the new AOF in a temporary file.</p> </li> <li> <p>The parent accumulates all the new changes in an in-memory buffer (but at the same time it writes the new changes in the old append-only file, so if the rewriting fails, we are safe).</p> </li> <li> <p>When the child is done rewriting the file, the parent gets a signal, and appends the in-memory buffer at the end of the file generated by the child.</p> </li> <li> <p>Now Redis atomically renames the new file into the old one, and starts appending new data into the new file.</p> </li> </ul>"},{"location":"7-management/persistence/#how-i-can-switch-to-aof-if-im-currently-using-dumprdb-snapshots","title":"How I can switch to AOF, if I'm currently using dump.rdb snapshots?","text":"<p>There is a different procedure to do this in version 2.0 and later versions, as you can guess it's simpler since Redis 2.2 and does not require a restart at all.</p> <p>Redis &gt;= 2.2</p> <ul> <li>Make a backup of your latest dump.rdb file.</li> <li>Transfer this backup to a safe place.</li> <li>Issue the following two commands:</li> <li><code>redis-cli config set appendonly yes</code></li> <li><code>redis-cli config set save \"\"</code></li> <li>Make sure your database contains the same number of keys it contained.</li> <li>Make sure writes are appended to the append only file correctly.</li> </ul> <p>The first CONFIG command enables the Append Only File persistence.</p> <p>The second CONFIG command is used to turn off snapshotting persistence. This is optional, if you wish you can take both the persistence methods enabled.</p> <p>IMPORTANT: remember to edit your redis.conf to turn on the AOF, otherwise when you restart the server the configuration changes will be lost and the server will start again with the old configuration.</p> <p>Redis 2.0</p> <ul> <li>Make a backup of your latest dump.rdb file.</li> <li>Transfer this backup into a safe place.</li> <li>Stop all the writes against the database!</li> <li>Issue a <code>redis-cli BGREWRITEAOF</code>. This will create the append only file.</li> <li>Stop the server when Redis finished generating the AOF dump.</li> <li>Edit redis.conf end enable append only file persistence.</li> <li>Restart the server.</li> <li>Make sure that your database contains the same number of keys it contained before the switch.</li> <li>Make sure that writes are appended to the append only file correctly.</li> </ul>"},{"location":"7-management/persistence/#interactions-between-aof-and-rdb-persistence","title":"Interactions between AOF and RDB persistence","text":"<p>Redis &gt;= 2.4 makes sure to avoid triggering an AOF rewrite when an RDB snapshotting operation is already in progress, or allowing a <code>BGSAVE</code> while the AOF rewrite is in progress. This prevents two Redis background processes from doing heavy disk I/O at the same time.</p> <p>When snapshotting is in progress and the user explicitly requests a log rewrite operation using <code>BGREWRITEAOF</code> the server will reply with an OK status code telling the user the operation is scheduled, and the rewrite will start once the snapshotting is completed.</p> <p>In the case both AOF and RDB persistence are enabled and Redis restarts the AOF file will be used to reconstruct the original dataset since it is guaranteed to be the most complete.</p>"},{"location":"7-management/persistence/#backing-up-redis-data","title":"Backing up Redis data","text":"<p>Before starting this section, make sure to read the following sentence: Make Sure to Backup Your Database. Disks break, instances in the cloud disappear, and so forth: no backups means huge risk of data disappearing into /dev/null.</p> <p>Redis is very data backup friendly since you can copy RDB files while the database is running: the RDB is never modified once produced, and while it gets produced it uses a temporary name and is renamed into its final destination atomically using rename(2) only when the new snapshot is complete.</p> <p>This means that copying the RDB file is completely safe while the server is running. This is what we suggest:</p> <ul> <li>Create a cron job in your server creating hourly snapshots of the RDB file in one directory, and daily snapshots in a different directory.</li> <li>Every time the cron script runs, make sure to call the <code>find</code> command to make sure too old snapshots are deleted: for instance you can take hourly snapshots for the latest 48 hours, and daily snapshots for one or two months. Make sure to name the snapshots with date and time information.</li> <li>At least one time every day make sure to transfer an RDB snapshot outside your data center or at least outside the physical machine running your Redis instance.</li> </ul>"},{"location":"7-management/persistence/#backing-up-aof-persistence","title":"Backing up AOF persistence","text":"<p>If you run a Redis instance with only AOF persistence enabled, you can still perform backups. Since Redis 7.0.0, AOF files are split into multiple files which reside in a single directory determined by the <code>appenddirname</code> configuration. During normal operation all you need to do is copy/tar the files in this directory to achieve a backup. However, if this is done during a rewrite, you might end up with an invalid backup. To work around this you must disable AOF rewrites during the backup:</p> <ol> <li>Turn off automatic rewrites with <code>CONFIG SET</code> <code>auto-aof-rewrite-percentage 0</code>    Make sure you don't manually start a rewrite (using <code>BGREWRITEAOF</code>) during this time.</li> <li>Check there's no current rewrite in progress using <code>INFO</code> <code>persistence</code>    and verifying <code>aof_rewrite_in_progress</code> is 0. If it's 1, then you'll need to wait for the rewrite to complete.</li> <li>Now you can safely copy the files in the <code>appenddirname</code> directory.</li> <li>Re-enable rewrites when done: <code>CONFIG SET</code> <code>auto-aof-rewrite-percentage &lt;prev-value&gt;</code></li> </ol> <p>Note: If you want to minimize the time AOF rewrites are disabled you may create hard links to the files in <code>appenddirname</code> (in step 3 above) and then re-enable rewrites (step 4) after the hard links are created. Now you can copy/tar the hardlinks and delete them when done. This works because Redis guarantees that it only appends to files in this directory, or completely replaces them if necessary, so the content should be consistent at any given point in time.</p> <p>Note: If you want to handle the case of the server being restarted during the backup and make sure no rewrite will automatically start after the restart you can change step 1 above to also persist the updated configuration via <code>CONFIG REWRITE</code>. Just make sure to re-enable automatic rewrites when done (step 4) and persist it with another <code>CONFIG REWRITE</code>.</p> <p>Prior to version 7.0.0 backing up the AOF file can be done simply by copying the aof file (like backing up the RDB snapshot). The file may lack the final part but Redis will still be able to load it (see the previous sections about truncated AOF files).</p>"},{"location":"7-management/persistence/#disaster-recovery","title":"Disaster recovery","text":"<p>Disaster recovery in the context of Redis is basically the same story as backups, plus the ability to transfer those backups in many different external data centers. This way data is secured even in the case of some catastrophic event affecting the main data center where Redis is running and producing its snapshots.</p> <p>We'll review the most interesting disaster recovery techniques that don't have too high costs.</p> <ul> <li>Amazon S3 and other similar services are a good way for implementing your disaster recovery system. Simply transfer your daily or hourly RDB snapshot to S3 in an encrypted form. You can encrypt your data using <code>gpg -c</code> (in symmetric encryption mode). Make sure to store your password in many different safe places (for instance give a copy to the most important people of your organization). It is recommended to use multiple storage services for improved data safety.</li> <li>Transfer your snapshots using SCP (part of SSH) to far servers. This is a fairly simple and safe route: get a small VPS in a place that is very far from you, install ssh there, and generate a ssh client key without passphrase, then add it in the <code>authorized_keys</code> file of your small VPS. You are ready to transfer backups in an automated fashion. Get at least two VPS in two different providers for best results.</li> </ul> <p>It is important to understand that this system can easily fail if not implemented in the right way. At least, make absolutely sure that after the transfer is completed you are able to verify the file size (that should match the one of the file you copied) and possibly the SHA1 digest, if you are using a VPS.</p> <p>You also need some kind of independent alert system if the transfer of fresh backups is not working for some reason.</p>"},{"location":"7-management/replication/","title":"Redis replication","text":"<p>At the base of Redis replication (excluding the high availability features provided as an additional layer by Redis Cluster or Redis Sentinel) there is a leader follower (master-replica) replication that is simple to use and configure. It allows replica Redis instances to be exact copies of master instances. The replica will automatically reconnect to the master every time the link breaks, and will attempt to be an exact copy of it regardless of what happens to the master.</p> <p>This system works using three main mechanisms:</p> <ol> <li>When a master and a replica instances are well-connected, the master keeps the replica updated by sending a stream of commands to the replica to replicate the effects on the dataset happening in the master side due to: client writes, keys expired or evicted, any other action changing the master dataset.</li> <li>When the link between the master and the replica breaks, for network issues or because a timeout is sensed in the master or the replica, the replica reconnects and attempts to proceed with a partial resynchronization: it means that it will try to just obtain the part of the stream of commands it missed during the disconnection.</li> <li>When a partial resynchronization is not possible, the replica will ask for a full resynchronization. This will involve a more complex process in which the master needs to create a snapshot of all its data, send it to the replica, and then continue sending the stream of commands as the dataset changes.</li> </ol> <p>Redis uses by default asynchronous replication, which being low latency and high performance, is the natural replication mode for the vast majority of Redis use cases. However, Redis replicas asynchronously acknowledge the amount of data they received periodically with the master. So the master does not wait every time for a command to be processed by the replicas, however it knows, if needed, what replica already processed what command. This allows having optional synchronous replication.</p> <p>Synchronous replication of certain data can be requested by the clients using the <code>WAIT</code> command. However <code>WAIT</code> is only able to ensure there are the specified number of acknowledged copies in the other Redis instances, it does not turn a set of Redis instances into a CP system with strong consistency: acknowledged writes can still be lost during a failover, depending on the exact configuration of the Redis persistence. However with <code>WAIT</code> the probability of losing a write after a failure event is greatly reduced to certain hard to trigger failure modes.</p> <p>You can check the Redis Sentinel or Redis Cluster documentation for more information about high availability and failover. The rest of this document mainly describes the basic characteristics of Redis basic replication.</p>"},{"location":"7-management/replication/#important-facts-about-redis-replication","title":"Important facts about Redis replication","text":"<ul> <li>Redis uses asynchronous replication, with asynchronous replica-to-master acknowledges of the amount of data processed.</li> <li>A master can have multiple replicas.</li> <li>Replicas are able to accept connections from other replicas. Aside from connecting a number of replicas to the same master, replicas can also be connected to other replicas in a cascading-like structure. Since Redis 4.0, all the sub-replicas will receive exactly the same replication stream from the master.</li> <li>Redis replication is non-blocking on the master side. This means that the master will continue to handle queries when one or more replicas perform the initial synchronization or a partial resynchronization.</li> <li>Replication is also largely non-blocking on the replica side. While the replica is performing the initial synchronization, it can handle queries using the old version of the dataset, assuming you configured Redis to do so in redis.conf.  Otherwise, you can configure Redis replicas to return an error to clients if the replication stream is down. However, after the initial sync, the old dataset must be deleted and the new one must be loaded. The replica will block incoming connections during this brief window (that can be as long as many seconds for very large datasets). Since Redis 4.0 you can configure Redis so that the deletion of the old data set happens in a different thread, however loading the new initial dataset will still happen in the main thread and block the replica.</li> <li>Replication can be used both for scalability, to have multiple replicas for read-only queries (for example, slow O(N) operations can be offloaded to replicas), or simply for improving data safety and high availability.</li> <li>You can use replication to avoid the cost of having the master writing the full dataset to disk: a typical technique involves configuring your master <code>redis.conf</code> to avoid persisting to disk at all, then connect a replica configured to save from time to time, or with AOF enabled. However, this setup must be handled with care, since a restarting master will start with an empty dataset: if the replica tries to sync with it, the replica will be emptied as well.</li> </ul>"},{"location":"7-management/replication/#safety-of-replication-when-master-has-persistence-turned-off","title":"Safety of replication when master has persistence turned off","text":"<p>In setups where Redis replication is used, it is strongly advised to have persistence turned on in the master and in the replicas. When this is not possible, for example because of latency concerns due to very slow disks, instances should be configured to avoid restarting automatically after a reboot.</p> <p>To better understand why masters with persistence turned off configured to auto restart are dangerous, check the following failure mode where data is wiped from the master and all its replicas:</p> <ol> <li>We have a setup with node A acting as master, with persistence turned down, and nodes B and C replicating from node A.</li> <li>Node A crashes, however it has some auto-restart system, that restarts the process. However since persistence is turned off, the node restarts with an empty data set.</li> <li>Nodes B and C will replicate from node A, which is empty, so they'll effectively destroy their copy of the data.</li> </ol> <p>When Redis Sentinel is used for high availability, also turning off persistence on the master, together with auto restart of the process, is dangerous. For example the master can restart fast enough for Sentinel to not detect a failure, so that the failure mode described above happens.</p> <p>Every time data safety is important, and replication is used with master configured without persistence, auto restart of instances should be disabled.</p>"},{"location":"7-management/replication/#how-redis-replication-works","title":"How Redis replication works","text":"<p>Every Redis master has a replication ID: it is a large pseudo random string that marks a given story of the dataset. Each master also takes an offset that increments for every byte of replication stream that it is produced to be sent to replicas, to update the state of the replicas with the new changes modifying the dataset. The replication offset is incremented even if no replica is actually connected, so basically every given pair of:</p> <pre><code>Replication ID, offset\n</code></pre> <p>Identifies an exact version of the dataset of a master.</p> <p>When replicas connect to masters, they use the <code>PSYNC</code> command to send their old master replication ID and the offsets they processed so far. This way the master can send just the incremental part needed. However if there is not enough backlog in the master buffers, or if the replica is referring to an history (replication ID) which is no longer known, then a full resynchronization happens: in this case the replica will get a full copy of the dataset, from scratch.</p> <p>This is how a full synchronization works in more details:</p> <p>The master starts a background saving process to produce an RDB file. At the same time it starts to buffer all new write commands received from the clients. When the background saving is complete, the master transfers the database file to the replica, which saves it on disk, and then loads it into memory. The master will then send all buffered commands to the replica. This is done as a stream of commands and is in the same format of the Redis protocol itself.</p> <p>You can try it yourself via telnet. Connect to the Redis port while the server is doing some work and issue the <code>SYNC</code> command. You'll see a bulk transfer and then every command received by the master will be re-issued in the telnet session. Actually <code>SYNC</code> is an old protocol no longer used by newer Redis instances, but is still there for backward compatibility: it does not allow partial resynchronizations, so now <code>PSYNC</code> is used instead.</p> <p>As already said, replicas are able to automatically reconnect when the master-replica link goes down for some reason. If the master receives multiple concurrent replica synchronization requests, it performs a single background save in to serve all of them.</p>"},{"location":"7-management/replication/#replication-id-explained","title":"Replication ID explained","text":"<p>In the previous section we said that if two instances have the same replication ID and replication offset, they have exactly the same data. However it is useful to understand what exactly is the replication ID, and why instances have actually two replication IDs: the main ID and the secondary ID.</p> <p>A replication ID basically marks a given history of the data set. Every time an instance restarts from scratch as a master, or a replica is promoted to master, a new replication ID is generated for this instance. The replicas connected to a master will inherit its replication ID after the handshake. So two instances with the same ID are related by the fact that they hold the same data, but potentially at a different time. It is the offset that works as a logical time to understand, for a given history (replication ID), who holds the most updated data set.</p> <p>For instance, if two instances A and B have the same replication ID, but one with offset 1000 and one with offset 1023, it means that the first lacks certain commands applied to the data set. It also means that A, by applying just a few commands, may reach exactly the same state of B.</p> <p>The reason why Redis instances have two replication IDs is because of replicas that are promoted to masters. After a failover, the promoted replica requires to still remember what was its past replication ID, because such replication ID was the one of the former master. In this way, when other replicas will sync with the new master, they will try to perform a partial resynchronization using the old master replication ID. This will work as expected, because when the replica is promoted to master it sets its secondary ID to its main ID, remembering what was the offset when this ID switch happened. Later it will select a new random replication ID, because a new history begins. When handling the new replicas connecting, the master will match their IDs and offsets both with the current ID and the secondary ID (up to a given offset, for safety). In short this means that after a failover, replicas connecting to the newly promoted master don't have to perform a full sync.</p> <p>In case you wonder why a replica promoted to master needs to change its replication ID after a failover: it is possible that the old master is still working as a master because of some network partition: retaining the same replication ID would violate the fact that the same ID and same offset of any two random instances mean they have the same data set.</p>"},{"location":"7-management/replication/#diskless-replication","title":"Diskless replication","text":"<p>Normally a full resynchronization requires creating an RDB file on disk, then reloading the same RDB from disk to feed the replicas with the data.</p> <p>With slow disks this can be a very stressing operation for the master. Redis version 2.8.18 is the first version to have support for diskless replication. In this setup the child process directly sends the RDB over the wire to replicas, without using the disk as intermediate storage.</p>"},{"location":"7-management/replication/#configuration","title":"Configuration","text":"<p>To configure basic Redis replication is trivial: just add the following line to the replica configuration file:</p> <pre><code>replicaof 192.168.1.1 6379\n</code></pre> <p>Of course you need to replace 192.168.1.1 6379 with your master IP address (or hostname) and port. Alternatively, you can call the <code>REPLICAOF</code> command and the master host will start a sync with the replica.</p> <p>There are also a few parameters for tuning the replication backlog taken in memory by the master to perform the partial resynchronization. See the example <code>redis.conf</code> shipped with the Redis distribution for more information.</p> <p>Diskless replication can be enabled using the <code>repl-diskless-sync</code> configuration parameter. The delay to start the transfer to wait for more replicas to arrive after the first one is controlled by the <code>repl-diskless-sync-delay</code> parameter. Please refer to the example <code>redis.conf</code> file in the Redis distribution for more details.</p>"},{"location":"7-management/replication/#read-only-replica","title":"Read-only replica","text":"<p>Since Redis 2.6, replicas support a read-only mode that is enabled by default. This behavior is controlled by the <code>replica-read-only</code> option in the redis.conf file, and can be enabled and disabled at runtime using <code>CONFIG SET</code>.</p> <p>Read-only replicas will reject all write commands, so that it is not possible to write to a replica because of a mistake. This does not mean that the feature is intended to expose a replica instance to the internet or more generally to a network where untrusted clients exist, because administrative commands like <code>DEBUG</code> or <code>CONFIG</code> are still enabled. The Security page describes how to secure a Redis instance.</p> <p>You may wonder why it is possible to revert the read-only setting and have replica instances that can be targeted by write operations. The answer is that writable replicas exist only for historical reasons. Using writable replicas can result in inconsistency between the master and the replica, so it is not recommended to use writable replicas. To understand in which situations this can be a problem, we need to understand how replication works. Changes on the master is replicated by propagating regular Redis commands to the replica. When a key expires on the master, this is propagated as a DEL command. If a key which exists on the master but is deleted, expired or has a different type on the replica compared to the master will react differently to commands like DEL, INCR or RPOP propagated from the master than intended. The propagated command may fail on the replica or result in a different outcome. To minimize the risks (if you insist on using writable replicas) we suggest you follow these recommendations:</p> <ul> <li> <p>Don't write to keys in a writable replica that are also used on the master.   (This can be hard to guarantee if you don't have control over all the clients that write to the master.)</p> </li> <li> <p>Don't configure an instance as a writable replica as an intermediary step when upgrading a set of instances in a running system.   In general, don't configure an instance as a writable replica if it can ever be promoted to a master if you want to guarantee data consistency.</p> </li> </ul> <p>Historically, there were some use cases that were considered legitimate for writable replicas. As of version 7.0, these use cases are now all obsolete and the same can be achieved by other means. For example:</p> <ul> <li> <p>Computing slow Set or Sorted set operations and storing the result in temporary local keys using commands like <code>SUNIONSTORE</code> and <code>ZINTERSTORE</code>.   Instead, use commands that return the result without storing it, such as <code>SUNION</code> and <code>ZINTER</code>.</p> </li> <li> <p>Using the <code>SORT</code> command (which is not considered a read-only command because of the optional STORE option and therefore cannot be used on a read-only replica).   Instead, use <code>SORT_RO</code>, which is a read-only command.</p> </li> <li> <p>Using <code>EVAL</code> and <code>EVALSHA</code> are also not considered read-only commands, because the Lua script may call write commands.   Instead, use <code>EVAL_RO</code> and <code>EVALSHA_RO</code> where the Lua script can only call read-only commands.</p> </li> </ul> <p>While writes to a replica will be discarded if the replica and the master resync or if the replica is restarted, there is no guarantee that they will sync automatically.</p> <p>Before version 4.0, writable replicas were incapable of expiring keys with a time to live set. This means that if you use <code>EXPIRE</code> or other commands that set a maximum TTL for a key, the key will leak, and while you may no longer see it while accessing it with read commands, you will see it in the count of keys and it will still use memory. Redis 4.0 RC3 and greater versions are able to evict keys with TTL as masters do, with the exceptions of keys written in DB numbers greater than 63 (but by default Redis instances only have 16 databases). Note though that even in versions greater than 4.0, using <code>EXPIRE</code> on a key that could ever exists on the master can cause inconsistency between the replica and the master.</p> <p>Also note that since Redis 4.0 replica writes are only local, and are not propagated to sub-replicas attached to the instance. Sub-replicas instead will always receive the replication stream identical to the one sent by the top-level master to the intermediate replicas. So for example in the following setup:</p> <pre><code>A ---&gt; B ---&gt; C\n</code></pre> <p>Even if <code>B</code> is writable, C will not see <code>B</code> writes and will instead have identical dataset as the master instance <code>A</code>.</p>"},{"location":"7-management/replication/#setting-a-replica-to-authenticate-to-a-master","title":"Setting a replica to authenticate to a master","text":"<p>If your master has a password via <code>requirepass</code>, it's trivial to configure the replica to use that password in all sync operations.</p> <p>To do it on a running instance, use <code>redis-cli</code> and type:</p> <pre><code>config set masterauth &lt;password&gt;\n</code></pre> <p>To set it permanently, add this to your config file:</p> <pre><code>masterauth &lt;password&gt;\n</code></pre>"},{"location":"7-management/replication/#allow-writes-only-with-n-attached-replicas","title":"Allow writes only with N attached replicas","text":"<p>Starting with Redis 2.8, you can configure a Redis master to accept write queries only if at least N replicas are currently connected to the master.</p> <p>However, because Redis uses asynchronous replication it is not possible to ensure the replica actually received a given write, so there is always a window for data loss.</p> <p>This is how the feature works:</p> <ul> <li>Redis replicas ping the master every second, acknowledging the amount of replication stream processed.</li> <li>Redis masters will remember the last time it received a ping from every replica.</li> <li>The user can configure a minimum number of replicas that have a lag not greater than a maximum number of seconds.</li> </ul> <p>If there are at least N replicas, with a lag less than M seconds, then the write will be accepted.</p> <p>You may think of it as a best effort data safety mechanism, where consistency is not ensured for a given write, but at least the time window for data loss is restricted to a given number of seconds. In general bound data loss is better than unbound one.</p> <p>If the conditions are not met, the master will instead reply with an error and the write will not be accepted.</p> <p>There are two configuration parameters for this feature:</p> <ul> <li>min-replicas-to-write <code>&lt;number of replicas&gt;</code></li> <li>min-replicas-max-lag <code>&lt;number of seconds&gt;</code></li> </ul> <p>For more information, please check the example <code>redis.conf</code> file shipped with the Redis source distribution.</p>"},{"location":"7-management/replication/#how-redis-replication-deals-with-expires-on-keys","title":"How Redis replication deals with expires on keys","text":"<p>Redis expires allow keys to have a limited time to live (TTL). Such a feature depends on the ability of an instance to count the time, however Redis replicas correctly replicate keys with expires, even when such keys are altered using Lua scripts.</p> <p>To implement such a feature Redis cannot rely on the ability of the master and replica to have synced clocks, since this is a problem that cannot be solved and would result in race conditions and diverging data sets, so Redis uses three main techniques to make the replication of expired keys able to work:</p> <ol> <li>Replicas don't expire keys, instead they wait for masters to expire the keys. When a master expires a key (or evict it because of LRU), it synthesizes a <code>DEL</code> command which is transmitted to all the replicas.</li> <li>However because of master-driven expire, sometimes replicas may still have in memory keys that are already logically expired, since the master was not able to provide the <code>DEL</code> command in time. To deal with that the replica uses its logical clock to report that a key does not exist only for read operations that don't violate the consistency of the data set (as new commands from the master will arrive). In this way replicas avoid reporting logically expired keys that are still existing. In practical terms, an HTML fragments cache that uses replicas to scale will avoid returning items that are already older than the desired time to live.</li> <li>During Lua scripts executions no key expiries are performed. As a Lua script runs, conceptually the time in the master is frozen, so that a given key will either exist or not for all the time the script runs. This prevents keys expiring in the middle of a script, and is needed to send the same script to the replica in a way that is guaranteed to have the same effects in the data set.</li> </ol> <p>Once a replica is promoted to a master it will start to expire keys independently, and will not require any help from its old master.</p>"},{"location":"7-management/replication/#configuring-replication-in-docker-and-nat","title":"Configuring replication in Docker and NAT","text":"<p>When Docker, or other types of containers using port forwarding, or Network Address Translation is used, Redis replication needs some extra care, especially when using Redis Sentinel or other systems where the master <code>INFO</code> or <code>ROLE</code> commands output is scanned to discover replicas' addresses.</p> <p>The problem is that the <code>ROLE</code> command, and the replication section of the <code>INFO</code> output, when issued into a master instance, will show replicas as having the IP address they use to connect to the master, which, in environments using NAT may be different compared to the logical address of the replica instance (the one that clients should use to connect to replicas).</p> <p>Similarly the replicas will be listed with the listening port configured into <code>redis.conf</code>, that may be different from the forwarded port in case the port is remapped.</p> <p>To fix both issues, it is possible, since Redis 3.2.2, to force a replica to announce an arbitrary pair of IP and port to the master. The two configurations directives to use are:</p> <pre><code>replica-announce-ip 5.5.5.5\nreplica-announce-port 1234\n</code></pre> <p>And are documented in the example <code>redis.conf</code> of recent Redis distributions.</p>"},{"location":"7-management/replication/#the-info-and-role-command","title":"The INFO and ROLE command","text":"<p>There are two Redis commands that provide a lot of information on the current replication parameters of master and replica instances. One is <code>INFO</code>. If the command is called with the <code>replication</code> argument as <code>INFO replication</code> only information relevant to the replication are displayed. Another more computer-friendly command is <code>ROLE</code>, that provides the replication status of masters and replicas together with their replication offsets, list of connected replicas and so forth.</p>"},{"location":"7-management/replication/#partial-sync-after-restarts-and-failovers","title":"Partial sync after restarts and failovers","text":"<p>Since Redis 4.0, when an instance is promoted to master after a failover, it will still be able to perform a partial resynchronization with the replicas of the old master. To do so, the replica remembers the old replication ID and offset of its former master, so can provide part of the backlog to the connecting replicas even if they ask for the old replication ID.</p> <p>However the new replication ID of the promoted replica will be different, since it constitutes a different history of the data set. For example, the master can return available and can continue accepting writes for some time, so using the same replication ID in the promoted replica would violate the rule that a replication ID and offset pair identifies only a single data set.</p> <p>Moreover, replicas - when powered off gently and restarted - are able to store in the <code>RDB</code> file the information needed to resync with their master. This is useful in case of upgrades. When this is needed, it is better to use the <code>SHUTDOWN</code> command in order to perform a <code>save &amp; quit</code> operation on the replica.</p> <p>It is not possible to partially sync a replica that restarted via the AOF file. However the instance may be turned to RDB persistence before shutting down it, than can be restarted, and finally AOF can be enabled again.</p>"},{"location":"7-management/replication/#maxmemory-on-replicas","title":"<code>Maxmemory</code> on replicas","text":"<p>By default, a replica will ignore <code>maxmemory</code> (unless it is promoted to master after a failover or manually). It means that the eviction of keys will be handled by the master, sending the DEL commands to the replica as keys evict in the master side.</p> <p>This behavior ensures that masters and replicas stay consistent, which is usually what you want. However, if your replica is writable, or you want the replica to have a different memory setting, and you are sure all the writes performed to the replica are idempotent, then you may change this default (but be sure to understand what you are doing).</p> <p>Note that since the replica by default does not evict, it may end up using more memory than what is set via <code>maxmemory</code> (since there are certain buffers that may be larger on the replica, or data structures may sometimes take more memory and so forth). Make sure you monitor your replicas, and make sure they have enough memory to never hit a real out-of-memory condition before the master hits the configured <code>maxmemory</code> setting.</p> <p>To change this behavior, you can allow a replica to not ignore the <code>maxmemory</code>. The configuration directives to use is:</p> <pre><code>replica-ignore-maxmemory no\n</code></pre>"},{"location":"7-management/scaling/","title":"Scale with Redis Cluster","text":"<p>Redis scales horizontally with a deployment topology called Redis Cluster.  This topic will teach you how to set up, test, and operate Redis Cluster in production. You will learn about the availability and consistency characteristics of Redis Cluster from the end user's point of view.</p> <p>If you plan to run a production Redis Cluster deployment or want to understand better how Redis Cluster works internally, consult the Redis Cluster specification. To learn how Redis Enterprise handles scaling, see Linear Scaling with Redis Enterprise.</p>"},{"location":"7-management/scaling/#redis-cluster-101","title":"Redis Cluster 101","text":"<p>Redis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes.  Redis Cluster also provides some degree of availability during partitions\u2014in practical terms, the ability to continue operations when some nodes fail or are unable to communicate.  However, the cluster will become unavailable in the event of larger failures (for example, when the majority of masters are unavailable).</p> <p>So, with Redis Cluster, you get the ability to:</p> <ul> <li>Automatically split your dataset among multiple nodes.</li> <li>Continue operations when a subset of the nodes are experiencing failures or are unable to communicate with the rest of the cluster.</li> </ul>"},{"location":"7-management/scaling/#redis-cluster-tcp-ports","title":"Redis Cluster TCP ports","text":"<p>Every Redis Cluster node requires two open TCP connections: a Redis TCP port used to serve clients, e.g., 6379, and second port known as the cluster bus port.  By default, the cluster bus port is set by adding 10000 to the data port (e.g., 16379); however, you can override this in the <code>cluster-port</code> configuration.</p> <p>Cluster bus is a node-to-node communication channel that uses a binary protocol, which is more suited to exchanging information between nodes due to little bandwidth and processing time.  Nodes use the cluster bus for failure detection, configuration updates, failover authorization, and so forth.  Clients should never try to communicate with the cluster bus port, but rather use the Redis command port.  However, make sure you open both ports in your firewall, otherwise Redis cluster nodes won't be able to communicate.</p> <p>For a Redis Cluster to work properly you need, for each node:</p> <ol> <li>The client communication port (usually 6379) used to communicate with clients and be open to all the clients that need to reach the cluster, plus all the other cluster nodes that use the client port for key migrations.</li> <li>The cluster bus port must be reachable from all the other cluster nodes.</li> </ol> <p>If you don't open both TCP ports, your cluster will not work as expected.</p>"},{"location":"7-management/scaling/#redis-cluster-and-docker","title":"Redis Cluster and Docker","text":"<p>Currently, Redis Cluster does not support NATted environments and in general environments where IP addresses or TCP ports are remapped.</p> <p>Docker uses a technique called port mapping: programs running inside Docker containers may be exposed with a different port compared to the one the program believes to be using.  This is useful for running multiple containers using the same ports, at the same time, in the same server.</p> <p>To make Docker compatible with Redis Cluster, you need to use Docker's host networking mode.  Please see the <code>--net=host</code> option in the Docker documentation for more information.</p>"},{"location":"7-management/scaling/#redis-cluster-data-sharding","title":"Redis Cluster data sharding","text":"<p>Redis Cluster does not use consistent hashing, but a different form of sharding where every key is conceptually part of what we call a hash slot.</p> <p>There are 16384 hash slots in Redis Cluster, and to compute the hash slot for a given key, we simply take the CRC16 of the key modulo 16384.</p> <p>Every node in a Redis Cluster is responsible for a subset of the hash slots, so, for example, you may have a cluster with 3 nodes, where:</p> <ul> <li>Node A contains hash slots from 0 to 5500.</li> <li>Node B contains hash slots from 5501 to 11000.</li> <li>Node C contains hash slots from 11001 to 16383.</li> </ul> <p>This makes it easy to add and remove cluster nodes. For example, if I want to add a new node D, I need to move some hash slots from nodes A, B, C to D. Similarly, if I want to remove node A from the cluster, I can just move the hash slots served by A to B and C. Once node A is empty, I can remove it from the cluster completely.</p> <p>Moving hash slots from a node to another does not require stopping any operations; therefore, adding and removing nodes, or changing the percentage of hash slots held by a node, requires no downtime.</p> <p>Redis Cluster supports multiple key operations as long as all of the keys involved in a single command execution (or whole transaction, or Lua script execution) belong to the same hash slot. The user can force multiple keys to be part of the same hash slot by using a feature called hash tags.</p> <p>Hash tags are documented in the Redis Cluster specification, but the gist is that if there is a substring between {} brackets in a key, only what is inside the string is hashed. For example, the keys <code>user:{123}:profile</code> and <code>user:{123}:account</code> are guaranteed to be in the same hash slot because they share the same hash tag. As a result, you can operate on these two keys in the same multi-key operation.</p>"},{"location":"7-management/scaling/#redis-cluster-master-replica-model","title":"Redis Cluster master-replica model","text":"<p>To remain available when a subset of master nodes are failing or are not able to communicate with the majority of nodes, Redis Cluster uses a master-replica model where every hash slot has from 1 (the master itself) to N replicas (N-1 additional replica nodes).</p> <p>In our example cluster with nodes A, B, C, if node B fails the cluster is not able to continue, since we no longer have a way to serve hash slots in the range 5501-11000.</p> <p>However, when the cluster is created (or at a later time), we add a replica node to every master, so that the final cluster is composed of A, B, C that are master nodes, and A1, B1, C1 that are replica nodes. This way, the system can continue if node B fails.</p> <p>Node B1 replicates B, and B fails, the cluster will promote node B1 as the new master and will continue to operate correctly.</p> <p>However, note that if nodes B and B1 fail at the same time, Redis Cluster will not be able to continue to operate.</p>"},{"location":"7-management/scaling/#redis-cluster-consistency-guarantees","title":"Redis Cluster consistency guarantees","text":"<p>Redis Cluster does not guarantee strong consistency. In practical terms this means that under certain conditions it is possible that Redis Cluster will lose writes that were acknowledged by the system to the client.</p> <p>The first reason why Redis Cluster can lose writes is because it uses asynchronous replication. This means that during writes the following happens:</p> <ul> <li>Your client writes to the master B.</li> <li>The master B replies OK to your client.</li> <li>The master B propagates the write to its replicas B1, B2 and B3.</li> </ul> <p>As you can see, B does not wait for an acknowledgement from B1, B2, B3 before replying to the client, since this would be a prohibitive latency penalty for Redis, so if your client writes something, B acknowledges the write, but crashes before being able to send the write to its replicas, one of the replicas (that did not receive the write) can be promoted to master, losing the write forever.</p> <p>This is very similar to what happens with most databases that are configured to flush data to disk every second, so it is a scenario you are already able to reason about because of past experiences with traditional database systems not involving distributed systems. Similarly you can improve consistency by forcing the database to flush data to disk before replying to the client, but this usually results in prohibitively low performance. That would be the equivalent of synchronous replication in the case of Redis Cluster.</p> <p>Basically, there is a trade-off to be made between performance and consistency.</p> <p>Redis Cluster has support for synchronous writes when absolutely needed, implemented via the <code>WAIT</code> command. This makes losing writes a lot less likely. However, note that Redis Cluster does not implement strong consistency even when synchronous replication is used: it is always possible, under more complex failure scenarios, that a replica that was not able to receive the write will be elected as master.</p> <p>There is another notable scenario where Redis Cluster will lose writes, that happens during a network partition where a client is isolated with a minority of instances including at least a master.</p> <p>Take as an example our 6 nodes cluster composed of A, B, C, A1, B1, C1, with 3 masters and 3 replicas. There is also a client, that we will call Z1.</p> <p>After a partition occurs, it is possible that in one side of the partition we have A, C, A1, B1, C1, and in the other side we have B and Z1.</p> <p>Z1 is still able to write to B, which will accept its writes. If the partition heals in a very short time, the cluster will continue normally. However, if the partition lasts enough time for B1 to be promoted to master on the majority side of the partition, the writes that Z1 has sent to B in the meantime will be lost.</p> <p>{{% alert title=\"Note\" color=\"info\" %}} There is a maximum window to the amount of writes Z1 will be able to send to B: if enough time has elapsed for the majority side of the partition to elect a replica as master, every master node in the minority side will have stopped accepting writes. {{% /alert %}}</p> <p>This amount of time is a very important configuration directive of Redis Cluster, and is called the node timeout.</p> <p>After node timeout has elapsed, a master node is considered to be failing, and can be replaced by one of its replicas. Similarly, after node timeout has elapsed without a master node to be able to sense the majority of the other master nodes, it enters an error state and stops accepting writes.</p>"},{"location":"7-management/scaling/#redis-cluster-configuration-parameters","title":"Redis Cluster configuration parameters","text":"<p>We are about to create an example cluster deployment.  Before we continue, let's introduce the configuration parameters that Redis Cluster introduces in the <code>redis.conf</code> file.</p> <ul> <li>cluster-enabled <code>&lt;yes/no&gt;</code>: If yes, enables Redis Cluster support in a specific Redis instance. Otherwise the instance starts as a standalone instance as usual.</li> <li>cluster-config-file <code>&lt;filename&gt;</code>: Note that despite the name of this option, this is not a user editable configuration file, but the file where a Redis Cluster node automatically persists the cluster configuration (the state, basically) every time there is a change, in order to be able to re-read it at startup. The file lists things like the other nodes in the cluster, their state, persistent variables, and so forth. Often this file is rewritten and flushed on disk as a result of some message reception.</li> <li>cluster-node-timeout <code>&lt;milliseconds&gt;</code>: The maximum amount of time a Redis Cluster node can be unavailable, without it being considered as failing. If a master node is not reachable for more than the specified amount of time, it will be failed over by its replicas. This parameter controls other important things in Redis Cluster. Notably, every node that can't reach the majority of master nodes for the specified amount of time, will stop accepting queries.</li> <li>cluster-slave-validity-factor <code>&lt;factor&gt;</code>: If set to zero, a replica will always consider itself valid, and will therefore always try to failover a master, regardless of the amount of time the link between the master and the replica remained disconnected. If the value is positive, a maximum disconnection time is calculated as the node timeout value multiplied by the factor provided with this option, and if the node is a replica, it will not try to start a failover if the master link was disconnected for more than the specified amount of time. For example, if the node timeout is set to 5 seconds and the validity factor is set to 10, a replica disconnected from the master for more than 50 seconds will not try to failover its master. Note that any value different than zero may result in Redis Cluster being unavailable after a master failure if there is no replica that is able to failover it. In that case the cluster will return to being available only when the original master rejoins the cluster.</li> <li>cluster-migration-barrier <code>&lt;count&gt;</code>: Minimum number of replicas a master will remain connected with, for another replica to migrate to a master which is no longer covered by any replica. See the appropriate section about replica migration in this tutorial for more information.</li> <li>cluster-require-full-coverage <code>&lt;yes/no&gt;</code>: If this is set to yes, as it is by default, the cluster stops accepting writes if some percentage of the key space is not covered by any node. If the option is set to no, the cluster will still serve queries even if only requests about a subset of keys can be processed.</li> <li>cluster-allow-reads-when-down <code>&lt;yes/no&gt;</code>: If this is set to no, as it is by default, a node in a Redis Cluster will stop serving all traffic when the cluster is marked as failed, either when a node can't reach a quorum of masters or when full coverage is not met. This prevents reading potentially inconsistent data from a node that is unaware of changes in the cluster. This option can be set to yes to allow reads from a node during the fail state, which is useful for applications that want to prioritize read availability but still want to prevent inconsistent writes. It can also be used for when using Redis Cluster with only one or two shards, as it allows the nodes to continue serving writes when a master fails but automatic failover is impossible.</li> </ul>"},{"location":"7-management/scaling/#create-and-use-a-redis-cluster","title":"Create and use a Redis Cluster","text":"<p>To create and use a Redis Cluster, follow these steps:</p> <ul> <li>Create a Redis Cluster</li> <li>Interact with the cluster</li> <li>Write an example app with redis-rb-cluster</li> <li>Reshard the cluster</li> <li>A more interesting example application</li> <li>Test the failover</li> <li>Manual failover</li> <li>Add a new node</li> <li>Remove a node</li> <li>Replica migration</li> <li>Upgrade nodes in a Redis Cluster</li> <li>Migrate to Redis Cluster</li> </ul> <p>But, first, familiarize yourself with the requirements for creating a cluster.</p>"},{"location":"7-management/scaling/#requirements-to-create-a-redis-cluster","title":"Requirements to create a Redis Cluster","text":"<p>To create a cluster, the first thing you need is to have a few empty Redis instances running in cluster mode. </p> <p>At minimum, set the following directives in the <code>redis.conf</code> file:</p> <pre><code>port 7000\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 5000\nappendonly yes\n</code></pre> <p>To enable cluster mode, set the <code>cluster-enabled</code> directive to <code>yes</code>. Every instance also contains the path of a file where the configuration for this node is stored, which by default is <code>nodes.conf</code>. This file is never touched by humans; it is simply generated at startup by the Redis Cluster instances, and updated every time it is needed.</p> <p>Note that the minimal cluster that works as expected must contain at least three master nodes. For deployment, we strongly recommend a six-node cluster, with three masters and three replicas.</p> <p>You can test this locally by creating the following directories named after the port number of the instance you'll run inside any given directory.</p> <p>For example:</p> <pre><code>mkdir cluster-test\ncd cluster-test\nmkdir 7000 7001 7002 7003 7004 7005\n</code></pre> <p>Create a <code>redis.conf</code> file inside each of the directories, from 7000 to 7005. As a template for your configuration file just use the small example above, but make sure to replace the port number <code>7000</code> with the right port number according to the directory name.</p> <p>You can start each instance as follows, each running in a separate terminal tab:</p> <p><pre><code>cd 7000\nredis-server ./redis.conf\n</code></pre> You'll see from the logs that every node assigns itself a new ID:</p> <pre><code>[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I'm 97a3a64667477371c4479320d683e4c8db5858b1\n</code></pre> <p>This ID will be used forever by this specific instance in order for the instance to have a unique name in the context of the cluster. Every node remembers every other node using this IDs, and not by IP or port. IP addresses and ports may change, but the unique node identifier will never change for all the life of the node. We call this identifier simply Node ID.</p>"},{"location":"7-management/scaling/#create-a-redis-cluster","title":"Create a Redis Cluster","text":"<p>Now that we have a number of instances running, you need to create your cluster by writing some meaningful configuration to the nodes.</p> <p>You can configure and execute individual instances manually or use the create-cluster script. Let's go over how you do it manually.</p> <p>To create the cluster, run:</p> <pre><code>redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \\\n127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \\\n--cluster-replicas 1\n</code></pre> <p>The command used here is create, since we want to create a new cluster. The option <code>--cluster-replicas 1</code> means that we want a replica for every master created.</p> <p>The other arguments are the list of addresses of the instances I want to use to create the new cluster.</p> <p><code>redis-cli</code> will propose a configuration. Accept the proposed configuration by typing yes. The cluster will be configured and joined, which means that instances will be bootstrapped into talking with each other. Finally, if everything has gone well, you'll see a message like this:</p> <pre><code>[OK] All 16384 slots covered\n</code></pre> <p>This means that there is at least one master instance serving each of the 16384 available slots.</p> <p>If you don't want to create a Redis Cluster by configuring and executing individual instances manually as explained above, there is a much simpler system (but you'll not learn the same amount of operational details).</p> <p>Find the <code>utils/create-cluster</code> directory in the Redis distribution. There is a script called <code>create-cluster</code> inside (same name as the directory it is contained into), it's a simple bash script. In order to start a 6 nodes cluster with 3 masters and 3 replicas just type the following commands:</p> <ol> <li><code>create-cluster start</code></li> <li><code>create-cluster create</code></li> </ol> <p>Reply to <code>yes</code> in step 2 when the <code>redis-cli</code> utility wants you to accept the cluster layout.</p> <p>You can now interact with the cluster, the first node will start at port 30001 by default. When you are done, stop the cluster with:</p> <ol> <li><code>create-cluster stop</code></li> </ol> <p>Please read the <code>README</code> inside this directory for more information on how to run the script.</p>"},{"location":"7-management/scaling/#interact-with-the-cluster","title":"Interact with the cluster","text":"<p>To connect to Redis Cluster, you'll need a cluster-aware Redis client.  See the documentation for your client of choice to determine its cluster support.</p> <p>You can also test your Redis Cluster using the <code>redis-cli</code> command line utility:</p> <pre><code>$ redis-cli -c -p 7000\nredis 127.0.0.1:7000&gt; set foo bar\n-&gt; Redirected to slot [12182] located at 127.0.0.1:7002\nOK\nredis 127.0.0.1:7002&gt; set hello world\n-&gt; Redirected to slot [866] located at 127.0.0.1:7000\nOK\nredis 127.0.0.1:7000&gt; get foo\n-&gt; Redirected to slot [12182] located at 127.0.0.1:7002\n\"bar\"\nredis 127.0.0.1:7002&gt; get hello\n-&gt; Redirected to slot [866] located at 127.0.0.1:7000\n\"world\"\n</code></pre> <p>{{% alert title=\"Note\" color=\"info\" %}}  If you created the cluster using the script, your nodes may listen on different ports, starting from 30001 by default. {{% /alert %}}</p> <p>The <code>redis-cli</code> cluster support is very basic, so it always uses the fact that Redis Cluster nodes are able to redirect a client to the right node. A serious client is able to do better than that, and cache the map between hash slots and nodes addresses, to directly use the right connection to the right node. The map is refreshed only when something changed in the cluster configuration, for example after a failover or after the system administrator changed the cluster layout by adding or removing nodes.</p>"},{"location":"7-management/scaling/#write-an-example-app-with-redis-rb-cluster","title":"Write an example app with redis-rb-cluster","text":"<p>Before going forward showing how to operate the Redis Cluster, doing things like a failover, or a resharding, we need to create some example application or at least to be able to understand the semantics of a simple Redis Cluster client interaction.</p> <p>In this way we can run an example and at the same time try to make nodes failing, or start a resharding, to see how Redis Cluster behaves under real world conditions. It is not very helpful to see what happens while nobody is writing to the cluster.</p> <p>This section explains some basic usage of redis-rb-cluster showing two examples.  The first is the following, and is the <code>example.rb</code> file inside the redis-rb-cluster distribution:</p> <pre><code>   1  require './cluster'\n   2\n   3  if ARGV.length != 2\n   4      startup_nodes = [\n   5          {:host =&gt; \"127.0.0.1\", :port =&gt; 7000},\n   6          {:host =&gt; \"127.0.0.1\", :port =&gt; 7001}\n   7      ]\n   8  else\n   9      startup_nodes = [\n  10          {:host =&gt; ARGV[0], :port =&gt; ARGV[1].to_i}\n  11      ]\n  12  end\n  13\n  14  rc = RedisCluster.new(startup_nodes,32,:timeout =&gt; 0.1)\n  15\n  16  last = false\n  17\n  18  while not last\n  19      begin\n  20          last = rc.get(\"__last__\")\n  21          last = 0 if !last\n  22      rescue =&gt; e\n  23          puts \"error #{e.to_s}\"\n  24          sleep 1\n  25      end\n  26  end\n  27\n  28  ((last.to_i+1)..1000000000).each{|x|\n  29      begin\n  30          rc.set(\"foo#{x}\",x)\n  31          puts rc.get(\"foo#{x}\")\n  32          rc.set(\"__last__\",x)\n  33      rescue =&gt; e\n  34          puts \"error #{e.to_s}\"\n  35      end\n  36      sleep 0.1\n  37  }\n</code></pre> <p>The application does a very simple thing, it sets keys in the form <code>foo&lt;number&gt;</code> to <code>number</code>, one after the other. So if you run the program the result is the following stream of commands:</p> <ul> <li>SET foo0 0</li> <li>SET foo1 1</li> <li>SET foo2 2</li> <li>And so forth...</li> </ul> <p>The program looks more complex than it should usually as it is designed to show errors on the screen instead of exiting with an exception, so every operation performed with the cluster is wrapped by <code>begin</code> <code>rescue</code> blocks.</p> <p>The line 14 is the first interesting line in the program. It creates the Redis Cluster object, using as argument a list of startup nodes, the maximum number of connections this object is allowed to take against different nodes, and finally the timeout after a given operation is considered to be failed.</p> <p>The startup nodes don't need to be all the nodes of the cluster. The important thing is that at least one node is reachable. Also note that redis-rb-cluster updates this list of startup nodes as soon as it is able to connect with the first node. You should expect such a behavior with any other serious client.</p> <p>Now that we have the Redis Cluster object instance stored in the rc variable, we are ready to use the object like if it was a normal Redis object instance.</p> <p>This is exactly what happens in line 18 to 26: when we restart the example we don't want to start again with <code>foo0</code>, so we store the counter inside Redis itself. The code above is designed to read this counter, or if the counter does not exist, to assign it the value of zero.</p> <p>However note how it is a while loop, as we want to try again and again even if the cluster is down and is returning errors. Normal applications don't need to be so careful.</p> <p>Lines between 28 and 37 start the main loop where the keys are set or an error is displayed.</p> <p>Note the <code>sleep</code> call at the end of the loop. In your tests you can remove the sleep if you want to write to the cluster as fast as possible (relatively to the fact that this is a busy loop without real parallelism of course, so you'll get the usually 10k ops/second in the best of the conditions).</p> <p>Normally writes are slowed down in order for the example application to be easier to follow by humans.</p> <p>Starting the application produces the following output:</p> <pre><code>ruby ./example.rb\n1\n2\n3\n4\n5\n6\n7\n8\n9\n^C (I stopped the program here)\n</code></pre> <p>This is not a very interesting program and we'll use a better one in a moment but we can already see what happens during a resharding when the program is running.</p>"},{"location":"7-management/scaling/#reshard-the-cluster","title":"Reshard the cluster","text":"<p>Now we are ready to try a cluster resharding. To do this, please keep the example.rb program running, so that you can see if there is some impact on the program running. Also, you may want to comment the <code>sleep</code> call to have some more serious write load during resharding.</p> <p>Resharding basically means to move hash slots from a set of nodes to another set of nodes.  Like cluster creation, it is accomplished using the redis-cli utility.</p> <p>To start a resharding, just type:</p> <pre><code>redis-cli --cluster reshard 127.0.0.1:7000\n</code></pre> <p>You only need to specify a single node, redis-cli will find the other nodes automatically.</p> <p>Currently redis-cli is only able to reshard with the administrator support, you can't just say move 5% of slots from this node to the other one (but this is pretty trivial to implement). So it starts with questions. The first is how much of a resharding do you want to do:</p> <pre><code>How many slots do you want to move (from 1 to 16384)?\n</code></pre> <p>We can try to reshard 1000 hash slots, that should already contain a non trivial amount of keys if the example is still running without the sleep call.</p> <p>Then redis-cli needs to know what is the target of the resharding, that is, the node that will receive the hash slots. I'll use the first master node, that is, 127.0.0.1:7000, but I need to specify the Node ID of the instance. This was already printed in a list by redis-cli, but I can always find the ID of a node with the following command if I need:</p> <pre><code>$ redis-cli -p 7000 cluster nodes | grep myself\n97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5460\n</code></pre> <p>Ok so my target node is 97a3a64667477371c4479320d683e4c8db5858b1.</p> <p>Now you'll get asked from what nodes you want to take those keys. I'll just type <code>all</code> in order to take a bit of hash slots from all the other master nodes.</p> <p>After the final confirmation you'll see a message for every slot that redis-cli is going to move from a node to another, and a dot will be printed for every actual key moved from one side to the other.</p> <p>While the resharding is in progress you should be able to see your example program running unaffected. You can stop and restart it multiple times during the resharding if you want.</p> <p>At the end of the resharding, you can test the health of the cluster with the following command:</p> <pre><code>redis-cli --cluster check 127.0.0.1:7000\n</code></pre> <p>All the slots will be covered as usual, but this time the master at 127.0.0.1:7000 will have more hash slots, something around 6461.</p> <p>Resharding can be performed automatically without the need to manually enter the parameters in an interactive way. This is possible using a command line like the following:</p> <pre><code>redis-cli --cluster reshard &lt;host&gt;:&lt;port&gt; --cluster-from &lt;node-id&gt; --cluster-to &lt;node-id&gt; --cluster-slots &lt;number of slots&gt; --cluster-yes\n</code></pre> <p>This allows to build some automatism if you are likely to reshard often, however currently there is no way for <code>redis-cli</code> to automatically rebalance the cluster checking the distribution of keys across the cluster nodes and intelligently moving slots as needed. This feature will be added in the future.</p> <p>The <code>--cluster-yes</code> option instructs the cluster manager to automatically answer \"yes\" to the command's prompts, allowing it to run in a non-interactive mode. Note that this option can also be activated by setting the <code>REDISCLI_CLUSTER_YES</code> environment variable.</p>"},{"location":"7-management/scaling/#a-more-interesting-example-application","title":"A more interesting example application","text":"<p>The example application we wrote early is not very good. It writes to the cluster in a simple way without even checking if what was written is the right thing.</p> <p>From our point of view the cluster receiving the writes could just always write the key <code>foo</code> to <code>42</code> to every operation, and we would not notice at all.</p> <p>So in the <code>redis-rb-cluster</code> repository, there is a more interesting application that is called <code>consistency-test.rb</code>. It uses a set of counters, by default 1000, and sends <code>INCR</code> commands in order to increment the counters.</p> <p>However instead of just writing, the application does two additional things:</p> <ul> <li>When a counter is updated using <code>INCR</code>, the application remembers the write.</li> <li>It also reads a random counter before every write, and check if the value is what we expected it to be, comparing it with the value it has in memory.</li> </ul> <p>What this means is that this application is a simple consistency checker, and is able to tell you if the cluster lost some write, or if it accepted a write that we did not receive acknowledgment for. In the first case we'll see a counter having a value that is smaller than the one we remember, while in the second case the value will be greater.</p> <p>Running the consistency-test application produces a line of output every second:</p> <pre><code>$ ruby consistency-test.rb\n925 R (0 err) | 925 W (0 err) |\n5030 R (0 err) | 5030 W (0 err) |\n9261 R (0 err) | 9261 W (0 err) |\n13517 R (0 err) | 13517 W (0 err) |\n17780 R (0 err) | 17780 W (0 err) |\n22025 R (0 err) | 22025 W (0 err) |\n25818 R (0 err) | 25818 W (0 err) |\n</code></pre> <p>The line shows the number of Reads and Writes performed, and the number of errors (query not accepted because of errors since the system was not available).</p> <p>If some inconsistency is found, new lines are added to the output. This is what happens, for example, if I reset a counter manually while the program is running:</p> <pre><code>$ redis-cli -h 127.0.0.1 -p 7000 set key_217 0\nOK\n\n(in the other tab I see...)\n\n94774 R (0 err) | 94774 W (0 err) |\n98821 R (0 err) | 98821 W (0 err) |\n102886 R (0 err) | 102886 W (0 err) | 114 lost |\n107046 R (0 err) | 107046 W (0 err) | 114 lost |\n</code></pre> <p>When I set the counter to 0 the real value was 114, so the program reports 114 lost writes (<code>INCR</code> commands that are not remembered by the cluster).</p> <p>This program is much more interesting as a test case, so we'll use it to test the Redis Cluster failover.</p>"},{"location":"7-management/scaling/#test-the-failover","title":"Test the failover","text":"<p>To trigger the failover, the simplest thing we can do (that is also the semantically simplest failure that can occur in a distributed system) is to crash a single process, in our case a single master.</p> <p>{{% alert title=\"Note\" color=\"info\" %}}  During this test, you should take a tab open with the consistency test application running. {{% /alert %}} </p> <p>We can identify a master and crash it with the following command:</p> <pre><code>$ redis-cli -p 7000 cluster nodes | grep master\n3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385482984082 0 connected 5960-10921\n2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 master - 0 1385482983582 0 connected 11423-16383\n97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422\n</code></pre> <p>Ok, so 7000, 7001, and 7002 are masters. Let's crash node 7002 with the DEBUG SEGFAULT command:</p> <pre><code>$ redis-cli -p 7002 debug segfault\nError: Server closed the connection\n</code></pre> <p>Now we can look at the output of the consistency test to see what it reported.</p> <pre><code>18849 R (0 err) | 18849 W (0 err) |\n23151 R (0 err) | 23151 W (0 err) |\n27302 R (0 err) | 27302 W (0 err) |\n\n... many error warnings here ...\n\n29659 R (578 err) | 29660 W (577 err) |\n33749 R (578 err) | 33750 W (577 err) |\n37918 R (578 err) | 37919 W (577 err) |\n42077 R (578 err) | 42078 W (577 err) |\n</code></pre> <p>As you can see during the failover the system was not able to accept 578 reads and 577 writes, however no inconsistency was created in the database. This may sound unexpected as in the first part of this tutorial we stated that Redis Cluster can lose writes during the failover because it uses asynchronous replication. What we did not say is that this is not very likely to happen because Redis sends the reply to the client, and the commands to replicate to the replicas, about at the same time, so there is a very small window to lose data. However the fact that it is hard to trigger does not mean that it is impossible, so this does not change the consistency guarantees provided by Redis cluster.</p> <p>We can now check what is the cluster setup after the failover (note that in the meantime I restarted the crashed instance so that it rejoins the cluster as a replica):</p> <pre><code>$ redis-cli -p 7000 cluster nodes\n3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385503418521 0 connected\na211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385503419023 0 connected\n97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422\n3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385503419023 3 connected 11423-16383\n3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385503417005 0 connected 5960-10921\n2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385503418016 3 connected\n</code></pre> <p>Now the masters are running on ports 7000, 7001 and 7005. What was previously a master, that is the Redis instance running on port 7002, is now a replica of 7005.</p> <p>The output of the <code>CLUSTER NODES</code> command may look intimidating, but it is actually pretty simple, and is composed of the following tokens:</p> <ul> <li>Node ID</li> <li>ip:port</li> <li>flags: master, replica, myself, fail, ...</li> <li>if it is a replica, the Node ID of the master</li> <li>Time of the last pending PING still waiting for a reply.</li> <li>Time of the last PONG received.</li> <li>Configuration epoch for this node (see the Cluster specification).</li> <li>Status of the link to this node.</li> <li>Slots served...</li> </ul>"},{"location":"7-management/scaling/#manual-failover","title":"Manual failover","text":"<p>Sometimes it is useful to force a failover without actually causing any problem on a master. For example, to upgrade the Redis process of one of the master nodes it is a good idea to failover it to turn it into a replica with minimal impact on availability.</p> <p>Manual failovers are supported by Redis Cluster using the <code>CLUSTER FAILOVER</code> command, that must be executed in one of the replicas of the master you want to failover.</p> <p>Manual failovers are special and are safer compared to failovers resulting from actual master failures. They occur in a way that avoids data loss in the process, by switching clients from the original master to the new master only when the system is sure that the new master processed all the replication stream from the old one.</p> <p>This is what you see in the replica log when you perform a manual failover:</p> <pre><code># Manual failover user request accepted.\n# Received replication offset for paused master manual failover: 347540\n# All master replication stream processed, manual failover can start.\n# Start of election delayed for 0 milliseconds (rank #0, offset 347540).\n# Starting a failover election for epoch 7545.\n# Failover election won: I'm the new master.\n</code></pre> <p>Basically clients connected to the master we are failing over are stopped. At the same time the master sends its replication offset to the replica, that waits to reach the offset on its side. When the replication offset is reached, the failover starts, and the old master is informed about the configuration switch. When the clients are unblocked on the old master, they are redirected to the new master.</p> <p>{{% alert title=\"Note\" color=\"info\" %}}  To promote a replica to master, it must first be known as a replica by a majority of the masters in the cluster.   Otherwise, it cannot win the failover election.   If the replica has just been added to the cluster (see Add a new node as a replica), you may need to wait a while before sending the <code>CLUSTER FAILOVER</code> command, to make sure the masters in cluster are aware of the new replica. {{% /alert %}} </p>"},{"location":"7-management/scaling/#add-a-new-node","title":"Add a new node","text":"<p>Adding a new node is basically the process of adding an empty node and then moving some data into it, in case it is a new master, or telling it to setup as a replica of a known node, in case it is a replica.</p> <p>We'll show both, starting with the addition of a new master instance.</p> <p>In both cases the first step to perform is adding an empty node.</p> <p>This is as simple as to start a new node in port 7006 (we already used from 7000 to 7005 for our existing 6 nodes) with the same configuration used for the other nodes, except for the port number, so what you should do in order to conform with the setup we used for the previous nodes:</p> <ul> <li>Create a new tab in your terminal application.</li> <li>Enter the <code>cluster-test</code> directory.</li> <li>Create a directory named <code>7006</code>.</li> <li>Create a redis.conf file inside, similar to the one used for the other nodes but using 7006 as port number.</li> <li>Finally start the server with <code>../redis-server ./redis.conf</code></li> </ul> <p>At this point the server should be running.</p> <p>Now we can use redis-cli as usual in order to add the node to the existing cluster.</p> <pre><code>redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000\n</code></pre> <p>As you can see I used the add-node command specifying the address of the new node as first argument, and the address of a random existing node in the cluster as second argument.</p> <p>In practical terms redis-cli here did very little to help us, it just sent a <code>CLUSTER MEET</code> message to the node, something that is also possible to accomplish manually. However redis-cli also checks the state of the cluster before to operate, so it is a good idea to perform cluster operations always via redis-cli even when you know how the internals work.</p> <p>Now we can connect to the new node to see if it really joined the cluster:</p> <pre><code>redis 127.0.0.1:7006&gt; cluster nodes\n3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921\n3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected\nf093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected\n2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected\na211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected\n97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422\n3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383\n</code></pre> <p>Note that since this node is already connected to the cluster it is already able to redirect client queries correctly and is generally speaking part of the cluster. However it has two peculiarities compared to the other masters:</p> <ul> <li>It holds no data as it has no assigned hash slots.</li> <li>Because it is a master without assigned slots, it does not participate in the election process when a replica wants to become a master.</li> </ul> <p>Now it is possible to assign hash slots to this node using the resharding feature of <code>redis-cli</code>.  It is basically useless to show this as we already did in a previous section, there is no difference, it is just a resharding having as a target the empty node.</p>"},{"location":"7-management/scaling/#add-a-new-node-as-a-replica","title":"Add a new node as a replica","text":"<p>Adding a new replica can be performed in two ways. The obvious one is to use redis-cli again, but with the --cluster-slave option, like this:</p> <pre><code>redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-slave\n</code></pre> <p>Note that the command line here is exactly like the one we used to add a new master, so we are not specifying to which master we want to add the replica. In this case, what happens is that redis-cli will add the new node as replica of a random master among the masters with fewer replicas.</p> <p>However you can specify exactly what master you want to target with your new replica with the following command line:</p> <pre><code>redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-slave --cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e\n</code></pre> <p>This way we assign the new replica to a specific master.</p> <p>A more manual way to add a replica to a specific master is to add the new node as an empty master, and then turn it into a replica using the <code>CLUSTER REPLICATE</code> command. This also works if the node was added as a replica but you want to move it as a replica of a different master.</p> <p>For example in order to add a replica for the node 127.0.0.1:7005 that is currently serving hash slots in the range 11423-16383, that has a Node ID 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e, all I need to do is to connect with the new node (already added as empty master) and send the command:</p> <pre><code>redis 127.0.0.1:7006&gt; cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e\n</code></pre> <p>That's it. Now we have a new replica for this set of hash slots, and all the other nodes in the cluster already know (after a few seconds needed to update their config). We can verify with the following command:</p> <pre><code>$ redis-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e\nf093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected\n2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected\n</code></pre> <p>The node 3c3a0c... now has two replicas, running on ports 7002 (the existing one) and 7006 (the new one).</p>"},{"location":"7-management/scaling/#remove-a-node","title":"Remove a node","text":"<p>To remove a replica node just use the <code>del-node</code> command of redis-cli:</p> <pre><code>redis-cli --cluster del-node 127.0.0.1:7000 `&lt;node-id&gt;`\n</code></pre> <p>The first argument is just a random node in the cluster, the second argument is the ID of the node you want to remove.</p> <p>You can remove a master node in the same way as well, however in order to remove a master node it must be empty. If the master is not empty you need to reshard data away from it to all the other master nodes before.</p> <p>An alternative to remove a master node is to perform a manual failover of it over one of its replicas and remove the node after it turned into a replica of the new master. Obviously this does not help when you want to reduce the actual number of masters in your cluster, in that case, a resharding is needed.</p>"},{"location":"7-management/scaling/#replica-migration","title":"Replica migration","text":"<p>In Redis Cluster, you can reconfigure a replica to replicate with a different master at any time just using this command:</p> <pre><code>CLUSTER REPLICATE &lt;master-node-id&gt;\n</code></pre> <p>However there is a special scenario where you want replicas to move from one master to another one automatically, without the help of the system administrator. The automatic reconfiguration of replicas is called replicas migration and is able to improve the reliability of a Redis Cluster.</p> <p>{{% alert title=\"Note\" color=\"info\" %}}  You can read the details of replicas migration in the Redis Cluster Specification, here we'll only provide some information about the general idea and what you should do in order to benefit from it. {{% /alert %}} </p> <p>The reason why you may want to let your cluster replicas to move from one master to another under certain condition, is that usually the Redis Cluster is as resistant to failures as the number of replicas attached to a given master.</p> <p>For example a cluster where every master has a single replica can't continue operations if the master and its replica fail at the same time, simply because there is no other instance to have a copy of the hash slots the master was serving. However while net-splits are likely to isolate a number of nodes at the same time, many other kind of failures, like hardware or software failures local to a single node, are a very notable class of failures that are unlikely to happen at the same time, so it is possible that in your cluster where every master has a replica, the replica is killed at 4am, and the master is killed at 6am. This still will result in a cluster that can no longer operate.</p> <p>To improve reliability of the system we have the option to add additional replicas to every master, but this is expensive. Replica migration allows to add more replicas to just a few masters. So you have 10 masters with 1 replica each, for a total of 20 instances. However you add, for example, 3 instances more as replicas of some of your masters, so certain masters will have more than a single replica.</p> <p>With replicas migration what happens is that if a master is left without replicas, a replica from a master that has multiple replicas will migrate to the orphaned master. So after your replica goes down at 4am as in the example we made above, another replica will take its place, and when the master will fail as well at 5am, there is still a replica that can be elected so that the cluster can continue to operate.</p> <p>So what you should know about replicas migration in short?</p> <ul> <li>The cluster will try to migrate a replica from the master that has the greatest number of replicas in a given moment.</li> <li>To benefit from replica migration you have just to add a few more replicas to a single master in your cluster, it does not matter what master.</li> <li>There is a configuration parameter that controls the replica migration feature that is called <code>cluster-migration-barrier</code>: you can read more about it in the example <code>redis.conf</code> file provided with Redis Cluster.</li> </ul>"},{"location":"7-management/scaling/#upgrade-nodes-in-a-redis-cluster","title":"Upgrade nodes in a Redis Cluster","text":"<p>Upgrading replica nodes is easy since you just need to stop the node and restart it with an updated version of Redis. If there are clients scaling reads using replica nodes, they should be able to reconnect to a different replica if a given one is not available.</p> <p>Upgrading masters is a bit more complex, and the suggested procedure is:</p> <ol> <li>Use <code>CLUSTER FAILOVER</code> to trigger a manual failover of the master to one of its replicas.    (See the Manual failover in this topic.)</li> <li>Wait for the master to turn into a replica.</li> <li>Finally upgrade the node as you do for replicas.</li> <li>If you want the master to be the node you just upgraded, trigger a new manual failover in order to turn back the upgraded node into a master.</li> </ol> <p>Following this procedure you should upgrade one node after the other until all the nodes are upgraded.</p>"},{"location":"7-management/scaling/#migrate-to-redis-cluster","title":"Migrate to Redis Cluster","text":"<p>Users willing to migrate to Redis Cluster may have just a single master, or may already using a preexisting sharding setup, where keys are split among N nodes, using some in-house algorithm or a sharding algorithm implemented by their client library or Redis proxy.</p> <p>In both cases it is possible to migrate to Redis Cluster easily, however what is the most important detail is if multiple-keys operations are used by the application, and how. There are three different cases:</p> <ol> <li>Multiple keys operations, or transactions, or Lua scripts involving multiple keys, are not used. Keys are accessed independently (even if accessed via transactions or Lua scripts grouping multiple commands, about the same key, together).</li> <li>Multiple keys operations, or transactions, or Lua scripts involving multiple keys are used but only with keys having the same hash tag, which means that the keys used together all have a <code>{...}</code> sub-string that happens to be identical. For example the following multiple keys operation is defined in the context of the same hash tag: <code>SUNION {user:1000}.foo {user:1000}.bar</code>.</li> <li>Multiple keys operations, or transactions, or Lua scripts involving multiple keys are used with key names not having an explicit, or the same, hash tag.</li> </ol> <p>The third case is not handled by Redis Cluster: the application requires to be modified in order to not use multi keys operations or only use them in the context of the same hash tag.</p> <p>Case 1 and 2 are covered, so we'll focus on those two cases, that are handled in the same way, so no distinction will be made in the documentation.</p> <p>Assuming you have your preexisting data set split into N masters, where N=1 if you have no preexisting sharding, the following steps are needed in order to migrate your data set to Redis Cluster:</p> <ol> <li>Stop your clients. No automatic live-migration to Redis Cluster is currently possible. You may be able to do it orchestrating a live migration in the context of your application / environment.</li> <li>Generate an append only file for all of your N masters using the <code>BGREWRITEAOF</code> command, and waiting for the AOF file to be completely generated.</li> <li>Save your AOF files from aof-1 to aof-N somewhere. At this point you can stop your old instances if you wish (this is useful since in non-virtualized deployments you often need to reuse the same computers).</li> <li>Create a Redis Cluster composed of N masters and zero replicas. You'll add replicas later. Make sure all your nodes are using the append only file for persistence.</li> <li>Stop all the cluster nodes, substitute their append only file with your pre-existing append only files, aof-1 for the first node, aof-2 for the second node, up to aof-N.</li> <li>Restart your Redis Cluster nodes with the new AOF files. They'll complain that there are keys that should not be there according to their configuration.</li> <li>Use <code>redis-cli --cluster fix</code> command in order to fix the cluster so that keys will be migrated according to the hash slots each node is authoritative or not.</li> <li>Use <code>redis-cli --cluster check</code> at the end to make sure your cluster is ok.</li> <li>Restart your clients modified to use a Redis Cluster aware client library.</li> </ol> <p>There is an alternative way to import data from external instances to a Redis Cluster, which is to use the <code>redis-cli --cluster import</code> command.</p> <p>The command moves all the keys of a running instance (deleting the keys from the source instance) to the specified pre-existing Redis Cluster. However note that if you use a Redis 2.8 instance as source instance the operation may be slow since 2.8 does not implement migrate connection caching, so you may want to restart your source instance with a Redis 3.x version before to perform such operation.</p> <p>{{% alert title=\"Note\" color=\"info\" %}}  Starting with Redis 5, if not for backward compatibility, the Redis project no longer uses the word slave. Unfortunately in this command the word slave is part of the protocol, so we'll be able to remove such occurrences only when this API will be naturally deprecated. {{% /alert %}} </p>"},{"location":"7-management/scaling/#learn-more","title":"Learn more","text":"<ul> <li>Redis Cluster specification</li> <li>Linear Scaling with Redis Enterprise</li> <li>Docker documentation</li> </ul>"},{"location":"7-management/sentinel/","title":"High availability with Redis Sentinel","text":"<p>Redis Sentinel provides high availability for Redis when not using Redis Cluster. </p> <p>Redis Sentinel also provides other collateral tasks such as monitoring, notifications and acts as a configuration provider for clients.</p> <p>This is the full list of Sentinel capabilities at a macroscopic level (i.e. the big picture):</p> <ul> <li>Monitoring. Sentinel constantly checks if your master and replica instances are working as expected.</li> <li>Notification. Sentinel can notify the system administrator, or other computer programs, via an API, that something is wrong with one of the monitored Redis instances.</li> <li>Automatic failover. If a master is not working as expected, Sentinel can start a failover process where a replica is promoted to master, the other additional replicas are reconfigured to use the new master, and the applications using the Redis server are informed about the new address to use when connecting.</li> <li>Configuration provider. Sentinel acts as a source of authority for clients service discovery: clients connect to Sentinels in order to ask for the address of the current Redis master responsible for a given service. If a failover occurs, Sentinels will report the new address.</li> </ul>"},{"location":"7-management/sentinel/#sentinel-as-a-distributed-system","title":"Sentinel as a distributed system","text":"<p>Redis Sentinel is a distributed system:</p> <p>Sentinel itself is designed to run in a configuration where there are multiple Sentinel processes cooperating together. The advantage of having multiple Sentinel processes cooperating are the following:</p> <ol> <li>Failure detection is performed when multiple Sentinels agree about the fact a given master is no longer available. This lowers the probability of false positives.</li> <li>Sentinel works even if not all the Sentinel processes are working, making the system robust against failures. There is no fun in having a failover system which is itself a single point of failure, after all.</li> </ol> <p>The sum of Sentinels, Redis instances (masters and replicas) and clients connecting to Sentinel and Redis, are also a larger distributed system with specific properties. In this document concepts will be introduced gradually starting from basic information needed in order to understand the basic properties of Sentinel, to more complex information (that are optional) in order to understand how exactly Sentinel works.</p>"},{"location":"7-management/sentinel/#sentinel-quick-start","title":"Sentinel quick start","text":""},{"location":"7-management/sentinel/#obtaining-sentinel","title":"Obtaining Sentinel","text":"<p>The current version of Sentinel is called Sentinel 2. It is a rewrite of the initial Sentinel implementation using stronger and simpler-to-predict algorithms (that are explained in this documentation).</p> <p>A stable release of Redis Sentinel is shipped since Redis 2.8.</p> <p>New developments are performed in the unstable branch, and new features sometimes are back ported into the latest stable branch as soon as they are considered to be stable.</p> <p>Redis Sentinel version 1, shipped with Redis 2.6, is deprecated and should not be used.</p>"},{"location":"7-management/sentinel/#running-sentinel","title":"Running Sentinel","text":"<p>If you are using the <code>redis-sentinel</code> executable (or if you have a symbolic link with that name to the <code>redis-server</code> executable) you can run Sentinel with the following command line:</p> <pre><code>redis-sentinel /path/to/sentinel.conf\n</code></pre> <p>Otherwise you can use directly the <code>redis-server</code> executable starting it in Sentinel mode:</p> <pre><code>redis-server /path/to/sentinel.conf --sentinel\n</code></pre> <p>Both ways work the same.</p> <p>However it is mandatory to use a configuration file when running Sentinel, as this file will be used by the system in order to save the current state that will be reloaded in case of restarts. Sentinel will simply refuse to start if no configuration file is given or if the configuration file path is not writable.</p> <p>Sentinels by default run listening for connections to TCP port 26379, so for Sentinels to work, port 26379 of your servers must be open to receive connections from the IP addresses of the other Sentinel instances. Otherwise Sentinels can't talk and can't agree about what to do, so failover will never be performed.</p>"},{"location":"7-management/sentinel/#fundamental-things-to-know-about-sentinel-before-deploying","title":"Fundamental things to know about Sentinel before deploying","text":"<ol> <li>You need at least three Sentinel instances for a robust deployment.</li> <li>The three Sentinel instances should be placed into computers or virtual machines that are believed to fail in an independent way. So for example different physical servers or Virtual Machines executed on different availability zones.</li> <li>Sentinel + Redis distributed system does not guarantee that acknowledged writes are retained during failures, since Redis uses asynchronous replication. However there are ways to deploy Sentinel that make the window to lose writes limited to certain moments, while there are other less secure ways to deploy it.</li> <li>You need Sentinel support in your clients. Popular client libraries have Sentinel support, but not all.</li> <li>There is no HA setup which is safe if you don't test from time to time in development environments, or even better if you can, in production environments, if they work. You may have a misconfiguration that will become apparent only when it's too late (at 3am when your master stops working).</li> <li>Sentinel, Docker, or other forms of Network Address Translation or Port Mapping should be mixed with care: Docker performs port remapping, breaking Sentinel auto discovery of other Sentinel processes and the list of replicas for a master. Check the section about Sentinel and Docker later in this document for more information.</li> </ol>"},{"location":"7-management/sentinel/#configuring-sentinel","title":"Configuring Sentinel","text":"<p>The Redis source distribution contains a file called <code>sentinel.conf</code> that is a self-documented example configuration file you can use to configure Sentinel, however a typical minimal configuration file looks like the following:</p> <pre><code>sentinel monitor mymaster 127.0.0.1 6379 2\nsentinel down-after-milliseconds mymaster 60000\nsentinel failover-timeout mymaster 180000\nsentinel parallel-syncs mymaster 1\n\nsentinel monitor resque 192.168.1.3 6380 4\nsentinel down-after-milliseconds resque 10000\nsentinel failover-timeout resque 180000\nsentinel parallel-syncs resque 5\n</code></pre> <p>You only need to specify the masters to monitor, giving to each separated master (that may have any number of replicas) a different name. There is no need to specify replicas, which are auto-discovered. Sentinel will update the configuration automatically with additional information about replicas (in order to retain the information in case of restart). The configuration is also rewritten every time a replica is promoted to master during a failover and every time a new Sentinel is discovered.</p> <p>The example configuration above basically monitors two sets of Redis instances, each composed of a master and an undefined number of replicas. One set of instances is called <code>mymaster</code>, and the other <code>resque</code>.</p> <p>The meaning of the arguments of <code>sentinel monitor</code> statements is the following:</p> <pre><code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;\n</code></pre> <p>For the sake of clarity, let's check line by line what the configuration options mean:</p> <p>The first line is used to tell Redis to monitor a master called mymaster, that is at address 127.0.0.1 and port 6379, with a quorum of 2. Everything is pretty obvious but the quorum argument:</p> <ul> <li>The quorum is the number of Sentinels that need to agree about the fact the master is not reachable, in order to really mark the master as failing, and eventually start a failover procedure if possible.</li> <li>However the quorum is only used to detect the failure. In order to actually perform a failover, one of the Sentinels need to be elected leader for the failover and be authorized to proceed. This only happens with the vote of the majority of the Sentinel processes.</li> </ul> <p>So for example if you have 5 Sentinel processes, and the quorum for a given master set to the value of 2, this is what happens:</p> <ul> <li>If two Sentinels agree at the same time about the master being unreachable, one of the two will try to start a failover.</li> <li>If there are at least a total of three Sentinels reachable, the failover will be authorized and will actually start.</li> </ul> <p>In practical terms this means during failures Sentinel never starts a failover if the majority of Sentinel processes are unable to talk (aka no failover in the minority partition).</p>"},{"location":"7-management/sentinel/#other-sentinel-options","title":"Other Sentinel options","text":"<p>The other options are almost always in the form:</p> <pre><code>sentinel &lt;option_name&gt; &lt;master_name&gt; &lt;option_value&gt;\n</code></pre> <p>And are used for the following purposes:</p> <ul> <li><code>down-after-milliseconds</code> is the time in milliseconds an instance should not be reachable (either does not reply to our PINGs or it is replying with an error) for a Sentinel starting to think it is down.</li> <li><code>parallel-syncs</code> sets the number of replicas that can be reconfigured to use the new master after a failover at the same time. The lower the number, the more time it will take for the failover process to complete, however if the replicas are configured to serve old data, you may not want all the replicas to re-synchronize with the master at the same time. While the replication process is mostly non blocking for a replica, there is a moment when it stops to load the bulk data from the master. You may want to make sure only one replica at a time is not reachable by setting this option to the value of 1.</li> </ul> <p>Additional options are described in the rest of this document and documented in the example <code>sentinel.conf</code> file shipped with the Redis distribution.</p> <p>Configuration parameters can be modified at runtime:</p> <ul> <li>Master-specific configuration parameters are modified using <code>SENTINEL SET</code>.</li> <li>Global configuration parameters are modified using <code>SENTINEL CONFIG SET</code>.</li> </ul> <p>See the Reconfiguring Sentinel at runtime section for more information.</p>"},{"location":"7-management/sentinel/#example-sentinel-deployments","title":"Example Sentinel deployments","text":"<p>Now that you know the basic information about Sentinel, you may wonder where you should place your Sentinel processes, how many Sentinel processes you need and so forth. This section shows a few example deployments.</p> <p>We use ASCII art in order to show you configuration examples in a graphical format, this is what the different symbols means:</p> <pre><code>+--------------------+\n| This is a computer |\n| or VM that fails   |\n| independently. We  |\n| call it a \"box\"    |\n+--------------------+\n</code></pre> <p>We write inside the boxes what they are running:</p> <pre><code>+-------------------+\n| Redis master M1   |\n| Redis Sentinel S1 |\n+-------------------+\n</code></pre> <p>Different boxes are connected by lines, to show that they are able to talk:</p> <pre><code>+-------------+               +-------------+\n| Sentinel S1 |---------------| Sentinel S2 |\n+-------------+               +-------------+\n</code></pre> <p>Network partitions are shown as interrupted lines using slashes:</p> <pre><code>+-------------+                +-------------+\n| Sentinel S1 |------ // ------| Sentinel S2 |\n+-------------+                +-------------+\n</code></pre> <p>Also note that:</p> <ul> <li>Masters are called M1, M2, M3, ..., Mn.</li> <li>Replicas are called R1, R2, R3, ..., Rn (R stands for replica).</li> <li>Sentinels are called S1, S2, S3, ..., Sn.</li> <li>Clients are called C1, C2, C3, ..., Cn.</li> <li>When an instance changes role because of Sentinel actions, we put it inside square brackets, so [M1] means an instance that is now a master because of Sentinel intervention.</li> </ul> <p>Note that we will never show setups where just two Sentinels are used, since Sentinels always need to talk with the majority in order to start a failover.</p>"},{"location":"7-management/sentinel/#example-1-just-two-sentinels-dont-do-this","title":"Example 1: just two Sentinels, DON'T DO THIS","text":"<pre><code>+----+         +----+\n| M1 |---------| R1 |\n| S1 |         | S2 |\n+----+         +----+\n\nConfiguration: quorum = 1\n</code></pre> <ul> <li>In this setup, if the master M1 fails, R1 will be promoted since the two Sentinels can reach agreement about the failure (obviously with quorum set to 1) and can also authorize a failover because the majority is two. So apparently it could superficially work, however check the next points to see why this setup is broken.</li> <li>If the box where M1 is running stops working, also S1 stops working. The Sentinel running in the other box S2 will not be able to authorize a failover, so the system will become not available.</li> </ul> <p>Note that a majority is needed in order to order different failovers, and later propagate the latest configuration to all the Sentinels. Also note that the ability to failover in a single side of the above setup, without any agreement, would be very dangerous:</p> <pre><code>+----+           +------+\n| M1 |----//-----| [M1] |\n| S1 |           | S2   |\n+----+           +------+\n</code></pre> <p>In the above configuration we created two masters (assuming S2 could failover without authorization) in a perfectly symmetrical way. Clients may write indefinitely to both sides, and there is no way to understand when the partition heals what configuration is the right one, in order to prevent a permanent split brain condition.</p> <p>So please deploy at least three Sentinels in three different boxes always.</p>"},{"location":"7-management/sentinel/#example-2-basic-setup-with-three-boxes","title":"Example 2: basic setup with three boxes","text":"<p>This is a very simple setup, that has the advantage to be simple to tune for additional safety. It is based on three boxes, each box running both a Redis process and a Sentinel process.</p> <pre><code>       +----+\n       | M1 |\n       | S1 |\n       +----+\n          |\n+----+    |    +----+\n| R2 |----+----| R3 |\n| S2 |         | S3 |\n+----+         +----+\n\nConfiguration: quorum = 2\n</code></pre> <p>If the master M1 fails, S2 and S3 will agree about the failure and will be able to authorize a failover, making clients able to continue.</p> <p>In every Sentinel setup, as Redis uses asynchronous replication, there is always the risk of losing some writes because a given acknowledged write may not be able to reach the replica which is promoted to master. However in the above setup there is a higher risk due to clients being partitioned away with an old master, like in the following picture:</p> <pre><code>         +----+\n         | M1 |\n         | S1 | &lt;- C1 (writes will be lost)\n         +----+\n            |\n            /\n            /\n+------+    |    +----+\n| [M2] |----+----| R3 |\n| S2   |         | S3 |\n+------+         +----+\n</code></pre> <p>In this case a network partition isolated the old master M1, so the replica R2 is promoted to master. However clients, like C1, that are in the same partition as the old master, may continue to write data to the old master. This data will be lost forever since when the partition will heal, the master will be reconfigured as a replica of the new master, discarding its data set.</p> <p>This problem can be mitigated using the following Redis replication feature, that allows to stop accepting writes if a master detects that it is no longer able to transfer its writes to the specified number of replicas.</p> <pre><code>min-replicas-to-write 1\nmin-replicas-max-lag 10\n</code></pre> <p>With the above configuration (please see the self-commented <code>redis.conf</code> example in the Redis distribution for more information) a Redis instance, when acting as a master, will stop accepting writes if it can't write to at least 1 replica. Since replication is asynchronous not being able to write actually means that the replica is either disconnected, or is not sending us asynchronous acknowledges for more than the specified <code>max-lag</code> number of seconds.</p> <p>Using this configuration, the old Redis master M1 in the above example, will become unavailable after 10 seconds. When the partition heals, the Sentinel configuration will converge to the new one, the client C1 will be able to fetch a valid configuration and will continue with the new master.</p> <p>However there is no free lunch. With this refinement, if the two replicas are down, the master will stop accepting writes. It's a trade off.</p>"},{"location":"7-management/sentinel/#example-3-sentinel-in-the-client-boxes","title":"Example 3: Sentinel in the client boxes","text":"<p>Sometimes we have only two Redis boxes available, one for the master and one for the replica. The configuration in the example 2 is not viable in that case, so we can resort to the following, where Sentinels are placed where clients are:</p> <pre><code>            +----+         +----+\n            | M1 |----+----| R1 |\n            |    |    |    |    |\n            +----+    |    +----+\n                      |\n         +------------+------------+\n         |            |            |\n         |            |            |\n      +----+        +----+      +----+\n      | C1 |        | C2 |      | C3 |\n      | S1 |        | S2 |      | S3 |\n      +----+        +----+      +----+\n\n      Configuration: quorum = 2\n</code></pre> <p>In this setup, the point of view Sentinels is the same as the clients: if a master is reachable by the majority of the clients, it is fine. C1, C2, C3 here are generic clients, it does not mean that C1 identifies a single client connected to Redis. It is more likely something like an application server, a Rails app, or something like that.</p> <p>If the box where M1 and S1 are running fails, the failover will happen without issues, however it is easy to see that different network partitions will result in different behaviors. For example Sentinel will not be able to setup if the network between the clients and the Redis servers is disconnected, since the Redis master and replica will both be unavailable.</p> <p>Note that if C3 gets partitioned with M1 (hardly possible with the network described above, but more likely possible with different layouts, or because of failures at the software layer), we have a similar issue as described in Example 2, with the difference that here we have no way to break the symmetry, since there is just a replica and master, so the master can't stop accepting queries when it is disconnected from its replica, otherwise the master would never be available during replica failures.</p> <p>So this is a valid setup but the setup in the Example 2 has advantages such as the HA system of Redis running in the same boxes as Redis itself which may be simpler to manage, and the ability to put a bound on the amount of time a master in the minority partition can receive writes.</p>"},{"location":"7-management/sentinel/#example-4-sentinel-client-side-with-less-than-three-clients","title":"Example 4: Sentinel client side with less than three clients","text":"<p>The setup described in the Example 3 cannot be used if there are less than three boxes in the client side (for example three web servers). In this case we need to resort to a mixed setup like the following:</p> <pre><code>            +----+         +----+\n            | M1 |----+----| R1 |\n            | S1 |    |    | S2 |\n            +----+    |    +----+\n                      |\n               +------+-----+\n               |            |\n               |            |\n            +----+        +----+\n            | C1 |        | C2 |\n            | S3 |        | S4 |\n            +----+        +----+\n\n      Configuration: quorum = 3\n</code></pre> <p>This is similar to the setup in Example 3, but here we run four Sentinels in the four boxes we have available. If the master M1 becomes unavailable the other three Sentinels will perform the failover.</p> <p>In theory this setup works removing the box where C2 and S4 are running, and setting the quorum to 2. However it is unlikely that we want HA in the Redis side without having high availability in our application layer.</p>"},{"location":"7-management/sentinel/#sentinel-docker-nat-and-possible-issues","title":"Sentinel, Docker, NAT, and possible issues","text":"<p>Docker uses a technique called port mapping: programs running inside Docker containers may be exposed with a different port compared to the one the program believes to be using. This is useful in order to run multiple containers using the same ports, at the same time, in the same server.</p> <p>Docker is not the only software system where this happens, there are other Network Address Translation setups where ports may be remapped, and sometimes not ports but also IP addresses.</p> <p>Remapping ports and addresses creates issues with Sentinel in two ways:</p> <ol> <li>Sentinel auto-discovery of other Sentinels no longer works, since it is based on hello messages where each Sentinel announce at which port and IP address they are listening for connection. However Sentinels have no way to understand that an address or port is remapped, so it is announcing an information that is not correct for other Sentinels to connect.</li> <li>Replicas are listed in the <code>INFO</code> output of a Redis master in a similar way: the address is detected by the master checking the remote peer of the TCP connection, while the port is advertised by the replica itself during the handshake, however the port may be wrong for the same reason as exposed in point 1.</li> </ol> <p>Since Sentinels auto detect replicas using masters <code>INFO</code> output information, the detected replicas will not be reachable, and Sentinel will never be able to failover the master, since there are no good replicas from the point of view of the system, so there is currently no way to monitor with Sentinel a set of master and replica instances deployed with Docker, unless you instruct Docker to map the port 1:1.</p> <p>For the first problem, in case you want to run a set of Sentinel instances using Docker with forwarded ports (or any other NAT setup where ports are remapped), you can use the following two Sentinel configuration directives in order to force Sentinel to announce a specific set of IP and port:</p> <pre><code>sentinel announce-ip &lt;ip&gt;\nsentinel announce-port &lt;port&gt;\n</code></pre> <p>Note that Docker has the ability to run in host networking mode (check the <code>--net=host</code> option for more information). This should create no issues since ports are not remapped in this setup.</p>"},{"location":"7-management/sentinel/#ip-addresses-and-dns-names","title":"IP Addresses and DNS names","text":"<p>Older versions of Sentinel did not support host names and required IP addresses to be specified everywhere. Starting with version 6.2, Sentinel has optional support for host names.</p> <p>This capability is disabled by default. If you're going to enable DNS/hostnames support, please note:</p> <ol> <li>The name resolution configuration on your Redis and Sentinel nodes must be reliable and be able to resolve addresses quickly. Unexpected delays in address resolution may have a negative impact on Sentinel.</li> <li>You should use hostnames everywhere and avoid mixing hostnames and IP addresses. To do that, use <code>replica-announce-ip &lt;hostname&gt;</code> and <code>sentinel announce-ip &lt;hostname&gt;</code> for all Redis and Sentinel instances, respectively.</li> </ol> <p>Enabling the <code>resolve-hostnames</code> global configuration allows Sentinel to accept host names:</p> <ul> <li>As part of a <code>sentinel monitor</code> command</li> <li>As a replica address, if the replica uses a host name value for <code>replica-announce-ip</code></li> </ul> <p>Sentinel will accept host names as valid inputs and resolve them, but will still refer to IP addresses when announcing an instance, updating configuration files, etc.</p> <p>Enabling the <code>announce-hostnames</code> global configuration makes Sentinel use host names instead. This affects replies to clients, values written in configuration files, the <code>REPLICAOF</code> command issued to replicas, etc.</p> <p>This behavior may not be compatible with all Sentinel clients, that may explicitly expect an IP address.</p> <p>Using host names may be useful when clients use TLS to connect to instances and require a name rather than an IP address in order to perform certificate ASN matching.</p>"},{"location":"7-management/sentinel/#a-quick-tutorial","title":"A quick tutorial","text":"<p>In the next sections of this document, all the details about Sentinel API, configuration and semantics will be covered incrementally. However for people that want to play with the system ASAP, this section is a tutorial that shows how to configure and interact with 3 Sentinel instances.</p> <p>Here we assume that the instances are executed at port 5000, 5001, 5002. We also assume that you have a running Redis master at port 6379 with a replica running at port 6380. We will use the IPv4 loopback address 127.0.0.1 everywhere during the tutorial, assuming you are running the simulation on your personal computer.</p> <p>The three Sentinel configuration files should look like the following:</p> <pre><code>port 5000\nsentinel monitor mymaster 127.0.0.1 6379 2\nsentinel down-after-milliseconds mymaster 5000\nsentinel failover-timeout mymaster 60000\nsentinel parallel-syncs mymaster 1\n</code></pre> <p>The other two configuration files will be identical but using 5001 and 5002 as port numbers.</p> <p>A few things to note about the above configuration:</p> <ul> <li>The master set is called <code>mymaster</code>. It identifies the master and its replicas. Since each master set has a different name, Sentinel can monitor different sets of masters and replicas at the same time.</li> <li>The quorum was set to the value of 2 (last argument of <code>sentinel monitor</code> configuration directive).</li> <li>The <code>down-after-milliseconds</code> value is 5000 milliseconds, that is 5 seconds, so masters will be detected as failing as soon as we don't receive any reply from our pings within this amount of time.</li> </ul> <p>Once you start the three Sentinels, you'll see a few messages they log, like:</p> <pre><code>+monitor master mymaster 127.0.0.1 6379 quorum 2\n</code></pre> <p>This is a Sentinel event, and you can receive this kind of events via Pub/Sub if you <code>SUBSCRIBE</code> to the event name as specified later in Pub/Sub Messages section.</p> <p>Sentinel generates and logs different events during failure detection and failover.</p>"},{"location":"7-management/sentinel/#asking-sentinel-about-the-state-of-a-master","title":"Asking Sentinel about the state of a master","text":"<p>The most obvious thing to do with Sentinel to get started, is check if the master it is monitoring is doing well:</p> <pre><code>$ redis-cli -p 5000\n127.0.0.1:5000&gt; sentinel master mymaster\n 1) \"name\"\n 2) \"mymaster\"\n 3) \"ip\"\n 4) \"127.0.0.1\"\n 5) \"port\"\n 6) \"6379\"\n 7) \"runid\"\n 8) \"953ae6a589449c13ddefaee3538d356d287f509b\"\n 9) \"flags\"\n10) \"master\"\n11) \"link-pending-commands\"\n12) \"0\"\n13) \"link-refcount\"\n14) \"1\"\n15) \"last-ping-sent\"\n16) \"0\"\n17) \"last-ok-ping-reply\"\n18) \"735\"\n19) \"last-ping-reply\"\n20) \"735\"\n21) \"down-after-milliseconds\"\n22) \"5000\"\n23) \"info-refresh\"\n24) \"126\"\n25) \"role-reported\"\n26) \"master\"\n27) \"role-reported-time\"\n28) \"532439\"\n29) \"config-epoch\"\n30) \"1\"\n31) \"num-slaves\"\n32) \"1\"\n33) \"num-other-sentinels\"\n34) \"2\"\n35) \"quorum\"\n36) \"2\"\n37) \"failover-timeout\"\n38) \"60000\"\n39) \"parallel-syncs\"\n40) \"1\"\n</code></pre> <p>As you can see, it prints a number of information about the master. There are a few that are of particular interest for us:</p> <ol> <li><code>num-other-sentinels</code> is 2, so we know the Sentinel already detected two more Sentinels for this master. If you check the logs you'll see the <code>+sentinel</code> events generated.</li> <li><code>flags</code> is just <code>master</code>. If the master was down we could expect to see <code>s_down</code> or <code>o_down</code> flag as well here.</li> <li><code>num-slaves</code> is correctly set to 1, so Sentinel also detected that there is an attached replica to our master.</li> </ol> <p>In order to explore more about this instance, you may want to try the following two commands:</p> <pre><code>SENTINEL replicas mymaster\nSENTINEL sentinels mymaster\n</code></pre> <p>The first will provide similar information about the replicas connected to the master, and the second about the other Sentinels.</p>"},{"location":"7-management/sentinel/#obtaining-the-address-of-the-current-master","title":"Obtaining the address of the current master","text":"<p>As we already specified, Sentinel also acts as a configuration provider for clients that want to connect to a set of master and replicas. Because of possible failovers or reconfigurations, clients have no idea about who is the currently active master for a given set of instances, so Sentinel exports an API to ask this question:</p> <pre><code>127.0.0.1:5000&gt; SENTINEL get-master-addr-by-name mymaster\n1) \"127.0.0.1\"\n2) \"6379\"\n</code></pre>"},{"location":"7-management/sentinel/#testing-the-failover","title":"Testing the failover","text":"<p>At this point our toy Sentinel deployment is ready to be tested. We can just kill our master and check if the configuration changes. To do so we can just do:</p> <pre><code>redis-cli -p 6379 DEBUG sleep 30\n</code></pre> <p>This command will make our master no longer reachable, sleeping for 30 seconds. It basically simulates a master hanging for some reason.</p> <p>If you check the Sentinel logs, you should be able to see a lot of action:</p> <ol> <li>Each Sentinel detects the master is down with an <code>+sdown</code> event.</li> <li>This event is later escalated to <code>+odown</code>, which means that multiple Sentinels agree about the fact the master is not reachable.</li> <li>Sentinels vote a Sentinel that will start the first failover attempt.</li> <li>The failover happens.</li> </ol> <p>If you ask again what is the current master address for <code>mymaster</code>, eventually we should get a different reply this time:</p> <pre><code>127.0.0.1:5000&gt; SENTINEL get-master-addr-by-name mymaster\n1) \"127.0.0.1\"\n2) \"6380\"\n</code></pre> <p>So far so good... At this point you may jump to create your Sentinel deployment or can read more to understand all the Sentinel commands and internals.</p>"},{"location":"7-management/sentinel/#sentinel-api","title":"Sentinel API","text":"<p>Sentinel provides an API in order to inspect its state, check the health of monitored masters and replicas, subscribe in order to receive specific notifications, and change the Sentinel configuration at run time.</p> <p>By default Sentinel runs using TCP port 26379 (note that 6379 is the normal Redis port). Sentinels accept commands using the Redis protocol, so you can use <code>redis-cli</code> or any other unmodified Redis client in order to talk with Sentinel.</p> <p>It is possible to directly query a Sentinel to check what is the state of the monitored Redis instances from its point of view, to see what other Sentinels it knows, and so forth. Alternatively, using Pub/Sub, it is possible to receive push style notifications from Sentinels, every time some event happens, like a failover, or an instance entering an error condition, and so forth.</p>"},{"location":"7-management/sentinel/#sentinel-commands","title":"Sentinel commands","text":"<p>The <code>SENTINEL</code> command is the main API for Sentinel. The following is the list of its subcommands (minimal version is noted for where applicable):</p> <ul> <li>SENTINEL CONFIG GET <code>&lt;name&gt;</code> (<code>&gt;= 6.2</code>) Get the current value of a global Sentinel configuration parameter. The specified name may be a wildcard, similar to the Redis <code>CONFIG GET</code> command.</li> <li>SENTINEL CONFIG SET <code>&lt;name&gt;</code> <code>&lt;value&gt;</code> (<code>&gt;= 6.2</code>) Set the value of a global Sentinel configuration parameter.</li> <li>SENTINEL CKQUORUM <code>&lt;master name&gt;</code> Check if the current Sentinel configuration is able to reach the quorum needed to failover a master, and the majority needed to authorize the failover. This command should be used in monitoring systems to check if a Sentinel deployment is ok.</li> <li>SENTINEL FLUSHCONFIG Force Sentinel to rewrite its configuration on disk, including the current Sentinel state. Normally Sentinel rewrites the configuration every time something changes in its state (in the context of the subset of the state which is persisted on disk across restart). However sometimes it is possible that the configuration file is lost because of operation errors, disk failures, package upgrade scripts or configuration managers. In those cases a way to force Sentinel to rewrite the configuration file is handy. This command works even if the previous configuration file is completely missing.</li> <li>SENTINEL FAILOVER <code>&lt;master name&gt;</code> Force a failover as if the master was not reachable, and without asking for agreement to other Sentinels (however a new version of the configuration will be published so that the other Sentinels will update their configurations).</li> <li>SENTINEL GET-MASTER-ADDR-BY-NAME <code>&lt;master name&gt;</code> Return the ip and port number of the master with that name. If a failover is in progress or terminated successfully for this master it returns the address and port of the promoted replica.</li> <li>SENTINEL INFO-CACHE (<code>&gt;= 3.2</code>) Return cached <code>INFO</code> output from masters and replicas.</li> <li>SENTINEL IS-MASTER-DOWN-BY-ADDR   Check if the master specified by ip:port is down from current Sentinel's point of view. This command is mostly for internal use. <li>SENTINEL MASTER <code>&lt;master name&gt;</code> Show the state and info of the specified master.</li> <li>SENTINEL MASTERS Show a list of monitored masters and their state.</li> <li>SENTINEL MONITOR Start Sentinel's monitoring. Refer to the Reconfiguring Sentinel at Runtime section for more information.</li> <li>SENTINEL MYID (<code>&gt;= 6.2</code>) Return the ID of the Sentinel instance.</li> <li>SENTINEL PENDING-SCRIPTS This command returns information about pending scripts.</li> <li>SENTINEL REMOVE Stop Sentinel's monitoring. Refer to the Reconfiguring Sentinel at Runtime section for more information.</li> <li>SENTINEL REPLICAS <code>&lt;master name&gt;</code> (<code>&gt;= 5.0</code>) Show a list of replicas for this master, and their state.</li> <li>SENTINEL SENTINELS <code>&lt;master name&gt;</code> Show a list of sentinel instances for this master, and their state.</li> <li>SENTINEL SET Set Sentinel's monitoring configuration. Refer to the Reconfiguring Sentinel at Runtime section for more information.</li> <li>SENTINEL SIMULATE-FAILURE (crash-after-election|crash-after-promotion|help) (<code>&gt;= 3.2</code>) This command simulates different Sentinel crash scenarios.</li> <li>SENTINEL RESET <code>&lt;pattern&gt;</code> This command will reset all the masters with matching name. The pattern argument is a glob-style pattern. The reset process clears any previous state in a master (including a failover in progress), and removes every replica and sentinel already discovered and associated with the master.</li> <p>For connection management and administration purposes, Sentinel supports the following subset of Redis' commands:</p> <ul> <li>ACL (<code>&gt;= 6.2</code>) This command manages the Sentinel Access Control List. For more information refer to the ACL documentation page and the Sentinel Access Control List authentication.</li> <li>AUTH (<code>&gt;= 5.0.1</code>) Authenticate a client connection. For more information refer to the <code>AUTH</code> command and the Configuring Sentinel instances with authentication section.</li> <li>CLIENT This command manages client connections. For more information refer to its subcommands' pages.</li> <li>COMMAND (<code>&gt;= 6.2</code>) This command returns information about commands. For more information refer to the <code>COMMAND</code> command and its various subcommands.</li> <li>HELLO (<code>&gt;= 6.0</code>) Switch the connection's protocol. For more information refer to the <code>HELLO</code> command.</li> <li>INFO Return information and statistics about the Sentinel server. For more information see the <code>INFO</code> command.</li> <li>PING This command simply returns PONG.</li> <li>ROLE This command returns the string \"sentinel\" and a list of monitored masters. For more information refer to the <code>ROLE</code> command.</li> <li>SHUTDOWN Shut down the Sentinel instance.</li> </ul> <p>Lastly, Sentinel also supports the <code>SUBSCRIBE</code>, <code>UNSUBSCRIBE</code>, <code>PSUBSCRIBE</code> and <code>PUNSUBSCRIBE</code> commands. Refer to the Pub/Sub Messages section for more details.</p>"},{"location":"7-management/sentinel/#reconfiguring-sentinel-at-runtime","title":"Reconfiguring Sentinel at Runtime","text":"<p>Starting with Redis version 2.8.4, Sentinel provides an API in order to add, remove, or change the configuration of a given master. Note that if you have multiple sentinels you should apply the changes to all to your instances for Redis Sentinel to work properly. This means that changing the configuration of a single Sentinel does not automatically propagate the changes to the other Sentinels in the network.</p> <p>The following is a list of <code>SENTINEL</code> subcommands used in order to update the configuration of a Sentinel instance.</p> <ul> <li>SENTINEL MONITOR <code>&lt;name&gt;</code> <code>&lt;ip&gt;</code> <code>&lt;port&gt;</code> <code>&lt;quorum&gt;</code> This command tells the Sentinel to start monitoring a new master with the specified name, ip, port, and quorum. It is identical to the <code>sentinel monitor</code> configuration directive in <code>sentinel.conf</code> configuration file, with the difference that you can't use a hostname in as <code>ip</code>, but you need to provide an IPv4 or IPv6 address.</li> <li>SENTINEL REMOVE <code>&lt;name&gt;</code> is used in order to remove the specified master: the master will no longer be monitored, and will totally be removed from the internal state of the Sentinel, so it will no longer listed by <code>SENTINEL masters</code> and so forth.</li> <li>SENTINEL SET <code>&lt;name&gt;</code> [<code>&lt;option&gt;</code> <code>&lt;value&gt;</code> ...] The SET command is very similar to the <code>CONFIG SET</code> command of Redis, and is used in order to change configuration parameters of a specific master. Multiple option / value pairs can be specified (or none at all). All the configuration parameters that can be configured via <code>sentinel.conf</code> are also configurable using the SET command.</li> </ul> <p>The following is an example of <code>SENTINEL SET</code> command in order to modify the <code>down-after-milliseconds</code> configuration of a master called <code>objects-cache</code>:</p> <pre><code>SENTINEL SET objects-cache-master down-after-milliseconds 1000\n</code></pre> <p>As already stated, <code>SENTINEL SET</code> can be used to set all the configuration parameters that are settable in the startup configuration file. Moreover it is possible to change just the master quorum configuration without removing and re-adding the master with <code>SENTINEL REMOVE</code> followed by <code>SENTINEL MONITOR</code>, but simply using:</p> <pre><code>SENTINEL SET objects-cache-master quorum 5\n</code></pre> <p>Note that there is no equivalent GET command since <code>SENTINEL MASTER</code> provides all the configuration parameters in a simple to parse format (as a field/value pairs array).</p> <p>Starting with Redis version 6.2, Sentinel also allows getting and setting global configuration parameters which were only supported in the configuration file prior to that.</p> <ul> <li>SENTINEL CONFIG GET <code>&lt;name&gt;</code> Get the current value of a global Sentinel configuration parameter. The specified name may be a wildcard, similar to the Redis <code>CONFIG GET</code> command.</li> <li>SENTINEL CONFIG SET <code>&lt;name&gt;</code> <code>&lt;value&gt;</code> Set the value of a global Sentinel configuration parameter.</li> </ul> <p>Global parameters that can be manipulated include:</p> <ul> <li><code>resolve-hostnames</code>, <code>announce-hostnames</code>. See IP addresses and DNS names.</li> <li><code>announce-ip</code>, <code>announce-port</code>. See Sentinel, Docker, NAT, and possible issues.</li> <li><code>sentinel-user</code>, <code>sentinel-pass</code>. See Configuring Sentinel instances with authentication.</li> </ul>"},{"location":"7-management/sentinel/#adding-or-removing-sentinels","title":"Adding or removing Sentinels","text":"<p>Adding a new Sentinel to your deployment is a simple process because of the auto-discover mechanism implemented by Sentinel. All you need to do is to start the new Sentinel configured to monitor the currently active master. Within 10 seconds the Sentinel will acquire the list of other Sentinels and the set of replicas attached to the master.</p> <p>If you need to add multiple Sentinels at once, it is suggested to add it one after the other, waiting for all the other Sentinels to already know about the first one before adding the next. This is useful in order to still guarantee that majority can be achieved only in one side of a partition, in the chance failures should happen in the process of adding new Sentinels.</p> <p>This can be easily achieved by adding every new Sentinel with a 30 seconds delay, and during absence of network partitions.</p> <p>At the end of the process it is possible to use the command <code>SENTINEL MASTER mastername</code> in order to check if all the Sentinels agree about the total number of Sentinels monitoring the master.</p> <p>Removing a Sentinel is a bit more complex: Sentinels never forget already seen Sentinels, even if they are not reachable for a long time, since we don't want to dynamically change the majority needed to authorize a failover and the creation of a new configuration number. So in order to remove a Sentinel the following steps should be performed in absence of network partitions:</p> <ol> <li>Stop the Sentinel process of the Sentinel you want to remove.</li> <li>Send a <code>SENTINEL RESET *</code> command to all the other Sentinel instances (instead of <code>*</code> you can use the exact master name if you want to reset just a single master). One after the other, waiting at least 30 seconds between instances.</li> <li>Check that all the Sentinels agree about the number of Sentinels currently active, by inspecting the output of <code>SENTINEL MASTER mastername</code> of every Sentinel.</li> </ol>"},{"location":"7-management/sentinel/#removing-the-old-master-or-unreachable-replicas","title":"Removing the old master or unreachable replicas","text":"<p>Sentinels never forget about replicas of a given master, even when they are unreachable for a long time. This is useful, because Sentinels should be able to correctly reconfigure a returning replica after a network partition or a failure event.</p> <p>Moreover, after a failover, the failed over master is virtually added as a replica of the new master, this way it will be reconfigured to replicate with the new master as soon as it will be available again.</p> <p>However sometimes you want to remove a replica (that may be the old master) forever from the list of replicas monitored by Sentinels.</p> <p>In order to do this, you need to send a <code>SENTINEL RESET mastername</code> command to all the Sentinels: they'll refresh the list of replicas within the next 10 seconds, only adding the ones listed as correctly replicating from the current master <code>INFO</code> output.</p>"},{"location":"7-management/sentinel/#pubsub-messages","title":"Pub/Sub messages","text":"<p>A client can use a Sentinel as a Redis-compatible Pub/Sub server (but you can't use <code>PUBLISH</code>) in order to <code>SUBSCRIBE</code> or <code>PSUBSCRIBE</code> to channels and get notified about specific events.</p> <p>The channel name is the same as the name of the event. For instance the channel named <code>+sdown</code> will receive all the notifications related to instances entering an <code>SDOWN</code> (SDOWN means the instance is no longer reachable from the point of view of the Sentinel you are querying) condition.</p> <p>To get all the messages simply subscribe using <code>PSUBSCRIBE *</code>.</p> <p>The following is a list of channels and message formats you can receive using this API. The first word is the channel / event name, the rest is the format of the data.</p> <p>Note: where instance details is specified it means that the following arguments are provided to identify the target instance:</p> <pre><code>&lt;instance-type&gt; &lt;name&gt; &lt;ip&gt; &lt;port&gt; @ &lt;master-name&gt; &lt;master-ip&gt; &lt;master-port&gt;\n</code></pre> <p>The part identifying the master (from the @ argument to the end) is optional and is only specified if the instance is not a master itself.</p> <ul> <li>+reset-master <code>&lt;instance details&gt;</code> -- The master was reset.</li> <li>+slave <code>&lt;instance details&gt;</code> -- A new replica was detected and attached.</li> <li>+failover-state-reconf-slaves <code>&lt;instance details&gt;</code> -- Failover state changed to <code>reconf-slaves</code> state.</li> <li>+failover-detected <code>&lt;instance details&gt;</code> -- A failover started by another Sentinel or any other external entity was detected (An attached replica turned into a master).</li> <li>+slave-reconf-sent <code>&lt;instance details&gt;</code> -- The leader sentinel sent the <code>REPLICAOF</code> command to this instance in order to reconfigure it for the new replica.</li> <li>+slave-reconf-inprog <code>&lt;instance details&gt;</code> -- The replica being reconfigured showed to be a replica of the new master ip:port pair, but the synchronization process is not yet complete.</li> <li>+slave-reconf-done <code>&lt;instance details&gt;</code> -- The replica is now synchronized with the new master.</li> <li>-dup-sentinel <code>&lt;instance details&gt;</code> -- One or more sentinels for the specified master were removed as duplicated (this happens for instance when a Sentinel instance is restarted).</li> <li>+sentinel <code>&lt;instance details&gt;</code> -- A new sentinel for this master was detected and attached.</li> <li>+sdown <code>&lt;instance details&gt;</code> -- The specified instance is now in Subjectively Down state.</li> <li>-sdown <code>&lt;instance details&gt;</code> -- The specified instance is no longer in Subjectively Down state.</li> <li>+odown <code>&lt;instance details&gt;</code> -- The specified instance is now in Objectively Down state.</li> <li>-odown <code>&lt;instance details&gt;</code> -- The specified instance is no longer in Objectively Down state.</li> <li>+new-epoch <code>&lt;instance details&gt;</code> -- The current epoch was updated.</li> <li>+try-failover <code>&lt;instance details&gt;</code> -- New failover in progress, waiting to be elected by the majority.</li> <li>+elected-leader <code>&lt;instance details&gt;</code> -- Won the election for the specified epoch, can do the failover.</li> <li>+failover-state-select-slave <code>&lt;instance details&gt;</code> -- New failover state is <code>select-slave</code>: we are trying to find a suitable replica for promotion.</li> <li>no-good-slave <code>&lt;instance details&gt;</code> -- There is no good replica to promote. Currently we'll try after some time, but probably this will change and the state machine will abort the failover at all in this case.</li> <li>selected-slave <code>&lt;instance details&gt;</code> -- We found the specified good replica to promote.</li> <li>failover-state-send-slaveof-noone <code>&lt;instance details&gt;</code> -- We are trying to reconfigure the promoted replica as master, waiting for it to switch.</li> <li>failover-end-for-timeout <code>&lt;instance details&gt;</code> -- The failover terminated for timeout, replicas will eventually be configured to replicate with the new master anyway.</li> <li>failover-end <code>&lt;instance details&gt;</code> -- The failover terminated with success. All the replicas appears to be reconfigured to replicate with the new master.</li> <li>switch-master <code>&lt;master name&gt; &lt;oldip&gt; &lt;oldport&gt; &lt;newip&gt; &lt;newport&gt;</code> -- The master new IP and address is the specified one after a configuration change. This is the message most external users are interested in.</li> <li>+tilt -- Tilt mode entered.</li> <li>-tilt -- Tilt mode exited.</li> </ul>"},{"location":"7-management/sentinel/#handling-of-busy-state","title":"Handling of -BUSY state","text":"<p>The -BUSY error is returned by a Redis instance when a Lua script is running for more time than the configured Lua script time limit. When this happens before triggering a fail over Redis Sentinel will try to send a <code>SCRIPT KILL</code> command, that will only succeed if the script was read-only.</p> <p>If the instance is still in an error condition after this try, it will eventually be failed over.</p>"},{"location":"7-management/sentinel/#replicas-priority","title":"Replicas priority","text":"<p>Redis instances have a configuration parameter called <code>replica-priority</code>. This information is exposed by Redis replica instances in their <code>INFO</code> output, and Sentinel uses it in order to pick a replica among the ones that can be used in order to failover a master:</p> <ol> <li>If the replica priority is set to 0, the replica is never promoted to master.</li> <li>Replicas with a lower priority number are preferred by Sentinel.</li> </ol> <p>For example if there is a replica S1 in the same data center of the current master, and another replica S2 in another data center, it is possible to set S1 with a priority of 10 and S2 with a priority of 100, so that if the master fails and both S1 and S2 are available, S1 will be preferred.</p> <p>For more information about the way replicas are selected, please check the Replica selection and priority section of this documentation.</p>"},{"location":"7-management/sentinel/#sentinel-and-redis-authentication","title":"Sentinel and Redis authentication","text":"<p>When the master is configured to require authentication from clients, as a security measure, replicas need to also be aware of the credentials in order to authenticate with the master and create the master-replica connection used for the asynchronous replication protocol.</p>"},{"location":"7-management/sentinel/#redis-access-control-list-authentication","title":"Redis Access Control List authentication","text":"<p>Starting with Redis 6, user authentication and permission is managed with the Access Control List (ACL).</p> <p>In order for Sentinels to connect to Redis server instances when they are configured with ACL, the Sentinel configuration must include the following directives:</p> <pre><code>sentinel auth-user &lt;master-name&gt; &lt;username&gt;\nsentinel auth-pass &lt;master-name&gt; &lt;password&gt;\n</code></pre> <p>Where <code>&lt;username&gt;</code> and <code>&lt;password&gt;</code> are the username and password for accessing the group's instances. These credentials should be provisioned on all of the group's Redis instances with the minimal control permissions. For example:</p> <pre><code>127.0.0.1:6379&gt; ACL SETUSER sentinel-user ON &gt;somepassword allchannels +multi +slaveof +ping +exec +subscribe +config|rewrite +role +publish +info +client|setname +client|kill +script|kill\n</code></pre>"},{"location":"7-management/sentinel/#redis-password-only-authentication","title":"Redis password-only authentication","text":"<p>Until Redis 6, authentication is achieved using the following configuration directives:</p> <ul> <li><code>requirepass</code> in the master, in order to set the authentication password, and to make sure the instance will not process requests for non authenticated clients.</li> <li><code>masterauth</code> in the replicas in order for the replicas to authenticate with the master in order to correctly replicate data from it.</li> </ul> <p>When Sentinel is used, there is not a single master, since after a failover replicas may play the role of masters, and old masters can be reconfigured in order to act as replicas, so what you want to do is to set the above directives in all your instances, both masters and replicas.</p> <p>This is also usually a sane setup since you don't want to protect data only in the master, having the same data accessible in the replicas.</p> <p>However, in the uncommon case where you need a replica that is accessible without authentication, you can still do it by setting up a replica priority of zero, to prevent this replica from being promoted to master, and configuring in this replica only the <code>masterauth</code> directive, without using the <code>requirepass</code> directive, so that data will be readable by unauthenticated clients.</p> <p>In order for Sentinels to connect to Redis server instances when they are configured with <code>requirepass</code>, the Sentinel configuration must include the <code>sentinel auth-pass</code> directive, in the format:</p> <pre><code>sentinel auth-pass &lt;master-name&gt; &lt;password&gt;\n</code></pre>"},{"location":"7-management/sentinel/#configuring-sentinel-instances-with-authentication","title":"Configuring Sentinel instances with authentication","text":"<p>Sentinel instances themselves can be secured by requiring clients to authenticate via the <code>AUTH</code> command. Starting with Redis 6.2, the Access Control List (ACL) is available, whereas previous versions (starting with Redis 5.0.1) support password-only authentication. </p> <p>Note that Sentinel's authentication configuration should be applied to each of the instances in your deployment, and all instances should use the same configuration. Furthermore, ACL and password-only authentication should not be used together.</p>"},{"location":"7-management/sentinel/#sentinel-access-control-list-authentication","title":"Sentinel Access Control List authentication","text":"<p>The first step in securing a Sentinel instance with ACL is preventing any unauthorized access to it. To do that, you'll need to disable the default superuser (or at the very least set it up with a strong password) and create a new one and allow it access to Pub/Sub channels:</p> <pre><code>127.0.0.1:5000&gt; ACL SETUSER admin ON &gt;admin-password allchannels +@all\nOK\n127.0.0.1:5000&gt; ACL SETUSER default off\nOK\n</code></pre> <p>The default user is used by Sentinel to connect to other instances. You can provide the credentials of another superuser with the following configuration directives:</p> <pre><code>sentinel sentinel-user &lt;username&gt;\nsentinel sentinel-pass &lt;password&gt;\n</code></pre> <p>Where <code>&lt;username&gt;</code> and <code>&lt;password&gt;</code> are the Sentinel's superuser and password, respectively (e.g. <code>admin</code> and <code>admin-password</code> in the example above).</p> <p>Lastly, for authenticating incoming client connections, you can create a Sentinel restricted user profile such as the following:</p> <pre><code>127.0.0.1:5000&gt; ACL SETUSER sentinel-user ON &gt;user-password -@all +auth +client|getname +client|id +client|setname +command +hello +ping +role +sentinel|get-master-addr-by-name +sentinel|master +sentinel|myid +sentinel|replicas +sentinel|sentinels\n</code></pre> <p>Refer to the documentation of your Sentinel client of choice for further information.</p>"},{"location":"7-management/sentinel/#sentinel-password-only-authentication","title":"Sentinel password-only authentication","text":"<p>To use Sentinel with password-only authentication, add the <code>requirepass</code> configuration directive to all your Sentinel instances as follows:</p> <pre><code>requirepass \"your_password_here\"\n</code></pre> <p>When configured this way, Sentinels will do two things:</p> <ol> <li>A password will be required from clients in order to send commands to Sentinels. This is obvious since this is how such configuration directive works in Redis in general.</li> <li>Moreover the same password configured to access the local Sentinel, will be used by this Sentinel instance in order to authenticate to all the other Sentinel instances it connects to.</li> </ol> <p>This means that you will have to configure the same <code>requirepass</code> password in all the Sentinel instances. This way every Sentinel can talk with every other Sentinel without any need to configure for each Sentinel the password to access all the other Sentinels, that would be very impractical.</p> <p>Before using this configuration, make sure your client library can send the <code>AUTH</code> command to Sentinel instances.</p>"},{"location":"7-management/sentinel/#sentinel-clients-implementation","title":"Sentinel clients implementation","text":"<p>Sentinel requires explicit client support, unless the system is configured to execute a script that performs a transparent redirection of all the requests to the new master instance (virtual IP or other similar systems). The topic of client libraries implementation is covered in the document Sentinel clients guidelines.</p>"},{"location":"7-management/sentinel/#more-advanced-concepts","title":"More advanced concepts","text":"<p>In the following sections we'll cover a few details about how Sentinel works, without resorting to implementation details and algorithms that will be covered in the final part of this document.</p>"},{"location":"7-management/sentinel/#sdown-and-odown-failure-state","title":"SDOWN and ODOWN failure state","text":"<p>Redis Sentinel has two different concepts of being down, one is called a Subjectively Down condition (SDOWN) and is a down condition that is local to a given Sentinel instance. Another is called Objectively Down condition (ODOWN) and is reached when enough Sentinels (at least the number configured as the <code>quorum</code> parameter of the monitored master) have an SDOWN condition, and get feedback from other Sentinels using the <code>SENTINEL is-master-down-by-addr</code> command.</p> <p>From the point of view of a Sentinel an SDOWN condition is reached when it does not receive a valid reply to PING requests for the number of seconds specified in the configuration as <code>is-master-down-after-milliseconds</code> parameter.</p> <p>An acceptable reply to PING is one of the following:</p> <ul> <li>PING replied with +PONG.</li> <li>PING replied with -LOADING error.</li> <li>PING replied with -MASTERDOWN error.</li> </ul> <p>Any other reply (or no reply at all) is considered non valid. However note that a logical master that advertises itself as a replica in the INFO output is considered to be down.</p> <p>Note that SDOWN requires that no acceptable reply is received for the whole interval configured, so for instance if the interval is 30000 milliseconds (30 seconds) and we receive an acceptable ping reply every 29 seconds, the instance is considered to be working.</p> <p>SDOWN is not enough to trigger a failover: it only means a single Sentinel believes a Redis instance is not available. To trigger a failover, the ODOWN state must be reached.</p> <p>To switch from SDOWN to ODOWN no strong consensus algorithm is used, but just a form of gossip: if a given Sentinel gets reports that a master is not working from enough Sentinels in a given time range, the SDOWN is promoted to ODOWN. If this acknowledge is later missing, the flag is cleared.</p> <p>A more strict authorization that uses an actual majority is required in order to really start the failover, but no failover can be triggered without reaching the ODOWN state.</p> <p>The ODOWN condition only applies to masters. For other kind of instances Sentinel doesn't require to act, so the ODOWN state is never reached for replicas and other sentinels, but only SDOWN is.</p> <p>However SDOWN has also semantic implications. For example a replica in SDOWN state is not selected to be promoted by a Sentinel performing a failover.</p>"},{"location":"7-management/sentinel/#sentinels-and-replicas-auto-discovery","title":"Sentinels and replicas auto discovery","text":"<p>Sentinels stay connected with other Sentinels in order to reciprocally check the availability of each other, and to exchange messages. However you don't need to configure a list of other Sentinel addresses in every Sentinel instance you run, as Sentinel uses the Redis instances Pub/Sub capabilities in order to discover the other Sentinels that are monitoring the same masters and replicas.</p> <p>This feature is implemented by sending hello messages into the channel named <code>__sentinel__:hello</code>.</p> <p>Similarly you don't need to configure what is the list of the replicas attached to a master, as Sentinel will auto discover this list querying Redis.</p> <ul> <li>Every Sentinel publishes a message to every monitored master and replica Pub/Sub channel <code>__sentinel__:hello</code>, every two seconds, announcing its presence with ip, port, runid.</li> <li>Every Sentinel is subscribed to the Pub/Sub channel <code>__sentinel__:hello</code> of every master and replica, looking for unknown sentinels. When new sentinels are detected, they are added as sentinels of this master.</li> <li>Hello messages also include the full current configuration of the master. If the receiving Sentinel has a configuration for a given master which is older than the one received, it updates to the new configuration immediately.</li> <li>Before adding a new sentinel to a master a Sentinel always checks if there is already a sentinel with the same runid or the same address (ip and port pair). In that case all the matching sentinels are removed, and the new added.</li> </ul>"},{"location":"7-management/sentinel/#sentinel-reconfiguration-of-instances-outside-the-failover-procedure","title":"Sentinel reconfiguration of instances outside the failover procedure","text":"<p>Even when no failover is in progress, Sentinels will always try to set the current configuration on monitored instances. Specifically:</p> <ul> <li>Replicas (according to the current configuration) that claim to be masters, will be configured as replicas to replicate with the current master.</li> <li>Replicas connected to a wrong master, will be reconfigured to replicate with the right master.</li> </ul> <p>For Sentinels to reconfigure replicas, the wrong configuration must be observed for some time, that is greater than the period used to broadcast new configurations.</p> <p>This prevents Sentinels with a stale configuration (for example because they just rejoined from a partition) will try to change the replicas configuration before receiving an update.</p> <p>Also note how the semantics of always trying to impose the current configuration makes the failover more resistant to partitions:</p> <ul> <li>Masters failed over are reconfigured as replicas when they return available.</li> <li>Replicas partitioned away during a partition are reconfigured once reachable.</li> </ul> <p>The important lesson to remember about this section is: Sentinel is a system where each process will always try to impose the last logical configuration to the set of monitored instances.</p>"},{"location":"7-management/sentinel/#replica-selection-and-priority","title":"Replica selection and priority","text":"<p>When a Sentinel instance is ready to perform a failover, since the master is in <code>ODOWN</code> state and the Sentinel received the authorization to failover from the majority of the Sentinel instances known, a suitable replica needs to be selected.</p> <p>The replica selection process evaluates the following information about replicas:</p> <ol> <li>Disconnection time from the master.</li> <li>Replica priority.</li> <li>Replication offset processed.</li> <li>Run ID.</li> </ol> <p>A replica that is found to be disconnected from the master for more than ten times the configured master timeout (down-after-milliseconds option), plus the time the master is also not available from the point of view of the Sentinel doing the failover, is considered to be not suitable for the failover and is skipped.</p> <p>In more rigorous terms, a replica whose the <code>INFO</code> output suggests it has been disconnected from the master for more than:</p> <pre><code>(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state\n</code></pre> <p>Is considered to be unreliable and is disregarded entirely.</p> <p>The replica selection only considers the replicas that passed the above test, and sorts it based on the above criteria, in the following order.</p> <ol> <li>The replicas are sorted by <code>replica-priority</code> as configured in the <code>redis.conf</code> file of the Redis instance. A lower priority will be preferred.</li> <li>If the priority is the same, the replication offset processed by the replica is checked, and the replica that received more data from the master is selected.</li> <li>If multiple replicas have the same priority and processed the same data from the master, a further check is performed, selecting the replica with the lexicographically smaller run ID. Having a lower run ID is not a real advantage for a replica, but is useful in order to make the process of replica selection more deterministic, instead of resorting to select a random replica.</li> </ol> <p>In most cases, <code>replica-priority</code> does not need to be set explicitly so all instances will use the same default value. If there is a particular fail-over preference, <code>replica-priority</code> must be set on all instances, including masters, as a master may become a replica at some future point in time - and it will then need the proper <code>replica-priority</code> settings.</p> <p>A Redis instance can be configured with a special <code>replica-priority</code> of zero in order to be never selected by Sentinels as the new master. However a replica configured in this way will still be reconfigured by Sentinels in order to replicate with the new master after a failover, the only difference is that it will never become a master itself.</p>"},{"location":"7-management/sentinel/#algorithms-and-internals","title":"Algorithms and internals","text":"<p>In the following sections we will explore the details of Sentinel behavior. It is not strictly needed for users to be aware of all the details, but a deep understanding of Sentinel may help to deploy and operate Sentinel in a more effective way.</p>"},{"location":"7-management/sentinel/#quorum","title":"Quorum","text":"<p>The previous sections showed that every master monitored by Sentinel is associated to a configured quorum. It specifies the number of Sentinel processes that need to agree about the unreachability or error condition of the master in order to trigger a failover.</p> <p>However, after the failover is triggered, in order for the failover to actually be performed, at least a majority of Sentinels must authorize the Sentinel to failover. Sentinel never performs a failover in the partition where a minority of Sentinels exist.</p> <p>Let's try to make things a bit more clear:</p> <ul> <li>Quorum: the number of Sentinel processes that need to detect an error condition in order for a master to be flagged as ODOWN.</li> <li>The failover is triggered by the ODOWN state.</li> <li>Once the failover is triggered, the Sentinel trying to failover is required to ask for authorization to a majority of Sentinels (or more than the majority if the quorum is set to a number greater than the majority).</li> </ul> <p>The difference may seem subtle but is actually quite simple to understand and use.  For example if you have 5 Sentinel instances, and the quorum is set to 2, a failover will be triggered as soon as 2 Sentinels believe that the master is not reachable, however one of the two Sentinels will be able to failover only if it gets authorization at least from 3 Sentinels.</p> <p>If instead the quorum is configured to 5, all the Sentinels must agree about the master error condition, and the authorization from all Sentinels is required in order to failover.</p> <p>This means that the quorum can be used to tune Sentinel in two ways:</p> <ol> <li>If a quorum is set to a value smaller than the majority of Sentinels we deploy, we are basically making Sentinel more sensitive to master failures, triggering a failover as soon as even just a minority of Sentinels is no longer able to talk with the master.</li> <li>If a quorum is set to a value greater than the majority of Sentinels, we are making Sentinel able to failover only when there are a very large number (larger than majority) of well connected Sentinels which agree about the master being down.</li> </ol>"},{"location":"7-management/sentinel/#configuration-epochs","title":"Configuration epochs","text":"<p>Sentinels require to get authorizations from a majority in order to start a failover for a few important reasons:</p> <p>When a Sentinel is authorized, it gets a unique configuration epoch for the master it is failing over. This is a number that will be used to version the new configuration after the failover is completed. Because a majority agreed that a given version was assigned to a given Sentinel, no other Sentinel will be able to use it. This means that every configuration of every failover is versioned with a unique version. We'll see why this is so important.</p> <p>Moreover Sentinels have a rule: if a Sentinel voted another Sentinel for the failover of a given master, it will wait some time to try to failover the same master again. This delay is the <code>2 * failover-timeout</code> you can configure in <code>sentinel.conf</code>. This means that Sentinels will not try to failover the same master at the same time, the first to ask to be authorized will try, if it fails another will try after some time, and so forth.</p> <p>Redis Sentinel guarantees the liveness property that if a majority of Sentinels are able to talk, eventually one will be authorized to failover if the master is down.</p> <p>Redis Sentinel also guarantees the safety property that every Sentinel will failover the same master using a different configuration epoch.</p>"},{"location":"7-management/sentinel/#configuration-propagation","title":"Configuration propagation","text":"<p>Once a Sentinel is able to failover a master successfully, it will start to broadcast the new configuration so that the other Sentinels will update their information about a given master.</p> <p>For a failover to be considered successful, it requires that the Sentinel was able to send the <code>REPLICAOF NO ONE</code> command to the selected replica, and that the switch to master was later observed in the <code>INFO</code> output of the master.</p> <p>At this point, even if the reconfiguration of the replicas is in progress, the failover is considered to be successful, and all the Sentinels are required to start reporting the new configuration.</p> <p>The way a new configuration is propagated is the reason why we need that every Sentinel failover is authorized with a different version number (configuration epoch).</p> <p>Every Sentinel continuously broadcast its version of the configuration of a master using Redis Pub/Sub messages, both in the master and all the replicas.  At the same time all the Sentinels wait for messages to see what is the configuration advertised by the other Sentinels.</p> <p>Configurations are broadcast in the <code>__sentinel__:hello</code> Pub/Sub channel.</p> <p>Because every configuration has a different version number, the greater version always wins over smaller versions.</p> <p>So for example the configuration for the master <code>mymaster</code> start with all the Sentinels believing the master is at 192.168.1.50:6379. This configuration has version 1. After some time a Sentinel is authorized to failover with version 2. If the failover is successful, it will start to broadcast a new configuration, let's say 192.168.1.50:9000, with version 2. All the other instances will see this configuration and will update their configuration accordingly, since the new configuration has a greater version.</p> <p>This means that Sentinel guarantees a second liveness property: a set of Sentinels that are able to communicate will all converge to the same configuration with the higher version number.</p> <p>Basically if the net is partitioned, every partition will converge to the higher local configuration. In the special case of no partitions, there is a single partition and every Sentinel will agree about the configuration.</p>"},{"location":"7-management/sentinel/#consistency-under-partitions","title":"Consistency under partitions","text":"<p>Redis Sentinel configurations are eventually consistent, so every partition will converge to the higher configuration available. However in a real-world system using Sentinel there are three different players:</p> <ul> <li>Redis instances.</li> <li>Sentinel instances.</li> <li>Clients.</li> </ul> <p>In order to define the behavior of the system we have to consider all three.</p> <p>The following is a simple network where there are 3 nodes, each running a Redis instance, and a Sentinel instance:</p> <pre><code>            +-------------+\n            | Sentinel 1  |----- Client A\n            | Redis 1 (M) |\n            +-------------+\n                    |\n                    |\n+-------------+     |          +------------+\n| Sentinel 2  |-----+-- // ----| Sentinel 3 |----- Client B\n| Redis 2 (S) |                | Redis 3 (M)|\n+-------------+                +------------+\n</code></pre> <p>In this system the original state was that Redis 3 was the master, while Redis 1 and 2 were replicas. A partition occurred isolating the old master. Sentinels 1 and 2 started a failover promoting Sentinel 1 as the new master.</p> <p>The Sentinel properties guarantee that Sentinel 1 and 2 now have the new configuration for the master. However Sentinel 3 has still the old configuration since it lives in a different partition.</p> <p>We know that Sentinel 3 will get its configuration updated when the network partition will heal, however what happens during the partition if there are clients partitioned with the old master?</p> <p>Clients will be still able to write to Redis 3, the old master. When the partition will rejoin, Redis 3 will be turned into a replica of Redis 1, and all the data written during the partition will be lost.</p> <p>Depending on your configuration you may want or not that this scenario happens:</p> <ul> <li>If you are using Redis as a cache, it could be handy that Client B is still able to write to the old master, even if its data will be lost.</li> <li>If you are using Redis as a store, this is not good and you need to configure the system in order to partially prevent this problem.</li> </ul> <p>Since Redis is asynchronously replicated, there is no way to totally prevent data loss in this scenario, however you can bound the divergence between Redis 3 and Redis 1 using the following Redis configuration option:</p> <pre><code>min-replicas-to-write 1\nmin-replicas-max-lag 10\n</code></pre> <p>With the above configuration (please see the self-commented <code>redis.conf</code> example in the Redis distribution for more information) a Redis instance, when acting as a master, will stop accepting writes if it can't write to at least 1 replica. Since replication is asynchronous not being able to write actually means that the replica is either disconnected, or is not sending us asynchronous acknowledges for more than the specified <code>max-lag</code> number of seconds.</p> <p>Using this configuration the Redis 3 in the above example will become unavailable after 10 seconds. When the partition heals, the Sentinel 3 configuration will converge to the new one, and Client B will be able to fetch a valid configuration and continue.</p> <p>In general Redis + Sentinel as a whole are an eventually consistent system where the merge function is last failover wins, and the data from old masters are discarded to replicate the data of the current master, so there is always a window for losing acknowledged writes. This is due to Redis asynchronous replication and the discarding nature of the \"virtual\" merge function of the system. Note that this is not a limitation of Sentinel itself, and if you orchestrate the failover with a strongly consistent replicated state machine, the same properties will still apply. There are only two ways to avoid losing acknowledged writes:</p> <ol> <li>Use synchronous replication (and a proper consensus algorithm to run a replicated state machine).</li> <li>Use an eventually consistent system where different versions of the same object can be merged.</li> </ol> <p>Redis currently is not able to use any of the above systems, and is currently outside the development goals. However there are proxies implementing solution \"2\" on top of Redis stores such as SoundCloud Roshi, or Netflix Dynomite.</p>"},{"location":"7-management/sentinel/#sentinel-persistent-state","title":"Sentinel persistent state","text":"<p>Sentinel state is persisted in the sentinel configuration file. For example every time a new configuration is received, or created (leader Sentinels), for a master, the configuration is persisted on disk together with the configuration epoch. This means that it is safe to stop and restart Sentinel processes.</p>"},{"location":"7-management/sentinel/#tilt-mode","title":"TILT mode","text":"<p>Redis Sentinel is heavily dependent on the computer time: for instance in order to understand if an instance is available it remembers the time of the latest successful reply to the PING command, and compares it with the current time to understand how old it is.</p> <p>However if the computer time changes in an unexpected way, or if the computer is very busy, or the process blocked for some reason, Sentinel may start to behave in an unexpected way.</p> <p>The TILT mode is a special \"protection\" mode that a Sentinel can enter when something odd is detected that can lower the reliability of the system. The Sentinel timer interrupt is normally called 10 times per second, so we expect that more or less 100 milliseconds will elapse between two calls to the timer interrupt.</p> <p>What a Sentinel does is to register the previous time the timer interrupt was called, and compare it with the current call: if the time difference is negative or unexpectedly big (2 seconds or more) the TILT mode is entered (or if it was already entered the exit from the TILT mode postponed).</p> <p>When in TILT mode the Sentinel will continue to monitor everything, but:</p> <ul> <li>It stops acting at all.</li> <li>It starts to reply negatively to <code>SENTINEL is-master-down-by-addr</code> requests as the ability to detect a failure is no longer trusted.</li> </ul> <p>If everything appears to be normal for 30 second, the TILT mode is exited.</p> <p>In the Sentinel TILT mode, if we send the INFO command, we could get the following response:</p> <pre><code>$ redis-cli -p 26379\n127.0.0.1:26379&gt; info\n(Other information from Sentinel server skipped.)\n\n# Sentinel\nsentinel_masters:1\nsentinel_tilt:0\nsentinel_tilt_since_seconds:-1\nsentinel_running_scripts:0\nsentinel_scripts_queue_length:0\nsentinel_simulate_failure_flags:0\nmaster0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=0,sentinels=1\n</code></pre> <p>The field \"sentinel_tilt_since_seconds\" indicates how many seconds the Sentinel already is in the TILT mode. If it is not in TILT mode, the value will be -1.</p> <p>Note that in some ways TILT mode could be replaced using the monotonic clock API that many kernels offer. However it is not still clear if this is a good solution since the current system avoids issues in case the process is just suspended or not executed by the scheduler for a long time.</p> <p>A note about the word slave used in this man page: Starting with Redis 5, if not for backward compatibility, the Redis project no longer uses the word slave. Unfortunately in this command the word slave is part of the protocol, so we'll be able to remove such occurrences only when this API will be naturally deprecated.</p>"},{"location":"7-management/troubleshooting/","title":"Troubleshooting Redis","text":"<p>This page tries to help you with what to do if you have issues with Redis. Part of the Redis project is helping people that are experiencing problems because we don't like to leave people alone with their issues.</p> <ul> <li>If you have latency problems with Redis, that in some way appears to be idle for some time, read our Redis latency troubleshooting guide.</li> <li>Redis stable releases are usually very reliable, however in the rare event you are experiencing crashes the developers can help a lot more if you provide debugging information. Please read our Debugging Redis guide.</li> <li>We have a long history of users experiencing crashes with Redis that actually turned out to be servers with broken RAM. Please test your RAM using redis-server --test-memory in case Redis is not stable in your system. Redis built-in memory test is fast and reasonably reliable, but if you can you should reboot your server and use memtest86.</li> </ul> <p>For every other problem please drop a message to the Redis Google Group. We will be glad to help.</p> <p>You can also find assistance on the Redis Discord server.</p>"},{"location":"7-management/troubleshooting/#list-of-known-critical-bugs-in-redis-30x-28x-and-26x","title":"List of known critical bugs in Redis 3.0.x, 2.8.x and 2.6.x","text":"<p>To find a list of critical bugs please refer to the changelogs:</p> <ul> <li>Redis 3.0 Changelog.</li> <li>Redis 2.8 Changelog.</li> <li>Redis 2.6 Changelog.</li> </ul> <p>Check the upgrade urgency level in each patch release to more easily spot releases that included important fixes.</p>"},{"location":"7-management/troubleshooting/#list-of-known-linux-related-bugs-affecting-redis","title":"List of known Linux related bugs affecting Redis.","text":"<ul> <li>Ubuntu 10.04 and 10.10 contain bugs that can cause performance issues. The default kernels shipped with these distributions are not recommended. Bugs were reported as having affected EC2 instances, but some users also cited server impact.</li> <li>Certain versions of the Xen hypervisor report poor fork() performance. See the latency page for more information.</li> </ul>"},{"location":"7-management/optimization/cpu-profiling/","title":"Redis CPU profiling","text":""},{"location":"7-management/optimization/cpu-profiling/#filling-the-performance-checklist","title":"Filling the performance checklist","text":"<p>Redis is developed with a great emphasis on performance. We do our best with every release to make sure you'll experience a very stable and fast product. </p> <p>Nevertheless, if you're finding room to improve the efficiency of Redis or are pursuing a performance regression investigation you will need a concise methodical way of monitoring and analyzing Redis performance. </p> <p>To do so you can rely on different methodologies (some more suited than other  depending on the class of issues/analysis we intend to make). A curated list of methodologies and their steps are enumerated by Brendan Greg at the following link. </p> <p>We recommend the Utilization Saturation and Errors (USE) Method for answering the question of what is your bottleneck. Check the following mapping between system resource, metric, and tools for a practical deep dive: USE method. </p>"},{"location":"7-management/optimization/cpu-profiling/#ensuring-the-cpu-is-your-bottleneck","title":"Ensuring the CPU is your bottleneck","text":"<p>This guide assumes you've followed one of the above methodologies to perform a  complete check of system health, and identified the bottleneck being the CPU.  If you have identified that most of the time is spent blocked on I/O, locks, timers, paging/swapping, etc., this guide is not for you. </p>"},{"location":"7-management/optimization/cpu-profiling/#build-prerequisites","title":"Build Prerequisites","text":"<p>For a proper On-CPU analysis, Redis (and any dynamically loaded library like Redis Modules) requires stack traces to be available to tracers, which you may need to fix first. </p> <p>By default, Redis is compiled with the <code>-O2</code> switch (which we intent to keep during profiling). This means that compiler optimizations are enabled. Many compilers omit the frame pointer as a runtime optimization (saving a register), thus breaking frame pointer-based stack walking. This makes the Redis executable faster, but at the same time it makes Redis (like any other program) harder to trace, potentially wrongfully pinpointing on-CPU time to the last available frame pointer of a call stack that can get a lot deeper (but impossible to trace).</p> <p>It's important that you ensure that: - debug information is present: compile option <code>-g</code> - frame pointer register is present: <code>-fno-omit-frame-pointer</code> - we still run with optimizations to get an accurate representation of production run times, meaning we will keep: <code>-O2</code></p> <p>You can do it as follows within redis main repo:</p> <pre><code>$ make REDIS_CFLAGS=\"-g -fno-omit-frame-pointer\"\n</code></pre>"},{"location":"7-management/optimization/cpu-profiling/#a-set-of-instruments-to-identify-performance-regressions-andor-potential-on-cpu-performance-improvements","title":"A set of instruments to identify performance regressions and/or potential on-CPU performance improvements","text":"<p>This document focuses specifically on on-CPU resource bottlenecks analysis, meaning we're interested in understanding where threads are spending CPU cycles while running on-CPU and, as importantly, whether those cycles are effectively being used for computation or stalled waiting (not blocked!) for memory I/O, and cache misses, etc.</p> <p>For that we will rely on toolkits (perf, bcc tools), and hardware specific PMCs (Performance Monitoring Counters), to proceed with:</p> <ul> <li> <p>Hotspot analysis (perf or bcc tools): to profile code execution and determine which functions are consuming the most time and thus are targets for optimization. We'll present two options to collect, report, and visualize hotspots either with perf or bcc/BPF tracing tools.</p> </li> <li> <p>Call counts analysis: to count events including function calls, enabling us to correlate several calls/components at once, relying on bcc/BPF tracing tools.</p> </li> <li> <p>Hardware event sampling: crucial for understanding CPU behavior, including memory I/O, stall cycles, and cache misses.</p> </li> </ul>"},{"location":"7-management/optimization/cpu-profiling/#tool-prerequisites","title":"Tool prerequisites","text":"<p>The following steps rely on Linux perf_events (aka \"perf\"), bcc/BPF tracing tools, and Brendan Greg\u2019s FlameGraph repo.</p> <p>We assume beforehand you have:</p> <ul> <li>Installed the perf tool on your system. Most Linux distributions will likely package this as a package related to the kernel. More information about the perf tool can be found at perf wiki.</li> <li>Followed the install bcc/BPF instructions to install bcc toolkit on your machine.</li> <li>Cloned Brendan Greg\u2019s FlameGraph repo and made accessible the <code>difffolded.pl</code> and <code>flamegraph.pl</code> files, to generated the collapsed stack traces and Flame Graphs.</li> </ul>"},{"location":"7-management/optimization/cpu-profiling/#hotspot-analysis-with-perf-or-ebpf-stack-traces-sampling","title":"Hotspot analysis with perf or eBPF (stack traces sampling)","text":"<p>Profiling CPU usage by sampling stack traces at a timed interval is a fast and easy way to identify performance-critical code sections (hotspots).</p>"},{"location":"7-management/optimization/cpu-profiling/#sampling-stack-traces-using-perf","title":"Sampling stack traces using perf","text":"<p>To profile both user- and kernel-level stacks of redis-server for a specific length of time, for example 60 seconds, at a sampling frequency of 999 samples per second:</p> <pre><code>$ perf record -g --pid $(pgrep redis-server) -F 999 -- sleep 60\n</code></pre>"},{"location":"7-management/optimization/cpu-profiling/#displaying-the-recorded-profile-information-using-perf-report","title":"Displaying the recorded profile information using perf report","text":"<p>By default perf record will generate a perf.data file in the current working directory. </p> <p>You can then report with a call-graph output (call chain, stack backtrace), with a minimum call graph inclusion threshold of 0.5%, with:</p> <pre><code>$ perf report -g \"graph,0.5,caller\"\n</code></pre> <p>See the perf report documentation for advanced filtering, sorting and aggregation capabilities.</p>"},{"location":"7-management/optimization/cpu-profiling/#visualizing-the-recorded-profile-information-using-flame-graphs","title":"Visualizing the recorded profile information using Flame Graphs","text":"<p>Flame graphs allow for a quick and accurate visualization of frequent code-paths. They can be generated using Brendan Greg's open source programs on github, which create interactive SVGs from folded stack files.</p> <p>Specifically, for perf we need to convert the generated perf.data into the captured stacks, and fold each of them into single lines. You can then render the on-CPU flame graph with:</p> <pre><code>$ perf script &gt; redis.perf.stacks\n$ stackcollapse-perf.pl redis.perf.stacks &gt; redis.folded.stacks\n$ flamegraph.pl redis.folded.stacks &gt; redis.svg\n</code></pre> <p>By default, perf script will generate a perf.data file in the current working directory. See the perf script documentation for advanced usage.</p> <p>See FlameGraph usage options for more advanced stack trace visualizations (like the differential one).</p>"},{"location":"7-management/optimization/cpu-profiling/#archiving-and-sharing-recorded-profile-information","title":"Archiving and sharing recorded profile information","text":"<p>So that analysis of the perf.data contents can be possible on a machine other than the one on which collection happened, you need to export along with the perf.data file all object files with build-ids found in the record data file. This can be easily done with the help of  perf-archive.sh script:</p> <pre><code>$ perf-archive.sh perf.data\n</code></pre> <p>Now please run:</p> <pre><code>$ tar xvf perf.data.tar.bz2 -C ~/.debug\n</code></pre> <p>on the machine where you need to run <code>perf report</code>.</p>"},{"location":"7-management/optimization/cpu-profiling/#sampling-stack-traces-using-bccbpfs-profile","title":"Sampling stack traces using bcc/BPF's profile","text":"<p>Similarly to perf, as of Linux kernel 4.9, BPF-optimized profiling is now fully available with the promise of lower overhead on CPU (as stack traces are frequency counted in kernel context) and disk I/O resources during profiling. </p> <p>Apart from that, and relying solely on bcc/BPF's profile tool, we have also removed the perf.data and intermediate steps if stack traces analysis is our main goal. You can use bcc's profile tool to output folded format directly, for flame graph generation:</p> <pre><code>$ /usr/share/bcc/tools/profile -F 999 -f --pid $(pgrep redis-server) --duration 60 &gt; redis.folded.stacks\n</code></pre> <p>In that manner, we've remove any preprocessing and can render the on-CPU flame graph with a single command:</p> <pre><code>$ flamegraph.pl redis.folded.stacks &gt; redis.svg\n</code></pre>"},{"location":"7-management/optimization/cpu-profiling/#visualizing-the-recorded-profile-information-using-flame-graphs_1","title":"Visualizing the recorded profile information using Flame Graphs","text":""},{"location":"7-management/optimization/cpu-profiling/#call-counts-analysis-with-bccbpf","title":"Call counts analysis with bcc/BPF","text":"<p>A function may consume significant CPU cycles either because its code is slow or because it's frequently called. To answer at what rate functions are being called, you can rely upon call counts analysis using BCC's <code>funccount</code> tool:</p> <pre><code>$ /usr/share/bcc/tools/funccount 'redis-server:(call*|*Read*|*Write*)' --pid $(pgrep redis-server) --duration 60\nTracing 64 functions for \"redis-server:(call*|*Read*|*Write*)\"... Hit Ctrl-C to end.\n\nFUNC                                    COUNT\ncall                                      334\nhandleClientsWithPendingWrites            388\nclientInstallWriteHandler                 388\npostponeClientRead                        514\nhandleClientsWithPendingReadsUsingThreads      735\nhandleClientsWithPendingWritesUsingThreads      735\nprepareClientToWrite                     1442\nDetaching...\n</code></pre> <p>The above output shows that, while tracing, the Redis's call() function was called 334 times, handleClientsWithPendingWrites() 388 times, etc.</p>"},{"location":"7-management/optimization/cpu-profiling/#hardware-event-counting-with-performance-monitoring-counters-pmcs","title":"Hardware event counting with Performance Monitoring Counters (PMCs)","text":"<p>Many modern processors contain a performance monitoring unit (PMU) exposing Performance Monitoring Counters (PMCs). PMCs are crucial for understanding CPU behavior, including memory I/O, stall cycles, and cache misses, and provide low-level CPU performance statistics that aren't available anywhere else.</p> <p>The design and functionality of a PMU is CPU-specific and you should assess your CPU supported counters and features by using <code>perf list</code>. </p> <p>To calculate the number of instructions per cycle, the number of micro ops executed, the number of cycles during which no micro ops were dispatched, the number stalled cycles on memory, including a per memory type stalls, for the duration of 60s, specifically for redis process: </p> <pre><code>$ perf stat -e \"cpu-clock,cpu-cycles,instructions,uops_executed.core,uops_executed.stall_cycles,cache-references,cache-misses,cycle_activity.stalls_total,cycle_activity.stalls_mem_any,cycle_activity.stalls_l3_miss,cycle_activity.stalls_l2_miss,cycle_activity.stalls_l1d_miss\" --pid $(pgrep redis-server) -- sleep 60\n\nPerformance counter stats for process id '3038':\n\n  60046.411437      cpu-clock (msec)          #    1.001 CPUs utilized          \n  168991975443      cpu-cycles                #    2.814 GHz                      (36.40%)\n  388248178431      instructions              #    2.30  insn per cycle           (45.50%)\n  443134227322      uops_executed.core        # 7379.862 M/sec                    (45.51%)\n   30317116399      uops_executed.stall_cycles #  504.895 M/sec                    (45.51%)\n     670821512      cache-references          #   11.172 M/sec                    (45.52%)\n      23727619      cache-misses              #    3.537 % of all cache refs      (45.43%)\n   30278479141      cycle_activity.stalls_total #  504.251 M/sec                    (36.33%)\n   19981138777      cycle_activity.stalls_mem_any #  332.762 M/sec                    (36.33%)\n     725708324      cycle_activity.stalls_l3_miss #   12.086 M/sec                    (36.33%)\n    8487905659      cycle_activity.stalls_l2_miss #  141.356 M/sec                    (36.32%)\n   10011909368      cycle_activity.stalls_l1d_miss #  166.736 M/sec                    (36.31%)\n\n  60.002765665 seconds time elapsed\n</code></pre> <p>It's important to know that there are two very different ways in which PMCs can be used (counting and sampling), and we've focused solely on PMCs counting for the sake of this analysis. Brendan Greg clearly explains it on the following link.</p>"},{"location":"7-management/optimization/latency-monitor/","title":"Redis latency monitoring","text":"<p>Redis is often used for demanding use cases, where it serves a large number of queries per second per instance, but also has strict latency requirements for the average response time and the worst-case latency.</p> <p>While Redis is an in-memory system, it deals with the operating system in different ways, for example, in the context of persisting to disk. Moreover Redis implements a rich set of commands. Certain commands are fast and run in constant or logarithmic time. Other commands are slower O(N) commands that can cause latency spikes.</p> <p>Finally, Redis is single threaded. This is usually an advantage from the point of view of the amount of work it can perform per core, and in the latency figures it is able to provide. However, it poses a challenge for latency, since the single thread must be able to perform certain tasks incrementally, for example key expiration, in a way that does not impact the other clients that are served.</p> <p>For all these reasons, Redis 2.8.13 introduced a new feature called Latency Monitoring, that helps the user to check and troubleshoot possible latency problems. Latency monitoring is composed of the following conceptual parts:</p> <ul> <li>Latency hooks that sample different latency-sensitive code paths.</li> <li>Time series recording of latency spikes, split by different events.</li> <li>Reporting engine to fetch raw data from the time series.</li> <li>Analysis engine to provide human-readable reports and hints according to the measurements.</li> </ul> <p>The rest of this document covers the latency monitoring subsystem details. For more information about the general topic of Redis and latency, see Redis latency problems troubleshooting.</p>"},{"location":"7-management/optimization/latency-monitor/#events-and-time-series","title":"Events and time series","text":"<p>Different monitored code paths have different names and are called events. For example, <code>command</code> is an event that measures latency spikes of possibly slow command executions, while <code>fast-command</code> is the event name for the monitoring of the O(1) and O(log N) commands. Other events are less generic and monitor specific operations performed by Redis. For example, the <code>fork</code> event only monitors the time taken by Redis to execute the <code>fork(2)</code> system call.</p> <p>A latency spike is an event that takes more time to run than the configured latency threshold. There is a separate time series associated with every monitored event. This is how the time series work:</p> <ul> <li>Every time a latency spike happens, it is logged in the appropriate time series.</li> <li>Every time series is composed of 160 elements.</li> <li>Each element is a pair made of a Unix timestamp of the time the latency spike was measured and the number of milliseconds the event took to execute.</li> <li>Latency spikes for the same event that occur in the same second are merged by taking the maximum latency. Even if continuous latency spikes are measured for a given event, which could happen with a low threshold, at least 160 seconds of history are available.</li> <li>Records the all-time maximum latency for every element.</li> </ul> <p>The framework monitors and logs latency spikes in the execution time of these events:</p> <ul> <li><code>command</code>: regular commands.</li> <li><code>fast-command</code>: O(1) and O(log N) commands.</li> <li><code>fork</code>: the <code>fork(2)</code> system call.</li> <li><code>rdb-unlink-temp-file</code>: the <code>unlink(2)</code> system call.</li> <li><code>aof-fsync-always</code>: the <code>fsync(2)</code> system call when invoked by the <code>appendfsync allways</code> policy.</li> <li><code>aof-write</code>: writing to the AOF - a catchall event for <code>write(2)</code> system calls.</li> <li><code>aof-write-pending-fsync</code>: the <code>write(2)</code> system call when there is a pending fsync.</li> <li><code>aof-write-active-child</code>: the <code>write(2)</code> system call when there are active child processes.</li> <li><code>aof-write-alone</code>: the <code>write(2)</code> system call when no pending fsync and no active child process.</li> <li><code>aof-fstat</code>: the <code>fstat(2)</code> system call.</li> <li><code>aof-rename</code>: the <code>rename(2)</code> system call for renaming the temporary file after completing <code>BGREWRITEAOF</code>.</li> <li><code>aof-rewrite-diff-write</code>: writing the differences accumulated while performing <code>BGREWRITEAOF</code>.</li> <li><code>active-defrag-cycle</code>: the active defragmentation cycle.</li> <li><code>expire-cycle</code>: the expiration cycle.</li> <li><code>eviction-cycle</code>: the eviction cycle.</li> <li><code>eviction-del</code>: deletes during the eviction cycle.</li> </ul>"},{"location":"7-management/optimization/latency-monitor/#how-to-enable-latency-monitoring","title":"How to enable latency monitoring","text":"<p>What is high latency for one use case may not be considered high latency for another. Some applications may require that all queries be served in less than 1 millisecond. For other applications, it may be acceptable for a small amount of clients to experience a 2 second latency on occasion.</p> <p>The first step to enable the latency monitor is to set a latency threshold in milliseconds. Only events that take longer than the specified threshold will be logged as latency spikes. The user should set the threshold according to their needs. For example, if the application requires a maximum acceptable latency of 100 milliseconds, the threshold should be set to log all the events blocking the server for a time equal or greater to 100 milliseconds.</p> <p>Enable the latency monitor at runtime in a production server with the following command:</p> <pre><code>CONFIG SET latency-monitor-threshold 100\n</code></pre> <p>Monitoring is turned off by default (threshold set to 0), even if the actual cost of latency monitoring is near zero. While the memory requirements of latency monitoring are very small, there is no good reason to raise the baseline memory usage of a Redis instance that is working well.</p>"},{"location":"7-management/optimization/latency-monitor/#report-information-with-the-latency-command","title":"Report information with the LATENCY command","text":"<p>The user interface to the latency monitoring subsystem is the <code>LATENCY</code> command. Like many other Redis commands, <code>LATENCY</code> accepts subcommands that modify its behavior. These subcommands are:</p> <ul> <li><code>LATENCY LATEST</code> - returns the latest latency samples for all events.</li> <li><code>LATENCY HISTORY</code> - returns latency time series for a given event.</li> <li><code>LATENCY RESET</code> - resets latency time series data for one or more events.</li> <li><code>LATENCY GRAPH</code> - renders an ASCII-art graph of an event's latency samples.</li> <li><code>LATENCY DOCTOR</code> - replies with a human-readable latency analysis report.</li> </ul> <p>Refer to each subcommand's documentation page for further information.</p>"},{"location":"7-management/optimization/latency/","title":"Diagnosing latency issues","text":"<p>This document will help you understand what the problem could be if you are experiencing latency problems with Redis.</p> <p>In this context latency is the maximum delay between the time a client issues a command and the time the reply to the command is received by the client. Usually Redis processing time is extremely low, in the sub microsecond range, but there are certain conditions leading to higher latency figures.</p>"},{"location":"7-management/optimization/latency/#ive-little-time-give-me-the-checklist","title":"I've little time, give me the checklist","text":"<p>The following documentation is very important in order to run Redis in a low latency fashion. However I understand that we are busy people, so let's start with a quick checklist. If you fail following these steps, please return here to read the full documentation.</p> <ol> <li>Make sure you are not running slow commands that are blocking the server. Use the Redis Slow Log feature to check this.</li> <li>For EC2 users, make sure you use HVM based modern EC2 instances, like m3.medium. Otherwise fork() is too slow.</li> <li>Transparent huge pages must be disabled from your kernel. Use <code>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</code> to disable them, and restart your Redis process.</li> <li>If you are using a virtual machine, it is possible that you have an intrinsic latency that has nothing to do with Redis. Check the minimum latency you can expect from your runtime environment using <code>./redis-cli --intrinsic-latency 100</code>. Note: you need to run this command in the server not in the client.</li> <li>Enable and use the Latency monitor feature of Redis in order to get a human readable description of the latency events and causes in your Redis instance.</li> </ol> <p>In general, use the following table for durability VS latency/performance tradeoffs, ordered from stronger safety to better latency.</p> <ol> <li>AOF + fsync always: this is very slow, you should use it only if you know what you are doing.</li> <li>AOF + fsync every second: this is a good compromise.</li> <li>AOF + fsync every second + no-appendfsync-on-rewrite option set to yes: this is as the above, but avoids to fsync during rewrites to lower the disk pressure.</li> <li>AOF + fsync never. Fsyncing is up to the kernel in this setup, even less disk pressure and risk of latency spikes.</li> <li>RDB. Here you have a vast spectrum of tradeoffs depending on the save triggers you configure.</li> </ol> <p>And now for people with 15 minutes to spend, the details...</p>"},{"location":"7-management/optimization/latency/#measuring-latency","title":"Measuring latency","text":"<p>If you are experiencing latency problems, you probably know how to measure it in the context of your application, or maybe your latency problem is very evident even macroscopically. However redis-cli can be used to measure the latency of a Redis server in milliseconds, just try:</p> <pre><code>redis-cli --latency -h `host` -p `port`\n</code></pre>"},{"location":"7-management/optimization/latency/#using-the-internal-redis-latency-monitoring-subsystem","title":"Using the internal Redis latency monitoring subsystem","text":"<p>Since Redis 2.8.13, Redis provides latency monitoring capabilities that are able to sample different execution paths to understand where the server is blocking. This makes debugging of the problems illustrated in this documentation much simpler, so we suggest enabling latency monitoring ASAP. Please refer to the Latency monitor documentation.</p> <p>While the latency monitoring sampling and reporting capabilities will make it simpler to understand the source of latency in your Redis system, it is still advised that you read this documentation extensively to better understand the topic of Redis and latency spikes.</p>"},{"location":"7-management/optimization/latency/#latency-baseline","title":"Latency baseline","text":"<p>There is a kind of latency that is inherently part of the environment where you run Redis, that is the latency provided by your operating system kernel and, if you are using virtualization, by the hypervisor you are using.</p> <p>While this latency can't be removed it is important to study it because it is the baseline, or in other words, you won't be able to achieve a Redis latency that is better than the latency that every process running in your environment will experience because of the kernel or hypervisor implementation or setup.</p> <p>We call this kind of latency intrinsic latency, and <code>redis-cli</code> starting from Redis version 2.8.7 is able to measure it. This is an example run under Linux 3.11.0 running on an entry level server.</p> <p>Note: the argument <code>100</code> is the number of seconds the test will be executed. The more time we run the test, the more likely we'll be able to spot latency spikes. 100 seconds is usually appropriate, however you may want to perform a few runs at different times. Please note that the test is CPU intensive and will likely saturate a single core in your system.</p> <pre><code>$ ./redis-cli --intrinsic-latency 100\nMax latency so far: 1 microseconds.\nMax latency so far: 16 microseconds.\nMax latency so far: 50 microseconds.\nMax latency so far: 53 microseconds.\nMax latency so far: 83 microseconds.\nMax latency so far: 115 microseconds.\n</code></pre> <p>Note: redis-cli in this special case needs to run in the server where you run or plan to run Redis, not in the client. In this special mode redis-cli does not connect to a Redis server at all: it will just try to measure the largest time the kernel does not provide CPU time to run to the redis-cli process itself.</p> <p>In the above example, the intrinsic latency of the system is just 0.115 milliseconds (or 115 microseconds), which is a good news, however keep in mind that the intrinsic latency may change over time depending on the load of the system.</p> <p>Virtualized environments will not show so good numbers, especially with high load or if there are noisy neighbors. The following is a run on a Linode 4096 instance running Redis and Apache:</p> <pre><code>$ ./redis-cli --intrinsic-latency 100\nMax latency so far: 573 microseconds.\nMax latency so far: 695 microseconds.\nMax latency so far: 919 microseconds.\nMax latency so far: 1606 microseconds.\nMax latency so far: 3191 microseconds.\nMax latency so far: 9243 microseconds.\nMax latency so far: 9671 microseconds.\n</code></pre> <p>Here we have an intrinsic latency of 9.7 milliseconds: this means that we can't ask better than that to Redis. However other runs at different times in different virtualization environments with higher load or with noisy neighbors can easily show even worse values. We were able to measure up to 40 milliseconds in systems otherwise apparently running normally.</p>"},{"location":"7-management/optimization/latency/#latency-induced-by-network-and-communication","title":"Latency induced by network and communication","text":"<p>Clients connect to Redis using a TCP/IP connection or a Unix domain connection. The typical latency of a 1 Gbit/s network is about 200 us, while the latency with a Unix domain socket can be as low as 30 us. It actually depends on your network and system hardware. On top of the communication itself, the system adds some more latency (due to thread scheduling, CPU caches, NUMA placement, etc ...). System induced latencies are significantly higher on a virtualized environment than on a physical machine.</p> <p>The consequence is even if Redis processes most commands in sub microsecond range, a client performing many roundtrips to the server will have to pay for these network and system related latencies.</p> <p>An efficient client will therefore try to limit the number of roundtrips by pipelining several commands together. This is fully supported by the servers and most clients. Aggregated commands like MSET/MGET can be also used for that purpose. Starting with Redis 2.4, a number of commands also support variadic parameters for all data types.</p> <p>Here are some guidelines:</p> <ul> <li>If you can afford it, prefer a physical machine over a VM to host the server.</li> <li>Do not systematically connect/disconnect to the server (especially true   for web based applications). Keep your connections as long lived as possible.</li> <li>If your client is on the same host than the server, use Unix domain sockets.</li> <li>Prefer to use aggregated commands (MSET/MGET), or commands with variadic   parameters (if possible) over pipelining.</li> <li>Prefer to use pipelining (if possible) over sequence of roundtrips.</li> <li>Redis supports Lua server-side scripting to cover cases that are not suitable   for raw pipelining (for instance when the result of a command is an input for   the following commands).</li> </ul> <p>On Linux, some people can achieve better latencies by playing with process placement (taskset), cgroups, real-time priorities (chrt), NUMA configuration (numactl), or by using a low-latency kernel. Please note vanilla Redis is not really suitable to be bound on a single CPU core. Redis can fork background tasks that can be extremely CPU consuming like <code>BGSAVE</code> or <code>BGREWRITEAOF</code>. These tasks must never run on the same core as the main event loop.</p> <p>In most situations, these kind of system level optimizations are not needed. Only do them if you require them, and if you are familiar with them.</p>"},{"location":"7-management/optimization/latency/#single-threaded-nature-of-redis","title":"Single threaded nature of Redis","text":"<p>Redis uses a mostly single threaded design. This means that a single process serves all the client requests, using a technique called multiplexing. This means that Redis can serve a single request in every given moment, so all the requests are served sequentially. This is very similar to how Node.js works as well. However, both products are not often perceived as being slow. This is caused in part by the small amount of time to complete a single request, but primarily because these products are designed to not block on system calls, such as reading data from or writing data to a socket.</p> <p>I said that Redis is mostly single threaded since actually from Redis 2.4 we use threads in Redis in order to perform some slow I/O operations in the background, mainly related to disk I/O, but this does not change the fact that Redis serves all the requests using a single thread.</p>"},{"location":"7-management/optimization/latency/#latency-generated-by-slow-commands","title":"Latency generated by slow commands","text":"<p>A consequence of being single thread is that when a request is slow to serve all the other clients will wait for this request to be served. When executing normal commands, like <code>GET</code> or <code>SET</code> or <code>LPUSH</code> this is not a problem at all since these commands are executed in constant (and very small) time. However there are commands operating on many elements, like <code>SORT</code>, <code>LREM</code>, <code>SUNION</code> and others. For instance taking the intersection of two big sets can take a considerable amount of time.</p> <p>The algorithmic complexity of all commands is documented. A good practice is to systematically check it when using commands you are not familiar with.</p> <p>If you have latency concerns you should either not use slow commands against values composed of many elements, or you should run a replica using Redis replication where you run all your slow queries.</p> <p>It is possible to monitor slow commands using the Redis Slow Log feature.</p> <p>Additionally, you can use your favorite per-process monitoring program (top, htop, prstat, etc ...) to quickly check the CPU consumption of the main Redis process. If it is high while the traffic is not, it is usually a sign that slow commands are used.</p> <p>IMPORTANT NOTE: a VERY common source of latency generated by the execution of slow commands is the use of the <code>KEYS</code> command in production environments. <code>KEYS</code>, as documented in the Redis documentation, should only be used for debugging purposes. Since Redis 2.8 a new commands were introduced in order to iterate the key space and other large collections incrementally, please check the <code>SCAN</code>, <code>SSCAN</code>, <code>HSCAN</code> and <code>ZSCAN</code> commands for more information.</p>"},{"location":"7-management/optimization/latency/#latency-generated-by-fork","title":"Latency generated by fork","text":"<p>In order to generate the RDB file in background, or to rewrite the Append Only File if AOF persistence is enabled, Redis has to fork background processes. The fork operation (running in the main thread) can induce latency by itself.</p> <p>Forking is an expensive operation on most Unix-like systems, since it involves copying a good number of objects linked to the process. This is especially true for the page table associated to the virtual memory mechanism.</p> <p>For instance on a Linux/AMD64 system, the memory is divided in 4 kB pages. To convert virtual addresses to physical addresses, each process stores a page table (actually represented as a tree) containing at least a pointer per page of the address space of the process. So a large 24 GB Redis instance requires a page table of 24 GB / 4 kB * 8 = 48 MB.</p> <p>When a background save is performed, this instance will have to be forked, which will involve allocating and copying 48 MB of memory. It takes time and CPU, especially on virtual machines where allocation and initialization of a large memory chunk can be expensive.</p>"},{"location":"7-management/optimization/latency/#fork-time-in-different-systems","title":"Fork time in different systems","text":"<p>Modern hardware is pretty fast at copying the page table, but Xen is not. The problem with Xen is not virtualization-specific, but Xen-specific. For instance using VMware or Virtual Box does not result into slow fork time. The following is a table that compares fork time for different Redis instance size. Data is obtained performing a BGSAVE and looking at the <code>latest_fork_usec</code> filed in the <code>INFO</code> command output.</p> <p>However the good news is that new types of EC2 HVM based instances are much better with fork times, almost on par with physical servers, so for example using m3.medium (or better) instances will provide good results.</p> <ul> <li>Linux beefy VM on VMware 6.0GB RSS forked in 77 milliseconds (12.8 milliseconds per GB).</li> <li>Linux running on physical machine (Unknown HW) 6.1GB RSS forked in 80 milliseconds (13.1 milliseconds per GB)</li> <li>Linux running on physical machine (Xeon @ 2.27Ghz) 6.9GB RSS forked into 62 milliseconds (9 milliseconds per GB).</li> <li>Linux VM on 6sync (KVM) 360 MB RSS forked in 8.2 milliseconds (23.3 milliseconds per GB).</li> <li>Linux VM on EC2, old instance types (Xen) 6.1GB RSS forked in 1460 milliseconds (239.3 milliseconds per GB).</li> <li>Linux VM on EC2, new instance types (Xen) 1GB RSS forked in 10 milliseconds (10 milliseconds per GB).</li> <li>Linux VM on Linode (Xen) 0.9GBRSS forked into 382 milliseconds (424 milliseconds per GB).</li> </ul> <p>As you can see certain VMs running on Xen have a performance hit that is between one order to two orders of magnitude. For EC2 users the suggestion is simple: use modern HVM based instances.</p>"},{"location":"7-management/optimization/latency/#latency-induced-by-transparent-huge-pages","title":"Latency induced by transparent huge pages","text":"<p>Unfortunately when a Linux kernel has transparent huge pages enabled, Redis incurs to a big latency penalty after the <code>fork</code> call is used in order to persist on disk. Huge pages are the cause of the following issue:</p> <ol> <li>Fork is called, two processes with shared huge pages are created.</li> <li>In a busy instance, a few event loops runs will cause commands to target a few thousand of pages, causing the copy on write of almost the whole process memory.</li> <li>This will result in big latency and big memory usage.</li> </ol> <p>Make sure to disable transparent huge pages using the following command:</p> <pre><code>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled\n</code></pre>"},{"location":"7-management/optimization/latency/#latency-induced-by-swapping-operating-system-paging","title":"Latency induced by swapping (operating system paging)","text":"<p>Linux (and many other modern operating systems) is able to relocate memory pages from the memory to the disk, and vice versa, in order to use the system memory efficiently.</p> <p>If a Redis page is moved by the kernel from the memory to the swap file, when the data stored in this memory page is used by Redis (for example accessing a key stored into this memory page) the kernel will stop the Redis process in order to move the page back into the main memory. This is a slow operation involving random I/Os (compared to accessing a page that is already in memory) and will result into anomalous latency experienced by Redis clients.</p> <p>The kernel relocates Redis memory pages on disk mainly because of three reasons:</p> <ul> <li>The system is under memory pressure since the running processes are demanding more physical memory than the amount that is available. The simplest instance of this problem is simply Redis using more memory than is available.</li> <li>The Redis instance data set, or part of the data set, is mostly completely idle (never accessed by clients), so the kernel could swap idle memory pages on disk. This problem is very rare since even a moderately slow instance will touch all the memory pages often, forcing the kernel to retain all the pages in memory.</li> <li>Some processes are generating massive read or write I/Os on the system. Because files are generally cached, it tends to put pressure on the kernel to increase the filesystem cache, and therefore generate swapping activity. Please note it includes Redis RDB and/or AOF background threads which can produce large files.</li> </ul> <p>Fortunately Linux offers good tools to investigate the problem, so the simplest thing to do is when latency due to swapping is suspected is just to check if this is the case.</p> <p>The first thing to do is to checking the amount of Redis memory that is swapped on disk. In order to do so you need to obtain the Redis instance pid:</p> <pre><code>$ redis-cli info | grep process_id\nprocess_id:5454\n</code></pre> <p>Now enter the /proc file system directory for this process:</p> <pre><code>$ cd /proc/5454\n</code></pre> <p>Here you'll find a file called smaps that describes the memory layout of the Redis process (assuming you are using Linux 2.6.16 or newer). This file contains very detailed information about our process memory maps, and one field called Swap is exactly what we are looking for. However there is not just a single swap field since the smaps file contains the different memory maps of our Redis process (The memory layout of a process is more complex than a simple linear array of pages).</p> <p>Since we are interested in all the memory swapped by our process the first thing to do is to grep for the Swap field across all the file:</p> <pre><code>$ cat smaps | grep 'Swap:'\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                 12 kB\nSwap:                156 kB\nSwap:                  8 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  4 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  4 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  4 kB\nSwap:                  4 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  0 kB\nSwap:                  0 kB\n</code></pre> <p>If everything is 0 kB, or if there are sporadic 4k entries, everything is perfectly normal. Actually in our example instance (the one of a real web site running Redis and serving hundreds of users every second) there are a few entries that show more swapped pages. To investigate if this is a serious problem or not we change our command in order to also print the size of the memory map:</p> <pre><code>$ cat smaps | egrep '^(Swap|Size)'\nSize:                316 kB\nSwap:                  0 kB\nSize:                  4 kB\nSwap:                  0 kB\nSize:                  8 kB\nSwap:                  0 kB\nSize:                 40 kB\nSwap:                  0 kB\nSize:                132 kB\nSwap:                  0 kB\nSize:             720896 kB\nSwap:                 12 kB\nSize:               4096 kB\nSwap:                156 kB\nSize:               4096 kB\nSwap:                  8 kB\nSize:               4096 kB\nSwap:                  0 kB\nSize:                  4 kB\nSwap:                  0 kB\nSize:               1272 kB\nSwap:                  0 kB\nSize:                  8 kB\nSwap:                  0 kB\nSize:                  4 kB\nSwap:                  0 kB\nSize:                 16 kB\nSwap:                  0 kB\nSize:                 84 kB\nSwap:                  0 kB\nSize:                  4 kB\nSwap:                  0 kB\nSize:                  4 kB\nSwap:                  0 kB\nSize:                  8 kB\nSwap:                  4 kB\nSize:                  8 kB\nSwap:                  0 kB\nSize:                  4 kB\nSwap:                  0 kB\nSize:                  4 kB\nSwap:                  4 kB\nSize:                144 kB\nSwap:                  0 kB\nSize:                  4 kB\nSwap:                  0 kB\nSize:                  4 kB\nSwap:                  4 kB\nSize:                 12 kB\nSwap:                  4 kB\nSize:                108 kB\nSwap:                  0 kB\nSize:                  4 kB\nSwap:                  0 kB\nSize:                  4 kB\nSwap:                  0 kB\nSize:                272 kB\nSwap:                  0 kB\nSize:                  4 kB\nSwap:                  0 kB\n</code></pre> <p>As you can see from the output, there is a map of 720896 kB (with just 12 kB swapped) and 156 kB more swapped in another map: basically a very small amount of our memory is swapped so this is not going to create any problem at all.</p> <p>If instead a non trivial amount of the process memory is swapped on disk your latency problems are likely related to swapping. If this is the case with your Redis instance you can further verify it using the vmstat command:</p> <pre><code>$ vmstat 1\nprocs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa\n 0  0   3980 697932 147180 1406456    0    0     2     2    2    0  4  4 91  0\n 0  0   3980 697428 147180 1406580    0    0     0     0 19088 16104  9  6 84  0\n 0  0   3980 697296 147180 1406616    0    0     0    28 18936 16193  7  6 87  0\n 0  0   3980 697048 147180 1406640    0    0     0     0 18613 15987  6  6 88  0\n 2  0   3980 696924 147180 1406656    0    0     0     0 18744 16299  6  5 88  0\n 0  0   3980 697048 147180 1406688    0    0     0     4 18520 15974  6  6 88  0\n^C\n</code></pre> <p>The interesting part of the output for our needs are the two columns si and so, that counts the amount of memory swapped from/to the swap file. If you see non zero counts in those two columns then there is swapping activity in your system.</p> <p>Finally, the iostat command can be used to check the global I/O activity of the system.</p> <pre><code>$ iostat -xk 1\navg-cpu:  %user   %nice %system %iowait  %steal   %idle\n          13.55    0.04    2.92    0.53    0.00   82.95\n\nDevice:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util\nsda               0.77     0.00    0.01    0.00     0.40     0.00    73.65     0.00    3.62   2.58   0.00\nsdb               1.27     4.75    0.82    3.54    38.00    32.32    32.19     0.11   24.80   4.24   1.85\n</code></pre> <p>If your latency problem is due to Redis memory being swapped on disk you need to lower the memory pressure in your system, either adding more RAM if Redis is using more memory than the available, or avoiding running other memory hungry processes in the same system.</p>"},{"location":"7-management/optimization/latency/#latency-due-to-aof-and-disk-io","title":"Latency due to AOF and disk I/O","text":"<p>Another source of latency is due to the Append Only File support on Redis. The AOF basically uses two system calls to accomplish its work. One is write(2) that is used in order to write data to the append only file, and the other one is fdatasync(2) that is used in order to flush the kernel file buffer on disk in order to ensure the durability level specified by the user.</p> <p>Both the write(2) and fdatasync(2) calls can be source of latency. For instance write(2) can block both when there is a system wide sync in progress, or when the output buffers are full and the kernel requires to flush on disk in order to accept new writes.</p> <p>The fdatasync(2) call is a worse source of latency as with many combinations of kernels and file systems used it can take from a few milliseconds to a few seconds to complete, especially in the case of some other process doing I/O. For this reason when possible Redis does the fdatasync(2) call in a different thread since Redis 2.4.</p> <p>We'll see how configuration can affect the amount and source of latency when using the AOF file.</p> <p>The AOF can be configured to perform a fsync on disk in three different ways using the appendfsync configuration option (this setting can be modified at runtime using the CONFIG SET command).</p> <ul> <li> <p>When appendfsync is set to the value of no Redis performs no fsync. In this configuration the only source of latency can be write(2). When this happens usually there is no solution since simply the disk can't cope with the speed at which Redis is receiving data, however this is uncommon if the disk is not seriously slowed down by other processes doing I/O.</p> </li> <li> <p>When appendfsync is set to the value of everysec Redis performs a fsync every second. It uses a different thread, and if the fsync is still in progress Redis uses a buffer to delay the write(2) call up to two seconds (since write would block on Linux if a fsync is in progress against the same file). However if the fsync is taking too long Redis will eventually perform the write(2) call even if the fsync is still in progress, and this can be a source of latency.</p> </li> <li> <p>When appendfsync is set to the value of always a fsync is performed at every write operation before replying back to the client with an OK code (actually Redis will try to cluster many commands executed at the same time into a single fsync). In this mode performances are very low in general and it is strongly recommended to use a fast disk and a file system implementation that can perform the fsync in short time.</p> </li> </ul> <p>Most Redis users will use either the no or everysec setting for the appendfsync configuration directive. The suggestion for minimum latency is to avoid other processes doing I/O in the same system. Using an SSD disk can help as well, but usually even non SSD disks perform well with the append only file if the disk is spare as Redis writes to the append only file without performing any seek.</p> <p>If you want to investigate your latency issues related to the append only file you can use the strace command under Linux:</p> <pre><code>sudo strace -p $(pidof redis-server) -T -e trace=fdatasync\n</code></pre> <p>The above command will show all the fdatasync(2) system calls performed by Redis in the main thread. With the above command you'll not see the fdatasync system calls performed by the background thread when the appendfsync config option is set to everysec. In order to do so just add the -f switch to strace.</p> <p>If you wish you can also see both fdatasync and write system calls with the following command:</p> <pre><code>sudo strace -p $(pidof redis-server) -T -e trace=fdatasync,write\n</code></pre> <p>However since write(2) is also used in order to write data to the client sockets this will likely show too many things unrelated to disk I/O. Apparently there is no way to tell strace to just show slow system calls so I use the following command:</p> <pre><code>sudo strace -f -p $(pidof redis-server) -T -e trace=fdatasync,write 2&gt;&amp;1 | grep -v '0.0' | grep -v unfinished\n</code></pre>"},{"location":"7-management/optimization/latency/#latency-generated-by-expires","title":"Latency generated by expires","text":"<p>Redis evict expired keys in two ways:</p> <ul> <li>One lazy way expires a key when it is requested by a command, but it is found to be already expired.</li> <li>One active way expires a few keys every 100 milliseconds.</li> </ul> <p>The active expiring is designed to be adaptive. An expire cycle is started every 100 milliseconds (10 times per second), and will do the following:</p> <ul> <li>Sample <code>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</code> keys, evicting all the keys already expired.</li> <li>If the more than 25% of the keys were found expired, repeat.</li> </ul> <p>Given that <code>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</code> is set to 20 by default, and the process is performed ten times per second, usually just 200 keys per second are actively expired. This is enough to clean the DB fast enough even when already expired keys are not accessed for a long time, so that the lazy algorithm does not help. At the same time expiring just 200 keys per second has no effects in the latency a Redis instance.</p> <p>However the algorithm is adaptive and will loop if it finds more than 25% of keys already expired in the set of sampled keys. But given that we run the algorithm ten times per second, this means that the unlucky event of more than 25% of the keys in our random sample are expiring at least in the same second.</p> <p>Basically this means that if the database has many, many keys expiring in the same second, and these make up at least 25% of the current population of keys with an expire set, Redis can block in order to get the percentage of keys already expired below 25%.</p> <p>This approach is needed in order to avoid using too much memory for keys that are already expired, and usually is absolutely harmless since it's strange that a big number of keys are going to expire in the same exact second, but it is not impossible that the user used <code>EXPIREAT</code> extensively with the same Unix time.</p> <p>In short: be aware that many keys expiring at the same moment can be a source of latency.</p>"},{"location":"7-management/optimization/latency/#redis-software-watchdog","title":"Redis software watchdog","text":"<p>Redis 2.6 introduces the Redis Software Watchdog that is a debugging tool designed to track those latency problems that for one reason or the other escaped an analysis using normal tools.</p> <p>The software watchdog is an experimental feature. While it is designed to be used in production environments care should be taken to backup the database before proceeding as it could possibly have unexpected interactions with the normal execution of the Redis server.</p> <p>It is important to use it only as last resort when there is no way to track the issue by other means.</p> <p>This is how this feature works:</p> <ul> <li>The user enables the software watchdog using the <code>CONFIG SET</code> command.</li> <li>Redis starts monitoring itself constantly.</li> <li>If Redis detects that the server is blocked into some operation that is not returning fast enough, and that may be the source of the latency issue, a low level report about where the server is blocked is dumped on the log file.</li> <li>The user contacts the developers writing a message in the Redis Google Group, including the watchdog report in the message.</li> </ul> <p>Note that this feature cannot be enabled using the redis.conf file, because it is designed to be enabled only in already running instances and only for debugging purposes.</p> <p>To enable the feature just use the following:</p> <pre><code>CONFIG SET watchdog-period 500\n</code></pre> <p>The period is specified in milliseconds. In the above example I specified to log latency issues only if the server detects a delay of 500 milliseconds or greater. The minimum configurable period is 200 milliseconds.</p> <p>When you are done with the software watchdog you can turn it off setting the <code>watchdog-period</code> parameter to 0. Important: remember to do this because keeping the instance with the watchdog turned on for a longer time than needed is generally not a good idea.</p> <p>The following is an example of what you'll see printed in the log file once the software watchdog detects a delay longer than the configured one:</p> <pre><code>[8547 | signal handler] (1333114359)\n--- WATCHDOG TIMER EXPIRED ---\n/lib/libc.so.6(nanosleep+0x2d) [0x7f16b5c2d39d]\n/lib/libpthread.so.0(+0xf8f0) [0x7f16b5f158f0]\n/lib/libc.so.6(nanosleep+0x2d) [0x7f16b5c2d39d]\n/lib/libc.so.6(usleep+0x34) [0x7f16b5c62844]\n./redis-server(debugCommand+0x3e1) [0x43ab41]\n./redis-server(call+0x5d) [0x415a9d]\n./redis-server(processCommand+0x375) [0x415fc5]\n./redis-server(processInputBuffer+0x4f) [0x4203cf]\n./redis-server(readQueryFromClient+0xa0) [0x4204e0]\n./redis-server(aeProcessEvents+0x128) [0x411b48]\n./redis-server(aeMain+0x2b) [0x411dbb]\n./redis-server(main+0x2b6) [0x418556]\n/lib/libc.so.6(__libc_start_main+0xfd) [0x7f16b5ba1c4d]\n./redis-server() [0x411099]\n------\n</code></pre> <p>Note: in the example the DEBUG SLEEP command was used in order to block the server. The stack trace is different if the server blocks in a different context.</p> <p>If you happen to collect multiple watchdog stack traces you are encouraged to send everything to the Redis Google Group: the more traces we obtain, the simpler it will be to understand what the problem with your instance is.</p>"},{"location":"7-management/optimization/memory-optimization/","title":"Memory optimization","text":""},{"location":"7-management/optimization/memory-optimization/#special-encoding-of-small-aggregate-data-types","title":"Special encoding of small aggregate data types","text":"<p>Since Redis 2.2 many data types are optimized to use less space up to a certain size. Hashes, Lists, Sets composed of just integers, and Sorted Sets, when smaller than a given number of elements, and up to a maximum element size, are encoded in a very memory-efficient way that uses up to 10 times less memory (with 5 times less memory used being the average saving).</p> <p>This is completely transparent from the point of view of the user and API. Since this is a CPU / memory tradeoff it is possible to tune the maximum  number of elements and maximum element size for special encoded types  using the following redis.conf directives (defaults are shown):</p>"},{"location":"7-management/optimization/memory-optimization/#redis-62","title":"Redis &lt;= 6.2","text":"<pre><code>hash-max-ziplist-entries 512\nhash-max-ziplist-value 64\nzset-max-ziplist-entries 128 \nzset-max-ziplist-value 64\nset-max-intset-entries 512\n</code></pre>"},{"location":"7-management/optimization/memory-optimization/#redis-70","title":"Redis &gt;= 7.0","text":"<pre><code>hash-max-listpack-entries 512\nhash-max-listpack-value 64\nzset-max-listpack-entries 128\nzset-max-listpack-value 64\nset-max-intset-entries 512\n</code></pre>"},{"location":"7-management/optimization/memory-optimization/#redis-72","title":"Redis &gt;= 7.2","text":"<p>The following directives are also available:</p> <pre><code>set-max-listpack-entries 128\nset-max-listpack-value 64\n</code></pre> <p>If a specially encoded value overflows the configured max size, Redis will automatically convert it into normal encoding. This operation is very fast for small values, but if you change the setting in order to use specially encoded values for much larger aggregate types the suggestion is to run some  benchmarks and tests to check the conversion time.</p>"},{"location":"7-management/optimization/memory-optimization/#using-32-bit-instances","title":"Using 32-bit instances","text":"<p>When Redis is compiled as a 32-bit target, it uses a lot less memory per key, since pointers are small, but such an instance will be limited to 4 GB of maximum memory usage. To compile Redis as 32-bit binary use make 32bit. RDB and AOF files are compatible between 32-bit and 64-bit instances (and between little and big endian of course) so you can switch from 32 to 64-bit, or the contrary, without problems.</p>"},{"location":"7-management/optimization/memory-optimization/#bit-and-byte-level-operations","title":"Bit and byte level operations","text":"<p>Redis 2.2 introduced new bit and byte level operations: <code>GETRANGE</code>, <code>SETRANGE</code>, <code>GETBIT</code> and <code>SETBIT</code>. Using these commands you can treat the Redis string type as a random access array. For instance, if you have an application where users are identified by a unique progressive integer number, you can use a bitmap to save information about the subscription of users in a mailing list, setting the bit for subscribed and clearing it for unsubscribed, or the other way around. With 100 million users this data will take just 12 megabytes of RAM in a Redis instance. You can do the same using <code>GETRANGE</code> and <code>SETRANGE</code> to store one byte of information for each user. This is just an example but it is possible to model several problems in very little space with these new primitives.</p>"},{"location":"7-management/optimization/memory-optimization/#use-hashes-when-possible","title":"Use hashes when possible","text":"<p>Small hashes are encoded in a very small space, so you should try representing your data using hashes whenever possible. For instance, if you have objects representing users in a web application,  instead of using different keys for name, surname, email, password, use a single hash with all the required fields.</p> <p>If you want to know more about this, read the next section.</p>"},{"location":"7-management/optimization/memory-optimization/#using-hashes-to-abstract-a-very-memory-efficient-plain-key-value-store-on-top-of-redis","title":"Using hashes to abstract a very memory-efficient plain key-value store on top of Redis","text":"<p>I understand the title of this section is a bit scary, but I'm going to explain in detail what this is about.</p> <p>Basically it is possible to model a plain key-value store using Redis where values can just be just strings, which is not just more memory efficient than Redis plain keys but also much more memory efficient than memcached.</p> <p>Let's start with some facts: a few keys use a lot more memory than a single key containing a hash with a few fields. How is this possible? We use a trick. In theory to guarantee that we perform lookups in constant time (also known as O(1) in big O notation) there is the need to use a data structure with a constant time complexity in the average case, like a hash table.</p> <p>But many times hashes contain just a few fields. When hashes are small we can instead just encode them in an O(N) data structure, like a linear array with length-prefixed key-value pairs. Since we do this only when N is small, the amortized time for <code>HGET</code> and <code>HSET</code> commands is still O(1): the hash will be converted into a real hash table as soon as the number of elements it contains grows too large (you can configure the limit in redis.conf).</p> <p>This does not only work well from the point of view of time complexity, but also from the point of view of constant times since a linear array of key-value pairs happens to play very well with the CPU cache (it has a better cache locality than a hash table).</p> <p>However since hash fields and values are not (always) represented as full-featured Redis objects, hash fields can't have an associated time to live (expire) like a real key, and can only contain a string. But we are okay with this, this was the intention anyway when the hash data type API was designed (we trust simplicity more than features, so nested data structures are not allowed, as expires of single fields are not allowed).</p> <p>So hashes are memory efficient. This is useful when using hashes to represent objects or to model other problems when there are group of related fields. But what about if we have a plain key value business?</p> <p>Imagine we want to use Redis as a cache for many small objects, which can be JSON encoded objects, small HTML fragments, simple key -&gt; boolean values and so forth. Basically, anything is a string -&gt; string map with small keys and values.</p> <p>Now let's assume the objects we want to cache are numbered, like:</p> <ul> <li>object:102393</li> <li>object:1234</li> <li>object:5</li> </ul> <p>This is what we can do. Every time we perform a SET operation to set a new value, we actually split the key into two parts, one part used as a key, and the other part used as the field name for the hash. For instance, the object named \"object:1234\" is actually split into:</p> <ul> <li>a Key named object:12</li> <li>a Field named 34</li> </ul> <p>So we use all the characters but the last two for the key, and the final two characters for the hash field name. To set our key we use the following command:</p> <pre><code>HSET object:12 34 somevalue\n</code></pre> <p>As you can see every hash will end up containing 100 fields, which is an optimal compromise between CPU and memory saved.</p> <p>There is another important thing to note, with this schema every hash will have more or less 100 fields regardless of the number of objects we cached. This is because our objects will always end with a number and not a random string. In some way, the final number can be considered as a form of implicit pre-sharding.</p> <p>What about small numbers? Like object:2? We handle this case using just \"object:\" as a key name, and the whole number as the hash field name. So object:2 and object:10 will both end inside the key \"object:\", but one as field name \"2\" and one as \"10\".</p> <p>How much memory do we save this way?</p> <p>I used the following Ruby program to test how this works:</p> <pre><code>require 'rubygems'\nrequire 'redis'\n\nUSE_OPTIMIZATION = true\n\ndef hash_get_key_field(key)\n  s = key.split(':')\n  if s[1].length &gt; 2\n    { key: s[0] + ':' + s[1][0..-3], field: s[1][-2..-1] }\n  else\n    { key: s[0] + ':', field: s[1] }\n  end\nend\n\ndef hash_set(r, key, value)\n  kf = hash_get_key_field(key)\n  r.hset(kf[:key], kf[:field], value)\nend\n\ndef hash_get(r, key, value)\n  kf = hash_get_key_field(key)\n  r.hget(kf[:key], kf[:field], value)\nend\n\nr = Redis.new\n(0..100_000).each do |id|\n  key = \"object:#{id}\"\n  if USE_OPTIMIZATION\n    hash_set(r, key, 'val')\n  else\n    r.set(key, 'val')\n  end\nend\n</code></pre> <p>This is the result against a 64 bit instance of Redis 2.2:</p> <ul> <li>USE_OPTIMIZATION set to true: 1.7 MB of used memory</li> <li>USE_OPTIMIZATION set to false; 11 MB of used memory</li> </ul> <p>This is an order of magnitude, I think this makes Redis more or less the most memory efficient plain key value store out there.</p> <p>WARNING: for this to work, make sure that in your redis.conf you have something like this:</p> <pre><code>hash-max-zipmap-entries 256\n</code></pre> <p>Also remember to set the following field accordingly to the maximum size of your keys and values:</p> <pre><code>hash-max-zipmap-value 1024\n</code></pre> <p>Every time a hash exceeds the number of elements or element size specified it will be converted into a real hash table, and the memory saving will be lost.</p> <p>You may ask, why don't you do this implicitly in the normal key space so that I don't have to care? There are two reasons: one is that we tend to make tradeoffs explicit, and this is a clear tradeoff between many things: CPU, memory, and max element size. The second is that the top-level key space must support a lot of interesting things like expires, LRU data, and so forth so it is not practical to do this in a general way.</p> <p>But the Redis Way is that the user must understand how things work so that he can pick the best compromise and to understand how the system will behave exactly.</p>"},{"location":"7-management/optimization/memory-optimization/#memory-allocation","title":"Memory allocation","text":"<p>To store user keys, Redis allocates at most as much memory as the <code>maxmemory</code> setting enables (however there are small extra allocations possible).</p> <p>The exact value can be set in the configuration file or set later via <code>CONFIG SET</code> (for more info, see Using memory as an LRU cache). There are a few things that should be noted about how Redis manages memory:</p> <ul> <li>Redis will not always free up (return) memory to the OS when keys are removed. This is not something special about Redis, but it is how most malloc() implementations work. For example, if you fill an instance with 5GB worth of data, and then remove the equivalent of 2GB of data, the Resident Set Size (also known as the RSS, which is the number of memory pages consumed by the process) will probably still be around 5GB, even if Redis will claim that the user memory is around 3GB.  This happens because the underlying allocator can't easily release the memory. For example, often most of the removed keys were allocated on the same pages as the other keys that still exist.</li> <li>The previous point means that you need to provision memory based on your peak memory usage. If your workload from time to time requires 10GB, even if most of the time 5GB could do, you need to provision for 10GB.</li> <li>However allocators are smart and are able to reuse free chunks of memory, so after you free 2GB of your 5GB data set, when you start adding more keys again, you'll see the RSS (Resident Set Size) stay steady and not grow more, as you add up to 2GB of additional keys. The allocator is basically trying to reuse the 2GB of memory previously (logically) freed.</li> <li>Because of all this, the fragmentation ratio is not reliable when you had a memory usage that at the peak is much larger than the currently used memory. The fragmentation is calculated as the physical memory actually used (the RSS value) divided by the amount of memory currently in use (as the sum of all the allocations performed by Redis). Because the RSS reflects the peak memory, when the (virtually) used memory is low since a lot of keys/values were freed, but the RSS is high, the ratio <code>RSS / mem_used</code> will be very high.</li> </ul> <p>If <code>maxmemory</code> is not set Redis will keep allocating memory as it sees fit and thus it can (gradually) eat up all your free memory. Therefore it is generally advisable to configure some limits. You may also want to set <code>maxmemory-policy</code> to <code>noeviction</code> (which is not the default value in some older versions of Redis).</p> <p>It makes Redis return an out-of-memory error for write commands if and when it reaches the  limit - which in turn may result in errors in the application but will not render the  whole machine dead because of memory starvation.</p>"},{"location":"7-management/optimization/benchmarks/","title":"Redis benchmark","text":"<p>Redis includes the <code>redis-benchmark</code> utility that simulates running commands done by N clients while at the same time sending M total queries. The utility provides a default set of tests, or you can supply a custom set of tests.</p> <p>The following options are supported:</p> <pre><code>Usage: redis-benchmark [-h &lt;host&gt;] [-p &lt;port&gt;] [-c &lt;clients&gt;] [-n &lt;requests]&gt; [-k &lt;boolean&gt;]\n\n -h &lt;hostname&gt;      Server hostname (default 127.0.0.1)\n -p &lt;port&gt;          Server port (default 6379)\n -s &lt;socket&gt;        Server socket (overrides host and port)\n -a &lt;password&gt;      Password for Redis Auth\n -c &lt;clients&gt;       Number of parallel connections (default 50)\n -n &lt;requests&gt;      Total number of requests (default 100000)\n -d &lt;size&gt;          Data size of SET/GET value in bytes (default 3)\n --dbnum &lt;db&gt;       SELECT the specified db number (default 0)\n -k &lt;boolean&gt;       1=keep alive 0=reconnect (default 1)\n -r &lt;keyspacelen&gt;   Use random keys for SET/GET/INCR, random values for SADD\n  Using this option the benchmark will expand the string __rand_int__\n  inside an argument with a 12 digits number in the specified range\n  from 0 to keyspacelen-1. The substitution changes every time a command\n  is executed. Default tests use this to hit random keys in the\n  specified range.\n -P &lt;numreq&gt;        Pipeline &lt;numreq&gt; requests. Default 1 (no pipeline).\n -q                 Quiet. Just show query/sec values\n --csv              Output in CSV format\n -l                 Loop. Run the tests forever\n -t &lt;tests&gt;         Only run the comma separated list of tests. The test\n                    names are the same as the ones produced as output.\n -I                 Idle mode. Just open N idle connections and wait.\n</code></pre> <p>You need to have a running Redis instance before launching the benchmark. You can run the benchmarking utility like so:</p> <pre><code>redis-benchmark -q -n 100000\n</code></pre>"},{"location":"7-management/optimization/benchmarks/#running-only-a-subset-of-the-tests","title":"Running only a subset of the tests","text":"<p>You don't need to run all the default tests every time you execute <code>redis-benchmark</code>. For example, to select only a subset of tests, use the <code>-t</code> option as in the following example:</p> <pre><code>$ redis-benchmark -t set,lpush -n 100000 -q\nSET: 74239.05 requests per second\nLPUSH: 79239.30 requests per second\n</code></pre> <p>This example runs the tests for the <code>SET</code> and <code>LPUSH</code> commands and uses quiet mode (see the <code>-q</code> switch).</p> <p>You can even benchmark a specific command:</p> <pre><code>$ redis-benchmark -n 100000 -q script load \"redis.call('set','foo','bar')\"\nscript load redis.call('set','foo','bar'): 69881.20 requests per second\n</code></pre>"},{"location":"7-management/optimization/benchmarks/#selecting-the-size-of-the-key-space","title":"Selecting the size of the key space","text":"<p>By default, the benchmark runs against a single key. In Redis the difference between such a synthetic benchmark and a real one is not huge since it is an in-memory system, however it is possible to stress cache misses and in general to simulate a more real-world work load by using a large key space.</p> <p>This is obtained by using the <code>-r</code> switch. For instance if I want to run one million SET operations, using a random key for every operation out of 100k possible keys, I'll use the following command line:</p> <pre><code>$ redis-cli flushall\nOK\n\n$ redis-benchmark -t set -r 100000 -n 1000000\n====== SET ======\n  1000000 requests completed in 13.86 seconds\n  50 parallel clients\n  3 bytes payload\n  keep alive: 1\n\n99.76% `&lt;=` 1 milliseconds\n99.98% `&lt;=` 2 milliseconds\n100.00% `&lt;=` 3 milliseconds\n100.00% `&lt;=` 3 milliseconds\n72144.87 requests per second\n\n$ redis-cli dbsize\n(integer) 99993\n</code></pre>"},{"location":"7-management/optimization/benchmarks/#using-pipelining","title":"Using pipelining","text":"<p>By default every client (the benchmark simulates 50 clients if not otherwise specified with <code>-c</code>) sends the next command only when the reply of the previous command is received, this means that the server will likely need a read call in order to read each command from every client. Also RTT is paid as well.</p> <p>Redis supports pipelining, so it is possible to send multiple commands at once, a feature often exploited by real world applications. Redis pipelining is able to dramatically improve the number of operations per second a server is able do deliver.</p> <p>Consider this example of running the benchmark using a pipelining of 16 commands:</p> <pre><code>$ redis-benchmark -n 1000000 -t set,get -P 16 -q\nSET: 403063.28 requests per second\nGET: 508388.41 requests per second\n</code></pre> <p>Using pipelining results in a significant increase in performance.</p>"},{"location":"7-management/optimization/benchmarks/#pitfalls-and-misconceptions","title":"Pitfalls and misconceptions","text":"<p>The first point is obvious: the golden rule of a useful benchmark is to only compare apples and apples. You can compare different versions of Redis on the same workload or the same version of Redis, but with different options. If you plan to compare Redis to something else, then it is important to evaluate the functional and technical differences, and take them in account.</p> <ul> <li>Redis is a server: all commands involve network or IPC round trips. It is meaningless to compare it to embedded data stores, because the cost of most operations is primarily in network/protocol management.</li> <li>Redis commands return an acknowledgment for all usual commands. Some other data stores do not. Comparing Redis to stores involving one-way queries is only mildly useful.</li> <li>Naively iterating on synchronous Redis commands does not benchmark Redis itself, but rather measure your network (or IPC) latency and the client library intrinsic latency. To really test Redis, you need multiple connections (like redis-benchmark) and/or to use pipelining to aggregate several commands and/or multiple threads or processes.</li> <li>Redis is an in-memory data store with some optional persistence options. If you plan to compare it to transactional servers (MySQL, PostgreSQL, etc ...), then you should consider activating AOF and decide on a suitable fsync policy.</li> <li>Redis is, mostly, a single-threaded server from the POV of commands execution (actually modern versions of Redis use threads for different things). It is not designed to benefit from multiple CPU cores. People are supposed to launch several Redis instances to scale out on several cores if needed. It is not really fair to compare one single Redis instance to a multi-threaded data store.</li> </ul> <p>The <code>redis-benchmark</code> program is a quick and useful way to get some figures and evaluate the performance of a Redis instance on a given hardware. However, by default, it does not represent the maximum throughput a Redis instance can sustain. Actually, by using pipelining and a fast client (hiredis), it is fairly easy to write a program generating more throughput than redis-benchmark. The default behavior of redis-benchmark is to achieve throughput by exploiting concurrency only (i.e. it creates several connections to the server). It does not use pipelining or any parallelism at all (one pending query per connection at most, and no multi-threading), if not explicitly enabled via the <code>-P</code> parameter. So in some way using <code>redis-benchmark</code> and, triggering, for example, a <code>BGSAVE</code> operation in the background at the same time, will provide the user with numbers more near to the worst case than to the best case.</p> <p>To run a benchmark using pipelining mode (and achieve higher throughput), you need to explicitly use the -P option. Please note that it is still a realistic behavior since a lot of Redis based applications actively use pipelining to improve performance. However you should use a pipeline size that is more or less the average pipeline length you'll be able to use in your application in order to get realistic numbers.</p> <p>The benchmark should apply the same operations, and work in the same way with the multiple data stores you want to compare. It is absolutely pointless to compare the result of redis-benchmark to the result of another benchmark program and extrapolate.</p> <p>For instance, Redis and memcached in single-threaded mode can be compared on GET/SET operations. Both are in-memory data stores, working mostly in the same way at the protocol level. Provided their respective benchmark application is aggregating queries in the same way (pipelining) and use a similar number of connections, the comparison is actually meaningful.</p> <p>When you're benchmarking a high-performance, in-memory database like Redis, it may be difficult to saturate the server. Sometimes, the performance bottleneck is on the client side, and not the server-side. In that case, the client (i.e., the benchmarking program itself) must be fixed, or perhaps scaled out, to reach the maximum throughput.</p>"},{"location":"7-management/optimization/benchmarks/#factors-impacting-redis-performance","title":"Factors impacting Redis performance","text":"<p>There are multiple factors having direct consequences on Redis performance. We mention them here, since they can alter the result of any benchmarks. Please note however, that a typical Redis instance running on a low end, untuned box usually provides good enough performance for most applications.</p> <ul> <li>Network bandwidth and latency usually have a direct impact on the performance. It is a good practice to use the ping program to quickly check the latency between the client and server hosts is normal before launching the benchmark. Regarding the bandwidth, it is generally useful to estimate the throughput in Gbit/s and compare it to the theoretical bandwidth of the network. For instance a benchmark setting 4 KB strings in Redis at 100000 q/s, would actually consume 3.2 Gbit/s of bandwidth and probably fit within a 10 Gbit/s link, but not a 1 Gbit/s one. In many real world scenarios, Redis throughput is limited by the network well before being limited by the CPU. To consolidate several high-throughput Redis instances on a single server, it worth considering putting a 10 Gbit/s NIC or multiple 1 Gbit/s NICs with TCP/IP bonding.</li> <li>CPU is another very important factor. Being single-threaded, Redis favors fast CPUs with large caches and not many cores. At this game, Intel CPUs are currently the winners. It is not uncommon to get only half the performance on an AMD Opteron CPU compared to similar Nehalem EP/Westmere EP/Sandy Bridge Intel CPUs with Redis. When client and server run on the same box, the CPU is the limiting factor with redis-benchmark.</li> <li>Speed of RAM and memory bandwidth seem less critical for global performance especially for small objects. For large objects (&gt;10 KB), it may become noticeable though. Usually, it is not really cost-effective to buy expensive fast memory modules to optimize Redis.</li> <li>Redis runs slower on a VM compared to running without virtualization using the same hardware. If you have the chance to run Redis on a physical machine this is preferred. However this does not mean that Redis is slow in virtualized environments, the delivered performances are still very good and most of the serious performance issues you may incur in virtualized environments are due to over-provisioning, non-local disks with high latency, or old hypervisor software that have slow <code>fork</code> syscall implementation.</li> <li>When the server and client benchmark programs run on the same box, both the TCP/IP loopback and unix domain sockets can be used. Depending on the platform, unix domain sockets can achieve around 50% more throughput than the TCP/IP loopback (on Linux for instance). The default behavior of redis-benchmark is to use the TCP/IP loopback.</li> <li>The performance benefit of unix domain sockets compared to TCP/IP loopback tends to decrease when pipelining is heavily used (i.e. long pipelines).</li> <li> <p>When an ethernet network is used to access Redis, aggregating commands using pipelining is especially efficient when the size of the data is kept under the ethernet packet size (about 1500 bytes). Actually, processing 10 bytes, 100 bytes, or 1000 bytes queries almost result in the same throughput. See the graph below.</p> <p></p> </li> <li> <p>On multi CPU sockets servers, Redis performance becomes dependent on the NUMA configuration and process location. The most visible effect is that redis-benchmark results seem non-deterministic because client and server processes are distributed randomly on the cores. To get deterministic results, it is required to use process placement tools (on Linux: taskset or numactl). The most efficient combination is always to put the client and server on two different cores of the same CPU to benefit from the L3 cache. Here are some results of 4 KB SET benchmark for 3 server CPUs (AMD Istanbul, Intel Nehalem EX, and Intel Westmere) with different relative placements. Please note this benchmark is not meant to compare CPU models between themselves (CPUs exact model and frequency are therefore not disclosed).</p> <p></p> </li> <li> <p>With high-end configurations, the number of client connections is also an important factor. Being based on epoll/kqueue, the Redis event loop is quite scalable. Redis has already been benchmarked at more than 60000 connections, and was still able to sustain 50000 q/s in these conditions. As a rule of thumb, an instance with 30000 connections can only process half the throughput achievable with 100 connections. Here is an example showing the throughput of a Redis instance per number of connections:</p> <p></p> </li> <li> <p>With high-end configurations, it is possible to achieve higher throughput by tuning the NIC(s) configuration and associated interruptions. Best throughput is achieved by setting an affinity between Rx/Tx NIC queues and CPU cores, and activating RPS (Receive Packet Steering) support. More information in this thread. Jumbo frames may also provide a performance boost when large objects are used.</p> </li> <li>Depending on the platform, Redis can be compiled against different memory allocators (libc malloc, jemalloc, tcmalloc), which may have different behaviors in term of raw speed, internal and external fragmentation. If you did not compile Redis yourself, you can use the INFO command to check the <code>mem_allocator</code> field. Please note most benchmarks do not run long enough to generate significant external fragmentation (contrary to production Redis instances).</li> </ul>"},{"location":"7-management/optimization/benchmarks/#other-things-to-consider","title":"Other things to consider","text":"<p>One important goal of any benchmark is to get reproducible results, so they can be compared to the results of other tests.</p> <ul> <li>A good practice is to try to run tests on isolated hardware as much as possible. If it is not possible, then the system must be monitored to check the benchmark is not impacted by some external activity.</li> <li>Some configurations (desktops and laptops for sure, some servers as well) have a variable CPU core frequency mechanism. The policy controlling this mechanism can be set at the OS level. Some CPU models are more aggressive than others at adapting the frequency of the CPU cores to the workload. To get reproducible results, it is better to set the highest possible fixed frequency for all the CPU cores involved in the benchmark.</li> <li>An important point is to size the system accordingly to the benchmark. The system must have enough RAM and must not swap. On Linux, do not forget to set the <code>overcommit_memory</code> parameter correctly. Please note 32 and 64 bit Redis instances do not have the same memory footprint.</li> <li>If you plan to use RDB or AOF for your benchmark, please check there is no other I/O activity in the system. Avoid putting RDB or AOF files on NAS or NFS shares, or on any other devices impacting your network bandwidth and/or latency (for instance, EBS on Amazon EC2).</li> <li>Set Redis logging level (loglevel parameter) to warning or notice. Avoid putting the generated log file on a remote filesystem.</li> <li>Avoid using monitoring tools which can alter the result of the benchmark. For instance using INFO at regular interval to gather statistics is probably fine, but MONITOR will impact the measured performance significantly.</li> </ul>"},{"location":"7-management/optimization/benchmarks/#other-redis-benchmarking-tools","title":"Other Redis benchmarking tools","text":"<p>There are several third-party tools that can be used for benchmarking Redis. Refer to each tool's documentation for more information about its goals and capabilities.</p> <ul> <li>memtier_benchmark from Redis Ltd. is a NoSQL Redis and Memcache traffic generation and benchmarking tool.</li> <li>rpc-perf from Twitter is a tool for benchmarking RPC services that supports Redis and Memcache.</li> <li>YCSB from Yahoo @Yahoo is a benchmarking framework with clients to many databases, including Redis. </li> </ul>"},{"location":"7-management/security/_index/","title":"Redis security","text":"<p>This document provides an introduction to the topic of security from the point of view of Redis. It covers the access control provided by Redis, code security concerns, attacks that can be triggered from the outside by selecting malicious inputs, and other similar topics.  You can learn more about access control, data protection and encryption, secure Redis architectures, and secure deployment techniques by taking the Redis University security course.</p> <p>For security-related contacts, open an issue on GitHub, or when you feel it is really important to preserve the security of the communication, use the GPG key at the end of this document.</p>"},{"location":"7-management/security/_index/#security-model","title":"Security model","text":"<p>Redis is designed to be accessed by trusted clients inside trusted environments. This means that usually it is not a good idea to expose the Redis instance directly to the internet or, in general, to an environment where untrusted clients can directly access the Redis TCP port or UNIX socket.</p> <p>For instance, in the common context of a web application implemented using Redis as a database, cache, or messaging system, the clients inside the front-end (web side) of the application will query Redis to generate pages or to perform operations requested or triggered by the web application user.</p> <p>In this case, the web application mediates access between Redis and untrusted clients (the user browsers accessing the web application).</p> <p>In general, untrusted access to Redis should always be mediated by a layer implementing ACLs, validating user input, and deciding what operations to perform against the Redis instance.</p>"},{"location":"7-management/security/_index/#network-security","title":"Network security","text":"<p>Access to the Redis port should be denied to everybody but trusted clients in the network, so the servers running Redis should be directly accessible only by the computers implementing the application using Redis.</p> <p>In the common case of a single computer directly exposed to the internet, such as a virtualized Linux instance (Linode, EC2, ...), the Redis port should be firewalled to prevent access from the outside. Clients will still be able to access Redis using the loopback interface.</p> <p>Note that it is possible to bind Redis to a single interface by adding a line like the following to the redis.conf file:</p> <pre><code>bind 127.0.0.1\n</code></pre> <p>Failing to protect the Redis port from the outside can have a big security impact because of the nature of Redis. For instance, a single <code>FLUSHALL</code> command can be used by an external attacker to delete the whole data set.</p>"},{"location":"7-management/security/_index/#protected-mode","title":"Protected mode","text":"<p>Unfortunately, many users fail to protect Redis instances from being accessed from external networks. Many instances are simply left exposed on the internet with public IPs. Since version 3.2.0, Redis enters a special mode called protected mode when it is executed with the default configuration (binding all the interfaces) and without any password in order to access it. In this mode, Redis only replies to queries from the loopback interfaces, and replies to clients connecting from other addresses with an error that explains the problem and how to configure Redis properly.</p> <p>We expect protected mode to seriously decrease the security issues caused by unprotected Redis instances executed without proper administration. However, the system administrator can still ignore the error given by Redis and disable protected mode or manually bind all the interfaces.</p>"},{"location":"7-management/security/_index/#authentication","title":"Authentication","text":"<p>Redis provides two ways to authenticate clients. The recommended authentication method, introduced in Redis 6, is via Access Control Lists, allowing named users to be created and assigned fine-grained permissions. Read more about Access Control Lists here.</p> <p>The legacy authentication method is enabled by editing the redis.conf file, and providing a database password using the <code>requirepass</code> setting. This password is then used by all clients.</p> <p>When the <code>requirepass</code> setting is enabled, Redis will refuse any query by unauthenticated clients. A client can authenticate itself by sending the AUTH command followed by the password.</p> <p>The password is set by the system administrator in clear text inside the redis.conf file. It should be long enough to prevent brute force attacks for two reasons:</p> <ul> <li>Redis is very fast at serving queries. Many passwords per second can be tested by an external client.</li> <li>The Redis password is stored in the redis.conf file and inside the client configuration. Since the system administrator does not need to remember it, the password can be very long.</li> </ul> <p>The goal of the authentication layer is to optionally provide a layer of redundancy. If firewalling or any other system implemented to protect Redis from external attackers fail, an external client will still not be able to access the Redis instance without knowledge of the authentication password.</p> <p>Since the <code>AUTH</code> command, like every other Redis command, is sent unencrypted, it does not protect against an attacker that has enough access to the network to perform eavesdropping.</p>"},{"location":"7-management/security/_index/#tls-support","title":"TLS support","text":"<p>Redis has optional support for TLS on all communication channels, including client connections, replication links, and the Redis Cluster bus protocol.</p>"},{"location":"7-management/security/_index/#disallowing-specific-commands","title":"Disallowing specific commands","text":"<p>It is possible to disallow commands in Redis or to rename them as an unguessable name, so that normal clients are limited to a specified set of commands.</p> <p>For instance, a virtualized server provider may offer a managed Redis instance service. In this context, normal users should probably not be able to call the Redis CONFIG command to alter the configuration of the instance, but the systems that provide and remove instances should be able to do so.</p> <p>In this case, it is possible to either rename or completely shadow commands from the command table. This feature is available as a statement that can be used inside the redis.conf configuration file. For example:</p> <pre><code>rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52\n</code></pre> <p>In the above example, the CONFIG command was renamed into an unguessable name.  It is also possible to completely disallow it (or any other command) by renaming it to the empty string, like in the following example:</p> <pre><code>rename-command CONFIG \"\"\n</code></pre>"},{"location":"7-management/security/_index/#attacks-triggered-by-malicious-inputs-from-external-clients","title":"Attacks triggered by malicious inputs from external clients","text":"<p>There is a class of attacks that an attacker can trigger from the outside even without external access to the instance. For example, an attacker might insert data into Redis that triggers pathological (worst case) algorithm complexity on data structures implemented inside Redis internals.</p> <p>An attacker could supply, via a web form, a set of strings that are known to hash to the same bucket in a hash table in order to turn the O(1) expected time (the average time) to the O(N) worst case. This can consume more CPU than expected and ultimately cause a Denial of Service.</p> <p>To prevent this specific attack, Redis uses a per-execution, pseudo-random seed to the hash function.</p> <p>Redis implements the SORT command using the qsort algorithm. Currently, the algorithm is not randomized, so it is possible to trigger a quadratic worst-case behavior by carefully selecting the right set of inputs.</p>"},{"location":"7-management/security/_index/#string-escaping-and-nosql-injection","title":"String escaping and NoSQL injection","text":"<p>The Redis protocol has no concept of string escaping, so injection is impossible under normal circumstances using a normal client library. The protocol uses prefixed-length strings and is completely binary safe.</p> <p>Since Lua scripts executed by the <code>EVAL</code> and <code>EVALSHA</code> commands follow the same rules, those commands are also safe.</p> <p>While it would be a strange use case, the application should avoid composing the body of the Lua script from strings obtained from untrusted sources.</p>"},{"location":"7-management/security/_index/#code-security","title":"Code security","text":"<p>In a classical Redis setup, clients are allowed full access to the command set, but accessing the instance should never result in the ability to control the system where Redis is running.</p> <p>Internally, Redis uses all the well-known practices for writing secure code to prevent buffer overflows, format bugs, and other memory corruption issues. However, the ability to control the server configuration using the CONFIG command allows the client to change the working directory of the program and the name of the dump file. This allows clients to write RDB Redis files to random paths. This is a security issue that may lead to the ability to compromise the system and/or run untrusted code as the same user as Redis is running.</p> <p>Redis does not require root privileges to run. It is recommended to run it as an unprivileged redis user that is only used for this purpose.</p>"},{"location":"7-management/security/_index/#gpg-key","title":"GPG key","text":"<pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmQINBF9FWioBEADfBiOE/iKpj2EF/cJ/KzFX+jSBKa8SKrE/9RE0faVF6OYnqstL\nS5ox/o+yT45FdfFiRNDflKenjFbOmCbAdIys9Ta0iq6I9hs4sKfkNfNVlKZWtSVG\nW4lI6zO2Zyc2wLZonI+Q32dDiXWNcCEsmajFcddukPevj9vKMTJZtF79P2SylEPq\nmUuhMy/jOt7q1ibJCj5srtaureBH9662t4IJMFjsEe+hiZ5v071UiQA6Tp7rxLqZ\nO6ZRzuamFP3xfy2Lz5NQ7QwnBH1ROabhJPoBOKCATCbfgFcM1Rj+9AOGfoDCOJKH\n7yiEezMqr9VbDrEmYSmCO4KheqwC0T06lOLIQC4nnwKopNO/PN21mirCLHvfo01O\nH/NUG1LZifOwAURbiFNF8Z3+L0csdhD8JnO+1nphjDHr0Xn9Vff2Vej030pRI/9C\nSJ2s5fZUq8jK4n06sKCbqA4pekpbKyhRy3iuITKv7Nxesl4T/uhkc9ccpAvbuD1E\nNczN1IH05jiMUMM3lC1A9TSvxSqflqI46TZU3qWLa9yg45kDC8Ryr39TY37LscQk\n9x3WwLLkuHeUurnwAk46fSj7+FCKTGTdPVw8v7XbvNOTDf8vJ3o2PxX1uh2P2BHs\n9L+E1P96oMkiEy1ug7gu8V+mKu5PAuD3QFzU3XCB93DpDakgtznRRXCkAQARAQAB\ntBtSZWRpcyBMYWJzIDxyZWRpc0ByZWRpcy5pbz6JAk4EEwEKADgWIQR5sNCo1OBf\nWO913l22qvOUq0evbgUCX0VaKgIbAwULCQgHAgYVCgkICwIEFgIDAQIeAQIXgAAK\nCRC2qvOUq0evbpZaD/4rN7xesDcAG4ec895Fqzk3w74W1/K9lzRKZDwRsAqI+sAz\nZXvQMtWSxLfF2BITxLnHJXK5P+2Y6XlNgrn1GYwC1MsARyM9e1AzwDJHcXFkHU82\n2aALIMXGtiZs/ejFh9ZSs5cgRlxBSqot/uxXm9AvKEByhmIeHPZse/Rc6e3qa57v\nOhCkVZB4ETx5iZrgA+gdmS8N7MXG0cEu5gJLacG57MHi+2WMOCU9Xfj6+Pqhw3qc\nE6lBinKcA/LdgUJ1onK0JCnOG1YVHjuFtaisfPXvEmUBGaSGE6lM4J7lass/OWps\nDd+oHCGI+VOGNx6AiBDZG8mZacu0/7goRnOTdljJ93rKkj31I+6+j4xzkAC0IXW8\nLAP9Mmo9TGx0L5CaljykhW6z/RK3qd7dAYE+i7e8J9PuQaGG5pjFzuW4vY45j0V/\n9JUMKDaGbU5choGqsCpAVtAMFfIBj3UQ5LCt5zKyescKCUb9uifOLeeQ1vay3R9o\neRSD52YpRBpor0AyYxcLur/pkHB0sSvXEfRZENQTohpY71rHSaFd3q1Hkk7lZl95\nm24NRlrJnjFmeSPKP22vqUYIwoGNUF/D38UzvqHD8ltTPgkZc+Y+RRbVNqkQYiwW\nGH/DigNB8r2sdkt+1EUu+YkYosxtzxpxxpYGKXYXx0uf+EZmRqRt/OSHKnf2GLkC\nDQRfRVoqARAApffsrDNo4JWjX3r6wHJJ8IpwnGEJ2IzGkg8f1Ofk2uKrjkII/oIx\nsXC3EeauC1Plhs+m9GP/SPY0LXmZ0OzGD/S1yMpmBeBuXJ0gONDo+xCg1pKGshPs\n75XzpbggSOtEYR5S8Z46yCu7TGJRXBMGBhDgCfPVFBBNsnG5B0EeHXM4trqqlN6d\nPAcwtLnKPz/Z+lloKR6bFXvYGuN5vjRXjcVYZLLCEwdV9iY5/Opqk9sCluasb3t/\nc2gcsLWWFnNz2desvb/Y4ADJzxY+Um848DSR8IcdoArSsqmcCTiYvYC/UU7XPVNk\nJrx/HwgTVYiLGbtMB3u3fUpHW8SabdHc4xG3sx0LeIvl+JwHgx7yVhNYJEyOQfnE\nmfS97x6surXgTVLbWVjXKIJhoWnWbLP4NkBc27H4qo8wM/IWH4SSXYNzFLlCDPnw\nvQZSel21qxdqAWaSxkKcymfMS4nVDhVj0jhlcTY3aZcHMjqoUB07p5+laJr9CCGv\n0Y0j0qT2aUO22A3kbv6H9c1Yjv8EI7eNz07aoH1oYU6ShsiaLfIqPfGYb7LwOFWi\nPSl0dCY7WJg2H6UHsV/y2DwRr/3oH0a9hv/cvcMneMi3tpIkRwYFBPXEsIcoD9xr\nRI5dp8BBdO/Nt+puoQq9oyialWnQK5+AY7ErW1yxjgie4PQ+XtN+85UAEQEAAYkC\nNgQYAQoAIBYhBHmw0KjU4F9Y73XeXbaq85SrR69uBQJfRVoqAhsMAAoJELaq85Sr\nR69uoV0QAIvlxAHYTjvH1lt5KbpVGs5gwIAnCMPxmaOXcaZ8V0Z1GEU+/IztwV+N\nMYCBv1tYa7OppNs1pn75DhzoNAi+XQOVvU0OZgVJutthZe0fNDFGG9B4i/cxRscI\nLd8TPQQNiZPBZ4ubcxbZyBinE9HsYUM49otHjsyFZ0GqTpyne+zBf1GAQoekxlKo\ntWSkkmW0x4qW6eiAmyo5lPS1bBjvaSc67i+6Bv5QkZa0UIkRqAzKN4zVvc2FyILz\n+7wVLCzWcXrJt8dOeS6Y/Fjbhb6m7dtapUSETAKu6wJvSd9ndDUjFHD33NQIZ/nL\nWaPbn01+e/PHtUDmyZ2W2KbcdlIT9nb2uHrruqdCN04sXkID8E2m2gYMA+TjhC0Q\nJBJ9WPmdBeKH91R6wWDq6+HwOpgc/9na+BHZXMG+qyEcvNHB5RJdiu2r1Haf6gHi\nFd6rJ6VzaVwnmKmUSKA2wHUuUJ6oxVJ1nFb7Aaschq8F79TAfee0iaGe9cP+xUHL\nzBDKwZ9PtyGfdBp1qNOb94sfEasWPftT26rLgKPFcroCSR2QCK5qHsMNCZL+u71w\nNnTtq9YZDRaQ2JAc6VDZCcgu+dLiFxVIi1PFcJQ31rVe16+AQ9zsafiNsxkPdZcY\nU9XKndQE028dGZv1E3S5BwpnikrUkWdxcYrVZ4fiNIy5I3My2yCe\n=J9BD\n-----END PGP PUBLIC KEY BLOCK-----\n</code></pre>"},{"location":"7-management/security/acl/","title":"ACL","text":"<p>The Redis ACL, short for Access Control List, is the feature that allows certain connections to be limited in terms of the commands that can be executed and the keys that can be accessed. The way it works is that, after connecting, a client is required to provide a username and a valid password to authenticate. If authentication succeeded, the connection is associated with a given user and the limits the user has. Redis can be configured so that new connections are already authenticated with a \"default\" user (this is the default configuration). Configuring the default user has, as a side effect, the ability to provide only a specific subset of functionalities to connections that are not explicitly authenticated.</p> <p>In the default configuration, Redis 6 (the first version to have ACLs) works exactly like older versions of Redis. Every new connection is capable of calling every possible command and accessing every key, so the ACL feature is backward compatible with old clients and applications. Also the old way to configure a password, using the requirepass configuration directive, still works as expected. However, it now sets a password for the default user.</p> <p>The Redis <code>AUTH</code> command was extended in Redis 6, so now it is possible to use it in the two-arguments form:</p> <pre><code>AUTH &lt;username&gt; &lt;password&gt;\n</code></pre> <p>Here's an example of the old form:</p> <pre><code>AUTH &lt;password&gt;\n</code></pre> <p>What happens is that the username used to authenticate is \"default\", so just specifying the password implies that we want to authenticate against the default user. This provides backward compatibility.</p>"},{"location":"7-management/security/acl/#when-acls-are-useful","title":"When ACLs are useful","text":"<p>Before using ACLs, you may want to ask yourself what's the goal you want to accomplish by implementing this layer of protection. Normally there are two main goals that are well served by ACLs:</p> <ol> <li>You want to improve security by restricting the access to commands and keys, so that untrusted clients have no access and trusted clients have just the minimum access level to the database in order to perform the work needed. For instance, certain clients may just be able to execute read only commands.</li> <li>You want to improve operational safety, so that processes or humans accessing Redis are not allowed to damage the data or the configuration due to software errors or manual mistakes. For instance, there is no reason for a worker that fetches delayed jobs from Redis to be able to call the <code>FLUSHALL</code> command.</li> </ol> <p>Another typical usage of ACLs is related to managed Redis instances. Redis is often provided as a managed service both by internal company teams that handle the Redis infrastructure for the other internal customers they have, or is provided in a software-as-a-service setup by cloud providers. In both  setups, we want to be sure that configuration commands are excluded for the customers.</p>"},{"location":"7-management/security/acl/#configure-acls-with-the-acl-command","title":"Configure ACLs with the ACL command","text":"<p>ACLs are defined using a DSL (domain specific language) that describes what a given user is allowed to do. Such rules are always implemented from the first to the last, left-to-right, because sometimes the order of the rules is important to understand what the user is really able to do.</p> <p>By default there is a single user defined, called default. We can use the <code>ACL LIST</code> command in order to check the currently active ACLs and verify what the configuration of a freshly started, defaults-configured Redis instance is:</p> <pre><code>&gt; ACL LIST\n1) \"user default on nopass ~* &amp;* +@all\"\n</code></pre> <p>The command above reports the list of users in the same format that is used in the Redis configuration files, by translating the current ACLs set for the users back into their description.</p> <p>The first two words in each line are \"user\" followed by the username. The next words are ACL rules that describe different things. We'll show how the rules work in detail, but for now it is enough to say that the default user is configured to be active (on), to require no password (nopass), to access every possible key (<code>~*</code>) and Pub/Sub channel (<code>&amp;*</code>), and be able to call every possible command (<code>+@all</code>).</p> <p>Also, in the special case of the default user, having the nopass rule means that new connections are automatically authenticated with the default user without any explicit <code>AUTH</code> call needed.</p>"},{"location":"7-management/security/acl/#acl-rules","title":"ACL rules","text":"<p>The following is the list of valid ACL rules. Certain rules are just single words that are used in order to activate or remove a flag, or to perform a given change to the user ACL. Other rules are char prefixes that are concatenated with command or category names, key patterns, and so forth.</p> <p>Enable and disallow users:</p> <ul> <li><code>on</code>: Enable the user: it is possible to authenticate as this user.</li> <li><code>off</code>: Disallow the user: it's no longer possible to authenticate with this user; however, previously authenticated connections will still work. Note that if the default user is flagged as off, new connections will start as not authenticated and will require the user to send <code>AUTH</code> or <code>HELLO</code> with the AUTH option in order to authenticate in some way, regardless of the default user configuration.</li> </ul> <p>Allow and disallow commands:</p> <ul> <li><code>+&lt;command&gt;</code>: Add the command to the list of commands the user can call. Can be used with <code>|</code> for allowing subcommands (e.g \"+config|get\").</li> <li><code>-&lt;command&gt;</code>: Remove the command to the list of commands the user can call. Starting Redis 7.0, it can be used with <code>|</code> for blocking subcommands (e.g \"-config|set\").</li> <li><code>+@&lt;category&gt;</code>: Add all the commands in such category to be called by the user, with valid categories being like @admin, @set, @sortedset, ... and so forth, see the full list by calling the <code>ACL CAT</code> command. The special category @all means all the commands, both the ones currently present in the server, and the ones that will be loaded in the future via modules.</li> <li><code>-@&lt;category&gt;</code>: Like <code>+@&lt;category&gt;</code> but removes the commands from the list of commands the client can call.</li> <li><code>+&lt;command&gt;|first-arg</code>: Allow a specific first argument of an otherwise disabled command. It is only supported on commands with no sub-commands, and is not allowed as negative form like -SELECT|1, only additive starting with \"+\". This feature is deprecated and may be removed in the future.</li> <li><code>allcommands</code>: Alias for +@all. Note that it implies the ability to execute all the future commands loaded via the modules system.</li> <li><code>nocommands</code>: Alias for -@all.</li> </ul> <p>Allow and disallow certain keys and key permissions:</p> <ul> <li><code>~&lt;pattern&gt;</code>: Add a pattern of keys that can be mentioned as part of commands. For instance <code>~*</code> allows all the keys. The pattern is a glob-style pattern like the one of <code>KEYS</code>. It is possible to specify multiple patterns.</li> <li><code>%R~&lt;pattern&gt;</code>: (Available in Redis 7.0 and later) Add the specified read key pattern. This behaves similar to the regular key pattern but only grants permission to read from keys that match the given pattern. See key permissions for more information.</li> <li><code>%W~&lt;pattern&gt;</code>: (Available in Redis 7.0 and later) Add the specified write key pattern. This behaves similar to the regular key pattern but only grants permission to write to keys that match the given pattern. See key permissions for more information.</li> <li><code>%RW~&lt;pattern&gt;</code>: (Available in Redis 7.0 and later) Alias for <code>~&lt;pattern&gt;</code>. </li> <li><code>allkeys</code>: Alias for <code>~*</code>.</li> <li><code>resetkeys</code>: Flush the list of allowed keys patterns. For instance the ACL <code>~foo:* ~bar:* resetkeys ~objects:*</code>, will only allow the client to access keys that match the pattern <code>objects:*</code>.</li> </ul> <p>Allow and disallow Pub/Sub channels:</p> <ul> <li><code>&amp;&lt;pattern&gt;</code>: (Available in Redis 6.2 and later) Add a glob style pattern of Pub/Sub channels that can be accessed by the user. It is possible to specify multiple channel patterns. Note that pattern matching is done only for channels mentioned by <code>PUBLISH</code> and <code>SUBSCRIBE</code>, whereas <code>PSUBSCRIBE</code> requires a literal match between its channel patterns and those allowed for user.</li> <li><code>allchannels</code>: Alias for <code>&amp;*</code> that allows the user to access all Pub/Sub channels.</li> <li><code>resetchannels</code>: Flush the list of allowed channel patterns and disconnect the user's Pub/Sub clients if these are no longer able to access their respective channels and/or channel patterns.</li> </ul> <p>Configure valid passwords for the user:</p> <ul> <li><code>&gt;&lt;password&gt;</code>: Add this password to the list of valid passwords for the user. For example <code>&gt;mypass</code> will add \"mypass\" to the list of valid passwords.  This directive clears the nopass flag (see later). Every user can have any number of passwords.</li> <li><code>&lt;&lt;password&gt;</code>: Remove this password from the list of valid passwords. Emits an error in case the password you are trying to remove is actually not set.</li> <li><code>#&lt;hash&gt;</code>: Add this SHA-256 hash value to the list of valid passwords for the user. This hash value will be compared to the hash of a password entered for an ACL user. This allows users to store hashes in the <code>acl.conf</code> file rather than storing cleartext passwords. Only SHA-256 hash values are accepted as the password hash must be 64 characters and only contain lowercase hexadecimal characters.</li> <li><code>!&lt;hash&gt;</code>: Remove this hash value from the list of valid passwords. This is useful when you do not know the password specified by the hash value but would like to remove the password from the user.</li> <li><code>nopass</code>: All the set passwords of the user are removed, and the user is flagged as requiring no password: it means that every password will work against this user. If this directive is used for the default user, every new connection will be immediately authenticated with the default user without any explicit AUTH command required. Note that the resetpass directive will clear this condition.</li> <li><code>resetpass</code>: Flushes the list of allowed passwords and removes the nopass status. After resetpass, the user has no associated passwords and there is no way to authenticate without adding some password (or setting it as nopass later).</li> </ul> <p>Note: if a user is not flagged with nopass and has no list of valid passwords, that user is effectively impossible to use because there will be no way to log in as that user.</p> <p>Configure selectors for the user:</p> <ul> <li><code>(&lt;rule list&gt;)</code>: (Available in Redis 7.0 and later) Create a new selector to match rules against. Selectors are evaluated after the user permissions, and are evaluated according to the order they are defined. If a command matches either the user permissions or any selector, it is allowed. See selectors for more information.</li> <li><code>clearselectors</code>: (Available in Redis 7.0 and later) Delete all of the selectors attached to the user.</li> </ul> <p>Reset the user:</p> <ul> <li><code>reset</code> Performs the following actions: resetpass, resetkeys, resetchannels, allchannels (if acl-pubsub-default is set), off, clearselectors, -@all. The user returns to the same state it had immediately after its creation.</li> </ul>"},{"location":"7-management/security/acl/#create-and-edit-user-acls-with-the-acl-setuser-command","title":"Create and edit user ACLs with the ACL SETUSER command","text":"<p>Users can be created and modified in two main ways:</p> <ol> <li>Using the ACL command and its <code>ACL SETUSER</code> subcommand.</li> <li>Modifying the server configuration, where users can be defined, and restarting the server. With an external ACL file, just call <code>ACL LOAD</code>.</li> </ol> <p>In this section we'll learn how to define users using the <code>ACL</code> command. With such knowledge, it will be trivial to do the same things via the configuration files. Defining users in the configuration deserves its own section and will be discussed later separately.</p> <p>To start, try the simplest <code>ACL SETUSER</code> command call:</p> <pre><code>&gt; ACL SETUSER alice\nOK\n</code></pre> <p>The <code>ACL SETUSER</code> command takes the username and a list of ACL rules to apply to the user. However the above example did not specify any rule at all. This will just create the user if it did not exist, using the defaults for new users. If the user already exists, the command above will do nothing at all.</p> <p>Check the default user status:</p> <pre><code>&gt; ACL LIST\n1) \"user alice off resetchannels -@all\"\n2) \"user default on nopass ~* &amp;* +@all\"\n</code></pre> <p>The new user \"alice\" is:</p> <ul> <li>In the off status, so <code>AUTH</code> will not work for the user \"alice\".</li> <li>The user also has no passwords set.</li> <li>Cannot access any command. Note that the user is created by default without the ability to access any command, so the <code>-@all</code> in the output above could be omitted; however, <code>ACL LIST</code> attempts to be explicit rather than implicit.</li> <li>There are no key patterns that the user can access.</li> <li>There are no Pub/Sub channels that the user can access.</li> </ul> <p>New users are created with restrictive permissions by default. Starting with Redis 6.2, ACL provides Pub/Sub channels access management as well. To ensure backward compatibility with version 6.0 when upgrading to Redis 6.2, new users are granted the 'allchannels' permission by default. The default can be set to <code>resetchannels</code> via the <code>acl-pubsub-default</code> configuration directive.</p> <p>From 7.0, The <code>acl-pubsub-default</code> value is set to <code>resetchannels</code> to restrict the channels access by default to provide better security. The default can be set to <code>allchannels</code> via the <code>acl-pubsub-default</code> configuration directive to be compatible with previous versions.</p> <p>Such user is completely useless. Let's try to define the user so that it is active, has a password, and can access with only the <code>GET</code> command to key names starting with the string \"cached:\".</p> <pre><code>&gt; ACL SETUSER alice on &gt;p1pp0 ~cached:* +get\nOK\n</code></pre> <p>Now the user can do something, but will refuse to do other things:</p> <pre><code>&gt; AUTH alice p1pp0\nOK\n&gt; GET foo\n(error) NOPERM this user has no permissions to access one of the keys used as arguments\n&gt; GET cached:1234\n(nil)\n&gt; SET cached:1234 zap\n(error) NOPERM this user has no permissions to run the 'set' command\n</code></pre> <p>Things are working as expected. In order to inspect the configuration of the user alice (remember that user names are case sensitive), it is possible to use an alternative to <code>ACL LIST</code> which is designed to be more suitable for computers to read, while <code>ACL GETUSER</code> is more human readable.</p> <pre><code>&gt; ACL GETUSER alice\n1) \"flags\"\n2) 1) \"on\"\n3) \"passwords\"\n4) 1) \"2d9c75...\"\n5) \"commands\"\n6) \"-@all +get\"\n7) \"keys\"\n8) \"~cached:*\"\n9) \"channels\"\n10) \"\"\n11) \"selectors\"\n12) (empty array)\n</code></pre> <p>The <code>ACL GETUSER</code> returns a field-value array that describes the user in more parsable terms. The output includes the set of flags, a list of key patterns, passwords, and so forth. The output is probably more readable if we use RESP3, so that it is returned as a map reply:</p> <pre><code>&gt; ACL GETUSER alice\n1# \"flags\" =&gt; 1~ \"on\"\n2# \"passwords\" =&gt; 1) \"2d9c75273d72b32df726fb545c8a4edc719f0a95a6fd993950b10c474ad9c927\"\n3# \"commands\" =&gt; \"-@all +get\"\n4# \"keys\" =&gt; \"~cached:*\"\n5# \"channels\" =&gt; \"\"\n6# \"selectors\" =&gt; (empty array)\n</code></pre> <p>Note: from now on, we'll continue using the Redis default protocol, version 2</p> <p>Using another <code>ACL SETUSER</code> command (from a different user, because alice cannot run the <code>ACL</code> command), we can add multiple patterns to the user:</p> <pre><code>&gt; ACL SETUSER alice ~objects:* ~items:* ~public:*\nOK\n&gt; ACL LIST\n1) \"user alice on #2d9c75... ~cached:* ~objects:* ~items:* ~public:* resetchannels -@all +get\"\n2) \"user default on nopass ~* &amp;* +@all\"\n</code></pre> <p>The user representation in memory is now as we expect it to be.</p>"},{"location":"7-management/security/acl/#multiple-calls-to-acl-setuser","title":"Multiple calls to ACL SETUSER","text":"<p>It is very important to understand what happens when <code>ACL SETUSER</code> is called multiple times. What is critical to know is that every <code>ACL SETUSER</code> call will NOT reset the user, but will just apply the ACL rules to the existing user. The user is reset only if it was not known before. In that case, a brand new user is created with zeroed-ACLs. The user cannot do anything, is disallowed, has no passwords, and so forth. This is the best default for safety.</p> <p>However later calls will just modify the user incrementally. For instance, the following sequence:</p> <pre><code>&gt; ACL SETUSER myuser +set\nOK\n&gt; ACL SETUSER myuser +get\nOK\n</code></pre> <p>Will result in myuser being able to call both <code>GET</code> and <code>SET</code>:</p> <pre><code>&gt; ACL LIST\n1) \"user default on nopass ~* &amp;* +@all\"\n2) \"user myuser off resetchannels -@all +get +set\"\n</code></pre>"},{"location":"7-management/security/acl/#command-categories","title":"Command categories","text":"<p>Setting user ACLs by specifying all the commands one after the other is really annoying, so instead we do things like this:</p> <pre><code>&gt; ACL SETUSER antirez on +@all -@dangerous &gt;42a979... ~*\n</code></pre> <p>By saying +@all and -@dangerous, we included all the commands and later removed all the commands that are tagged as dangerous inside the Redis command table. Note that command categories never include modules commands with the exception of +@all. If you say +@all, all the commands can be executed by the user, even future commands loaded via the modules system. However if you use the ACL rule +@read or any other, the modules commands are always excluded. This is very important because you should just trust the Redis internal command table. Modules may expose dangerous things and in the case of an ACL that is just additive, that is, in the form of <code>+@all -...</code> You should be absolutely sure that you'll never include what you did not mean to.</p> <p>The following is a list of command categories and their meanings:</p> <ul> <li>admin - Administrative commands. Normal applications will never need to use   these. Includes <code>REPLICAOF</code>, <code>CONFIG</code>, <code>DEBUG</code>, <code>SAVE</code>, <code>MONITOR</code>, <code>ACL</code>, <code>SHUTDOWN</code>, etc.</li> <li>bitmap - Data type: bitmaps related.</li> <li>blocking - Potentially blocking the connection until released by another   command.</li> <li>connection - Commands affecting the connection or other connections.   This includes <code>AUTH</code>, <code>SELECT</code>, <code>COMMAND</code>, <code>CLIENT</code>, <code>ECHO</code>, <code>PING</code>, etc.</li> <li>dangerous - Potentially dangerous commands (each should be considered with care for   various reasons). This includes <code>FLUSHALL</code>, <code>MIGRATE</code>, <code>RESTORE</code>, <code>SORT</code>, <code>KEYS</code>,   <code>CLIENT</code>, <code>DEBUG</code>, <code>INFO</code>, <code>CONFIG</code>, <code>SAVE</code>, <code>REPLICAOF</code>, etc.</li> <li>geo - Data type: geospatial indexes related.</li> <li>hash - Data type: hashes related.</li> <li>hyperloglog - Data type: hyperloglog related.</li> <li>fast - Fast O(1) commands. May loop on the number of arguments, but not the   number of elements in the key.</li> <li>keyspace - Writing or reading from keys, databases, or their metadata    in a type agnostic way. Includes <code>DEL</code>, <code>RESTORE</code>, <code>DUMP</code>, <code>RENAME</code>, <code>EXISTS</code>, <code>DBSIZE</code>,   <code>KEYS</code>, <code>EXPIRE</code>, <code>TTL</code>, <code>FLUSHALL</code>, etc. Commands that may modify the keyspace,   key, or metadata will also have the <code>write</code> category. Commands that only read   the keyspace, key, or metadata will have the <code>read</code> category.</li> <li>list - Data type: lists related.</li> <li>pubsub - PubSub-related commands.</li> <li>read - Reading from keys (values or metadata). Note that commands that don't   interact with keys, will not have either <code>read</code> or <code>write</code>.</li> <li>scripting - Scripting related.</li> <li>set - Data type: sets related.</li> <li>sortedset - Data type: sorted sets related.</li> <li>slow - All commands that are not <code>fast</code>.</li> <li>stream - Data type: streams related.</li> <li>string - Data type: strings related.</li> <li>transaction - <code>WATCH</code> / <code>MULTI</code> / <code>EXEC</code> related commands.</li> <li>write - Writing to keys (values or metadata).</li> </ul> <p>Redis can also show you a list of all categories and the exact commands each category includes using the Redis <code>ACL CAT</code> command. It can be used in two forms:</p> <pre><code>ACL CAT -- Will just list all the categories available\nACL CAT &lt;category-name&gt; -- Will list all the commands inside the category\n</code></pre> <p>Examples:</p> <pre><code> &gt; ACL CAT\n 1) \"keyspace\"\n 2) \"read\"\n 3) \"write\"\n 4) \"set\"\n 5) \"sortedset\"\n 6) \"list\"\n 7) \"hash\"\n 8) \"string\"\n 9) \"bitmap\"\n10) \"hyperloglog\"\n11) \"geo\"\n12) \"stream\"\n13) \"pubsub\"\n14) \"admin\"\n15) \"fast\"\n16) \"slow\"\n17) \"blocking\"\n18) \"dangerous\"\n19) \"connection\"\n20) \"transaction\"\n21) \"scripting\"\n</code></pre> <p>As you can see, so far there are 21 distinct categories. Now let's check what command is part of the geo category:</p> <pre><code> &gt; ACL CAT geo\n 1) \"geohash\"\n 2) \"georadius_ro\"\n 3) \"georadiusbymember\"\n 4) \"geopos\"\n 5) \"geoadd\"\n 6) \"georadiusbymember_ro\"\n 7) \"geodist\"\n 8) \"georadius\"\n 9) \"geosearch\"\n10) \"geosearchstore\"\n</code></pre> <p>Note that commands may be part of multiple categories. For example, an ACL rule like <code>+@geo -@read</code> will result in certain geo commands to be excluded because they are read-only commands.</p>"},{"location":"7-management/security/acl/#allowblock-subcommands","title":"Allow/block subcommands","text":"<p>Starting from Redis 7.0, subcommands can be allowed/blocked just like other commands (by using the separator <code>|</code> between the command and subcommand, for example: <code>+config|get</code> or <code>-config|set</code>)</p> <p>That is true for all commands except DEBUG. In order to allow/block specific DEBUG subcommands, see the next section.</p>"},{"location":"7-management/security/acl/#allow-the-first-arg-of-a-blocked-command","title":"Allow the first-arg of a blocked command","text":"<p>Note: This feature is deprecated since Redis 7.0 and may be removed in the future.</p> <p>Sometimes the ability to exclude or include a command or a subcommand as a whole is not enough. Many deployments may not be happy providing the ability to execute a <code>SELECT</code> for any DB, but may still want to be able to run <code>SELECT 0</code>.</p> <p>In such case we could alter the ACL of a user in the following way:</p> <pre><code>ACL SETUSER myuser -select +select|0\n</code></pre> <p>First, remove the <code>SELECT</code> command and then add the allowed first-arg. Note that it is not possible to do the reverse since first-args can be only added, not excluded. It is safer to specify all the first-args that are valid for some user since it is possible that new first-args may be added in the future.</p> <p>Another example:</p> <pre><code>ACL SETUSER myuser -debug +debug|digest\n</code></pre> <p>Note that first-arg matching may add some performance penalty; however, it is hard to measure even with synthetic benchmarks. The additional CPU cost is only paid when such commands are called, and not when other commands are called.</p> <p>It is possible to use this mechanism in order to allow subcommands in Redis versions prior to 7.0 (see above section).</p>"},{"location":"7-management/security/acl/#all-vs-all","title":"+@all VS -@all","text":"<p>In the previous section, it was observed how it is possible to define command ACLs based on adding/removing single commands.</p>"},{"location":"7-management/security/acl/#selectors","title":"Selectors","text":"<p>Starting with Redis 7.0, Redis supports adding multiple sets of rules that are evaluated independently of each other. These secondary sets of permissions are called selectors and added by wrapping a set of rules within parentheses. In order to execute a command, either the root permissions (rules defined outside of parenthesis) or any of the selectors (rules defined inside parenthesis) must match the given command. Internally, the root permissions are checked first followed by selectors in the order they were added.</p> <p>For example, consider a user with the ACL rules <code>+GET ~key1 (+SET ~key2)</code>. This user is able to execute <code>GET key1</code> and <code>SET key2 hello</code>, but not <code>GET key2</code> or <code>SET key1 world</code>.</p> <p>Unlike the user's root permissions, selectors cannot be modified after they are added. Instead, selectors can be removed with the <code>clearselectors</code> keyword, which removes all of the added selectors. Note that <code>clearselectors</code> does not remove the root permissions.</p>"},{"location":"7-management/security/acl/#key-permissions","title":"Key permissions","text":"<p>Starting with Redis 7.0, key patterns can also be used to define how a command is able to touch a key. This is achieved through rules that define key permissions. The key permission rules take the form of <code>%(&lt;permission&gt;)~&lt;pattern&gt;</code>. Permissions are defined as individual characters that map to the following key permissions:</p> <ul> <li>W (Write): The data stored within the key may be updated or deleted. </li> <li>R (Read): User supplied data from the key is processed, copied or returned. Note that this does not include metadata such as size information (example <code>STRLEN</code>), type information (example <code>TYPE</code>) or information about whether a value exists within a collection (example <code>SISMEMBER</code>). </li> </ul> <p>Permissions can be composed together by specifying multiple characters.  Specifying the permission as 'RW' is considered full access and is analogous to just passing in <code>~&lt;pattern&gt;</code>.</p> <p>For a concrete example, consider a user with ACL rules <code>+@all ~app1:* (+@read ~app2:*)</code>. This user has full access on <code>app1:*</code> and readonly access on <code>app2:*</code>. However, some commands support reading data from one key, doing some transformation, and storing it into another key. One such command is the <code>COPY</code> command, which copies the data from the source key into the destination key. The example set of ACL rules is unable to handle a request copying data from <code>app2:user</code> into <code>app1:user</code>, since neither the root permission nor the selector fully matches the command. However, using key selectors you can define a set of ACL rules that can handle this request <code>+@all ~app1:* %R~app2:*</code>. The first pattern is able to match <code>app1:user</code> and the second pattern is able to match <code>app2:user</code>.</p> <p>Which type of permission is required for a command is documented through key specifications. The type of permission is based off the keys logical operation flags.  The insert, update, and delete flags map to the write key permission.  The access flag maps to the read key permission. If the key has no logical operation flags, such as <code>EXISTS</code>, the user still needs either key read or key write permissions to execute the command. </p> <p>Note: Side channels to accessing user data are ignored when it comes to evaluating whether read permissions are required to execute a command. This means that some write commands that return metadata about the modified key only require write permission on the key to execute. For example, consider the following two commands:</p> <ul> <li><code>LPUSH key1 data</code>: modifies \"key1\" but only returns metadata about it, the size of the list after the push, so the command only requires write permission on \"key1\" to execute.</li> <li><code>LPOP key2</code>: modifies \"key2\" but also returns data from it, the left most item in the list, so the command requires both read and write permission on \"key2\" to execute.</li> </ul> <p>If an application needs to make sure no data is accessed from a key, including side channels, it's recommended to not provide any access to the key.</p>"},{"location":"7-management/security/acl/#how-passwords-are-stored-internally","title":"How passwords are stored internally","text":"<p>Redis internally stores passwords hashed with SHA256. If you set a password and check the output of <code>ACL LIST</code> or <code>ACL GETUSER</code>, you'll see a long hex string that looks pseudo random. Here is an example, because in the previous examples, for the sake of brevity, the long hex string was trimmed:</p> <pre><code>&gt; ACL GETUSER default\n1) \"flags\"\n2) 1) \"on\"\n3) \"passwords\"\n4) 1) \"2d9c75273d72b32df726fb545c8a4edc719f0a95a6fd993950b10c474ad9c927\"\n5) \"commands\"\n6) \"+@all\"\n7) \"keys\"\n8) \"~*\"\n9) \"channels\"\n10) \"&amp;*\"\n11) \"selectors\"\n12) (empty array)\n</code></pre> <p>Using SHA256 provides the ability to avoid storing the password in clear text while still allowing for a very fast <code>AUTH</code> command, which is a very important feature of Redis and is coherent with what clients expect from Redis.</p> <p>However ACL passwords are not really passwords. They are shared secrets between the server and the client, because the password is not an authentication token used by a human being. For instance:</p> <ul> <li>There are no length limits, the password will just be memorized in some client software. There is no human that needs to recall a password in this context.</li> <li>The ACL password does not protect any other thing. For example, it will never be the password for some email account.</li> <li>Often when you are able to access the hashed password itself, by having full access to the Redis commands of a given server, or corrupting the system itself, you already have access to what the password is protecting: the Redis instance stability and the data it contains.</li> </ul> <p>For this reason, slowing down the password authentication, in order to use an algorithm that uses time and space to make password cracking hard, is a very poor choice. What we suggest instead is to generate strong passwords, so that nobody will be able to crack it using a dictionary or a brute force attack even if they have the hash. To do so, there is a special ACL command <code>ACL GENPASS</code> that generates passwords using the system cryptographic pseudorandom generator:</p> <pre><code>&gt; ACL GENPASS\n\"dd721260bfe1b3d9601e7fbab36de6d04e2e67b0ef1c53de59d45950db0dd3cc\"\n</code></pre> <p>The command outputs a 32-byte (256-bit) pseudorandom string converted to a 64-byte alphanumerical string. This is long enough to avoid attacks and short enough to be easy to manage, cut &amp; paste, store, and so forth. This is what you should use in order to generate Redis passwords.</p>"},{"location":"7-management/security/acl/#use-an-external-acl-file","title":"Use an external ACL file","text":"<p>There are two ways to store users inside the Redis configuration:</p> <ol> <li>Users can be specified directly inside the <code>redis.conf</code> file.</li> <li>It is possible to specify an external ACL file.</li> </ol> <p>The two methods are mutually incompatible, so Redis will ask you to use one or the other. Specifying users inside <code>redis.conf</code> is good for simple use cases. When there are multiple users to define, in a complex environment, we recommend you use the ACL file instead.</p> <p>The format used inside <code>redis.conf</code> and in the external ACL file is exactly the same, so it is trivial to switch from one to the other, and is the following:</p> <pre><code>user &lt;username&gt; ... acl rules ...\n</code></pre> <p>For instance:</p> <pre><code>user worker +@list +@connection ~jobs:* on &gt;ffa9203c493aa99\n</code></pre> <p>When you want to use an external ACL file, you are required to specify the configuration directive called <code>aclfile</code>, like this:</p> <pre><code>aclfile /etc/redis/users.acl\n</code></pre> <p>When you are just specifying a few users directly inside the <code>redis.conf</code> file, you can use <code>CONFIG REWRITE</code> in order to store the new user configuration inside the file by rewriting it.</p> <p>The external ACL file however is more powerful. You can do the following:</p> <ul> <li>Use <code>ACL LOAD</code> if you modified the ACL file manually and you want Redis to reload the new configuration. Note that this command is able to load the file only if all the users are correctly specified. Otherwise, an error is reported to the user, and the old configuration will remain valid.</li> <li>Use <code>ACL SAVE</code> to save the current ACL configuration to the ACL file.</li> </ul> <p>Note that <code>CONFIG REWRITE</code> does not also trigger <code>ACL SAVE</code>. When you use an ACL file, the configuration and the ACLs are handled separately.</p>"},{"location":"7-management/security/acl/#acl-rules-for-sentinel-and-replicas","title":"ACL rules for Sentinel and Replicas","text":"<p>In case you don't want to provide Redis replicas and Redis Sentinel instances full access to your Redis instances, the following is the set of commands that must be allowed in order for everything to work correctly.</p> <p>For Sentinel, allow the user to access the following commands both in the master and replica instances:</p> <ul> <li>AUTH, CLIENT, SUBSCRIBE, SCRIPT, PUBLISH, PING, INFO, MULTI, SLAVEOF, CONFIG, CLIENT, EXEC.</li> </ul> <p>Sentinel does not need to access any key in the database but does use Pub/Sub, so the ACL rule would be the following (note: <code>AUTH</code> is not needed since it is always allowed):</p> <pre><code>ACL SETUSER sentinel-user on &gt;somepassword allchannels +multi +slaveof +ping +exec +subscribe +config|rewrite +role +publish +info +client|setname +client|kill +script|kill\n</code></pre> <p>Redis replicas require the following commands to be allowed on the master instance:</p> <ul> <li>PSYNC, REPLCONF, PING</li> </ul> <p>No keys need to be accessed, so this translates to the following rules:</p> <pre><code>ACL setuser replica-user on &gt;somepassword +psync +replconf +ping\n</code></pre> <p>Note that you don't need to configure the replicas to allow the master to be able to execute any set of commands. The master is always authenticated as the root user from the point of view of replicas.</p>"},{"location":"7-management/security/encryption/","title":"TLS","text":"<p>SSL/TLS is supported by Redis starting with version 6 as an optional feature that needs to be enabled at compile time.</p>"},{"location":"7-management/security/encryption/#getting-started","title":"Getting Started","text":""},{"location":"7-management/security/encryption/#building","title":"Building","text":"<p>To build with TLS support you'll need OpenSSL development libraries (e.g. <code>libssl-dev</code> on Debian/Ubuntu).</p> <p>Build Redis with the following command:</p> <pre><code>make BUILD_TLS=yes\n</code></pre>"},{"location":"7-management/security/encryption/#tests","title":"Tests","text":"<p>To run Redis test suite with TLS, you'll need TLS support for TCL (i.e. <code>tcl-tls</code> package on Debian/Ubuntu).</p> <ol> <li> <p>Run <code>./utils/gen-test-certs.sh</code> to generate a root CA and a server    certificate.</p> </li> <li> <p>Run <code>./runtest --tls</code> or <code>./runtest-cluster --tls</code> to run Redis and Redis    Cluster tests in TLS mode.</p> </li> </ol>"},{"location":"7-management/security/encryption/#running-manually","title":"Running manually","text":"<p>To manually run a Redis server with TLS mode (assuming <code>gen-test-certs.sh</code> was invoked so sample certificates/keys are available):</p> <pre><code>./src/redis-server --tls-port 6379 --port 0 \\\n    --tls-cert-file ./tests/tls/redis.crt \\\n    --tls-key-file ./tests/tls/redis.key \\\n    --tls-ca-cert-file ./tests/tls/ca.crt\n</code></pre> <p>To connect to this Redis server with <code>redis-cli</code>:</p> <pre><code>./src/redis-cli --tls \\\n    --cert ./tests/tls/redis.crt \\\n    --key ./tests/tls/redis.key \\\n    --cacert ./tests/tls/ca.crt\n</code></pre>"},{"location":"7-management/security/encryption/#certificate-configuration","title":"Certificate configuration","text":"<p>In order to support TLS, Redis must be configured with a X.509 certificate and a private key. In addition, it is necessary to specify a CA certificate bundle file or path to be used as a trusted root when validating certificates. To support DH based ciphers, a DH params file can also be configured. For example:</p> <pre><code>tls-cert-file /path/to/redis.crt\ntls-key-file /path/to/redis.key\ntls-ca-cert-file /path/to/ca.crt\ntls-dh-params-file /path/to/redis.dh\n</code></pre>"},{"location":"7-management/security/encryption/#tls-listening-port","title":"TLS listening port","text":"<p>The <code>tls-port</code> configuration directive enables accepting SSL/TLS connections on the specified port. This is in addition to listening on <code>port</code> for TCP connections, so it is possible to access Redis on different ports using TLS and non-TLS connections simultaneously.</p> <p>You may specify <code>port 0</code> to disable the non-TLS port completely. To enable only TLS on the default Redis port, use:</p> <pre><code>port 0\ntls-port 6379\n</code></pre>"},{"location":"7-management/security/encryption/#client-certificate-authentication","title":"Client certificate authentication","text":"<p>By default, Redis uses mutual TLS and requires clients to authenticate with a valid certificate (authenticated against trusted root CAs specified by <code>ca-cert-file</code> or <code>ca-cert-dir</code>).</p> <p>You may use <code>tls-auth-clients no</code> to disable client authentication.</p>"},{"location":"7-management/security/encryption/#replication","title":"Replication","text":"<p>A Redis master server handles connecting clients and replica servers in the same way, so the above <code>tls-port</code> and <code>tls-auth-clients</code> directives apply to replication links as well.</p> <p>On the replica server side, it is necessary to specify <code>tls-replication yes</code> to use TLS for outgoing connections to the master.</p>"},{"location":"7-management/security/encryption/#cluster","title":"Cluster","text":"<p>When Redis Cluster is used, use <code>tls-cluster yes</code> in order to enable TLS for the cluster bus and cross-node connections.</p>"},{"location":"7-management/security/encryption/#sentinel","title":"Sentinel","text":"<p>Sentinel inherits its networking configuration from the common Redis configuration, so all of the above applies to Sentinel as well.</p> <p>When connecting to master servers, Sentinel will use the <code>tls-replication</code> directive to determine if a TLS or non-TLS connection is required.</p> <p>In addition, the very same <code>tls-replication</code> directive will determine whether Sentinel's port, that accepts connections from other Sentinels, will support TLS as well. That is, Sentinel will be configured with <code>tls-port</code> if and only if <code>tls-replication</code> is enabled. </p>"},{"location":"7-management/security/encryption/#additional-configuration","title":"Additional configuration","text":"<p>Additional TLS configuration is available to control the choice of TLS protocol versions, ciphers and cipher suites, etc. Please consult the self documented <code>redis.conf</code> for more information.</p>"},{"location":"7-management/security/encryption/#performance-considerations","title":"Performance considerations","text":"<p>TLS adds a layer to the communication stack with overheads due to writing/reading to/from an SSL connection, encryption/decryption and integrity checks. Consequently, using TLS results in a decrease of the achievable throughput per Redis instance (for more information refer to this discussion). </p>"},{"location":"7-management/security/encryption/#limitations","title":"Limitations","text":"<p>I/O threading is currently not supported with TLS.</p>"},{"location":"8-reference/arm/","title":"ARM support","text":"<p>Redis versions 4.0 and above support the ARM processor in general, and the Raspberry Pi specifically, as a main platform. Every new release of Redis is tested on the Pi environment, and we update this documentation page with information about supported devices and other useful information. While Redis does run on Android, in the future we look forward to extend our testing efforts to Android to also make it an officially supported platform.</p> <p>We believe that Redis is ideal for IoT and embedded devices for several reasons:</p> <ul> <li>Redis has a very small memory footprint and CPU requirements. It can run in small devices like the Raspberry Pi Zero without impacting the overall performance, using a small amount of memory while delivering good performance for many use cases.</li> <li>The data structures of Redis are often an ideal way to model IoT/embedded use cases. Some examples include accumulating time series data, receiving or queuing commands to execute or respond to send back to the remote servers, and so forth.</li> <li>Modeling data inside Redis can be very useful in order to make in-device decisions for appliances that must respond very quickly or when the remote servers are offline.</li> <li>Redis can be used as a communication system between the processes running in the device.</li> <li>The append-only file storage of Redis is well suited for SSD cards.</li> <li>The stream data structure included in Redis versions 5.0 and higher was specifically designed for time series applications and has a very low memory overhead.</li> </ul>"},{"location":"8-reference/arm/#redis-proccpualignment-requirements","title":"Redis /proc/cpu/alignment requirements","text":"<p>Linux on ARM allows to trap unaligned accesses and fix them inside the kernel in order to continue the execution of the offending program instead of generating a <code>SIGBUS</code>. Redis 4.0 and greater are fixed in order to avoid any kind of unaligned access, so there is no need to have a specific value for this kernel configuration. Even when kernel alignment fixing set as disabled Redis should run as expected.</p>"},{"location":"8-reference/arm/#building-redis-in-the-pi","title":"Building Redis in the Pi","text":"<ul> <li>Download Redis version 4.0 or higher.</li> <li>Use <code>make</code> as usual to create the executable.</li> </ul> <p>There is nothing special in the process. The only difference is that by default, Redis uses the <code>libc</code> allocator instead of defaulting to <code>jemalloc</code> as it does in other Linux based environments. This is because we believe that for the small use cases inside embedded devices, memory fragmentation is unlikely to be a problem. Moreover <code>jemalloc</code> on ARM may not be as tested as the <code>libc</code> allocator.</p>"},{"location":"8-reference/arm/#performance","title":"Performance","text":"<p>Performance testing of Redis was performed on the Raspberry Pi 3 and Pi 1 model B. The difference between the two Pis in terms of delivered performance is quite big. The benchmarks were performed via the loopback interface, since most use cases will probably use Redis from within the device and not via the network. The following numbers were obtained using Redis 4.0.</p> <p>Raspberry Pi 3:</p> <ul> <li>Test 1 : 5 millions writes with 1 million keys (even distribution among keys).  No persistence, no pipelining. 28,000 ops/sec.</li> <li>Test 2: Like test 1 but with pipelining using groups of 8 operations: 80,000 ops/sec.</li> <li>Test 3: Like test 1 but with AOF enabled, fsync 1 sec: 23,000 ops/sec</li> <li>Test 4: Like test 3, but with an AOF rewrite in progress: 21,000 ops/sec</li> </ul> <p>Raspberry Pi 1 model B:</p> <ul> <li>Test 1 : 5 millions writes with 1 million keys (even distribution among keys).  No persistence, no pipelining.  2,200 ops/sec.</li> <li>Test 2: Like test 1 but with pipelining using groups of 8 operations: 8,500 ops/sec.</li> <li>Test 3: Like test 1 but with AOF enabled, fsync 1 sec: 1,820 ops/sec</li> <li>Test 4: Like test 3, but with an AOF rewrite in progress: 1,000 ops/sec</li> </ul> <p>The benchmarks above are referring to simple <code>SET</code>/<code>GET</code> operations. The performance is similar for all the Redis fast operations (not running in linear time). However sorted sets may show slightly slower numbers.</p>"},{"location":"8-reference/clients/","title":"Redis client handling","text":"<p>This document provides information about how Redis handles clients at the network layer level: connections, timeouts, buffers, and other similar topics are covered here.</p> <p>The information contained in this document is only applicable to Redis version 2.6 or greater.</p>"},{"location":"8-reference/clients/#accepting-client-connections","title":"Accepting Client Connections","text":"<p>Redis accepts clients connections on the configured TCP port and on the Unix socket if enabled. When a new client connection is accepted the following operations are performed:</p> <ul> <li>The client socket is put in the non-blocking state since Redis uses multiplexing and non-blocking I/O.</li> <li>The <code>TCP_NODELAY</code> option is set in order to ensure that there are no delays to the connection.</li> <li>A readable file event is created so that Redis is able to collect the client queries as soon as new data is available to read on the socket.</li> </ul> <p>After the client is initialized, Redis checks if it is already at the limit configured for the number of simultaneous clients (configured using the <code>maxclients</code> configuration directive, see the next section of this document for further information).</p> <p>When Redis can't accept a new client connection because the maximum number of clients has been reached, it tries to send an error to the client in order to make it aware of this condition, closing the connection immediately. The error message will reach the client even if the connection is closed immediately by Redis because the new socket output buffer is usually big enough to contain the error, so the kernel will handle transmission of the error.</p>"},{"location":"8-reference/clients/#what-order-are-client-requests-served-in","title":"What Order are Client Requests Served In?","text":"<p>The order is determined by a combination of the client socket file descriptor number and order in which the kernel reports events, so the order should be  considered as unspecified.</p> <p>However, Redis does the following two things when serving clients:</p> <ul> <li>It only performs a single <code>read()</code> system call every time there is something new to read from the client socket. This ensures that if we have multiple clients connected, and a few send queries at a high rate, other clients are not penalized and will not experience latency issues.</li> <li>However once new data is read from a client, all the queries contained in the current buffers are processed sequentially. This improves locality and does not need iterating a second time to see if there are clients that need some processing time.</li> </ul>"},{"location":"8-reference/clients/#maximum-concurrent-connected-clients","title":"Maximum Concurrent Connected Clients","text":"<p>In Redis 2.4 there was a hard-coded limit for the maximum number of clients that could be handled simultaneously.</p> <p>In Redis 2.6 and newer, this limit is dynamic: by default it is set to 10000 clients, unless otherwise stated by the <code>maxclients</code> directive in <code>redis.conf</code>.</p> <p>However, Redis checks with the kernel what the maximum number of file descriptors that we are able to open is (the soft limit is checked). If the limit is less than the maximum number of clients we want to handle, plus 32 (that is the number of file descriptors Redis reserves for internal uses), then the maximum number of clients is updated to match the number of clients it is really able to handle under the current operating system limit.</p> <p>When <code>maxclients</code> is set to a number greater than Redis can support, a message is logged at startup:</p> <pre><code>$ ./redis-server --maxclients 100000\n[41422] 23 Jan 11:28:33.179 # Unable to set the max number of files limit to 100032 (Invalid argument), setting the max clients configuration to 10112.\n</code></pre> <p>When Redis is configured in order to handle a specific number of clients it is a good idea to make sure that the operating system limit for the maximum number of file descriptors per process is also set accordingly.</p> <p>Under Linux these limits can be set both in the current session and as a system-wide setting with the following commands:</p> <ul> <li><code>ulimit -Sn 100000 # This will only work if hard limit is big enough.</code></li> <li><code>sysctl -w fs.file-max=100000</code></li> </ul>"},{"location":"8-reference/clients/#output-buffer-limits","title":"Output Buffer Limits","text":"<p>Redis needs to handle a variable-length output buffer for every client, since a command can produce a large amount of data that needs to be transferred to the client.</p> <p>However it is possible that a client sends more commands producing more output to serve at a faster rate than that which Redis can send the existing output to the client. This is especially true with Pub/Sub clients in case a client is not able to process new messages fast enough.</p> <p>Both conditions will cause the client output buffer to grow and consume more and more memory. For this reason by default Redis sets limits to the output buffer size for different kind of clients. When the limit is reached the client connection is closed and the event logged in the Redis log file.</p> <p>There are two kind of limits Redis uses:</p> <ul> <li>The hard limit is a fixed limit that when reached will make Redis close the client connection as soon as possible.</li> <li>The soft limit instead is a limit that depends on the time, for instance a soft limit of 32 megabytes per 10 seconds means that if the client has an output buffer bigger than 32 megabytes for, continuously, 10 seconds, the connection gets closed.</li> </ul> <p>Different kind of clients have different default limits:</p> <ul> <li>Normal clients have a default limit of 0, that means, no limit at all, because most normal clients use blocking implementations sending a single command and waiting for the reply to be completely read before sending the next command, so it is always not desirable to close the connection in case of a normal client.</li> <li>Pub/Sub clients have a default hard limit of 32 megabytes and a soft limit of 8 megabytes per 60 seconds.</li> <li>Replicas have a default hard limit of 256 megabytes and a soft limit of 64 megabyte per 60 seconds.</li> </ul> <p>It is possible to change the limit at runtime using the <code>CONFIG SET</code> command or in a permanent way using the Redis configuration file <code>redis.conf</code>. See the example <code>redis.conf</code> in the Redis distribution for more information about how to set the limit.</p>"},{"location":"8-reference/clients/#query-buffer-hard-limit","title":"Query Buffer Hard Limit","text":"<p>Every client is also subject to a query buffer limit. This is a non-configurable hard limit that will close the connection when the client query buffer (that is the buffer we use to accumulate commands from the client) reaches 1 GB, and is actually only an extreme limit to avoid a server crash in case of client or server software bugs.</p>"},{"location":"8-reference/clients/#client-eviction","title":"Client Eviction","text":"<p>Redis is built to handle a very large number of client connections. Client connections tend to consume memory, and when there are many of them, the aggregate memory consumption can be extremely high, leading to data eviction or out-of-memory errors. These cases can be mitigated to an extent using output buffer limits, but Redis allows us a more robust configuration to limit the aggregate memory used by all clients' connections.</p> <p>This mechanism is called client eviction, and it's essentially a safety mechanism that will disconnect clients once the aggregate memory usage of all clients is above a threshold. The mechanism first attempts to disconnect clients that use the most memory. It disconnects the minimal number of clients needed to return below the <code>maxmemory-clients</code> threshold.</p> <p><code>maxmemory-clients</code> defines the maximum aggregate memory usage of all clients connected to Redis. The aggregation takes into account all the memory used by the client connections: the query buffer, the output buffer, and other intermediate buffers.</p> <p>Note that replica and master connections aren't affected by the client eviction mechanism. Therefore, such connections are never evicted.</p> <p><code>maxmemory-clients</code> can be set permanently in the configuration file (<code>redis.conf</code>) or via the <code>CONFIG SET</code> command. This setting can either be 0 (meaning no limit), a size in bytes (possibly with <code>mb</code>/<code>gb</code> suffix), or a percentage of <code>maxmemory</code> by using the <code>%</code> suffix (e.g. setting it to <code>10%</code> would mean 10% of the <code>maxmemory</code> configuration).</p> <p>The default setting is 0, meaning client eviction is turned off by default. However, for any large production deployment, it is highly recommended to configure some non-zero <code>maxmemory-clients</code> value. A value <code>5%</code>, for example, can be a good place to start.</p> <p>It is possible to flag a specific client connection to be excluded from the client eviction mechanism. This is useful for control path connections. If, for example, you have an application that monitors the server via the <code>INFO</code> command and alerts you in case of a problem, you might want to make sure this connection isn't evicted. You can do so using the following command (from the relevant client's connection):</p> <p><code>CLIENT NO-EVICT</code> <code>on</code></p> <p>And you can revert that with:</p> <p><code>CLIENT NO-EVICT</code> <code>off</code></p> <p>For more information and an example refer to the <code>maxmemory-clients</code> section in the default <code>redis.conf</code> file.</p> <p>Client eviction is available from Redis 7.0.</p>"},{"location":"8-reference/clients/#client-timeouts","title":"Client Timeouts","text":"<p>By default recent versions of Redis don't close the connection with the client if the client is idle for many seconds: the connection will remain open forever.</p> <p>However if you don't like this behavior, you can configure a timeout, so that if the client is idle for more than the specified number of seconds, the client connection will be closed.</p> <p>You can configure this limit via <code>redis.conf</code> or simply using <code>CONFIG SET timeout &lt;value&gt;</code>.</p> <p>Note that the timeout only applies to normal clients and it does not apply to Pub/Sub clients, since a Pub/Sub connection is a push style connection so a client that is idle is the norm.</p> <p>Even if by default connections are not subject to timeout, there are two conditions when it makes sense to set a timeout:</p> <ul> <li>Mission critical applications where a bug in the client software may saturate the Redis server with idle connections, causing service disruption.</li> <li>As a debugging mechanism in order to be able to connect with the server if a bug in the client software saturates the server with idle connections, making it impossible to interact with the server.</li> </ul> <p>Timeouts are not to be considered very precise: Redis avoids setting timer events or running O(N) algorithms in order to check idle clients, so the check is performed incrementally from time to time. This means that it is possible that while the timeout is set to 10 seconds, the client connection will be closed, for instance, after 12 seconds if many clients are connected at the same time.</p>"},{"location":"8-reference/clients/#the-client-command","title":"The CLIENT Command","text":"<p>The Redis <code>CLIENT</code> command allows you to inspect the state of every connected client, to kill a specific client, and to name connections. It is a very powerful debugging tool if you use Redis at scale.</p> <p><code>CLIENT LIST</code> is used in order to obtain a list of connected clients and their state:</p> <pre><code>redis 127.0.0.1:6379&gt; client list\naddr=127.0.0.1:52555 fd=5 name= age=855 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client\naddr=127.0.0.1:52787 fd=6 name= age=6 idle=5 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=0 obl=0 oll=0 omem=0 events=r cmd=ping\n</code></pre> <p>In the above example two clients are connected to the Redis server. Let's look at what some of the data returned represents:</p> <ul> <li>addr: The client address, that is, the client IP and the remote port number it used to connect with the Redis server.</li> <li>fd: The client socket file descriptor number.</li> <li>name: The client name as set by <code>CLIENT SETNAME</code>.</li> <li>age: The number of seconds the connection existed for.</li> <li>idle: The number of seconds the connection is idle.</li> <li>flags: The kind of client (N means normal client, check the full list of flags).</li> <li>omem: The amount of memory used by the client for the output buffer.</li> <li>cmd: The last executed command.</li> </ul> <p>See the <code>CLIENT LIST</code> documentation for the full listing of fields and their purpose.</p> <p>Once you have the list of clients, you can close a client's connection using the <code>CLIENT KILL</code> command, specifying the client address as its argument.</p> <p>The commands <code>CLIENT SETNAME</code> and <code>CLIENT GETNAME</code> can be used to set and get the connection name. Starting with Redis 4.0, the client name is shown in the <code>SLOWLOG</code> output, to help identify clients that create latency issues.</p>"},{"location":"8-reference/clients/#tcp-keepalive","title":"TCP keepalive","text":"<p>From version 3.2 onwards, Redis has TCP keepalive (<code>SO_KEEPALIVE</code> socket option) enabled by default and set to about 300 seconds. This option is useful in order to detect dead peers (clients that cannot be reached even if they look connected). Moreover, if there is network equipment between clients and servers that need to see some traffic in order to take the connection open, the option will prevent unexpected connection closed events.</p>"},{"location":"8-reference/cluster-spec/","title":"Redis cluster specification","text":"<p>Welcome to the Redis Cluster Specification. Here you'll find information about the algorithms and design rationales of Redis Cluster. This document is a work in progress as it is continuously synchronized with the actual implementation of Redis.</p>"},{"location":"8-reference/cluster-spec/#main-properties-and-rationales-of-the-design","title":"Main properties and rationales of the design","text":""},{"location":"8-reference/cluster-spec/#redis-cluster-goals","title":"Redis Cluster goals","text":"<p>Redis Cluster is a distributed implementation of Redis with the following goals in order of importance in the design:</p> <ul> <li>High performance and linear scalability up to 1000 nodes. There are no proxies, asynchronous replication is used, and no merge operations are performed on values.</li> <li>Acceptable degree of write safety: the system tries (in a best-effort way) to retain all the writes originating from clients connected with the majority of the master nodes. Usually there are small windows where acknowledged writes can be lost. Windows to lose acknowledged writes are larger when clients are in a minority partition.</li> <li>Availability: Redis Cluster is able to survive partitions where the majority of the master nodes are reachable and there is at least one reachable replica for every master node that is no longer reachable. Moreover using replicas migration, masters no longer replicated by any replica will receive one from a master which is covered by multiple replicas.</li> </ul> <p>What is described in this document is implemented in Redis 3.0 or greater.</p>"},{"location":"8-reference/cluster-spec/#implemented-subset","title":"Implemented subset","text":"<p>Redis Cluster implements all the single key commands available in the non-distributed version of Redis. Commands performing complex multi-key operations like set unions and intersections are implemented for cases where all of the keys involved in the operation hash to the same slot.</p> <p>Redis Cluster implements a concept called hash tags that can be used to force certain keys to be stored in the same hash slot. However, during manual resharding, multi-key operations may become unavailable for some time while single-key operations are always available.</p> <p>Redis Cluster does not support multiple databases like the standalone version of Redis. We only support database <code>0</code>; the <code>SELECT</code> command is not allowed.</p>"},{"location":"8-reference/cluster-spec/#client-and-server-roles-in-the-redis-cluster-protocol","title":"Client and Server roles in the Redis cluster protocol","text":"<p>In Redis Cluster, nodes are responsible for holding the data, and taking the state of the cluster, including mapping keys to the right nodes. Cluster nodes are also able to auto-discover other nodes, detect non-working nodes, and promote replica nodes to master when needed in order to continue to operate when a failure occurs.</p> <p>To perform their tasks all the cluster nodes are connected using a TCP bus and a binary protocol, called the Redis Cluster Bus. Every node is connected to every other node in the cluster using the cluster bus. Nodes use a gossip protocol to propagate information about the cluster in order to discover new nodes, to send ping packets to make sure all the other nodes are working properly, and to send cluster messages needed to signal specific conditions. The cluster bus is also used in order to propagate Pub/Sub messages across the cluster and to orchestrate manual failovers when requested by users (manual failovers are failovers which are not initiated by the Redis Cluster failure detector, but by the system administrator directly).</p> <p>Since cluster nodes are not able to proxy requests, clients may be redirected to other nodes using redirection errors <code>-MOVED</code> and <code>-ASK</code>. The client is in theory free to send requests to all the nodes in the cluster, getting redirected if needed, so the client is not required to hold the state of the cluster. However clients that are able to cache the map between keys and nodes can improve the performance in a sensible way.</p>"},{"location":"8-reference/cluster-spec/#write-safety","title":"Write safety","text":"<p>Redis Cluster uses asynchronous replication between nodes, and last failover wins implicit merge function. This means that the last elected master dataset eventually replaces all the other replicas. There is always a window of time when it is possible to lose writes during partitions. However these windows are very different in the case of a client that is connected to the majority of masters, and a client that is connected to the minority of masters.</p> <p>Redis Cluster tries harder to retain writes that are performed by clients connected to the majority of masters, compared to writes performed in the minority side. The following are examples of scenarios that lead to loss of acknowledged writes received in the majority partitions during failures:</p> <ol> <li> <p>A write may reach a master, but while the master may be able to reply to the client, the write may not be propagated to replicas via the asynchronous replication used between master and replica nodes. If the master dies without the write reaching the replicas, the write is lost forever if the master is unreachable for a long enough period that one of its replicas is promoted. This is usually hard to observe in the case of a total, sudden failure of a master node since masters try to reply to clients (with the acknowledge of the write) and replicas (propagating the write) at about the same time. However it is a real world failure mode.</p> </li> <li> <p>Another theoretically possible failure mode where writes are lost is the following:</p> </li> <li> <p>A master is unreachable because of a partition.</p> </li> <li>It gets failed over by one of its replicas.</li> <li>After some time it may be reachable again.</li> <li>A client with an out-of-date routing table may write to the old master before it is converted into a replica (of the new master) by the cluster.</li> </ol> <p>The second failure mode is unlikely to happen because master nodes unable to communicate with the majority of the other masters for enough time to be failed over will no longer accept writes, and when the partition is fixed writes are still refused for a small amount of time to allow other nodes to inform about configuration changes. This failure mode also requires that the client's routing table has not yet been updated.</p> <p>Writes targeting the minority side of a partition have a larger window in which to get lost. For example, Redis Cluster loses a non-trivial number of writes on partitions where there is a minority of masters and at least one or more clients, since all the writes sent to the masters may potentially get lost if the masters are failed over in the majority side.</p> <p>Specifically, for a master to be failed over it must be unreachable by the majority of masters for at least <code>NODE_TIMEOUT</code>, so if the partition is fixed before that time, no writes are lost. When the partition lasts for more than <code>NODE_TIMEOUT</code>, all the writes performed in the minority side up to that point may be lost. However the minority side of a Redis Cluster will start refusing writes as soon as <code>NODE_TIMEOUT</code> time has elapsed without contact with the majority, so there is a maximum window after which the minority becomes no longer available. Hence, no writes are accepted or lost after that time.</p>"},{"location":"8-reference/cluster-spec/#availability","title":"Availability","text":"<p>Redis Cluster is not available in the minority side of the partition. In the majority side of the partition assuming that there are at least the majority of masters and a replica for every unreachable master, the cluster becomes available again after <code>NODE_TIMEOUT</code> time plus a few more seconds required for a replica to get elected and failover its master (failovers are usually executed in a matter of 1 or 2 seconds).</p> <p>This means that Redis Cluster is designed to survive failures of a few nodes in the cluster, but it is not a suitable solution for applications that require availability in the event of large net splits.</p> <p>In the example of a cluster composed of N master nodes where every node has a single replica, the majority side of the cluster will remain available as long as a single node is partitioned away, and will remain available with a probability of <code>1-(1/(N*2-1))</code> when two nodes are partitioned away (after the first node fails we are left with <code>N*2-1</code> nodes in total, and the probability of the only master without a replica to fail is <code>1/(N*2-1))</code>.</p> <p>For example, in a cluster with 5 nodes and a single replica per node, there is a <code>1/(5*2-1) = 11.11%</code> probability that after two nodes are partitioned away from the majority, the cluster will no longer be available.</p> <p>Thanks to a Redis Cluster feature called replicas migration the Cluster availability is improved in many real world scenarios by the fact that replicas migrate to orphaned masters (masters no longer having replicas). So at every successful failure event, the cluster may reconfigure the replicas layout in order to better resist the next failure.</p>"},{"location":"8-reference/cluster-spec/#performance","title":"Performance","text":"<p>In Redis Cluster nodes don't proxy commands to the right node in charge for a given key, but instead they redirect clients to the right nodes serving a given portion of the key space.</p> <p>Eventually clients obtain an up-to-date representation of the cluster and which node serves which subset of keys, so during normal operations clients directly contact the right nodes in order to send a given command.</p> <p>Because of the use of asynchronous replication, nodes do not wait for other nodes' acknowledgment of writes (if not explicitly requested using the <code>WAIT</code> command).</p> <p>Also, because multi-key commands are only limited to near keys, data is never moved between nodes except when resharding.</p> <p>Normal operations are handled exactly as in the case of a single Redis instance. This means that in a Redis Cluster with N master nodes you can expect the same performance as a single Redis instance multiplied by N as the design scales linearly. At the same time the query is usually performed in a single round trip, since clients usually retain persistent connections with the nodes, so latency figures are also the same as the single standalone Redis node case.</p> <p>Very high performance and scalability while preserving weak but reasonable forms of data safety and availability is the main goal of Redis Cluster.</p>"},{"location":"8-reference/cluster-spec/#why-merge-operations-are-avoided","title":"Why merge operations are avoided","text":"<p>The Redis Cluster design avoids conflicting versions of the same key-value pair in multiple nodes as in the case of the Redis data model this is not always desirable. Values in Redis are often very large; it is common to see lists or sorted sets with millions of elements. Also data types are semantically complex. Transferring and merging these kind of values can be a major bottleneck and/or may require the non-trivial involvement of application-side logic, additional memory to store meta-data, and so forth.</p> <p>There are no strict technological limits here. CRDTs or synchronously replicated state machines can model complex data types similar to Redis. However, the actual run time behavior of such systems would not be similar to Redis Cluster. Redis Cluster was designed in order to cover the exact use cases of the non-clustered Redis version.</p>"},{"location":"8-reference/cluster-spec/#overview-of-redis-cluster-main-components","title":"Overview of Redis Cluster main components","text":""},{"location":"8-reference/cluster-spec/#key-distribution-model","title":"Key distribution model","text":"<p>The cluster's key space is split into 16384 slots, effectively setting an upper limit for the cluster size of 16384 master nodes (however, the suggested max size of nodes is on the order of ~ 1000 nodes).</p> <p>Each master node in a cluster handles a subset of the 16384 hash slots. The cluster is stable when there is no cluster reconfiguration in progress (i.e. where hash slots are being moved from one node to another). When the cluster is stable, a single hash slot will be served by a single node (however the serving node can have one or more replicas that will replace it in the case of net splits or failures, and that can be used in order to scale read operations where reading stale data is acceptable).</p> <p>The base algorithm used to map keys to hash slots is the following (read the next paragraph for the hash tag exception to this rule):</p> <pre><code>HASH_SLOT = CRC16(key) mod 16384\n</code></pre> <p>The CRC16 is specified as follows:</p> <ul> <li>Name: XMODEM (also known as ZMODEM or CRC-16/ACORN)</li> <li>Width: 16 bit</li> <li>Poly: 1021 (That is actually x^16 + x^12 + x^5 + 1)</li> <li>Initialization: 0000</li> <li>Reflect Input byte: False</li> <li>Reflect Output CRC: False</li> <li>Xor constant to output CRC: 0000</li> <li>Output for \"123456789\": 31C3</li> </ul> <p>14 out of 16 CRC16 output bits are used (this is why there is a modulo 16384 operation in the formula above).</p> <p>In our tests CRC16 behaved remarkably well in distributing different kinds of keys evenly across the 16384 slots.</p> <p>Note: A reference implementation of the CRC16 algorithm used is available in the Appendix A of this document.</p>"},{"location":"8-reference/cluster-spec/#hash-tags","title":"Hash tags","text":"<p>There is an exception for the computation of the hash slot that is used in order to implement hash tags. Hash tags are a way to ensure that multiple keys are allocated in the same hash slot. This is used in order to implement multi-key operations in Redis Cluster.</p> <p>To implement hash tags, the hash slot for a key is computed in a slightly different way in certain conditions. If the key contains a \"{...}\" pattern only the substring between <code>{</code> and <code>}</code> is hashed in order to obtain the hash slot. However since it is possible that there are multiple occurrences of <code>{</code> or <code>}</code> the algorithm is well specified by the following rules:</p> <ul> <li>IF the key contains a <code>{</code> character.</li> <li>AND IF there is a <code>}</code> character to the right of <code>{</code>.</li> <li>AND IF there are one or more characters between the first occurrence of <code>{</code> and the first occurrence of <code>}</code>.</li> </ul> <p>Then instead of hashing the key, only what is between the first occurrence of <code>{</code> and the following first occurrence of <code>}</code> is hashed.</p> <p>Examples:</p> <ul> <li>The two keys <code>{user1000}.following</code> and <code>{user1000}.followers</code> will hash to the same hash slot since only the substring <code>user1000</code> will be hashed in order to compute the hash slot.</li> <li>For the key <code>foo{}{bar}</code> the whole key will be hashed as usually since the first occurrence of <code>{</code> is followed by <code>}</code> on the right without characters in the middle.</li> <li>For the key <code>foo{{bar}}zap</code> the substring <code>{bar</code> will be hashed, because it is the substring between the first occurrence of <code>{</code> and the first occurrence of <code>}</code> on its right.</li> <li>For the key <code>foo{bar}{zap}</code> the substring <code>bar</code> will be hashed, since the algorithm stops at the first valid or invalid (without bytes inside) match of <code>{</code> and <code>}</code>.</li> <li>What follows from the algorithm is that if the key starts with <code>{}</code>, it is guaranteed to be hashed as a whole. This is useful when using binary data as key names.</li> </ul> <p>Adding the hash tags exception, the following is an implementation of the <code>HASH_SLOT</code> function in Ruby and C language.</p> <p>Ruby example code:</p> <pre><code>def HASH_SLOT(key)\n    s = key.index \"{\"\n    if s\n        e = key.index \"}\",s+1\n        if e &amp;&amp; e != s+1\n            key = key[s+1..e-1]\n        end\n    end\n    crc16(key) % 16384\nend\n</code></pre> <p>C example code:</p> <pre><code>unsigned int HASH_SLOT(char *key, int keylen) {\n    int s, e; /* start-end indexes of { and } */\n\n    /* Search the first occurrence of '{'. */\n    for (s = 0; s &lt; keylen; s++)\n        if (key[s] == '{') break;\n\n    /* No '{' ? Hash the whole key. This is the base case. */\n    if (s == keylen) return crc16(key,keylen) &amp; 16383;\n\n    /* '{' found? Check if we have the corresponding '}'. */\n    for (e = s+1; e &lt; keylen; e++)\n        if (key[e] == '}') break;\n\n    /* No '}' or nothing between {} ? Hash the whole key. */\n    if (e == keylen || e == s+1) return crc16(key,keylen) &amp; 16383;\n\n    /* If we are here there is both a { and a } on its right. Hash\n     * what is in the middle between { and }. */\n    return crc16(key+s+1,e-s-1) &amp; 16383;\n}\n</code></pre>"},{"location":"8-reference/cluster-spec/#cluster-node-attributes","title":"Cluster node attributes","text":"<p>Every node has a unique name in the cluster. The node name is the hex representation of a 160 bit random number, obtained the first time a node is started (usually using /dev/urandom). The node will save its ID in the node configuration file, and will use the same ID forever, or at least as long as the node configuration file is not deleted by the system administrator, or a hard reset is requested via the <code>CLUSTER RESET</code> command.</p> <p>The node ID is used to identify every node across the whole cluster. It is possible for a given node to change its IP address without any need to also change the node ID. The cluster is also able to detect the change in IP/port and reconfigure using the gossip protocol running over the cluster bus.</p> <p>The node ID is not the only information associated with each node, but is the only one that is always globally consistent. Every node has also the following set of information associated. Some information is about the cluster configuration detail of this specific node, and is eventually consistent across the cluster. Some other information, like the last time a node was pinged, is instead local to each node.</p> <p>Every node maintains the following information about other nodes that it is aware of in the cluster: The node ID, IP and port of the node, a set of flags, what is the master of the node if it is flagged as <code>replica</code>, last time the node was pinged and the last time the pong was received, the current configuration epoch of the node (explained later in this specification), the link state and finally the set of hash slots served.</p> <p>A detailed explanation of all the node fields is described in the <code>CLUSTER NODES</code> documentation.</p> <p>The <code>CLUSTER NODES</code> command can be sent to any node in the cluster and provides the state of the cluster and the information for each node according to the local view the queried node has of the cluster.</p> <p>The following is sample output of the <code>CLUSTER NODES</code> command sent to a master node in a small cluster of three nodes.</p> <pre><code>$ redis-cli cluster nodes\nd1861060fe6a534d42d8a19aeb36600e18785e04 127.0.0.1:6379 myself - 0 1318428930 1 connected 0-1364\n3886e65cc906bfd9b1f7e7bde468726a052d1dae 127.0.0.1:6380 master - 1318428930 1318428931 2 connected 1365-2729\nd289c575dcbc4bdd2931585fd4339089e461a27d 127.0.0.1:6381 master - 1318428931 1318428931 3 connected 2730-4095\n</code></pre> <p>In the above listing the different fields are in order: node id, address:port, flags, last ping sent, last pong received, configuration epoch, link state, slots. Details about the above fields will be covered as soon as we talk of specific parts of Redis Cluster.</p>"},{"location":"8-reference/cluster-spec/#the-cluster-bus","title":"The cluster bus","text":"<p>Every Redis Cluster node has an additional TCP port for receiving incoming connections from other Redis Cluster nodes. This port will be derived by adding 10000 to the data port or it can be specified with the cluster-port config. </p> <p>Example 1:</p> <p>If a Redis node is listening for client connections on port 6379,  and you do not add cluster-port parameter in redis.conf, the Cluster bus port 16379 will be opened.</p> <p>Example 2:</p> <p>If a Redis node is listening for client connections on port 6379,  and you set cluster-port 20000 in redis.conf, the Cluster bus port 20000 will be opened.</p> <p>Node-to-node communication happens exclusively using the Cluster bus and the Cluster bus protocol: a binary protocol composed of frames of different types and sizes. The Cluster bus binary protocol is not publicly documented since it is not intended for external software devices to talk with Redis Cluster nodes using this protocol. However you can obtain more details about the Cluster bus protocol by reading the <code>cluster.h</code> and <code>cluster.c</code> files in the Redis Cluster source code.</p>"},{"location":"8-reference/cluster-spec/#cluster-topology","title":"Cluster topology","text":"<p>Redis Cluster is a full mesh where every node is connected with every other node using a TCP connection.</p> <p>In a cluster of N nodes, every node has N-1 outgoing TCP connections, and N-1 incoming connections.</p> <p>These TCP connections are kept alive all the time and are not created on demand. When a node expects a pong reply in response to a ping in the cluster bus, before waiting long enough to mark the node as unreachable, it will try to refresh the connection with the node by reconnecting from scratch.</p> <p>While Redis Cluster nodes form a full mesh, nodes use a gossip protocol and a configuration update mechanism in order to avoid exchanging too many messages between nodes during normal conditions, so the number of messages exchanged is not exponential.</p>"},{"location":"8-reference/cluster-spec/#node-handshake","title":"Node handshake","text":"<p>Nodes always accept connections on the cluster bus port, and even reply to pings when received, even if the pinging node is not trusted. However, all other packets will be discarded by the receiving node if the sending node is not considered part of the cluster.</p> <p>A node will accept another node as part of the cluster only in two ways:</p> <ul> <li> <p>If a node presents itself with a <code>MEET</code> message (<code>CLUSTER MEET</code> command). A meet message is exactly like a <code>PING</code> message, but forces the receiver to accept the node as part of the cluster. Nodes will send <code>MEET</code> messages to other nodes only if the system administrator requests this via the following command:</p> <p>CLUSTER MEET ip port</p> </li> <li> <p>A node will also register another node as part of the cluster if a node that is already trusted will gossip about this other node. So if A knows B, and B knows C, eventually B will send gossip messages to A about C. When this happens, A will register C as part of the network, and will try to connect with C.</p> </li> </ul> <p>This means that as long as we join nodes in any connected graph, they'll eventually form a fully connected graph automatically. This means that the cluster is able to auto-discover other nodes, but only if there is a trusted relationship that was forced by the system administrator.</p> <p>This mechanism makes the cluster more robust but prevents different Redis clusters from accidentally mixing after change of IP addresses or other network related events.</p>"},{"location":"8-reference/cluster-spec/#redirection-and-resharding","title":"Redirection and resharding","text":""},{"location":"8-reference/cluster-spec/#moved-redirection","title":"MOVED Redirection","text":"<p>A Redis client is free to send queries to every node in the cluster, including replica nodes. The node will analyze the query, and if it is acceptable (that is, only a single key is mentioned in the query, or the multiple keys mentioned are all to the same hash slot) it will lookup what node is responsible for the hash slot where the key or keys belong.</p> <p>If the hash slot is served by the node, the query is simply processed, otherwise the node will check its internal hash slot to node map, and will reply to the client with a MOVED error, like in the following example:</p> <pre><code>GET x\n-MOVED 3999 127.0.0.1:6381\n</code></pre> <p>The error includes the hash slot of the key (3999) and the endpoint:port of the instance that can serve the query. The client needs to reissue the query to the specified node's endpoint address and port.  The endpoint can be either an IP address, a hostname, or it can be empty (e.g. <code>-MOVED 3999 :6380</code>).  An empty endpoint indicates that the server node has an unknown endpoint, and the client should send the next request to the same endpoint as the current request but with the provided port. </p> <p>Note that even if the client waits a long time before reissuing the query, and in the meantime the cluster configuration changed, the destination node will reply again with a MOVED error if the hash slot 3999 is now served by another node. The same happens if the contacted node had no updated information.</p> <p>So while from the point of view of the cluster nodes are identified by IDs we try to simplify our interface with the client just exposing a map between hash slots and Redis nodes identified by endpoint:port pairs.</p> <p>The client is not required to, but should try to memorize that hash slot 3999 is served by 127.0.0.1:6381. This way once a new command needs to be issued it can compute the hash slot of the target key and have a greater chance of choosing the right node.</p> <p>An alternative is to just refresh the whole client-side cluster layout using the <code>CLUSTER SHARDS</code>, or the deprecated <code>CLUSTER SLOTS</code>, command when a MOVED redirection is received. When a redirection is encountered, it is likely multiple slots were reconfigured rather than just one, so updating the client configuration as soon as possible is often the best strategy.</p> <p>Note that when the Cluster is stable (no ongoing changes in the configuration), eventually all the clients will obtain a map of hash slots -&gt; nodes, making the cluster efficient, with clients directly addressing the right nodes without redirections, proxies or other single point of failure entities.</p> <p>A client must be also able to handle -ASK redirections that are described later in this document, otherwise it is not a complete Redis Cluster client.</p>"},{"location":"8-reference/cluster-spec/#live-reconfiguration","title":"Live reconfiguration","text":"<p>Redis Cluster supports the ability to add and remove nodes while the cluster is running. Adding or removing a node is abstracted into the same operation: moving a hash slot from one node to another. This means that the same basic mechanism can be used in order to rebalance the cluster, add or remove nodes, and so forth.</p> <ul> <li>To add a new node to the cluster an empty node is added to the cluster and some set of hash slots are moved from existing nodes to the new node.</li> <li>To remove a node from the cluster the hash slots assigned to that node are moved to other existing nodes.</li> <li>To rebalance the cluster a given set of hash slots are moved between nodes.</li> </ul> <p>The core of the implementation is the ability to move hash slots around. From a practical point of view a hash slot is just a set of keys, so what Redis Cluster really does during resharding is to move keys from an instance to another instance. Moving a hash slot means moving all the keys that happen to hash into this hash slot.</p> <p>To understand how this works we need to show the <code>CLUSTER</code> subcommands that are used to manipulate the slots translation table in a Redis Cluster node.</p> <p>The following subcommands are available (among others not useful in this case):</p> <ul> <li><code>CLUSTER ADDSLOTS</code> slot1 [slot2] ... [slotN]</li> <li><code>CLUSTER DELSLOTS</code> slot1 [slot2] ... [slotN]</li> <li><code>CLUSTER ADDSLOTSRANGE</code> start-slot1 end-slot1 [start-slot2 end-slot2] ... [start-slotN end-slotN]</li> <li><code>CLUSTER DELSLOTSRANGE</code> start-slot1 end-slot1 [start-slot2 end-slot2] ... [start-slotN end-slotN]</li> <li><code>CLUSTER SETSLOT</code> slot NODE node</li> <li><code>CLUSTER SETSLOT</code> slot MIGRATING node</li> <li><code>CLUSTER SETSLOT</code> slot IMPORTING node</li> </ul> <p>The first four commands, <code>ADDSLOTS</code>, <code>DELSLOTS</code>, <code>ADDSLOTSRANGE</code> and <code>DELSLOTSRANGE</code>, are simply used to assign (or remove) slots to a Redis node. Assigning a slot means to tell a given master node that it will be in charge of storing and serving content for the specified hash slot.</p> <p>After the hash slots are assigned they will propagate across the cluster using the gossip protocol, as specified later in the configuration propagation section.</p> <p>The <code>ADDSLOTS</code> and <code>ADDSLOTSRANGE</code> commands are usually used when a new cluster is created from scratch to assign each master node a subset of all the 16384 hash slots available.</p> <p>The <code>DELSLOTS</code>  and <code>DELSLOTSRANGE</code> are mainly used for manual modification of a cluster configuration or for debugging tasks: in practice it is rarely used.</p> <p>The <code>SETSLOT</code> subcommand is used to assign a slot to a specific node ID if the <code>SETSLOT &lt;slot&gt; NODE</code> form is used. Otherwise the slot can be set in the two special states <code>MIGRATING</code> and <code>IMPORTING</code>. Those two special states are used in order to migrate a hash slot from one node to another.</p> <ul> <li>When a slot is set as MIGRATING, the node will accept all queries that are about this hash slot, but only if the key in question exists, otherwise the query is forwarded using a <code>-ASK</code> redirection to the node that is target of the migration.</li> <li>When a slot is set as IMPORTING, the node will accept all queries that are about this hash slot, but only if the request is preceded by an <code>ASKING</code> command. If the <code>ASKING</code> command was not given by the client, the query is redirected to the real hash slot owner via a <code>-MOVED</code> redirection error, as would happen normally.</li> </ul> <p>Let's make this clearer with an example of hash slot migration. Assume that we have two Redis master nodes, called A and B. We want to move hash slot 8 from A to B, so we issue commands like this:</p> <ul> <li>We send B: CLUSTER SETSLOT 8 IMPORTING A</li> <li>We send A: CLUSTER SETSLOT 8 MIGRATING B</li> </ul> <p>All the other nodes will continue to point clients to node \"A\" every time they are queried with a key that belongs to hash slot 8, so what happens is that:</p> <ul> <li>All queries about existing keys are processed by \"A\".</li> <li>All queries about non-existing keys in A are processed by \"B\", because \"A\" will redirect clients to \"B\".</li> </ul> <p>This way we no longer create new keys in \"A\". In the meantime, <code>redis-cli</code> used during reshardings and Redis Cluster configuration will migrate existing keys in hash slot 8 from A to B. This is performed using the following command:</p> <pre><code>CLUSTER GETKEYSINSLOT slot count\n</code></pre> <p>The above command will return <code>count</code> keys in the specified hash slot. For keys returned, <code>redis-cli</code> sends node \"A\" a <code>MIGRATE</code> command, that will migrate the specified keys from A to B in an atomic way (both instances are locked for the time (usually very small time) needed to migrate keys so there are no race conditions). This is how <code>MIGRATE</code> works:</p> <pre><code>MIGRATE target_host target_port \"\" target_database id timeout KEYS key1 key2 ...\n</code></pre> <p><code>MIGRATE</code> will connect to the target instance, send a serialized version of the key, and once an OK code is received, the old key from its own dataset will be deleted. From the point of view of an external client a key exists either in A or B at any given time.</p> <p>In Redis Cluster there is no need to specify a database other than 0, but <code>MIGRATE</code> is a general command that can be used for other tasks not involving Redis Cluster. <code>MIGRATE</code> is optimized to be as fast as possible even when moving complex keys such as long lists, but in Redis Cluster reconfiguring the cluster where big keys are present is not considered a wise procedure if there are latency constraints in the application using the database.</p> <p>When the migration process is finally finished, the <code>SETSLOT &lt;slot&gt; NODE &lt;node-id&gt;</code> command is sent to the two nodes involved in the migration in order to set the slots to their normal state again. The same command is usually sent to all other nodes to avoid waiting for the natural propagation of the new configuration across the cluster.</p>"},{"location":"8-reference/cluster-spec/#ask-redirection","title":"ASK redirection","text":"<p>In the previous section, we briefly talked about ASK redirection. Why can't we simply use MOVED redirection? Because while MOVED means that we think the hash slot is permanently served by a different node and the next queries should be tried against the specified node. ASK means to send only the next query to the specified node.</p> <p>This is needed because the next query about hash slot 8 can be about a key that is still in A, so we always want the client to try A and then B if needed. Since this happens only for one hash slot out of 16384 available, the performance hit on the cluster is acceptable.</p> <p>We need to force that client behavior, so to make sure that clients will only try node B after A was tried, node B will only accept queries of a slot that is set as IMPORTING if the client sends the ASKING command before sending the query.</p> <p>Basically the ASKING command sets a one-time flag on the client that forces a node to serve a query about an IMPORTING slot.</p> <p>The full semantics of ASK redirection from the point of view of the client is as follows:</p> <ul> <li>If ASK redirection is received, send only the query that was redirected to the specified node but continue sending subsequent queries to the old node.</li> <li>Start the redirected query with the ASKING command.</li> <li>Don't yet update local client tables to map hash slot 8 to B.</li> </ul> <p>Once hash slot 8 migration is completed, A will send a MOVED message and the client may permanently map hash slot 8 to the new endpoint and port pair. Note that if a buggy client performs the map earlier this is not a problem since it will not send the ASKING command before issuing the query, so B will redirect the client to A using a MOVED redirection error.</p> <p>Slots migration is explained in similar terms but with different wording (for the sake of redundancy in the documentation) in the <code>CLUSTER SETSLOT</code> command documentation.</p>"},{"location":"8-reference/cluster-spec/#client-connections-and-redirection-handling","title":"Client connections and redirection handling","text":"<p>To be efficient, Redis Cluster clients maintain a map of the current slot configuration. However, this configuration is not required to be up to date. When contacting the wrong node results in a redirection, the client can update its internal slot map accordingly.</p> <p>Clients usually need to fetch a complete list of slots and mapped node addresses in two different situations:</p> <ul> <li>At startup, to populate the initial slots configuration</li> <li>When the client receives a <code>MOVED</code> redirection</li> </ul> <p>Note that a client may handle the <code>MOVED</code> redirection by updating just the moved slot in its table; however this is usually not efficient because often the configuration of multiple slots will be modified at once. For example, if a replica is promoted to master, all of the slots served by the old master will be remapped). It is much simpler to react to a <code>MOVED</code> redirection by fetching the full map of slots to nodes from scratch.</p> <p>Client can issue a <code>CLUSTER SLOTS</code> command to retrieve an array of slot ranges and the associated master and replica nodes serving the specified ranges.</p> <p>The following is an example of output of <code>CLUSTER SLOTS</code>:</p> <pre><code>127.0.0.1:7000&gt; cluster slots\n1) 1) (integer) 5461\n   2) (integer) 10922\n   3) 1) \"127.0.0.1\"\n      2) (integer) 7001\n   4) 1) \"127.0.0.1\"\n      2) (integer) 7004\n2) 1) (integer) 0\n   2) (integer) 5460\n   3) 1) \"127.0.0.1\"\n      2) (integer) 7000\n   4) 1) \"127.0.0.1\"\n      2) (integer) 7003\n3) 1) (integer) 10923\n   2) (integer) 16383\n   3) 1) \"127.0.0.1\"\n      2) (integer) 7002\n   4) 1) \"127.0.0.1\"\n      2) (integer) 7005\n</code></pre> <p>The first two sub-elements of every element of the returned array are the start and end slots of the range. The additional elements represent address-port pairs. The first address-port pair is the master serving the slot, and the additional address-port pairs are the replicas serving the same slot. Replicas will be listed only when not in an error condition (i.e., when their FAIL flag is not set).</p> <p>The first element in the output above says that slots from 5461 to 10922 (start and end included) are served by 127.0.0.1:7001, and it is possible to scale read-only load contacting the replica at 127.0.0.1:7004.</p> <p><code>CLUSTER SLOTS</code> is not guaranteed to return ranges that cover the full 16384 slots if the cluster is misconfigured, so clients should initialize the slots configuration map filling the target nodes with NULL objects, and report an error if the user tries to execute commands about keys that belong to unassigned slots.</p> <p>Before returning an error to the caller when a slot is found to be unassigned, the client should try to fetch the slots configuration again to check if the cluster is now configured properly.</p>"},{"location":"8-reference/cluster-spec/#multi-keys-operations","title":"Multi-keys operations","text":"<p>Using hash tags, clients are free to use multi-key operations. For example the following operation is valid:</p> <pre><code>MSET {user:1000}.name Angela {user:1000}.surname White\n</code></pre> <p>Multi-key operations may become unavailable when a resharding of the hash slot the keys belong to is in progress.</p> <p>More specifically, even during a resharding the multi-key operations targeting keys that all exist and all still hash to the same slot (either the source or destination node) are still available.</p> <p>Operations on keys that don't exist or are - during the resharding - split between the source and destination nodes, will generate a <code>-TRYAGAIN</code> error. The client can try the operation after some time, or report back the error.</p> <p>As soon as migration of the specified hash slot has terminated, all multi-key operations are available again for that hash slot.</p>"},{"location":"8-reference/cluster-spec/#scaling-reads-using-replica-nodes","title":"Scaling reads using replica nodes","text":"<p>Normally replica nodes will redirect clients to the authoritative master for the hash slot involved in a given command, however clients can use replicas in order to scale reads using the <code>READONLY</code> command.</p> <p><code>READONLY</code> tells a Redis Cluster replica node that the client is ok reading possibly stale data and is not interested in running write queries.</p> <p>When the connection is in readonly mode, the cluster will send a redirection to the client only if the operation involves keys not served by the replica's master node. This may happen because:</p> <ol> <li>The client sent a command about hash slots never served by the master of this replica.</li> <li>The cluster was reconfigured (for example resharded) and the replica is no longer able to serve commands for a given hash slot.</li> </ol> <p>When this happens the client should update its hash slot map as explained in the previous sections.</p> <p>The readonly state of the connection can be cleared using the <code>READWRITE</code> command.</p>"},{"location":"8-reference/cluster-spec/#fault-tolerance","title":"Fault Tolerance","text":""},{"location":"8-reference/cluster-spec/#heartbeat-and-gossip-messages","title":"Heartbeat and gossip messages","text":"<p>Redis Cluster nodes continuously exchange ping and pong packets. Those two kinds of packets have the same structure, and both carry important configuration information. The only actual difference is the message type field. We'll refer to the sum of ping and pong packets as heartbeat packets.</p> <p>Usually nodes send ping packets that will trigger the receivers to reply with pong packets. However this is not necessarily true. It is possible for nodes to just send pong packets to send information to other nodes about their configuration, without triggering a reply. This is useful, for example, in order to broadcast a new configuration as soon as possible.</p> <p>Usually a node will ping a few random nodes every second so that the total number of ping packets sent (and pong packets received) by each node is a constant amount regardless of the number of nodes in the cluster.</p> <p>However every node makes sure to ping every other node that hasn't sent a ping or received a pong for longer than half the <code>NODE_TIMEOUT</code> time. Before <code>NODE_TIMEOUT</code> has elapsed, nodes also try to reconnect the TCP link with another node to make sure nodes are not believed to be unreachable only because there is a problem in the current TCP connection.</p> <p>The number of messages globally exchanged can be sizable if <code>NODE_TIMEOUT</code> is set to a small figure and the number of nodes (N) is very large, since every node will try to ping every other node for which they don't have fresh information every half the <code>NODE_TIMEOUT</code> time.</p> <p>For example in a 100 node cluster with a node timeout set to 60 seconds, every node will try to send 99 pings every 30 seconds, with a total amount of pings of 3.3 per second. Multiplied by 100 nodes, this is 330 pings per second in the total cluster.</p> <p>There are ways to lower the number of messages, however there have been no reported issues with the bandwidth currently used by Redis Cluster failure detection, so for now the obvious and direct design is used. Note that even in the above example, the 330 packets per second exchanged are evenly divided among 100 different nodes, so the traffic each node receives is acceptable.</p>"},{"location":"8-reference/cluster-spec/#heartbeat-packet-content","title":"Heartbeat packet content","text":"<p>Ping and pong packets contain a header that is common to all types of packets (for instance packets to request a failover vote), and a special gossip section that is specific to Ping and Pong packets.</p> <p>The common header has the following information:</p> <ul> <li>Node ID, a 160 bit pseudorandom string that is assigned the first time a node is created and remains the same for all the life of a Redis Cluster node.</li> <li>The <code>currentEpoch</code> and <code>configEpoch</code> fields of the sending node that are used to mount the distributed algorithms used by Redis Cluster (this is explained in detail in the next sections). If the node is a replica the <code>configEpoch</code> is the last known <code>configEpoch</code> of its master.</li> <li>The node flags, indicating if the node is a replica, a master, and other single-bit node information.</li> <li>A bitmap of the hash slots served by the sending node, or if the node is a replica, a bitmap of the slots served by its master.</li> <li>The sender TCP base port that is the port used by Redis to accept client commands.</li> <li>The cluster port that is the port used by Redis for node-to-node communication.</li> <li>The state of the cluster from the point of view of the sender (down or ok).</li> <li>The master node ID of the sending node, if it is a replica.</li> </ul> <p>Ping and pong packets also contain a gossip section. This section offers to the receiver a view of what the sender node thinks about other nodes in the cluster. The gossip section only contains information about a few random nodes among the set of nodes known to the sender. The number of nodes mentioned in a gossip section is proportional to the cluster size.</p> <p>For every node added in the gossip section the following fields are reported:</p> <ul> <li>Node ID.</li> <li>IP and port of the node.</li> <li>Node flags.</li> </ul> <p>Gossip sections allow receiving nodes to get information about the state of other nodes from the point of view of the sender. This is useful both for failure detection and to discover other nodes in the cluster.</p>"},{"location":"8-reference/cluster-spec/#failure-detection","title":"Failure detection","text":"<p>Redis Cluster failure detection is used to recognize when a master or replica node is no longer reachable by the majority of nodes and then respond by promoting a replica to the role of master. When replica promotion is not possible the cluster is put in an error state to stop receiving queries from clients.</p> <p>As already mentioned, every node takes a list of flags associated with other known nodes. There are two flags that are used for failure detection that are called <code>PFAIL</code> and <code>FAIL</code>. <code>PFAIL</code> means Possible failure, and is a non-acknowledged failure type. <code>FAIL</code> means that a node is failing and that this condition was confirmed by a majority of masters within a fixed amount of time.</p> <p>PFAIL flag:</p> <p>A node flags another node with the <code>PFAIL</code> flag when the node is not reachable for more than <code>NODE_TIMEOUT</code> time. Both master and replica nodes can flag another node as <code>PFAIL</code>, regardless of its type.</p> <p>The concept of non-reachability for a Redis Cluster node is that we have an active ping (a ping that we sent for which we have yet to get a reply) pending for longer than <code>NODE_TIMEOUT</code>. For this mechanism to work the <code>NODE_TIMEOUT</code> must be large compared to the network round trip time. In order to add reliability during normal operations, nodes will try to reconnect with other nodes in the cluster as soon as half of the <code>NODE_TIMEOUT</code> has elapsed without a reply to a ping. This mechanism ensures that connections are kept alive so broken connections usually won't result in false failure reports between nodes.</p> <p>FAIL flag:</p> <p>The <code>PFAIL</code> flag alone is just local information every node has about other nodes, but it is not sufficient to trigger a replica promotion. For a node to be considered down the <code>PFAIL</code> condition needs to be escalated to a <code>FAIL</code> condition.</p> <p>As outlined in the node heartbeats section of this document, every node sends gossip messages to every other node including the state of a few random known nodes. Every node eventually receives a set of node flags for every other node. This way every node has a mechanism to signal other nodes about failure conditions they have detected.</p> <p>A <code>PFAIL</code> condition is escalated to a <code>FAIL</code> condition when the following set of conditions are met:</p> <ul> <li>Some node, that we'll call A, has another node B flagged as <code>PFAIL</code>.</li> <li>Node A collected, via gossip sections, information about the state of B from the point of view of the majority of masters in the cluster.</li> <li>The majority of masters signaled the <code>PFAIL</code> or <code>FAIL</code> condition within <code>NODE_TIMEOUT * FAIL_REPORT_VALIDITY_MULT</code> time. (The validity factor is set to 2 in the current implementation, so this is just two times the <code>NODE_TIMEOUT</code> time).</li> </ul> <p>If all the above conditions are true, Node A will:</p> <ul> <li>Mark the node as <code>FAIL</code>.</li> <li>Send a <code>FAIL</code> message (as opposed to a <code>FAIL</code> condition within a heartbeat message) to all the reachable nodes.</li> </ul> <p>The <code>FAIL</code> message will force every receiving node to mark the node in <code>FAIL</code> state, whether or not it already flagged the node in <code>PFAIL</code> state.</p> <p>Note that the FAIL flag is mostly one way. That is, a node can go from <code>PFAIL</code> to <code>FAIL</code>, but a <code>FAIL</code> flag can only be cleared in the following situations:</p> <ul> <li>The node is already reachable and is a replica. In this case the <code>FAIL</code> flag can be cleared as replicas are not failed over.</li> <li>The node is already reachable and is a master not serving any slot. In this case the <code>FAIL</code> flag can be cleared as masters without slots do not really participate in the cluster and are waiting to be configured in order to join the cluster.</li> <li>The node is already reachable and is a master, but a long time (N times the <code>NODE_TIMEOUT</code>) has elapsed without any detectable replica promotion. It's better for it to rejoin the cluster and continue in this case.</li> </ul> <p>It is useful to note that while the <code>PFAIL</code> -&gt; <code>FAIL</code> transition uses a form of agreement, the agreement used is weak:</p> <ol> <li>Nodes collect views of other nodes over some time period, so even if the majority of master nodes need to \"agree\", actually this is just state that we collected from different nodes at different times and we are not sure, nor we require, that at a given moment the majority of masters agreed. However we discard failure reports which are old, so the failure was signaled by the majority of masters within a window of time.</li> <li>While every node detecting the <code>FAIL</code> condition will force that condition on other nodes in the cluster using the <code>FAIL</code> message, there is no way to ensure the message will reach all the nodes. For instance a node may detect the <code>FAIL</code> condition and because of a partition will not be able to reach any other node.</li> </ol> <p>However the Redis Cluster failure detection has a liveness requirement: eventually all the nodes should agree about the state of a given node. There are two cases that can originate from split brain conditions. Either some minority of nodes believe the node is in <code>FAIL</code> state, or a minority of nodes believe the node is not in <code>FAIL</code> state. In both the cases eventually the cluster will have a single view of the state of a given node:</p> <p>Case 1: If a majority of masters have flagged a node as <code>FAIL</code>, because of failure detection and the chain effect it generates, every other node will eventually flag the master as <code>FAIL</code>, since in the specified window of time enough failures will be reported.</p> <p>Case 2: When only a minority of masters have flagged a node as <code>FAIL</code>, the replica promotion will not happen (as it uses a more formal algorithm that makes sure everybody knows about the promotion eventually) and every node will clear the <code>FAIL</code> state as per the <code>FAIL</code> state clearing rules above (i.e. no promotion after N times the <code>NODE_TIMEOUT</code> has elapsed).</p> <p>The <code>FAIL</code> flag is only used as a trigger to run the safe part of the algorithm for the replica promotion. In theory a replica may act independently and start a replica promotion when its master is not reachable, and wait for the masters to refuse to provide the acknowledgment if the master is actually reachable by the majority. However the added complexity of the <code>PFAIL -&gt; FAIL</code> state, the weak agreement, and the <code>FAIL</code> message forcing the propagation of the state in the shortest amount of time in the reachable part of the cluster, have practical advantages. Because of these mechanisms, usually all the nodes will stop accepting writes at about the same time if the cluster is in an error state. This is a desirable feature from the point of view of applications using Redis Cluster. Also erroneous election attempts initiated by replicas that can't reach its master due to local problems (the master is otherwise reachable by the majority of other master nodes) are avoided.</p>"},{"location":"8-reference/cluster-spec/#configuration-handling-propagation-and-failovers","title":"Configuration handling, propagation, and failovers","text":""},{"location":"8-reference/cluster-spec/#cluster-current-epoch","title":"Cluster current epoch","text":"<p>Redis Cluster uses a concept similar to the Raft algorithm \"term\". In Redis Cluster the term is called epoch instead, and it is used in order to give incremental versioning to events. When multiple nodes provide conflicting information, it becomes possible for another node to understand which state is the most up to date.</p> <p>The <code>currentEpoch</code> is a 64 bit unsigned number.</p> <p>At node creation every Redis Cluster node, both replicas and master nodes, set the <code>currentEpoch</code> to 0.</p> <p>Every time a packet is received from another node, if the epoch of the sender (part of the cluster bus messages header) is greater than the local node epoch, the <code>currentEpoch</code> is updated to the sender epoch.</p> <p>Because of these semantics, eventually all the nodes will agree to the greatest <code>currentEpoch</code> in the cluster.</p> <p>This information is used when the state of the cluster is changed and a node seeks agreement in order to perform some action.</p> <p>Currently this happens only during replica promotion, as described in the next section. Basically the epoch is a logical clock for the cluster and dictates that given information wins over one with a smaller epoch.</p>"},{"location":"8-reference/cluster-spec/#configuration-epoch","title":"Configuration epoch","text":"<p>Every master always advertises its <code>configEpoch</code> in ping and pong packets along with a bitmap advertising the set of slots it serves.</p> <p>The <code>configEpoch</code> is set to zero in masters when a new node is created.</p> <p>A new <code>configEpoch</code> is created during replica election. replicas trying to replace failing masters increment their epoch and try to get authorization from a majority of masters. When a replica is authorized, a new unique <code>configEpoch</code> is created and the replica turns into a master using the new <code>configEpoch</code>.</p> <p>As explained in the next sections the <code>configEpoch</code> helps to resolve conflicts when different nodes claim divergent configurations (a condition that may happen because of network partitions and node failures).</p> <p>replica nodes also advertise the <code>configEpoch</code> field in ping and pong packets, but in the case of replicas the field represents the <code>configEpoch</code> of its master as of the last time they exchanged packets. This allows other instances to detect when a replica has an old configuration that needs to be updated (master nodes will not grant votes to replicas with an old configuration).</p> <p>Every time the <code>configEpoch</code> changes for some known node, it is permanently stored in the nodes.conf file by all the nodes that receive this information. The same also happens for the <code>currentEpoch</code> value. These two variables are guaranteed to be saved and <code>fsync-ed</code> to disk when updated before a node continues its operations.</p> <p>The <code>configEpoch</code> values generated using a simple algorithm during failovers are guaranteed to be new, incremental, and unique.</p>"},{"location":"8-reference/cluster-spec/#replica-election-and-promotion","title":"Replica election and promotion","text":"<p>Replica election and promotion is handled by replica nodes, with the help of master nodes that vote for the replica to promote. A replica election happens when a master is in <code>FAIL</code> state from the point of view of at least one of its replicas that has the prerequisites in order to become a master.</p> <p>In order for a replica to promote itself to master, it needs to start an election and win it. All the replicas for a given master can start an election if the master is in <code>FAIL</code> state, however only one replica will win the election and promote itself to master.</p> <p>A replica starts an election when the following conditions are met:</p> <ul> <li>The replica's master is in <code>FAIL</code> state.</li> <li>The master was serving a non-zero number of slots.</li> <li>The replica replication link was disconnected from the master for no longer than a given amount of time, in order to ensure the promoted replica's data is reasonably fresh. This time is user configurable.</li> </ul> <p>In order to be elected, the first step for a replica is to increment its <code>currentEpoch</code> counter, and request votes from master instances.</p> <p>Votes are requested by the replica by broadcasting a <code>FAILOVER_AUTH_REQUEST</code> packet to every master node of the cluster. Then it waits for a maximum time of two times the <code>NODE_TIMEOUT</code> for replies to arrive (but always for at least 2 seconds).</p> <p>Once a master has voted for a given replica, replying positively with a <code>FAILOVER_AUTH_ACK</code>, it can no longer vote for another replica of the same master for a period of <code>NODE_TIMEOUT * 2</code>. In this period it will not be able to reply to other authorization requests for the same master. This is not needed to guarantee safety, but useful for preventing multiple replicas from getting elected (even if with a different <code>configEpoch</code>) at around the same time, which is usually not wanted.</p> <p>A replica discards any <code>AUTH_ACK</code> replies with an epoch that is less than the <code>currentEpoch</code> at the time the vote request was sent. This ensures it doesn't count votes intended for a previous election.</p> <p>Once the replica receives ACKs from the majority of masters, it wins the election. Otherwise if the majority is not reached within the period of two times <code>NODE_TIMEOUT</code> (but always at least 2 seconds), the election is aborted and a new one will be tried again after <code>NODE_TIMEOUT * 4</code> (and always at least 4 seconds).</p>"},{"location":"8-reference/cluster-spec/#replica-rank","title":"Replica rank","text":"<p>As soon as a master is in <code>FAIL</code> state, a replica waits a short period of time before trying to get elected. That delay is computed as follows:</p> <pre><code>DELAY = 500 milliseconds + random delay between 0 and 500 milliseconds +\n        REPLICA_RANK * 1000 milliseconds.\n</code></pre> <p>The fixed delay ensures that we wait for the <code>FAIL</code> state to propagate across the cluster, otherwise the replica may try to get elected while the masters are still unaware of the <code>FAIL</code> state, refusing to grant their vote.</p> <p>The random delay is used to desynchronize replicas so they're unlikely to start an election at the same time.</p> <p>The <code>REPLICA_RANK</code> is the rank of this replica regarding the amount of replication data it has processed from the master. Replicas exchange messages when the master is failing in order to establish a (best effort) rank: the replica with the most updated replication offset is at rank 0, the second most updated at rank 1, and so forth. In this way the most updated replicas try to get elected before others.</p> <p>Rank order is not strictly enforced; if a replica of higher rank fails to be elected, the others will try shortly.</p> <p>Once a replica wins the election, it obtains a new unique and incremental <code>configEpoch</code> which is higher than that of any other existing master. It starts advertising itself as master in ping and pong packets, providing the set of served slots with a <code>configEpoch</code> that will win over the past ones.</p> <p>In order to speedup the reconfiguration of other nodes, a pong packet is broadcast to all the nodes of the cluster. Currently unreachable nodes will eventually be reconfigured when they receive a ping or pong packet from another node or will receive an <code>UPDATE</code> packet from another node if the information it publishes via heartbeat packets are detected to be out of date.</p> <p>The other nodes will detect that there is a new master serving the same slots served by the old master but with a greater <code>configEpoch</code>, and will upgrade their configuration. Replicas of the old master (or the failed over master if it rejoins the cluster) will not just upgrade the configuration but will also reconfigure to replicate from the new master. How nodes rejoining the cluster are configured is explained in the next sections.</p>"},{"location":"8-reference/cluster-spec/#masters-reply-to-replica-vote-request","title":"Masters reply to replica vote request","text":"<p>In the previous section, we discussed how replicas try to get elected. This section explains what happens from the point of view of a master that is requested to vote for a given replica.</p> <p>Masters receive requests for votes in form of <code>FAILOVER_AUTH_REQUEST</code> requests from replicas.</p> <p>For a vote to be granted the following conditions need to be met:</p> <ol> <li>A master only votes a single time for a given epoch, and refuses to vote for older epochs: every master has a lastVoteEpoch field and will refuse to vote again as long as the <code>currentEpoch</code> in the auth request packet is not greater than the lastVoteEpoch. When a master replies positively to a vote request, the lastVoteEpoch is updated accordingly, and safely stored on disk.</li> <li>A master votes for a replica only if the replica's master is flagged as <code>FAIL</code>.</li> <li>Auth requests with a <code>currentEpoch</code> that is less than the master <code>currentEpoch</code> are ignored. Because of this the master reply will always have the same <code>currentEpoch</code> as the auth request. If the same replica asks again to be voted, incrementing the <code>currentEpoch</code>, it is guaranteed that an old delayed reply from the master can not be accepted for the new vote.</li> </ol> <p>Example of the issue caused by not using rule number 3:</p> <p>Master <code>currentEpoch</code> is 5, lastVoteEpoch is 1 (this may happen after a few failed elections)</p> <ul> <li>Replica <code>currentEpoch</code> is 3.</li> <li>Replica tries to be elected with epoch 4 (3+1), master replies with an ok with <code>currentEpoch</code> 5, however the reply is delayed.</li> <li> <p>Replica will try to be elected again, at a later time, with epoch 5 (4+1), the delayed reply reaches the replica with <code>currentEpoch</code> 5, and is accepted as valid.</p> </li> <li> <p>Masters don't vote for a replica of the same master before <code>NODE_TIMEOUT * 2</code> has elapsed if a replica of that master was already voted for. This is not strictly required as it is not possible for two replicas to win the election in the same epoch. However, in practical terms it ensures that when a replica is elected it has plenty of time to inform the other replicas and avoid the possibility that another replica will win a new election, performing an unnecessary second failover.</p> </li> <li>Masters make no effort to select the best replica in any way. If the replica's master is in <code>FAIL</code> state and the master did not vote in the current term, a positive vote is granted. The best replica is the most likely to start an election and win it before the other replicas, since it will usually be able to start the voting process earlier because of its higher rank as explained in the previous section.</li> <li>When a master refuses to vote for a given replica there is no negative response, the request is simply ignored.</li> <li>Masters don't vote for replicas sending a <code>configEpoch</code> that is less than any <code>configEpoch</code> in the master table for the slots claimed by the replica. Remember that the replica sends the <code>configEpoch</code> of its master, and the bitmap of the slots served by its master. This means that the replica requesting the vote must have a configuration for the slots it wants to failover that is newer or equal the one of the master granting the vote.</li> </ul>"},{"location":"8-reference/cluster-spec/#practical-example-of-configuration-epoch-usefulness-during-partitions","title":"Practical example of configuration epoch usefulness during partitions","text":"<p>This section illustrates how the epoch concept is used to make the replica promotion process more resistant to partitions.</p> <ul> <li>A master is no longer reachable indefinitely. The master has three replicas A, B, C.</li> <li>Replica A wins the election and is promoted to master.</li> <li>A network partition makes A not available for the majority of the cluster.</li> <li>Replica B wins the election and is promoted as master.</li> <li>A partition makes B not available for the majority of the cluster.</li> <li>The previous partition is fixed, and A is available again.</li> </ul> <p>At this point B is down and A is available again with a role of master (actually <code>UPDATE</code> messages would reconfigure it promptly, but here we assume all <code>UPDATE</code> messages were lost). At the same time, replica C will try to get elected in order to fail over B. This is what happens:</p> <ol> <li>C will try to get elected and will succeed, since for the majority of masters its master is actually down. It will obtain a new incremental <code>configEpoch</code>.</li> <li>A will not be able to claim to be the master for its hash slots, because the other nodes already have the same hash slots associated with a higher configuration epoch (the one of B) compared to the one published by A.</li> <li>So, all the nodes will upgrade their table to assign the hash slots to C, and the cluster will continue its operations.</li> </ol> <p>As you'll see in the next sections, a stale node rejoining a cluster will usually get notified as soon as possible about the configuration change because as soon as it pings any other node, the receiver will detect it has stale information and will send an <code>UPDATE</code> message.</p>"},{"location":"8-reference/cluster-spec/#hash-slots-configuration-propagation","title":"Hash slots configuration propagation","text":"<p>An important part of Redis Cluster is the mechanism used to propagate the information about which cluster node is serving a given set of hash slots. This is vital to both the startup of a fresh cluster and the ability to upgrade the configuration after a replica was promoted to serve the slots of its failing master.</p> <p>The same mechanism allows nodes partitioned away for an indefinite amount of time to rejoin the cluster in a sensible way.</p> <p>There are two ways hash slot configurations are propagated:</p> <ol> <li>Heartbeat messages. The sender of a ping or pong packet always adds information about the set of hash slots it (or its master, if it is a replica) serves.</li> <li><code>UPDATE</code> messages. Since in every heartbeat packet there is information about the sender <code>configEpoch</code> and set of hash slots served, if a receiver of a heartbeat packet finds the sender information is stale, it will send a packet with new information, forcing the stale node to update its info.</li> </ol> <p>The receiver of a heartbeat or <code>UPDATE</code> message uses certain simple rules in order to update its table mapping hash slots to nodes. When a new Redis Cluster node is created, its local hash slot table is simply initialized to <code>NULL</code> entries so that each hash slot is not bound or linked to any node. This looks similar to the following:</p> <pre><code>0 -&gt; NULL\n1 -&gt; NULL\n2 -&gt; NULL\n...\n16383 -&gt; NULL\n</code></pre> <p>The first rule followed by a node in order to update its hash slot table is the following:</p> <p>Rule 1: If a hash slot is unassigned (set to <code>NULL</code>), and a known node claims it, I'll modify my hash slot table and associate the claimed hash slots to it.</p> <p>So if we receive a heartbeat from node A claiming to serve hash slots 1 and 2 with a configuration epoch value of 3, the table will be modified to:</p> <pre><code>0 -&gt; NULL\n1 -&gt; A [3]\n2 -&gt; A [3]\n...\n16383 -&gt; NULL\n</code></pre> <p>When a new cluster is created, a system administrator needs to manually assign (using the <code>CLUSTER ADDSLOTS</code> command, via the redis-cli command line tool, or by any other means) the slots served by each master node only to the node itself, and the information will rapidly propagate across the cluster.</p> <p>However this rule is not enough. We know that hash slot mapping can change during two events:</p> <ol> <li>A replica replaces its master during a failover.</li> <li>A slot is resharded from a node to a different one.</li> </ol> <p>For now let's focus on failovers. When a replica fails over its master, it obtains a configuration epoch which is guaranteed to be greater than the one of its master (and more generally greater than any other configuration epoch generated previously). For example node B, which is a replica of A, may failover A with configuration epoch of 4. It will start to send heartbeat packets (the first time mass-broadcasting cluster-wide) and because of the following second rule, receivers will update their hash slot tables:</p> <p>Rule 2: If a hash slot is already assigned, and a known node is advertising it using a <code>configEpoch</code> that is greater than the <code>configEpoch</code> of the master currently associated with the slot, I'll rebind the hash slot to the new node.</p> <p>So after receiving messages from B that claim to serve hash slots 1 and 2 with configuration epoch of 4, the receivers will update their table in the following way:</p> <pre><code>0 -&gt; NULL\n1 -&gt; B [4]\n2 -&gt; B [4]\n...\n16383 -&gt; NULL\n</code></pre> <p>Liveness property: because of the second rule, eventually all nodes in the cluster will agree that the owner of a slot is the one with the greatest <code>configEpoch</code> among the nodes advertising it.</p> <p>This mechanism in Redis Cluster is called last failover wins.</p> <p>The same happens during resharding. When a node importing a hash slot completes the import operation, its configuration epoch is incremented to make sure the change will be propagated throughout the cluster.</p>"},{"location":"8-reference/cluster-spec/#update-messages-a-closer-look","title":"UPDATE messages, a closer look","text":"<p>With the previous section in mind, it is easier to see how update messages work. Node A may rejoin the cluster after some time. It will send heartbeat packets where it claims it serves hash slots 1 and 2 with configuration epoch of 3. All the receivers with updated information will instead see that the same hash slots are associated with node B having a higher configuration epoch. Because of this they'll send an <code>UPDATE</code> message to A with the new configuration for the slots. A will update its configuration because of the rule 2 above.</p>"},{"location":"8-reference/cluster-spec/#how-nodes-rejoin-the-cluster","title":"How nodes rejoin the cluster","text":"<p>The same basic mechanism is used when a node rejoins a cluster. Continuing with the example above, node A will be notified that hash slots 1 and 2 are now served by B. Assuming that these two were the only hash slots served by A, the count of hash slots served by A will drop to 0! So A will reconfigure to be a replica of the new master.</p> <p>The actual rule followed is a bit more complex than this. In general it may happen that A rejoins after a lot of time, in the meantime it may happen that hash slots originally served by A are served by multiple nodes, for example hash slot 1 may be served by B, and hash slot 2 by C.</p> <p>So the actual Redis Cluster node role switch rule is: A master node will change its configuration to replicate (be a replica of) the node that stole its last hash slot.</p> <p>During reconfiguration, eventually the number of served hash slots will drop to zero, and the node will reconfigure accordingly. Note that in the base case this just means that the old master will be a replica of the replica that replaced it after a failover. However in the general form the rule covers all possible cases.</p> <p>Replicas do exactly the same: they reconfigure to replicate the node that stole the last hash slot of its former master.</p>"},{"location":"8-reference/cluster-spec/#replica-migration","title":"Replica migration","text":"<p>Redis Cluster implements a concept called replica migration in order to improve the availability of the system. The idea is that in a cluster with a master-replica setup, if the map between replicas and masters is fixed availability is limited over time if multiple independent failures of single nodes happen.</p> <p>For example in a cluster where every master has a single replica, the cluster can continue operations as long as either the master or the replica fail, but not if both fail the same time. However there is a class of failures that are the independent failures of single nodes caused by hardware or software issues that can accumulate over time. For example:</p> <ul> <li>Master A has a single replica A1.</li> <li>Master A fails. A1 is promoted as new master.</li> <li>Three hours later A1 fails in an independent manner (unrelated to the failure of A). No other replica is available for promotion since node A is still down. The cluster cannot continue normal operations.</li> </ul> <p>If the map between masters and replicas is fixed, the only way to make the cluster more resistant to the above scenario is to add replicas to every master, however this is costly as it requires more instances of Redis to be executed, more memory, and so forth.</p> <p>An alternative is to create an asymmetry in the cluster, and let the cluster layout automatically change over time. For example the cluster may have three masters A, B, C. A and B have a single replica each, A1 and B1. However the master C is different and has two replicas: C1 and C2.</p> <p>Replica migration is the process of automatic reconfiguration of a replica in order to migrate to a master that has no longer coverage (no working replicas). With replica migration the scenario mentioned above turns into the following:</p> <ul> <li>Master A fails. A1 is promoted.</li> <li>C2 migrates as replica of A1, that is otherwise not backed by any replica.</li> <li>Three hours later A1 fails as well.</li> <li>C2 is promoted as new master to replace A1.</li> <li>The cluster can continue the operations.</li> </ul>"},{"location":"8-reference/cluster-spec/#replica-migration-algorithm","title":"Replica migration algorithm","text":"<p>The migration algorithm does not use any form of agreement since the replica layout in a Redis Cluster is not part of the cluster configuration that needs to be consistent and/or versioned with config epochs. Instead it uses an algorithm to avoid mass-migration of replicas when a master is not backed. The algorithm guarantees that eventually (once the cluster configuration is stable) every master will be backed by at least one replica.</p> <p>This is how the algorithm works. To start we need to define what is a good replica in this context: a good replica is a replica not in <code>FAIL</code> state from the point of view of a given node.</p> <p>The execution of the algorithm is triggered in every replica that detects that there is at least a single master without good replicas. However among all the replicas detecting this condition, only a subset should act. This subset is actually often a single replica unless different replicas have in a given moment a slightly different view of the failure state of other nodes.</p> <p>The acting replica is the replica among the masters with the maximum number of attached replicas, that is not in FAIL state and has the smallest node ID.</p> <p>So for example if there are 10 masters with 1 replica each, and 2 masters with 5 replicas each, the replica that will try to migrate is - among the 2 masters having 5 replicas - the one with the lowest node ID. Given that no agreement is used, it is possible that when the cluster configuration is not stable, a race condition occurs where multiple replicas believe themselves to be the non-failing replica with the lower node ID (it is unlikely for this to happen in practice). If this happens, the result is multiple replicas migrating to the same master, which is harmless. If the race happens in a way that will leave the ceding master without replicas, as soon as the cluster is stable again the algorithm will be re-executed again and will migrate a replica back to the original master.</p> <p>Eventually every master will be backed by at least one replica. However, the normal behavior is that a single replica migrates from a master with multiple replicas to an orphaned master.</p> <p>The algorithm is controlled by a user-configurable parameter called <code>cluster-migration-barrier</code>: the number of good replicas a master must be left with before a replica can migrate away. For example, if this parameter is set to 2, a replica can try to migrate only if its master remains with two working replicas.</p>"},{"location":"8-reference/cluster-spec/#configepoch-conflicts-resolution-algorithm","title":"configEpoch conflicts resolution algorithm","text":"<p>When new <code>configEpoch</code> values are created via replica promotion during failovers, they are guaranteed to be unique.</p> <p>However there are two distinct events where new configEpoch values are created in an unsafe way, just incrementing the local <code>currentEpoch</code> of the local node and hoping there are no conflicts at the same time. Both the events are system-administrator triggered:</p> <ol> <li><code>CLUSTER FAILOVER</code> command with <code>TAKEOVER</code> option is able to manually promote a replica node into a master without the majority of masters being available. This is useful, for example, in multi data center setups.</li> <li>Migration of slots for cluster rebalancing also generates new configuration epochs inside the local node without agreement for performance reasons.</li> </ol> <p>Specifically, during manual resharding, when a hash slot is migrated from a node A to a node B, the resharding program will force B to upgrade its configuration to an epoch which is the greatest found in the cluster, plus 1 (unless the node is already the one with the greatest configuration epoch), without requiring agreement from other nodes. Usually a real world resharding involves moving several hundred hash slots (especially in small clusters). Requiring an agreement to generate new configuration epochs during resharding, for each hash slot moved, is inefficient. Moreover it requires a fsync in each of the cluster nodes every time in order to store the new configuration. Because of the way it is performed instead, we only need a new config epoch when the first hash slot is moved, making it much more efficient in production environments.</p> <p>However because of the two cases above, it is possible (though unlikely) to end with multiple nodes having the same configuration epoch. A resharding operation performed by the system administrator, and a failover happening at the same time (plus a lot of bad luck) could cause <code>currentEpoch</code> collisions if they are not propagated fast enough.</p> <p>Moreover, software bugs and filesystem corruptions can also contribute to multiple nodes having the same configuration epoch.</p> <p>When masters serving different hash slots have the same <code>configEpoch</code>, there are no issues. It is more important that replicas failing over a master have unique configuration epochs.</p> <p>That said, manual interventions or resharding may change the cluster configuration in different ways. The Redis Cluster main liveness property requires that slot configurations always converge, so under every circumstance we really want all the master nodes to have a different <code>configEpoch</code>.</p> <p>In order to enforce this, a conflict resolution algorithm is used in the event that two nodes end up with the same <code>configEpoch</code>.</p> <ul> <li>IF a master node detects another master node is advertising itself with the same <code>configEpoch</code>.</li> <li>AND IF the node has a lexicographically smaller Node ID compared to the other node claiming the same <code>configEpoch</code>.</li> <li>THEN it increments its <code>currentEpoch</code> by 1, and uses it as the new <code>configEpoch</code>.</li> </ul> <p>If there are any set of nodes with the same <code>configEpoch</code>, all the nodes but the one with the greatest Node ID will move forward, guaranteeing that, eventually, every node will pick a unique configEpoch regardless of what happened.</p> <p>This mechanism also guarantees that after a fresh cluster is created, all nodes start with a different <code>configEpoch</code> (even if this is not actually used) since <code>redis-cli</code> makes sure to use <code>CLUSTER SET-CONFIG-EPOCH</code> at startup. However if for some reason a node is left misconfigured, it will update its configuration to a different configuration epoch automatically.</p>"},{"location":"8-reference/cluster-spec/#node-resets","title":"Node resets","text":"<p>Nodes can be software reset (without restarting them) in order to be reused in a different role or in a different cluster. This is useful in normal operations, in testing, and in cloud environments where a given node can be reprovisioned to join a different set of nodes to enlarge or create a new cluster.</p> <p>In Redis Cluster nodes are reset using the <code>CLUSTER RESET</code> command. The command is provided in two variants:</p> <ul> <li><code>CLUSTER RESET SOFT</code></li> <li><code>CLUSTER RESET HARD</code></li> </ul> <p>The command must be sent directly to the node to reset. If no reset type is provided, a soft reset is performed.</p> <p>The following is a list of operations performed by a reset:</p> <ol> <li>Soft and hard reset: If the node is a replica, it is turned into a master, and its dataset is discarded. If the node is a master and contains keys the reset operation is aborted.</li> <li>Soft and hard reset: All the slots are released, and the manual failover state is reset.</li> <li>Soft and hard reset: All the other nodes in the nodes table are removed, so the node no longer knows any other node.</li> <li>Hard reset only: <code>currentEpoch</code>, <code>configEpoch</code>, and <code>lastVoteEpoch</code> are set to 0.</li> <li>Hard reset only: the Node ID is changed to a new random ID.</li> </ol> <p>Master nodes with non-empty data sets can't be reset (since normally you want to reshard data to the other nodes). However, under special conditions when this is appropriate (e.g. when a cluster is totally destroyed with the intent of creating a new one), <code>FLUSHALL</code> must be executed before proceeding with the reset.</p>"},{"location":"8-reference/cluster-spec/#removing-nodes-from-a-cluster","title":"Removing nodes from a cluster","text":"<p>It is possible to practically remove a node from an existing cluster by resharding all its data to other nodes (if it is a master node) and shutting it down. However, the other nodes will still remember its node ID and address, and will attempt to connect with it.</p> <p>For this reason, when a node is removed we want to also remove its entry from all the other nodes tables. This is accomplished by using the <code>CLUSTER FORGET &lt;node-id&gt;</code> command.</p> <p>The command does two things:</p> <ol> <li>It removes the node with the specified node ID from the nodes table.</li> <li>It sets a 60 second ban which prevents a node with the same node ID from being re-added.</li> </ol> <p>The second operation is needed because Redis Cluster uses gossip in order to auto-discover nodes, so removing the node X from node A, could result in node B gossiping about node X to A again. Because of the 60 second ban, the Redis Cluster administration tools have 60 seconds in order to remove the node from all the nodes, preventing the re-addition of the node due to auto discovery.</p> <p>Further information is available in the <code>CLUSTER FORGET</code> documentation.</p>"},{"location":"8-reference/cluster-spec/#publishsubscribe","title":"Publish/Subscribe","text":"<p>In a Redis Cluster, clients can subscribe to every node, and can also publish to every other node. The cluster will make sure that published messages are forwarded as needed.</p> <p>The clients can send SUBSCRIBE to any node and can also send PUBLISH to any node.  It will simply broadcast each published message to all other nodes.</p> <p>Redis 7.0 and later features sharded pub/sub, in which shard channels are assigned to slots by the same algorithm used to assign keys to slots.  A shard message must be sent to a node that owns the slot the shard channel is hashed to.  The cluster makes sure the published shard messages are forwarded to all nodes in the shard, so clients can subscribe to a shard channel by connecting to either the master responsible for the slot, or to any of its replicas.</p>"},{"location":"8-reference/cluster-spec/#appendix","title":"Appendix","text":""},{"location":"8-reference/cluster-spec/#appendix-a-crc16-reference-implementation-in-ansi-c","title":"Appendix A: CRC16 reference implementation in ANSI C","text":"<pre><code>/*\n * Copyright 2001-2010 Georges Menie (www.menie.org)\n * Copyright 2010 Salvatore Sanfilippo (adapted to Redis coding style)\n * All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the University of California, Berkeley nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* CRC16 implementation according to CCITT standards.\n *\n * Note by @antirez: this is actually the XMODEM CRC 16 algorithm, using the\n * following parameters:\n *\n * Name                       : \"XMODEM\", also known as \"ZMODEM\", \"CRC-16/ACORN\"\n * Width                      : 16 bit\n * Poly                       : 1021 (That is actually x^16 + x^12 + x^5 + 1)\n * Initialization             : 0000\n * Reflect Input byte         : False\n * Reflect Output CRC         : False\n * Xor constant to output CRC : 0000\n * Output for \"123456789\"     : 31C3\n */\n\nstatic const uint16_t crc16tab[256]= {\n    0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,\n    0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,\n    0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,\n    0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,\n    0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,\n    0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,\n    0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,\n    0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,\n    0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,\n    0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,\n    0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,\n    0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,\n    0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,\n    0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,\n    0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,\n    0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,\n    0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,\n    0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,\n    0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,\n    0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,\n    0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,\n    0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,\n    0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,\n    0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,\n    0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,\n    0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,\n    0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,\n    0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,\n    0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,\n    0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,\n    0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,\n    0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0\n};\n\nuint16_t crc16(const char *buf, int len) {\n    int counter;\n    uint16_t crc = 0;\n    for (counter = 0; counter &lt; len; counter++)\n            crc = (crc&lt;&lt;8) ^ crc16tab[((crc&gt;&gt;8) ^ *buf++)&amp;0x00FF];\n    return crc;\n}\n</code></pre>"},{"location":"8-reference/command-arguments/","title":"Redis command arguments","text":"<p>The <code>COMMAND DOCS</code> command returns documentation-focused information about available Redis commands. The map reply that the command returns includes the arguments key. This key stores an array that describes the command's arguments.</p> <p>Every element in the arguments array is a map with the following fields:</p> <ul> <li>name: the argument's name, always present.   The name of an argument is given for identification purposes alone.   It isn't displayed during the command's syntax rendering.   The same name can appear more than once in the entire argument tree, but it is unique compared to other sibling arguments' names.   This allows obtaining a unique identifier for each argument (the concatenation of all names in the path from the root to any argument).</li> <li>display_text: the argument's display string, present in arguments that have a displayable representation (all arguments that aren't oneof/block).   This is the string used in the command's syntax rendering.</li> <li>type: the argument's type, always present.   An argument must have one of the following types:</li> <li>string: a string argument.</li> <li>integer: an integer argument.</li> <li>double: a double-precision argument.</li> <li>key: a string that represents the name of a key.</li> <li>pattern: a string that represents a glob-like pattern.</li> <li>unix-time: an integer that represents a Unix timestamp.</li> <li>pure-token: an argument is a token, meaning a reserved keyword, which may or may not be provided.      Not to be confused with free-text user input.</li> <li>oneof: the argument is a container for nested arguments.     This type enables choice among several nested arguments (see the <code>XADD</code> example below).</li> <li>block: the argument is a container for nested arguments.     This type enables grouping arguments and applying a property (such as optional) to all (see the <code>XADD</code> example below).</li> <li>key_spec_index: this value is available for every argument of the key type.   It is a 0-based index of the specification in the command's key specifications that corresponds to the argument.</li> <li>token: a constant literal that precedes the argument (user input) itself.</li> <li>summary: a short description of the argument.</li> <li>since: the debut Redis version of the argument (or for module commands, the module version).</li> <li>deprecated_since: the Redis version that deprecated the command (or for module commands, the module version).</li> <li>flags: an array of argument flags.   Possible flags are:</li> <li>optional: denotes that the argument is optional (for example, the GET clause of the  <code>SET</code> command).</li> <li>multiple: denotes that the argument may be repeated (such as the key argument of <code>DEL</code>).</li> <li>multiple-token: denotes the possible repetition of the argument with its preceding token (see <code>SORT</code>'s <code>GET pattern</code> clause).</li> <li>value: the argument's value.   For arguments types other than oneof and block, this is a string that describes the value in the command's syntax.   For the oneof and block types, this is an array of nested arguments, each being a map as described in this section.</li> </ul>"},{"location":"8-reference/command-arguments/#example","title":"Example","text":"<p>The trimming clause of <code>XADD</code>, i.e., <code>[MAXLEN|MINID [=|~] threshold [LIMIT count]]</code>, is represented at the top-level as block-typed argument.</p> <p>It consists of four nested arguments:</p> <ol> <li>trimming strategy: this nested argument has an oneof type with two nested arguments.   Each of the nested arguments, MAXLEN and MINID, is typed as pure-token.</li> <li>trimming operator: this nested argument is an optional oneof type with two nested arguments.   Each of the nested arguments, = and ~, is a pure-token.</li> <li>threshold: this nested argument is a string.</li> <li>count: this nested argument is an optional integer with a token (LIMIT).</li> </ol> <p>Here's <code>XADD</code>'s arguments array:</p> <pre><code>1) 1) \"name\"\n   2) \"key\"\n   3) \"type\"\n   4) \"key\"\n   5) \"value\"\n   6) \"key\"\n2)  1) \"name\"\n    2) \"nomkstream\"\n    3) \"type\"\n    4) \"pure-token\"\n    5) \"token\"\n    6) \"NOMKSTREAM\"\n    7) \"since\"\n    8) \"6.2\"\n    9) \"flags\"\n   10) 1) optional\n3) 1) \"name\"\n   2) \"trim\"\n   3) \"type\"\n   4) \"block\"\n   5) \"flags\"\n   6) 1) optional\n   7) \"value\"\n   8) 1) 1) \"name\"\n         2) \"strategy\"\n         3) \"type\"\n         4) \"oneof\"\n         5) \"value\"\n         6) 1) 1) \"name\"\n               2) \"maxlen\"\n               3) \"type\"\n               4) \"pure-token\"\n               5) \"token\"\n               6) \"MAXLEN\"\n            2) 1) \"name\"\n               2) \"minid\"\n               3) \"type\"\n               4) \"pure-token\"\n               5) \"token\"\n               6) \"MINID\"\n               7) \"since\"\n               8) \"6.2\"\n      2) 1) \"name\"\n         2) \"operator\"\n         3) \"type\"\n         4) \"oneof\"\n         5) \"flags\"\n         6) 1) optional\n         7) \"value\"\n         8) 1) 1) \"name\"\n               2) \"equal\"\n               3) \"type\"\n               4) \"pure-token\"\n               5) \"token\"\n               6) \"=\"\n            2) 1) \"name\"\n               2) \"approximately\"\n               3) \"type\"\n               4) \"pure-token\"\n               5) \"token\"\n               6) \"~\"\n      3) 1) \"name\"\n         2) \"threshold\"\n         3) \"type\"\n         4) \"string\"\n         5) \"value\"\n         6) \"threshold\"\n      4)  1) \"name\"\n          2) \"count\"\n          3) \"type\"\n          4) \"integer\"\n          5) \"token\"\n          6) \"LIMIT\"\n          7) \"since\"\n          8) \"6.2\"\n          9) \"flags\"\n         10) 1) optional\n         11) \"value\"\n         12) \"count\"\n4) 1) \"name\"\n   2) \"id_or_auto\"\n   3) \"type\"\n   4) \"oneof\"\n   5) \"value\"\n   6) 1) 1) \"name\"\n         2) \"auto_id\"\n         3) \"type\"\n         4) \"pure-token\"\n         5) \"token\"\n         6) \"*\"\n      2) 1) \"name\"\n         2) \"id\"\n         3) \"type\"\n         4) \"string\"\n         5) \"value\"\n         6) \"id\"\n5) 1) \"name\"\n   2) \"field_value\"\n   3) \"type\"\n   4) \"block\"\n   5) \"flags\"\n   6) 1) multiple\n   7) \"value\"\n   8) 1) 1) \"name\"\n         2) \"field\"\n         3) \"type\"\n         4) \"string\"\n         5) \"value\"\n         6) \"field\"\n      2) 1) \"name\"\n         2) \"value\"\n         3) \"type\"\n         4) \"string\"\n         5) \"value\"\n         6) \"value\"\n</code></pre>"},{"location":"8-reference/command-tips/","title":"Redis command tips","text":"<p>Command tips are an array of strings. These provide Redis clients with additional information about the command. The information can instruct Redis Cluster clients as to how the command should be executed and its output processed in a clustered deployment.</p> <p>Unlike the command's flags (see the 3rd element of <code>COMMAND</code>'s reply), which are strictly internal to the server's operation, tips don't serve any purpose other than being reported to clients.</p> <p>Command tips are arbitrary strings. However, the following sections describe proposed tips and demonstrate the conventions they are likely to adhere to.</p>"},{"location":"8-reference/command-tips/#nondeterministic_output","title":"nondeterministic_output","text":"<p>This tip indicates that the command's output isn't deterministic. That means that calls to the command may yield different results with the same arguments and data. That difference could be the result of the command's random nature (e.g., <code>RANDOMKEY</code> and <code>SPOP</code>); the call's timing (e.g., <code>TTL</code>); or generic differences that relate to the server's state (e.g., <code>INFO</code> and <code>CLIENT LIST</code>).</p> <p>Note: Prior to Redis 7.0, this tip was the random command flag.</p>"},{"location":"8-reference/command-tips/#nondeterministic_output_order","title":"nondeterministic_output_order","text":"<p>The existence of this tip indicates that the command's output is deterministic, but its ordering is random (e.g., <code>HGETALL</code> and <code>SMEMBERS</code>).</p> <p>Note: Prior to Redis 7.0, this tip was the sort_for_script flag.</p>"},{"location":"8-reference/command-tips/#request_policy","title":"request_policy","text":"<p>This tip can help clients determine the shards to send the command in clustering mode. The default behavior a client should implement for commands without the request_policy tip is as follows:</p> <ol> <li>The command doesn't accept key name arguments: the client can execute the command on an arbitrary shard.</li> <li>For commands that accept one or more key name arguments: the client should route the command to a single shard, as determined by the hash slot of the input keys.</li> </ol> <p>In cases where the client should adopt a behavior different than the default, the request_policy tip can be one of:</p> <ul> <li>all_nodes: the client should execute the command on all nodes - masters and replicas alike.   An example is the <code>CONFIG SET</code> command.    This tip is in-use by commands that don't accept key name arguments.   The command operates atomically per shard.</li> <li>all_shards: the client should execute the command on all master shards (e.g., the <code>DBSIZE</code> command).   This tip is in-use by commands that don't accept key name arguments.   The command operates atomically per shard.</li> <li>multi_shard: the client should execute the command on several shards.   The shards that execute the command are determined by the hash slots of its input key name arguments.   Examples for such commands include <code>MSET</code>, <code>MGET</code> and <code>DEL</code>.   However, note that <code>SUNIONSTORE</code> isn't considered as multi_shard because all of its keys must belong to the same hash slot.</li> <li>special: indicates a non-trivial form of the client's request policy, such as the <code>SCAN</code> command.</li> </ul>"},{"location":"8-reference/command-tips/#response_policy","title":"response_policy","text":"<p>This tip can help clients determine the aggregate they need to compute from the replies of multiple shards in a cluster. The default behavior for commands without a request_policy tip only applies to replies with of nested types (i.e., an array, a set, or a map). The client's implementation for the default behavior should be as follows:</p> <ol> <li>The command doesn't accept key name arguments: the client can aggregate all replies within a single nested data structure. For example, the array replies we get from calling <code>KEYS</code> against all shards. These should be packed in a single in no particular order.</li> <li>For commands that accept one or more key name arguments: the client needs to retain the same order of replies as the input key names. For example, <code>MGET</code>'s aggregated reply.</li> </ol> <p>The response_policy tip is set for commands that reply with scalar data types, or when it's expected that clients implement a non-default aggregate. This tip can be one of:</p> <ul> <li>one_succeeded: the clients should return success if at least one shard didn't reply with an error.   The client should reply with the first non-error reply it obtains.   If all shards return an error, the client can reply with any one of these.   For example, consider a <code>SCRIPT KILL</code> command that's sent to all shards.   Although the script should be loaded in all of the cluster's shards, the <code>SCRIPT KILL</code> will typically run only on one at a given time.</li> <li>all_succeeded: the client should return successfully only if there are no error replies.   Even a single error reply should disqualify the aggregate and be returned.   Otherwise, the client should return one of the non-error replies.   As an example, consider the <code>CONFIG SET</code>, <code>SCRIPT FLUSH</code> and <code>SCRIPT LOAD</code> commands.</li> <li>agg_logical_and: the client should return the result of a logical AND operation on all replies (only applies to integer replies, usually from commands that return either 0 or 1).   Consider the <code>SCRIPT EXISTS</code> command as an example.   It returns an array of 0's and 1's that denote the existence of its given SHA1 sums in the script cache.   The aggregated response should be 1 only when all shards had reported that a given script SHA1 sum is in their respective cache.</li> <li>agg_logical_or: the client should return the result of a logical AND operation on all replies (only applies to integer replies, usually from commands that return either 0 or 1).</li> <li>agg_min: the client should return the minimal value from the replies (only applies to numerical replies).   The aggregate reply from a cluster-wide <code>WAIT</code> command, for example, should be the minimal value (number of synchronized replicas) from all shards.</li> <li>agg_max: the client should return the maximal value from the replies (only applies to numerical replies).</li> <li>agg_sum: the client should return the sum of replies (only applies to numerical replies).   Example: <code>DBSIZE</code>.</li> <li>special: this type of tip indicates a non-trivial form of reply policy.   <code>INFO</code> is an excellent example of that.</li> </ul>"},{"location":"8-reference/command-tips/#example","title":"Example","text":"<pre><code>redis&gt; command info ping\n1)  1) \"ping\"\n    2) (integer) -1\n    3) 1) fast\n    4) (integer) 0\n    5) (integer) 0\n    6) (integer) 0\n    7) 1) @fast\n       2) @connection\n    8) 1) \"request_policy:all_shards\"\n       2) \"response_policy:all_succeeded\"\n    9) (empty array)\n   10) (empty array)\n</code></pre>"},{"location":"8-reference/gopher/","title":"Redis and the Gopher protocol","text":"<p>** Note: Support for Gopher was removed in Redis 7.0 **</p> <p>Redis contains an implementation of the Gopher protocol, as specified in the RFC 1436.</p> <p>The Gopher protocol was very popular in the late '90s. It is an alternative to the web, and the implementation both server and client side is so simple that the Redis server has just 100 lines of code in order to implement this support.</p> <p>What do you do with Gopher nowadays? Well Gopher never really died, and lately there is a movement in order for the Gopher more hierarchical content composed of just plain text documents to be resurrected. Some want a simpler internet, others believe that the mainstream internet became too much controlled, and it's cool to create an alternative space for people that want a bit of fresh air.</p> <p>Anyway, for the 10th birthday of the Redis, we gave it the Gopher protocol as a gift.</p>"},{"location":"8-reference/gopher/#how-it-works","title":"How it works","text":"<p>The Redis Gopher support uses the inline protocol of Redis, and specifically two kind of inline requests that were anyway illegal: an empty request or any request that starts with \"/\" (there are no Redis commands starting with such a slash). Normal RESP2/RESP3 requests are completely out of the path of the Gopher protocol implementation and are served as usually as well.</p> <p>If you open a connection to Redis when Gopher is enabled and send it a string like \"/foo\", if there is a key named \"/foo\" it is served via the Gopher protocol.</p> <p>In order to create a real Gopher \"hole\" (the name of a Gopher site in Gopher talking), you likely need a script such as the one in https://github.com/antirez/gopher2redis.</p>"},{"location":"8-reference/gopher/#security-warning","title":"SECURITY WARNING","text":"<p>If you plan to put Redis on the internet in a publicly accessible address to server Gopher pages make sure to set a password to the instance. Once a password is set:</p> <ol> <li>The Gopher server (when enabled, not by default) will kill serve content via Gopher.</li> <li>However other commands cannot be called before the client will authenticate.</li> </ol> <p>So use the <code>requirepass</code> option to protect your instance.</p> <p>To enable Gopher support use the following configuration line.</p> <pre><code>gopher-enabled yes\n</code></pre> <p>Accessing keys that are not strings or do not exit will generate an error in Gopher protocol format.</p>"},{"location":"8-reference/key-specs/","title":"Command key specifications","text":"<p>Many of the commands in Redis accept key names as input arguments. The 9th element in the reply of <code>COMMAND</code> (and <code>COMMAND INFO</code>) is an array that consists of the command's key specifications.</p> <p>A key specification describes a rule for extracting the names of one or more keys from the arguments of a given command. Key specifications provide a robust and flexible mechanism, compared to the first key, last key and step scheme employed until Redis 7.0. Before introducing these specifications, Redis clients had no trivial programmatic means to extract key names for all commands.</p> <p>Cluster-aware Redis clients had to have the keys' extraction logic hard-coded in the cases of commands such as <code>EVAL</code> and <code>ZUNIONSTORE</code> that rely on a numkeys argument or <code>SORT</code> and its many clauses. Alternatively, the <code>COMMAND GETKEYS</code> can be used to achieve a similar extraction effect but at a higher latency.</p> <p>A Redis client isn't obligated to support key specifications. It can continue using the legacy first key, last key and step scheme along with the movablekeys flag that remain unchanged.</p> <p>However, a Redis client that implements key specifications support can consolidate most of its keys' extraction logic. Even if the client encounters an unfamiliar type of key specification, it can always revert to the <code>COMMAND GETKEYS</code> command.</p> <p>That said, most cluster-aware clients only require a single key name to perform correct command routing, so it is possible that although a command features one unfamiliar specification, its other specification may still be usable by the client.</p> <p>Key specifications are maps with the following keys:</p> <ol> <li>begin_search:: the starting index for keys' extraction.</li> <li>find_keys: the rule for identifying the keys relative to the BS.</li> <li>notes: notes about this key spec, if there are any.</li> <li>flags: indicate the type of data access.</li> </ol>"},{"location":"8-reference/key-specs/#begin_search","title":"begin_search","text":"<p>The begin_search value of a specification informs the client of the extraction's beginning. The value is a map. There are three types of <code>begin_search</code>:</p> <ol> <li>index: key name arguments begin at a constant index.</li> <li>keyword: key names start after a specific keyword (token).</li> <li>unknown: an unknown type of specification - see the incomplete flag section for more details.</li> </ol>"},{"location":"8-reference/key-specs/#index","title":"index","text":"<p>The index type of <code>begin_search</code> indicates that input keys appear at a constant index. It is a map under the spec key with a single key:</p> <ol> <li>index: the 0-based index from which the client should start extracting key names.</li> </ol>"},{"location":"8-reference/key-specs/#keyword","title":"keyword","text":"<p>The keyword type of <code>begin_search</code> means a literal token precedes key name arguments. It is a map under the spec with two keys:</p> <ol> <li>keyword: the keyword (token) that marks the beginning of key name arguments.</li> <li>startfrom: an index to the arguments array from which the client should begin searching.    This can be a negative value, which means the search should start from the end of the arguments' array, in reverse order.   For example, -2's meaning is to search reverse from the penultimate argument.</li> </ol> <p>More examples of the keyword search type include:</p> <ul> <li><code>SET</code> has a <code>begin_search</code> specification of type index with a value of 1.</li> <li><code>XREAD</code> has a <code>begin_search</code> specification of type keyword with the values \"STREAMS\" and 1 as keyword and startfrom, respectively.</li> <li><code>MIGRATE</code> has a start_search specification of type keyword with the values of \"KEYS\" and -2.</li> </ul>"},{"location":"8-reference/key-specs/#find_keys","title":"find_keys","text":"<p>The <code>find_keys</code> value of a key specification tells the client how to continue the search for key names. <code>find_keys</code> has three possible types:</p> <ol> <li>range: keys stop at a specific index or relative to the last argument.</li> <li>keynum: an additional argument specifies the number of input keys.</li> <li>unknown: an unknown type of specification - see the incomplete flag section for more details.</li> </ol>"},{"location":"8-reference/key-specs/#range","title":"range","text":"<p>The range type of <code>find_keys</code> is a map under the spec key with three keys:</p> <ol> <li>lastkey: the index, relative to <code>begin_search</code>, of the last key argument.   This can be a negative value, in which case it isn't relative.   For example, -1 indicates to keep extracting keys until the last argument, -2 until one before the last, and so on.</li> <li>keystep: the number of arguments that should be skipped, after finding a key, to find the next one.</li> <li>limit: if lastkey is has the value of -1, we use the limit to stop the search by a factor.   0 and 1 mean no limit.   2 means half of the remaining arguments, 3 means a third, and so on.</li> </ol>"},{"location":"8-reference/key-specs/#keynum","title":"keynum","text":"<p>The keynum type of <code>find_keys</code> is a map under the spec key with three keys:</p> <ul> <li>keynumidx: the index, relative to <code>begin_search</code>, of the argument containing the number of keys.</li> <li>firstkey: the index, relative to <code>begin_search</code>, of the first key.   This is usually the next argument after keynumidx, and its value, in this case, is greater by one.</li> <li>keystep: Tthe number of arguments that should be skipped, after finding a key, to find the next one.</li> </ul> <p>Examples:</p> <ul> <li>The <code>SET</code> command has a range of 0, 1 and 0.</li> <li>The <code>MSET</code> command has a range of -1, 2 and 0.</li> <li>The <code>XREAD</code> command has a range of -1, 1 and 2.</li> <li>The <code>ZUNION</code> command has a start_search type index with the value 1, and <code>find_keys</code> of type keynum with values of 0, 1 and 1.</li> <li>The <code>AI.DAGRUN</code> command has a start_search of type keyword with values of \"LOAD\" and 1, and <code>find_keys</code> of type keynum with values of 0, 1 and 1.</li> </ul> <p>Note: this isn't a perfect solution as the module writers can come up with anything. However, this mechanism should allow the extraction of key name arguments for the vast majority of commands.</p>"},{"location":"8-reference/key-specs/#notes","title":"notes","text":"<p>Notes about non-obvious key specs considerations, if applicable.</p>"},{"location":"8-reference/key-specs/#flags","title":"flags","text":"<p>A key specification can have additional flags that provide more details about the key. These flags are divided into three groups, as described below.</p>"},{"location":"8-reference/key-specs/#access-type-flags","title":"Access type flags","text":"<p>The following flags declare the type of access the command uses to a key's value or its metadata. A key's metadata includes LRU/LFU counters, type, and cardinality. These flags do not relate to the reply sent back to the client.</p> <p>Every key specification has precisely one of the following flags:</p> <ul> <li>RW: the read-write flag.   The command modifies the data stored in the value of the key or its metadata.   This flag marks every operation that isn't distinctly a delete, an overwrite, or read-only.</li> <li>RO: the read-only flag.   The command only reads the value of the key (although it doesn't necessarily return it).</li> <li>OW: the overwrite flag.   The command overwrites the data stored in the value of the key.</li> <li>RM: the remove flag.   The command deletes the key.</li> </ul>"},{"location":"8-reference/key-specs/#logical-operation-flags","title":"Logical operation flags","text":"<p>The following flags declare the type of operations performed on the data stored as the key's value and its TTL (if any), not the metadata. These flags describe the logical operation that the command executes on data, driven by the input arguments. The flags do not relate to modifying or returning metadata (such as a key's type, cardinality, or existence).</p> <p>Every key specification may include the following flag:</p> <ul> <li>access: the access flag.   This flag indicates that the command returns, copies, or somehow uses the user's data that's stored in the key.</li> </ul> <p>In addition, the specification may include precisely one of the following:</p> <ul> <li>update: the update flag.   The command updates the data stored in the key's value.   The new value may depend on the old value.   This flag marks every operation that isn't distinctly an insert or a delete.</li> <li>insert: the insert flag.   The command only adds data to the value; existing data isn't modified or deleted.</li> <li>delete: the delete flag.   The command explicitly deletes data from the value stored at the key.</li> </ul>"},{"location":"8-reference/key-specs/#miscellaneous-flags","title":"Miscellaneous flags","text":"<p>Key specifications may have the following flags:</p> <ul> <li>not_key: this flag indicates that the specified argument isn't a key.   This argument is treated the same as a key when computing which slot a command should be assigned to for Redis cluster.    For all other purposes this argument should not be considered a key.</li> <li>incomplete: this flag is explained below.</li> <li>variable_flags: this flag is explained below.</li> </ul>"},{"location":"8-reference/key-specs/#incomplete","title":"incomplete","text":"<p>Some commands feature exotic approaches when it comes to specifying their keys, which makes extraction difficult. Consider, for example, what would happen with a call to <code>MIGRATE</code> that includes the literal string \"KEYS\" as an argument to its AUTH clause. Our key specifications would miss the mark, and extraction would begin at the wrong index.</p> <p>Thus, we recognize that key specifications are incomplete and may fail to extract all keys. However, we assure that even incomplete specifications never yield the wrong names of keys, providing that the command is syntactically correct.</p> <p>In the case of <code>MIGRATE</code>, the search begins at the end (startfrom has the value of -1). If and when we encounter a key named \"KEYS\", we'll only extract the subset of the key name arguments after it. That's why <code>MIGRATE</code> has the incomplete flag in its key specification.</p> <p>Another case of incompleteness is the <code>SORT</code> command. Here, the <code>begin_search</code> and <code>find_keys</code> are of type unknown. The client should revert to calling the <code>COMMAND GETKEYS</code> command to extract key names from the arguments, short of implementing it natively. The difficulty arises, for example, because the string \"STORE\" is both a keyword (token) and a valid literal argument for <code>SORT</code>.</p> <p>Note: the only commands with incomplete key specifications are <code>SORT</code> and <code>MIGRATE</code>. We don't expect the addition of such commands in the future.</p>"},{"location":"8-reference/key-specs/#variable_flags","title":"variable_flags","text":"<p>In some commands, the flags for the same key name argument can depend on other arguments. For example, consider the <code>SET</code> command and its optional  GET argument. Without the GET argument, <code>SET</code> is write-only, but it becomes a read and write command with it. When this flag is present, it means that the key specification flags cover all possible options, but the effective flags depend on other arguments.</p>"},{"location":"8-reference/key-specs/#examples","title":"Examples","text":""},{"location":"8-reference/key-specs/#sets-key-specifications","title":"<code>SET</code>'s key specifications","text":"<pre><code>  1) 1) \"flags\"\n     2) 1) RW\n        2) access\n        3) update\n     3) \"begin_search\"\n     4) 1) \"type\"\n        2) \"index\"\n        3) \"spec\"\n        4) 1) \"index\"\n           2) (integer) 1\n     5) \"find_keys\"\n     6) 1) \"type\"\n        2) \"range\"\n        3) \"spec\"\n        4) 1) \"lastkey\"\n           2) (integer) 0\n           3) \"keystep\"\n           4) (integer) 1\n           5) \"limit\"\n           6) (integer) 0\n</code></pre>"},{"location":"8-reference/key-specs/#zunions-key-specifications","title":"<code>ZUNION</code>'s key specifications","text":"<pre><code>  1) 1) \"flags\"\n     2) 1) RO\n        2) access\n     3) \"begin_search\"\n     4) 1) \"type\"\n        2) \"index\"\n        3) \"spec\"\n        4) 1) \"index\"\n           2) (integer) 1\n     5) \"find_keys\"\n     6) 1) \"type\"\n        2) \"keynum\"\n        3) \"spec\"\n        4) 1) \"keynumidx\"\n           2) (integer) 0\n           3) \"firstkey\"\n           4) (integer) 1\n           5) \"keystep\"\n           6) (integer) 1\n</code></pre>"},{"location":"8-reference/protocol-spec/","title":"Redis serialization protocol specification","text":"<p>To communicate with the Redis server, Redis clients use a protocol called REdis Serialization Protocol (RESP). While the protocol was designed specifically for Redis, you can use it for other client-server software projects.</p> <p>RESP is a compromise among the following considerations:</p> <ul> <li>Simple to implement.</li> <li>Fast to parse.</li> <li>Human readable.</li> </ul> <p>RESP can serialize different data types including integers, strings, and arrays. It also features an error-specific type. A client sends a request to the Redis server as an array of strings. The array's contents are the command and its arguments that the server should execute. The server's reply type is command-specific.</p> <p>RESP is binary-safe and uses prefixed length to transfer bulk data so it does not require processing bulk data transferred from one process to another.</p> <p>RESP is the protocol you should implement in your Redis client.</p> <p>{{% alert title=\"Note\" color=\"info\" %}} The protocol outlined here is used only for client-server communication. Redis Cluster uses a different binary protocol for exchanging messages between nodes. {{% /alert %}}</p>"},{"location":"8-reference/protocol-spec/#resp-versions","title":"RESP versions","text":"<p>Support for the first version of the RESP protocol was introduced in Redis 1.2. Using RESP with Redis 1.2 was optional and had mainly served the purpose of working the kinks out of the protocol.</p> <p>In Redis 2.0, the protocol's next version, a.k.a RESP2, became the standard communication method for clients with the Redis server.</p> <p>RESP3 is a superset of RESP2 that mainly aims to make a client author's life a little bit easier. Redis 6.0 introduced experimental opt-in support of RESP3's features (excluding streaming strings and streaming aggregates). In addition, the introduction of the <code>HELLO</code> command allows clients to handshake and upgrade the connection's protocol version (see Client handshake).</p> <p>Up to and including Redis 7, both RESP2 and RESP3 clients can invoke all core commands. However, commands may return differently typed replies for different protocol versions.</p> <p>Future versions of Redis may change the default protocol version, but it is unlikely that RESP2 will become entirely deprecated. It is possible, however, that new features in upcoming versions will require the use of RESP3.</p>"},{"location":"8-reference/protocol-spec/#network-layer","title":"Network layer","text":"<p>A client connects to a Redis server by creating a TCP connection to its port (the default is 6379).</p> <p>While RESP is technically non-TCP specific, the protocol is used exclusively with TCP connections (or equivalent stream-oriented connections like Unix sockets) in the context of Redis.</p>"},{"location":"8-reference/protocol-spec/#request-response-model","title":"Request-Response model","text":"<p>The Redis server accepts commands composed of different arguments. Then, the server processes the command and sends the reply back to the client.</p> <p>This is the simplest model possible; however, there are some exceptions:</p> <ul> <li>Redis requests can be pipelined.   Pipelining enables clients to send multiple commands at once and wait for replies later.</li> <li>When a RESP2 connection subscribes to a Pub/Sub channel, the protocol changes semantics and becomes a push protocol.   The client no longer requires sending commands because the server will automatically send new messages to the client (for the channels the client is subscribed to) as soon as they are received.</li> <li>The <code>MONITOR</code> command.   Invoking the <code>MONITOR</code> command switches the connection to an ad-hoc push mode.   The protocol of this mode is not specified but is obvious to parse.</li> <li>Protected mode.   Connections opened from a non-loopback address to a Redis while in protected mode are denied and terminated by the server.   Before terminating the connection, Redis unconditionally sends a <code>-DENIED</code> reply, regardless of whether the client writes to the socket.</li> <li>The RESP3 Push type.   As the name suggests, a push type allows the server to send out-of-band data to the connection.   The server may push data at any time, and the data isn't necessarily related to specific commands executed by the client.</li> </ul> <p>Excluding these exceptions, the Redis protocol is a simple request-response protocol.</p>"},{"location":"8-reference/protocol-spec/#resp-protocol-description","title":"RESP protocol description","text":"<p>RESP is essentially a serialization protocol that supports several data types. In RESP, the first byte of data determines its type.</p> <p>Redis generally uses RESP as a request-response protocol in the following way:</p> <ul> <li>Clients send commands to a Redis server as an array of bulk strings.   The first (and sometimes also the second) bulk string in the array is the command's name.   Subsequent elements of the array are the arguments for the command.</li> <li>The server replies with a RESP type.   The reply's type is determined by the command's implementation and possibly by the client's protocol version.</li> </ul> <p>RESP is a binary protocol that uses control sequences encoded in standard ASCII. The <code>A</code> character, for example, is encoded with the binary byte of value 65. Similarly, the characters CR (<code>\\r</code>), LF (<code>\\n</code>) and SP (<code></code>) have binary byte values of 13, 10 and 32, respectively.</p> <p>The <code>\\r\\n</code> (CRLF) is the protocol's terminator, which always separates its parts.</p> <p>The first byte in an RESP-serialized payload always identifies its type. Subsequent bytes constitute the type's contents.</p> <p>We categorize every RESP data type as either simple, bulk or aggregate.</p> <p>Simple types are similar to scalars in programming languages that represent plain literal values. Booleans and Integers are such examples.</p> <p>RESP strings are either simple or bulk. Simple strings never contain carriage return (<code>\\r</code>) or line feed (<code>\\n</code>) characters. Bulk strings can contain any binary data and may also be referred to as binary or blob. Note that bulk strings may be further encoded and decoded, e.g. with a wide multi-byte encoding, by the client.</p> <p>Aggregates, such as Arrays and Maps, can have varying numbers of sub-elements and nesting levels.</p> <p>The following table summarizes the RESP data types that Redis supports:</p> RESP data type Minimal protocol version Category First byte Simple strings RESP2 Simple <code>+</code> Simple Errors RESP2 Simple <code>-</code> Integers RESP2 Simple <code>:</code> Bulk strings RESP2 Aggregate <code>$</code> Arrays RESP2 Aggregate <code>*</code> Nulls RESP3 Simple <code>_</code> Booleans RESP3 Simple <code>#</code> Doubles RESP3 Simple <code>,</code> Big numbers RESP3 Simple <code>(</code> Bulk errors RESP3 Aggregate <code>!</code> Verbatim strings RESP3 Aggregate <code>=</code> Maps RESP3 Aggregate <code>%</code> Sets RESP3 Aggregate <code>~</code> Pushes RESP3 Aggregate <code>&gt;</code> <p></p>"},{"location":"8-reference/protocol-spec/#simple-strings","title":"Simple strings","text":"<p>Simple strings are encoded as a plus (<code>+</code>) character, followed by a string. The string mustn't contain a CR (<code>\\r</code>) or LF (<code>\\n</code>) character and is terminated by CRLF (i.e., <code>\\r\\n</code>).</p> <p>Simple strings transmit short, non-binary strings with minimal overhead. For example, many Redis commands reply with just \"OK\" on success. The encoding of this Simple String is the following 5 bytes:</p> <pre><code>+OK\\r\\n\n</code></pre> <p>When Redis replies with a simple string, a client library should return to the caller a string value composed of the first character after the <code>+</code> up to the end of the string, excluding the final CRLF bytes.</p> <p>To send binary strings, use bulk strings instead.</p> <p></p>"},{"location":"8-reference/protocol-spec/#simple-errors","title":"Simple errors","text":"<p>RESP has specific data types for errors. Simple errors, or simply just errors, are similar to simple strings, but their first character is the minus (<code>-</code>) character. The difference between simple strings and errors in RESP is that clients should treat errors as exceptions, whereas the string encoded in the error type is the error message itself.</p> <p>The basic format is:</p> <pre><code>-Error message\\r\\n\n</code></pre> <p>Redis replies with an error only when something goes wrong, for example, when you try to operate against the wrong data type, or when the command does not exist. The client should raise an exception when it receives an Error reply.</p> <p>The following are examples of error replies:</p> <pre><code>-ERR unknown command 'asdf'\n-WRONGTYPE Operation against a key holding the wrong kind of value\n</code></pre> <p>The first upper-case word after the <code>-</code>, up to the first space or newline, represents the kind of error returned. This word is called an error prefix. Note that the error prefix is a convention used by Redis rather than part of the RESP error type.</p> <p>For example, in Redis, <code>ERR</code> is a generic error, whereas <code>WRONGTYPE</code> is a more specific error that implies that the client attempted an operation against the wrong data type. The error prefix allows the client to understand the type of error returned by the server without checking the exact error message.</p> <p>A client implementation can return different types of exceptions for various errors, or provide a generic way for trapping errors by directly providing the error name to the caller as a string.</p> <p>However, such a feature should not be considered vital as it is rarely useful.  Also, simpler client implementations can return a generic error value, such as <code>false</code>.</p> <p></p>"},{"location":"8-reference/protocol-spec/#integers","title":"Integers","text":"<p>This type is a CRLF-terminated string that represents a signed, base-10, 64-bit integer.</p> <p>RESP encodes integers in the following way:</p> <pre><code>:[&lt;+|-&gt;]&lt;value&gt;\\r\\n\n</code></pre> <ul> <li>The colon (<code>:</code>) as the first byte.</li> <li>An optional plus (<code>+</code>) or minus (<code>-</code>) as the sign.</li> <li>One or more decimal digits (<code>0</code>..<code>9</code>) as the integer's unsigned, base-10 value.</li> <li>The CRLF terminator.</li> </ul> <p>For example, <code>:0\\r\\n</code> and <code>:1000\\r\\n</code> are integer replies (of zero and one thousand, respectively).</p> <p>Many Redis commands return RESP integers, including <code>INCR</code>, <code>LLEN</code>, and <code>LASTSAVE</code>. An integer, by itself, has no special meaning other than in the context of the command that returned it. For example, it is an incremental number for <code>INCR</code>, a UNIX timestamp for <code>LASTSAVE</code>, and so forth. However, the returned integer is guaranteed to be in the range of a signed 64-bit integer.</p> <p>In some cases, integers can represent true and false Boolean values. For instance, <code>SISMEMBER</code> returns 1 for true and 0 for false.</p> <p>Other commands, including <code>SADD</code>, <code>SREM</code>, and <code>SETNX</code>, return 1 when the data changes and 0 otherwise.</p> <p></p>"},{"location":"8-reference/protocol-spec/#bulk-strings","title":"Bulk strings","text":"<p>A bulk string represents a single binary string. The string can be of any size, but by default, Redis limits it to 512 MB (see the <code>proto-max-bulk-len</code> configuration directive).</p> <p>RESP encodes bulk strings in the following way:</p> <pre><code>$&lt;length&gt;\\r\\n&lt;data&gt;\\r\\n\n</code></pre> <ul> <li>The dollar sign (<code>$</code>) as the first byte.</li> <li>One or more decimal digits (<code>0</code>..<code>9</code>) as the string's length, in bytes, as an unsigned, base-10 value.</li> <li>The CRLF terminator.</li> <li>The data.</li> <li>A final CRLF.</li> </ul> <p>So the string \"hello\" is encoded as follows:</p> <pre><code>$5\\r\\nhello\\r\\n\n</code></pre> <p>The empty string's encoding is:</p> <pre><code>$0\\r\\n\\r\\n\n</code></pre> <p></p>"},{"location":"8-reference/protocol-spec/#null-bulk-strings","title":"Null bulk strings","text":"<p>Whereas RESP3 has a dedicated data type for null values, RESP2 has no such type. Instead, due to historical reasons, the representation of null values in RESP2 is via predetermined forms of the bulk strings and arrays types.</p> <p>The null bulk string represents a non-existing value. The <code>GET</code> command returns the Null Bulk String when the target key doesn't exist.</p> <p>It is encoded as a bulk string with the length of negative one (-1), like so:</p> <pre><code>$-1\\r\\n\n</code></pre> <p>A Redis client should return a nil object when the server replies with a null bulk string rather than the empty string. For example, a Ruby library should return <code>nil</code> while a C library should return <code>NULL</code> (or set a special flag in the reply object).</p> <p></p>"},{"location":"8-reference/protocol-spec/#arrays","title":"Arrays","text":"<p>Clients send commands to the Redis server as RESP arrays. Similarly, some Redis commands that return collections of elements use arrays as their replies.  An example is the <code>LRANGE</code> command that returns elements of a list.</p> <p>RESP Arrays' encoding uses the following format:</p> <pre><code>*&lt;number-of-elements&gt;\\r\\n&lt;element-1&gt;...&lt;element-n&gt;\n</code></pre> <ul> <li>An asterisk (<code>*</code>) as the first byte.</li> <li>One or more decimal digits (<code>0</code>..<code>9</code>) as the number of elements in the array as an unsigned, base-10 value.</li> <li>The CRLF terminator.</li> <li>An additional RESP type for every element of the array.</li> </ul> <p>So an empty Array is just the following:</p> <pre><code>*0\\r\\n\n</code></pre> <p>Whereas the encoding of an array consisting of the two bulk strings \"hello\" and \"world\" is:</p> <pre><code>*2\\r\\n$5\\r\\nhello\\r\\n$5\\r\\nworld\\r\\n\n</code></pre> <p>As you can see, after the <code>*&lt;count&gt;CRLF</code> part prefixing the array, the other data types that compose the array are concatenated one after the other. For example, an Array of three integers is encoded as follows:</p> <pre><code>*3\\r\\n:1\\r\\n:2\\r\\n:3\\r\\n\n</code></pre> <p>Arrays can contain mixed data types. For instance, the following encoding is of a list of four integers and a bulk string:</p> <pre><code>*5\\r\\n\n:1\\r\\n\n:2\\r\\n\n:3\\r\\n\n:4\\r\\n\n$5\\r\\n\nhello\\r\\n\n</code></pre> <p>(The raw RESP encoding is split into multiple lines for readability).</p> <p>The first line the server sent is <code>*5\\r\\n</code>. This numeric value tells the client that five reply types are about to follow it. Then, every successive reply constitutes an element in the array.</p> <p>All of the aggregate RESP types support nesting. For example, a nested array of two arrays is encoded as follows:</p> <pre><code>*2\\r\\n\n*3\\r\\n\n:1\\r\\n\n:2\\r\\n\n:3\\r\\n\n*2\\r\\n\n+Hello\\r\\n\n-World\\r\\n\n</code></pre> <p>(The raw RESP encoding is split into multiple lines for readability).</p> <p>The above encodes a two-element array. The first element is an array that, in turn, contains three integers (1, 2, 3). The second element is another array containing a simple string and an error.</p> <p>{{% alert title=\"Multi bulk reply\" color=\"info\" %}} In some places, the RESP Array type may be referred to as multi bulk. The two are the same. {{% /alert %}}</p> <p></p>"},{"location":"8-reference/protocol-spec/#null-arrays","title":"Null arrays","text":"<p>Whereas RESP3 has a dedicated data type for null values, RESP2 has no such type. Instead, due to historical reasons, the representation of null values in RESP2 is via predetermined forms of the Bulk Strings and arrays types.</p> <p>Null arrays exist as an alternative way of representing a null value. For instance, when the <code>BLPOP</code> command times out, it returns a null array.</p> <p>The encoding of a null array is that of an array with the length of -1, i.e.:</p> <pre><code>*-1\\r\\n\n</code></pre> <p>When Redis replies with a null array, the client should return a null object rather than an empty array. This is necessary to distinguish between an empty list and a different condition (for instance, the timeout condition of the <code>BLPOP</code> command).</p>"},{"location":"8-reference/protocol-spec/#null-elements-in-arrays","title":"Null elements in arrays","text":"<p>Single elements of an array may be null bulk string. This is used in Redis replies to signal that these elements are missing and not empty strings. This can happen, for example, with the <code>SORT</code> command when used with the <code>GET pattern</code> option if the specified key is missing.</p> <p>Here's an example of an array reply containing a null element:</p> <pre><code>*3\\r\\n\n$5\\r\\n\nhello\\r\\n\n$-1\\r\\n\n$5\\r\\n\nworld\\r\\n\n</code></pre> <p>Above, the second element is null. The client library should return to its caller something like this:</p> <pre><code>[\"hello\",nil,\"world\"]\n</code></pre> <p></p>"},{"location":"8-reference/protocol-spec/#nulls","title":"Nulls","text":"<p>The null data type represents non-existent values.</p> <p>Nulls' encoding is the underscore (<code>_</code>) character, followed by the CRLF terminator (<code>\\r\\n</code>). Here's Null's raw RESP encoding:</p> <pre><code>_\\r\\n\n</code></pre> <p>{{% alert title=\"Null Bulk String, Null Arrays and Nulls\" color=\"info\" %}} Due to historical reasons, RESP2 features two specially crafted values for representing null values of bulk strings and arrays. This duality has always been a redundancy that added zero semantical value to the protocol itself.</p> <p>The null type, introduced in RESP3, aims to fix this wrong. {{% /alert %}}</p> <p>"},{"location":"8-reference/protocol-spec/#booleans","title":"Booleans","text":"<p>RESP booleans are encoded as follows:</p> <pre><code>#&lt;t|f&gt;\\r\\n\n</code></pre> <ul> <li>The octothorpe character (<code>#</code>) as the first byte.</li> <li>A <code>t</code> character for true values, or an <code>f</code> character for false ones.</li> <li>The CRLF terminator.</li> </ul> <p></p>"},{"location":"8-reference/protocol-spec/#doubles","title":"Doubles","text":"<p>The Double RESP type encodes a double-precision floating point value. Doubles are encoded as follows:</p> <pre><code>,[&lt;+|-&gt;]&lt;integral&gt;[.&lt;fractional&gt;][&lt;E|e&gt;[sign]&lt;exponent&gt;]\\r\\n\n</code></pre> <ul> <li>The comma character (<code>,</code>) as the first byte.</li> <li>An optional plus (<code>+</code>) or minus (<code>-</code>) as the sign.</li> <li>One or more decimal digits (<code>0</code>..<code>9</code>) as an unsigned, base-10 integral value.</li> <li>An optional dot (<code>.</code>), followed by one or more decimal digits (<code>0</code>..<code>9</code>) as an unsigned, base-10 fractional value.</li> <li>An optional capital or lowercase letter E (<code>E</code> or <code>e</code>), followed by an optional plus (<code>+</code>) or minus (<code>-</code>) as the exponent's sign, ending with one or more decimal digits (<code>0</code>..<code>9</code>) as an unsigned, base-10 exponent value.</li> <li>The CRLF terminator.</li> </ul> <p>Here's the encoding of the number 1.23:</p> <pre><code>,1.23\\r\\n\n</code></pre> <p>Because the fractional part is optional, the integer value of ten (10) can, therefore, be RESP-encoded both as an integer as well as a double:</p> <pre><code>:10\\r\\n\n,10\\r\\n\n</code></pre> <p>In such cases, the Redis client should return native integer and double values, respectively, providing that these types are supported by the language of its implementation.</p> <p>The positive infinity, negative infinity and NaN values are encoded as follows:</p> <pre><code>,inf\\r\\n\n,-inf\\r\\n\n,nan\\r\\n\n</code></pre> <p></p>"},{"location":"8-reference/protocol-spec/#big-numbers","title":"Big numbers","text":"<p>This type can encode integer values outside the range of signed 64-bit integers.</p> <p>Big numbers use the following encoding:</p> <pre><code>([+|-]&lt;number&gt;\\r\\n\n</code></pre> <ul> <li>The left parenthesis character (<code>(</code>) as the first byte.</li> <li>An optional plus (<code>+</code>) or minus (<code>-</code>) as the sign.</li> <li>One or more decimal digits (<code>0</code>..<code>9</code>) as an unsigned, base-10 value.</li> <li>The CRLF terminator.</li> </ul> <p>Example:</p> <pre><code>(3492890328409238509324850943850943825024385\\r\\n\n</code></pre> <p>Big numbers can be positive or negative but can't include fractionals. Client libraries written in languages with a big number type should return a big number. When big numbers aren't supported, the client should return a string and, when possible, signal to the caller that the reply is a big integer (depending on the API used by the client library).</p> <p></p>"},{"location":"8-reference/protocol-spec/#bulk-errors","title":"Bulk errors","text":"<p>This type combines the purpose of simple errors with the expressive power of bulk strings.</p> <p>It is encoded as:</p> <pre><code>!&lt;length&gt;\\r\\n&lt;error&gt;\\r\\n\n</code></pre> <ul> <li>An exclamation mark (<code>!</code>) as the first byte.</li> <li>One or more decimal digits (<code>0</code>..<code>9</code>) as the error's length, in bytes, as an unsigned, base-10 value.</li> <li>The CRLF terminator.</li> <li>The error itself.</li> <li>A final CRLF.</li> </ul> <p>As a convention, the error begins with an uppercase (space-delimited) word that conveys the error message.</p> <p>For instance, the error \"SYNTAX invalid syntax\" is represented by the following protocol encoding:</p> <pre><code>!21\\r\\n\nSYNTAX invalid syntax\\r\\n\n</code></pre> <p>(The raw RESP encoding is split into multiple lines for readability).</p> <p>"},{"location":"8-reference/protocol-spec/#verbatim-strings","title":"Verbatim strings","text":"<p>This type is similar to the bulk string, with the addition of providing a hint about the data's encoding.</p> <p>A verbatim string's RESP encoding is as follows:</p> <pre><code>=&lt;length&gt;\\r\\n&lt;encoding&gt;:&lt;data&gt;\\r\\n\n</code></pre> <ul> <li>An equal sign (<code>=</code>) as the first byte.</li> <li>One or more decimal digits (<code>0</code>..<code>9</code>) as the string's total length, in bytes, as an unsigned, base-10 value.</li> <li>The CRLF terminator.</li> <li>Exactly three (3) bytes represent the data's encoding.</li> <li>The colon (<code>:</code>) character separates the encoding and data.</li> <li>The data.</li> <li>A final CRLF.</li> </ul> <p>Example:</p> <pre><code>=15\\r\\n\ntxt:Some string\\r\\n\n</code></pre> <p>(The raw RESP encoding is split into multiple lines for readability).</p> <p>Some client libraries may ignore the difference between this type and the string type and return a native string in both cases. However, interactive clients, such as command line interfaces (e.g., <code>redis-cli</code>), can use this type and know that their output should be presented to the human user as is and without quoting the string.</p> <p>For example, the Redis command <code>INFO</code> outputs a report that includes newlines. When using RESP3, <code>redis-cli</code> displays it correctly because it is sent as a Verbatim String reply (with its three bytes being \"txt\"). When using RESP2, however, the <code>redis-cli</code> is hard-coded to look for the <code>INFO</code> command to ensure its correct display to the user.</p> <p></p>"},{"location":"8-reference/protocol-spec/#maps","title":"Maps","text":"<p>The RESP map encodes a collection of key-value tuples, i.e., a dictionary or a hash.</p> <p>It is encoded as follows:</p> <pre><code>%&lt;number-of-entries&gt;\\r\\n&lt;key-1&gt;&lt;value-1&gt;...&lt;key-n&gt;&lt;value-n&gt;\n</code></pre> <ul> <li>A percent character (<code>%</code>) as the first byte.</li> <li>One or more decimal digits (<code>0</code>..<code>9</code>) as the number of entries, or key-value tuples, in the map as an unsigned, base-10 value.</li> <li>The CRLF terminator.</li> <li>Two additional RESP types for every key and value in the map.</li> </ul> <p>For example, the following JSON object:</p> <pre><code>{\n    \"first\": 1,\n    \"second\": 2\n}\n</code></pre> <p>Can be encoded in RESP like so:</p> <pre><code>%2\\r\\n\n+first\\r\\n\n:1\\r\\n\n+second\\r\\n\n:2\\r\\n\n</code></pre> <p>(The raw RESP encoding is split into multiple lines for readability).</p> <p>Both map keys and values can be any of RESP's types.</p> <p>Redis clients should return the idiomatic dictionary type that their language provides. However, low-level programming languages (such as C, for example) will likely return an array along with type information that indicates to the caller that it is a dictionary.</p> <p>{{% alert title=\"Map pattern in RESP2\" color=\"info\" %}} RESP2 doesn't have a map type. A map in RESP2 is represented by a flat array containing the keys and the values. The first element is a key, followed by the corresponding value, then the next key and so on, like this: <code>key1, value1, key2, value2, ...</code>. {{% /alert %}}</p> <p></p>"},{"location":"8-reference/protocol-spec/#sets","title":"Sets","text":"<p>Sets are somewhat like Arrays but are unordered and should only contain unique elements.</p> <p>RESP set's encoding is:</p> <pre><code>~&lt;number-of-elements&gt;\\r\\n&lt;element-1&gt;...&lt;element-n&gt;\n</code></pre> <ul> <li>A tilde (<code>~</code>) as the first byte.</li> <li>One or more decimal digits (<code>0</code>..<code>9</code>) as the number of elements in the set as an unsigned, base-10 value.</li> <li>The CRLF terminator.</li> <li>An additional RESP type for every element of the Set.</li> </ul> <p>Clients should return the native set type if it is available in their programming language. Alternatively, in the absence of a native set type, an array coupled with type information can be used (in C, for example).</p> <p></p>"},{"location":"8-reference/protocol-spec/#pushes","title":"Pushes","text":"<p>RESP's pushes contain out-of-band data. They are an exception to the protocol's request-response model and provide a generic push mode for connections.</p> <p>Push events are encoded similarly to arrays, differing only in their first byte:</p> <pre><code>&gt;&lt;number-of-elements&gt;\\r\\n&lt;element-1&gt;...&lt;element-n&gt;\n</code></pre> <ul> <li>A greater-than sign (<code>&gt;</code>) as the first byte.</li> <li>One or more decimal digits (<code>0</code>..<code>9</code>) as the number of elements in the message as an unsigned, base-10 value.</li> <li>The CRLF terminator.</li> <li>An additional RESP type for every element of the push event.</li> </ul> <p>Pushed data may precede or follow any of RESP's data types but never inside them. That means a client won't find push data in the middle of a map reply, for example. It also means that pushed data may appear before or after a command's reply, as well as by itself (without calling any command).</p> <p>Clients should react to pushes by invoking a callback that implements their handling of the pushed data.</p>"},{"location":"8-reference/protocol-spec/#client-handshake","title":"Client handshake","text":"<p>New RESP connections should begin the session by calling the <code>HELLO</code> command. This practice accomplishes two things:</p> <ol> <li>It allows servers to be backward compatible with RESP2 versions.   This is needed in Redis to make the transition to version 3 of the protocol gentler.</li> <li>The <code>HELLO</code> command returns information about the server and the protocol that the client can use for different goals.</li> </ol> <p>The <code>HELLO</code> command has the following high-level syntax:</p> <pre><code>HELLO &lt;protocol-version&gt; [optional-arguments]\n</code></pre> <p>The first argument of the command is the protocol version we want the connection to be set. By default, the connection starts in RESP2 mode. If we specify a connection version that is too big and unsupported by the server, it should reply with a <code>-NOPROTO</code> error. Example:</p> <pre><code>Client: HELLO 4\nServer: -NOPROTO sorry, this protocol version is not supported.\n</code></pre> <p>At that point, the client may retry with a lower protocol version.</p> <p>Similarly, the client can easily detect a server that is only able to speak RESP2:</p> <pre><code>Client: HELLO 3\nServer: -ERR unknown command 'HELLO'\n</code></pre> <p>The client can then proceed and use RESP2 to communicate with the server.</p> <p>Note that even if the protocol's version is supported, the <code>HELLO</code> command may return an error, perform no action and remain in RESP2 mode.  For example, when used with invalid authentication credentials in the command's optional <code>!AUTH</code> clause:</p> <pre><code>Client: HELLO 3 AUTH default mypassword\nServer: -ERR invalid password\n(the connection remains in RESP2 mode)\n</code></pre> <p>A successful reply to the <code>HELLO</code> command is a map reply. The information in the reply is partly server-dependent, but certain fields are mandatory for all the RESP3 implementations: * server: \"redis\" (or other software name). * version: the server's version. * proto: the highest supported version of the RESP protocol.</p> <p>In Redis' RESP3 implementation, the following fields are also emitted:</p> <ul> <li>id: the connection's identifier (ID).</li> <li>mode: \"standalone\", \"sentinel\" or \"cluster\".</li> <li>role: \"master\" or \"replica\".</li> <li>modules: list of loaded modules as an Array of Bulk Strings.</li> </ul>"},{"location":"8-reference/protocol-spec/#sending-commands-to-a-redis-server","title":"Sending commands to a Redis server","text":"<p>Now that you are familiar with the RESP serialization format, you can use it to help write a Redis client library. We can further specify how the interaction between the client and the server works:</p> <ul> <li>A client sends the Redis server an array consisting of only bulk strings.</li> <li>A Redis server replies to clients, sending any valid RESP data type as a reply.</li> </ul> <p>So, for example, a typical interaction could be the following.</p> <p>The client sends the command <code>LLEN mylist</code> to get the length of the list stored at the key mylist. Then the server replies with an integer reply as in the following example (<code>C:</code> is the client, <code>S:</code> the server).</p> <pre><code>C: *2\\r\\n\nC: $4\\r\\n\nC: LLEN\\r\\n\nC: $6\\r\\n\nC: mylist\\r\\n\n\nS: :48293\\r\\n\n</code></pre> <p>As usual, we separate different parts of the protocol with newlines for simplicity, but the actual interaction is the client sending <code>*2\\r\\n$4\\r\\nLLEN\\r\\n$6\\r\\nmylist\\r\\n</code> as a whole.</p>"},{"location":"8-reference/protocol-spec/#multiple-commands-and-pipelining","title":"Multiple commands and pipelining","text":"<p>A client can use the same connection to issue multiple commands. Pipelining is supported, so multiple commands can be sent with a single write operation by the client. The client can skip reading replies and continue to send the commands one after the other. All the replies can be read at the end.</p> <p>For more information, see Pipelining.</p>"},{"location":"8-reference/protocol-spec/#inline-commands","title":"Inline commands","text":"<p>Sometimes you may need to send a command to the Redis server but only have <code>telnet</code> available. While the Redis protocol is simple to implement, it is not ideal for interactive sessions, and <code>redis-cli</code> may not always be available. For this reason, Redis also accepts commands in the inline command format.</p> <p>The following example demonstrates a server/client exchange using an inline command (the server chat starts with <code>S:</code>, the client chat with <code>C:</code>):</p> <pre><code>C: PING\nS: +PONG\n</code></pre> <p>Here's another example of an inline command where the server returns an integer:</p> <pre><code>C: EXISTS somekey\nS: :0\n</code></pre> <p>Basically, to issue an inline command, you write space-separated arguments in a telnet session. Since no command starts with <code>*</code> (the identifying byte of RESP Arrays), Redis detects this condition and parses your command inline.</p>"},{"location":"8-reference/protocol-spec/#high-performance-parser-for-the-redis-protocol","title":"High-performance parser for the Redis protocol","text":"<p>While the Redis protocol is human-readable and easy to implement, its implementation can exhibit performance similar to that of a binary protocol.</p> <p>RESP uses prefixed lengths to transfer bulk data. That makes scanning the payload for special characters unnecessary (unlike parsing JSON, for example). For the same reason, quoting and escaping the payload isn't needed.</p> <p>Reading the length of aggregate types (for example, bulk strings or arrays) can be processed with code that performs a single operation per character while at the same time scanning for the CR character.</p> <p>Example (in C):</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    unsigned char *p = \"$123\\r\\n\";\n    int len = 0;\n\n    p++;\n    while(*p != '\\r') {\n        len = (len*10)+(*p - '0');\n        p++;\n    }\n\n    /* Now p points at '\\r', and the len is in bulk_len. */\n    printf(\"%d\\n\", len);\n    return 0;\n}\n</code></pre> <p>After the first CR is identified, it can be skipped along with the following LF without further processing. Then, the bulk data can be read with a single read operation that doesn't inspect the payload in any way. Finally, the remaining CR and LF characters are discarded without additional processing.</p> <p>While comparable in performance to a binary protocol, the Redis protocol is significantly more straightforward to implement in most high-level languages, reducing the number of bugs in client software.</p>"},{"location":"8-reference/protocol-spec/#tips-for-redis-client-authors","title":"Tips for Redis client authors","text":"<ul> <li>For testing purposes, use Lua's type conversions to have Redis reply with any RESP2/RESP3 needed.   As an example, a RESP3 double can be generated like so:   <pre><code>EVAL \"return { double = tonumber(ARGV[1]) }\" 0 1e0\n</code></pre></li> </ul>"},{"location":"8-reference/sentinel-clients/","title":"Sentinel client spec","text":"<p>Redis Sentinel is a monitoring solution for Redis instances that handles automatic failover of Redis masters and service discovery (who is the current master for a given group of instances?). Since Sentinel is both responsible for reconfiguring instances during failovers, and providing configurations to clients connecting to Redis masters or replicas, clients are required to have explicit support for Redis Sentinel.</p> <p>This document is targeted at Redis clients developers that want to support Sentinel in their clients implementation with the following goals:</p> <ul> <li>Automatic configuration of clients via Sentinel.</li> <li>Improved safety of Redis Sentinel automatic failover.</li> </ul> <p>For details about how Redis Sentinel works, please check the Redis Documentation, as this document only contains information needed for Redis client developers, and it is expected that readers are familiar with the way Redis Sentinel works.</p>"},{"location":"8-reference/sentinel-clients/#redis-service-discovery-via-sentinel","title":"Redis service discovery via Sentinel","text":"<p>Redis Sentinel identifies every master with a name like \"stats\" or \"cache\". Every name actually identifies a group of instances, composed of a master and a variable number of replicas.</p> <p>The address of the Redis master that is used for a specific purpose inside a network may change after events like an automatic failover, a manually triggered failover (for instance in order to upgrade a Redis instance), and other reasons.</p> <p>Normally Redis clients have some kind of hard-coded configuration that specifies the address of a Redis master instance within a network as IP address and port number. However if the master address changes, manual intervention in every client is needed.</p> <p>A Redis client supporting Sentinel can automatically discover the address of a Redis master from the master name using Redis Sentinel. So instead of a hard coded IP address and port, a client supporting Sentinel should optionally be able to take as input:</p> <ul> <li>A list of ip:port pairs pointing to known Sentinel instances.</li> <li>The name of the service, like \"cache\" or \"timelines\".</li> </ul> <p>This is the procedure a client should follow in order to obtain the master address starting from the list of Sentinels and the service name.</p>"},{"location":"8-reference/sentinel-clients/#step-1-connecting-to-the-first-sentinel","title":"Step 1: connecting to the first Sentinel","text":"<p>The client should iterate the list of Sentinel addresses. For every address it should try to connect to the Sentinel, using a short timeout (in the order of a few hundreds of milliseconds). On errors or timeouts the next Sentinel address should be tried.</p> <p>If all the Sentinel addresses were tried without success, an error should be returned to the client.</p> <p>The first Sentinel replying to the client request should be put at the start of the list, so that at the next reconnection, we'll try first the Sentinel that was reachable in the previous connection attempt, minimizing latency.</p>"},{"location":"8-reference/sentinel-clients/#step-2-ask-for-master-address","title":"Step 2: ask for master address","text":"<p>Once a connection with a Sentinel is established, the client should retry to execute the following command on the Sentinel:</p> <pre><code>SENTINEL get-master-addr-by-name master-name\n</code></pre> <p>Where master-name should be replaced with the actual service name specified by the user.</p> <p>The result from this call can be one of the following two replies:</p> <ul> <li>An ip:port pair.</li> <li>A null reply. This means Sentinel does not know this master.</li> </ul> <p>If an ip:port pair is received, this address should be used to connect to the Redis master. Otherwise if a null reply is received, the client should try the next Sentinel in the list.</p>"},{"location":"8-reference/sentinel-clients/#step-3-call-the-role-command-in-the-target-instance","title":"Step 3: call the ROLE command in the target instance","text":"<p>Once the client discovered the address of the master instance, it should attempt a connection with the master, and call the <code>ROLE</code> command in order to verify the role of the instance is actually a master.</p> <p>If the <code>ROLE</code> commands is not available (it was introduced in Redis 2.8.12), a client may resort to the <code>INFO replication</code> command parsing the <code>role:</code> field of the output.</p> <p>If the instance is not a master as expected, the client should wait a short amount of time (a few hundreds of milliseconds) and should try again starting from Step 1.</p>"},{"location":"8-reference/sentinel-clients/#handling-reconnections","title":"Handling reconnections","text":"<p>Once the service name is resolved into the master address and a connection is established with the Redis master instance, every time a reconnection is needed, the client should resolve again the address using Sentinels restarting from Step 1. For instance Sentinel should contacted again the following cases:</p> <ul> <li>If the client reconnects after a timeout or socket error.</li> <li>If the client reconnects because it was explicitly closed or reconnected by the user.</li> </ul> <p>In the above cases and any other case where the client lost the connection with the Redis server, the client should resolve the master address again.</p>"},{"location":"8-reference/sentinel-clients/#sentinel-failover-disconnection","title":"Sentinel failover disconnection","text":"<p>Starting with Redis 2.8.12, when Redis Sentinel changes the configuration of an instance, for example promoting a replica to a master, demoting a master to replicate to the new master after a failover, or simply changing the master address of a stale replica instance, it sends a <code>CLIENT KILL type normal</code> command to the instance in order to make sure all the clients are disconnected from the reconfigured instance. This will force clients to resolve the master address again.</p> <p>If the client will contact a Sentinel with yet not updated information, the verification of the Redis instance role via the <code>ROLE</code> command will fail, allowing the client to detect that the contacted Sentinel provided stale information, and will try again.</p> <p>Note: it is possible that a stale master returns online at the same time a client contacts a stale Sentinel instance, so the client may connect with a stale master, and yet the ROLE output will match. However when the master is back again Sentinel will try to demote it to replica, triggering a new disconnection. The same reasoning applies to connecting to stale replicas that will get reconfigured to replicate with a different master.</p>"},{"location":"8-reference/sentinel-clients/#connecting-to-replicas","title":"Connecting to replicas","text":"<p>Sometimes clients are interested to connect to replicas, for example in order to scale read requests. This protocol supports connecting to replicas by modifying step 2 slightly. Instead of calling the following command:</p> <pre><code>SENTINEL get-master-addr-by-name master-name\n</code></pre> <p>The clients should call instead:</p> <pre><code>SENTINEL replicas master-name\n</code></pre> <p>In order to retrieve a list of replica instances.</p> <p>Symmetrically the client should verify with the <code>ROLE</code> command that the instance is actually a replica, in order to avoid scaling read queries with the master.</p>"},{"location":"8-reference/sentinel-clients/#connection-pools","title":"Connection pools","text":"<p>For clients implementing connection pools, on reconnection of a single connection, the Sentinel should be contacted again, and in case of a master address change all the existing connections should be closed and connected to the new address.</p>"},{"location":"8-reference/sentinel-clients/#error-reporting","title":"Error reporting","text":"<p>The client should correctly return the information to the user in case of errors. Specifically:</p> <ul> <li>If no Sentinel can be contacted (so that the client was never able to get the reply to <code>SENTINEL get-master-addr-by-name</code>), an error that clearly states that Redis Sentinel is unreachable should be returned.</li> <li>If all the Sentinels in the pool replied with a null reply, the user should be informed with an error that Sentinels don't know this master name.</li> </ul>"},{"location":"8-reference/sentinel-clients/#sentinels-list-automatic-refresh","title":"Sentinels list automatic refresh","text":"<p>Optionally once a successful reply to <code>get-master-addr-by-name</code> is received, a client may update its internal list of Sentinel nodes following this procedure:</p> <ul> <li>Obtain a list of other Sentinels for this master using the command <code>SENTINEL sentinels &lt;master-name&gt;</code>.</li> <li>Add every ip:port pair not already existing in our list at the end of the list.</li> </ul> <p>It is not needed for a client to be able to make the list persistent updating its own configuration. The ability to upgrade the in-memory representation of the list of Sentinels can be already useful to improve reliability.</p>"},{"location":"8-reference/sentinel-clients/#subscribe-to-sentinel-events-to-improve-responsiveness","title":"Subscribe to Sentinel events to improve responsiveness","text":"<p>The Sentinel documentation shows how clients can connect to Sentinel instances using Pub/Sub in order to subscribe to changes in the Redis instances configurations.</p> <p>This mechanism can be used in order to speedup the reconfiguration of clients, that is, clients may listen to Pub/Sub in order to know when a configuration change happened in order to run the three steps protocol explained in this document in order to resolve the new Redis master (or replica) address.</p> <p>However update messages received via Pub/Sub should not substitute the above procedure, since there is no guarantee that a client is able to receive all the update messages.</p>"},{"location":"8-reference/sentinel-clients/#additional-information","title":"Additional information","text":"<p>For additional information or to discuss specific aspects of this guidelines, please drop a message to the Redis Google Group.</p>"},{"location":"8-reference/signals/","title":"Redis signal handling","text":"<p>This document provides information about how Redis reacts to different POSIX signals such as <code>SIGTERM</code> and <code>SIGSEGV</code>.</p> <p>The information in this document only applies to Redis version 2.6 or greater.</p>"},{"location":"8-reference/signals/#sigterm-and-sigint","title":"SIGTERM and SIGINT","text":"<p>The <code>SIGTERM</code> and <code>SIGINT</code> signals tell Redis to shut down gracefully. When the server receives this signal, it does not immediately exit. Instead, it schedules a shutdown similar to the one performed by the <code>SHUTDOWN</code> command. The scheduled shutdown starts as soon as possible, specifically as long as the current command in execution terminates (if any), with a possible additional delay of 0.1 seconds or less.</p> <p>If the server is blocked by a long-running Lua script, kill the script with <code>SCRIPT KILL</code> if possible. The scheduled shutdown will run just after the script is killed or terminates spontaneously.</p> <p>This shutdown process includes the following actions:</p> <ul> <li>If there are any replicas lagging behind in replication:</li> <li>Pause clients attempting to write with <code>CLIENT PAUSE</code> and the <code>WRITE</code> option.</li> <li>Wait up to the configured <code>shutdown-timeout</code> (default 10 seconds) for replicas to catch up with the master's replication offset.</li> <li>If a background child is saving the RDB file or performing an AOF rewrite, the child process is killed.</li> <li>If the AOF is active, Redis calls the <code>fsync</code> system call on the AOF file descriptor to flush the buffers on disk.</li> <li>If Redis is configured to persist on disk using RDB files, a synchronous (blocking) save is performed. Since the save is synchronous, it doesn't use any additional memory.</li> <li>If the server is daemonized, the PID file is removed.</li> <li>If the Unix domain socket is enabled, it gets removed.</li> <li>The server exits with an exit code of zero.</li> </ul> <p>IF the RDB file can't be saved, the shutdown fails, and the server continues to run in order to ensure no data loss. Likewise, if the user just turned on AOF, and the server triggered the first AOF rewrite in order to create the initial AOF file but this file can't be saved, the shutdown fails and the server continues to run. Since Redis 2.6.11, no further attempt to shut down will be made unless a new <code>SIGTERM</code> is received or the <code>SHUTDOWN</code> command is issued.</p> <p>Since Redis 7.0, the server waits for lagging replicas up to a configurable <code>shutdown-timeout</code>, 10 seconds by default, before shutting down. This provides a best effort to minimize the risk of data loss in a situation where no save points are configured and AOF is deactivated. Before version 7.0, shutting down a heavily loaded master node in a diskless setup was more likely to result in data loss. To minimize the risk of data loss in such setups, trigger a manual <code>FAILOVER</code> (or <code>CLUSTER FAILOVER</code>) to demote the master to a replica and promote one of the replicas to a new master before shutting down a master node.</p>"},{"location":"8-reference/signals/#sigsegv-sigbus-sigfpe-and-sigill","title":"SIGSEGV, SIGBUS, SIGFPE and SIGILL","text":"<p>The following signals are handled as a Redis crash:</p> <ul> <li>SIGSEGV</li> <li>SIGBUS</li> <li>SIGFPE</li> <li>SIGILL</li> </ul> <p>Once one of these signals is trapped, Redis stops any current operation and performs the following actions:</p> <ul> <li>Adds a bug report to the log file. This includes a stack trace, dump of registers, and information about the state of clients.</li> <li>Since Redis 2.8, a fast memory test is performed as a first check of the reliability of the crashing system.</li> <li>If the server was daemonized, the PID file is removed.</li> <li>Finally the server unregisters its own signal handler for the received signal and resends the same signal to itself to make sure that the default action is performed, such as dumping the core on the file system.</li> </ul>"},{"location":"8-reference/signals/#what-happens-when-a-child-process-gets-killed","title":"What happens when a child process gets killed","text":"<p>When the child performing the Append Only File rewrite gets killed by a signal, Redis handles this as an error and discards the (probably partial or corrupted) AOF file. It will attempt the rewrite again later.</p> <p>When the child performing an RDB save is killed, Redis handles the condition as a more severe error. While the failure of an AOF file rewrite can cause AOF file enlargement, failed RDB file creation reduces durability.</p> <p>As a result of the child producing the RDB file being killed by a signal, or when the child exits with an error (non zero exit code), Redis enters a special error condition where no further write command is accepted.</p> <ul> <li>Redis will continue to reply to read commands.</li> <li>Redis will reply to all write commands with a <code>MISCONFIG</code> error.</li> </ul> <p>This error condition will persist until it becomes possible to create an RDB file successfully.</p>"},{"location":"8-reference/signals/#kill-the-rdb-file-without-errors","title":"Kill the RDB file without errors","text":"<p>Sometimes the user may want to kill the RDB-saving child process without generating an error. Since Redis version 2.6.10, this can be done using the signal <code>SIGUSR1</code>. This signal is handled in a special way: it kills the child process like any other signal, but the parent process will not detect this as a critical error and will continue to serve write requests.</p>"},{"location":"8-reference/eviction/","title":"Key eviction","text":"<p>When Redis is used as a cache, it is often convenient to let it automatically evict old data as you add new data. This behavior is well known in the developer community, since it is the default behavior for the popular memcached system.</p> <p>This page covers the more general topic of the Redis <code>maxmemory</code> directive used to limit the memory usage to a fixed amount. It also extensively covers the LRU eviction algorithm used by Redis, which is actually an approximation of the exact LRU.</p>"},{"location":"8-reference/eviction/#maxmemory-configuration-directive","title":"<code>Maxmemory</code> configuration directive","text":"<p>The <code>maxmemory</code> configuration directive configures Redis to use a specified amount of memory for the data set. You can set the configuration directive using the <code>redis.conf</code> file, or later using the <code>CONFIG SET</code> command at runtime.</p> <p>For example, to configure a memory limit of 100 megabytes, you can use the following directive inside the <code>redis.conf</code> file:</p> <pre><code>maxmemory 100mb\n</code></pre> <p>Setting <code>maxmemory</code> to zero results into no memory limits. This is the default behavior for 64 bit systems, while 32 bit systems use an implicit memory limit of 3GB.</p> <p>When the specified amount of memory is reached, how eviction policies are configured determines the default behavior. Redis can return errors for commands that could result in more memory being used, or it can evict some old data to return back to the specified limit every time new data is added.</p>"},{"location":"8-reference/eviction/#eviction-policies","title":"Eviction policies","text":"<p>The exact behavior Redis follows when the <code>maxmemory</code> limit is reached is configured using the <code>maxmemory-policy</code> configuration directive.</p> <p>The following policies are available:</p> <ul> <li>noeviction: New values aren\u2019t saved when memory limit is reached. When a database uses replication, this applies to the primary database</li> <li>allkeys-lru: Keeps most recently used keys; removes least recently used (LRU) keys</li> <li>allkeys-lfu: Keeps frequently used keys; removes least frequently used (LFU) keys</li> <li>volatile-lru: Removes least recently used keys with the <code>expire</code> field set to <code>true</code>.</li> <li>volatile-lfu: Removes least frequently used keys with the <code>expire</code> field set to <code>true</code>.</li> <li>allkeys-random: Randomly removes keys to make space for the new data added.</li> <li>volatile-random: Randomly removes keys with <code>expire</code> field set to <code>true</code>.</li> <li>volatile-ttl: Removes keys with <code>expire</code> field set to <code>true</code> and the shortest remaining time-to-live (TTL) value.</li> </ul> <p>The policies volatile-lru, volatile-lfu, volatile-random, and volatile-ttl behave like noeviction if there are no keys to evict matching the prerequisites.</p> <p>Picking the right eviction policy is important depending on the access pattern of your application, however you can reconfigure the policy at runtime while the application is running, and monitor the number of cache misses and hits using the Redis <code>INFO</code> output to tune your setup.</p> <p>In general as a rule of thumb:</p> <ul> <li> <p>Use the allkeys-lru policy when you expect a power-law distribution in the popularity of your requests. That is, you expect a subset of elements will be accessed far more often than the rest. This is a good pick if you are unsure.</p> </li> <li> <p>Use the allkeys-random if you have a cyclic access where all the keys are scanned continuously, or when you expect the distribution to be uniform.</p> </li> <li> <p>Use the volatile-ttl if you want to be able to provide hints to Redis about what are good candidate for expiration by using different TTL values when you create your cache objects.</p> </li> </ul> <p>The volatile-lru and volatile-random policies are mainly useful when you want to use a single instance for both caching and to have a set of persistent keys. However it is usually a better idea to run two Redis instances to solve such a problem.</p> <p>It is also worth noting that setting an <code>expire</code> value to a key costs memory, so using a policy like allkeys-lru is more memory efficient since there is no need for an <code>expire</code> configuration for the key to be evicted under memory pressure.</p>"},{"location":"8-reference/eviction/#how-the-eviction-process-works","title":"How the eviction process works","text":"<p>It is important to understand that the eviction process works like this:</p> <ul> <li>A client runs a new command, resulting in more data added.</li> <li>Redis checks the memory usage, and if it is greater than the <code>maxmemory</code> limit , it evicts keys according to the policy.</li> <li>A new command is executed, and so forth.</li> </ul> <p>So we continuously cross the boundaries of the memory limit, by going over it, and then by evicting keys to return back under the limits.</p> <p>If a command results in a lot of memory being used (like a big set intersection stored into a new key) for some time, the memory limit can be surpassed by a noticeable amount.</p>"},{"location":"8-reference/eviction/#approximated-lru-algorithm","title":"Approximated LRU algorithm","text":"<p>Redis LRU algorithm is not an exact implementation. This means that Redis is not able to pick the best candidate for eviction, that is, the key that was accessed the furthest in the past. Instead it will try to run an approximation of the LRU algorithm, by sampling a small number of keys, and evicting the one that is the best (with the oldest access time) among the sampled keys.</p> <p>However, since Redis 3.0 the algorithm was improved to also take a pool of good candidates for eviction. This improved the performance of the algorithm, making it able to approximate more closely the behavior of a real LRU algorithm.</p> <p>What is important about the Redis LRU algorithm is that you are able to tune the precision of the algorithm by changing the number of samples to check for every eviction. This parameter is controlled by the following configuration directive:</p> <pre><code>maxmemory-samples 5\n</code></pre> <p>The reason Redis does not use a true LRU implementation is because it costs more memory. However, the approximation is virtually equivalent for an application using Redis. This figure compares the LRU approximation used by Redis with true LRU.</p> <p></p> <p>The test to generate the above graphs filled a Redis server with a given number of keys. The keys were accessed from the first to the last. The first keys are the best candidates for eviction using an LRU algorithm. Later more 50% of keys are added, in order to force half of the old keys to be evicted.</p> <p>You can see three kind of dots in the graphs, forming three distinct bands.</p> <ul> <li>The light gray band are objects that were evicted.</li> <li>The gray band are objects that were not evicted.</li> <li>The green band are objects that were added.</li> </ul> <p>In a theoretical LRU implementation we expect that, among the old keys, the first half will be expired. The Redis LRU algorithm will instead only probabilistically expire the older keys.</p> <p>As you can see Redis 3.0 does a better job with 5 samples compared to Redis 2.8, however most objects that are among the latest accessed are still retained by Redis 2.8. Using a sample size of 10 in Redis 3.0 the approximation is very close to the theoretical performance of Redis 3.0.</p> <p>Note that LRU is just a model to predict how likely a given key will be accessed in the future. Moreover, if your data access pattern closely resembles the power law, most of the accesses will be in the set of keys the LRU approximated algorithm can handle well.</p> <p>In simulations we found that using a power law access pattern, the difference between true LRU and Redis approximation were minimal or non-existent.</p> <p>However you can raise the sample size to 10 at the cost of some additional CPU usage to closely approximate true LRU, and check if this makes a difference in your cache misses rate.</p> <p>To experiment in production with different values for the sample size by using the <code>CONFIG SET maxmemory-samples &lt;count&gt;</code> command, is very simple.</p>"},{"location":"8-reference/eviction/#the-new-lfu-mode","title":"The new LFU mode","text":"<p>Starting with Redis 4.0, the Least Frequently Used eviction mode is available. This mode may work better (provide a better hits/misses ratio) in certain cases. In LFU mode, Redis will try to track the frequency of access of items, so the ones used rarely are evicted. This means the keys used often have a higher chance of remaining in memory.</p> <p>To configure the LFU mode, the following policies are available:</p> <ul> <li><code>volatile-lfu</code> Evict using approximated LFU among the keys with an expire set.</li> <li><code>allkeys-lfu</code> Evict any key using approximated LFU.</li> </ul> <p>LFU is approximated like LRU: it uses a probabilistic counter, called a Morris counter to estimate the object access frequency using just a few bits per object, combined with a decay period so that the counter is reduced over time. At some point we no longer want to consider keys as frequently accessed, even if they were in the past, so that the algorithm can adapt to a shift in the access pattern.</p> <p>That information is sampled similarly to what happens for LRU (as explained in the previous section of this documentation) to select a candidate for eviction.</p> <p>However unlike LRU, LFU has certain tunable parameters: for example, how fast should a frequent item lower in rank if it gets no longer accessed? It is also possible to tune the Morris counters range to better adapt the algorithm to specific use cases.</p> <p>By default Redis is configured to:</p> <ul> <li>Saturate the counter at, around, one million requests.</li> <li>Decay the counter every one minute.</li> </ul> <p>Those should be reasonable values and were tested experimental, but the user may want to play with these configuration settings to pick optimal values.</p> <p>Instructions about how to tune these parameters can be found inside the example <code>redis.conf</code> file in the source distribution. Briefly, they are:</p> <pre><code>lfu-log-factor 10\nlfu-decay-time 1\n</code></pre> <p>The decay time is the obvious one, it is the amount of minutes a counter should be decayed, when sampled and found to be older than that value. A special value of <code>0</code> means: we will never decay the counter.</p> <p>The counter logarithm factor changes how many hits are needed to saturate the frequency counter, which is just in the range 0-255. The higher the factor, the more accesses are needed to reach the maximum. The lower the factor, the better is the resolution of the counter for low accesses, according to the following table:</p> <pre><code>+--------+------------+------------+------------+------------+------------+\n| factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |\n+--------+------------+------------+------------+------------+------------+\n| 0      | 104        | 255        | 255        | 255        | 255        |\n+--------+------------+------------+------------+------------+------------+\n| 1      | 18         | 49         | 255        | 255        | 255        |\n+--------+------------+------------+------------+------------+------------+\n| 10     | 10         | 18         | 142        | 255        | 255        |\n+--------+------------+------------+------------+------------+------------+\n| 100    | 8          | 11         | 49         | 143        | 255        |\n+--------+------------+------------+------------+------------+------------+\n</code></pre> <p>So basically the factor is a trade off between better distinguishing items with low accesses VS distinguishing items with high accesses. More information is available in the example <code>redis.conf</code> file.</p>"},{"location":"8-reference/internals/_index/","title":"Redis internals","text":"<p>The following Redis documents were written by the creator of Redis, Salvatore Sanfilippo, early in the development of Redis (c. 2010), and do not necessarily reflect the latest Redis implementation.</p>"},{"location":"8-reference/internals/internals-rediseventlib/","title":"Event library","text":"<p>Note: this document was written by the creator of Redis, Salvatore Sanfilippo, early in the development of Redis (c. 2010), and does not necessarily reflect the latest Redis implementation.</p>"},{"location":"8-reference/internals/internals-rediseventlib/#why-is-an-event-library-needed-at-all","title":"Why is an Event Library needed at all?","text":"<p>Let us figure it out through a series of Q&amp;As.</p> <p>Q: What do you expect a network server to be doing all the time?  A: Watch for inbound connections on the port its listening and accept them.</p> <p>Q: Calling accept yields a descriptor. What do I do with it? A: Save the descriptor and do a non-blocking read/write operation on it.</p> <p>Q: Why does the read/write have to be non-blocking? A: If the file operation ( even a socket in Unix is a file ) is blocking how could the server for example accept other connection requests when its blocked in a file I/O operation.</p> <p>Q: I guess I have to do many such non-blocking operations on the socket to see when it's ready. Am I right? A: Yes. That is what an event library does for you. Now you get it.</p> <p>Q: How do Event Libraries do what they do? A: They use the operating system's polling facility along with timers.</p> <p>Q: So are there any open source event libraries that do what you just described?  A: Yes. <code>libevent</code> and <code>libev</code> are two such event libraries that I can recall off the top of my head.</p> <p>Q: Does Redis use such open source event libraries for handling socket I/O? A: No. For various reasons Redis uses its own event library.</p>"},{"location":"8-reference/internals/internals-rediseventlib/#the-redis-event-library","title":"The Redis event library","text":"<p>Redis implements its own event library. The event library is implemented in <code>ae.c</code>.</p> <p>The best way to understand how the Redis event library works is to understand how Redis uses it.</p>"},{"location":"8-reference/internals/internals-rediseventlib/#event-loop-initialization","title":"Event Loop Initialization","text":"<p><code>initServer</code> function defined in <code>redis.c</code> initializes the numerous fields of the <code>redisServer</code> structure variable. One such field is the Redis event loop <code>el</code>:</p> <pre><code>aeEventLoop *el\n</code></pre> <p><code>initServer</code> initializes <code>server.el</code> field by calling <code>aeCreateEventLoop</code> defined in <code>ae.c</code>. The definition of <code>aeEventLoop</code> is below:</p> <pre><code>typedef struct aeEventLoop\n{\n    int maxfd;\n    long long timeEventNextId;\n    aeFileEvent events[AE_SETSIZE]; /* Registered events */\n    aeFiredEvent fired[AE_SETSIZE]; /* Fired events */\n    aeTimeEvent *timeEventHead;\n    int stop;\n    void *apidata; /* This is used for polling API specific data */\n    aeBeforeSleepProc *beforesleep;\n} aeEventLoop;\n</code></pre>"},{"location":"8-reference/internals/internals-rediseventlib/#aecreateeventloop","title":"<code>aeCreateEventLoop</code>","text":"<p><code>aeCreateEventLoop</code> first <code>malloc</code>s <code>aeEventLoop</code> structure then calls <code>ae_epoll.c:aeApiCreate</code>.</p> <p><code>aeApiCreate</code> <code>malloc</code>s <code>aeApiState</code> that has two fields - <code>epfd</code> that holds the <code>epoll</code> file descriptor returned by a call from <code>epoll_create</code> and <code>events</code> that is of type <code>struct epoll_event</code> define by the Linux <code>epoll</code> library. The use of the <code>events</code> field will be  described later.</p> <p>Next is <code>ae.c:aeCreateTimeEvent</code>. But before that <code>initServer</code> call <code>anet.c:anetTcpServer</code> that creates and returns a listening descriptor. The descriptor listens on port 6379 by default. The returned  listening descriptor is stored in <code>server.fd</code> field.</p>"},{"location":"8-reference/internals/internals-rediseventlib/#aecreatetimeevent","title":"<code>aeCreateTimeEvent</code>","text":"<p><code>aeCreateTimeEvent</code> accepts the following as parameters:</p> <ul> <li><code>eventLoop</code>: This is <code>server.el</code> in <code>redis.c</code></li> <li>milliseconds: The number of milliseconds from the current time after which the timer expires.</li> <li><code>proc</code>: Function pointer. Stores the address of the function that has to be called after the timer expires.</li> <li><code>clientData</code>: Mostly <code>NULL</code>.</li> <li><code>finalizerProc</code>: Pointer to the function that has to be called before the timed event is removed from the list of timed events.</li> </ul> <p><code>initServer</code> calls <code>aeCreateTimeEvent</code> to add a timed event to <code>timeEventHead</code> field of <code>server.el</code>. <code>timeEventHead</code> is a pointer to a list of such timed events. The call to <code>aeCreateTimeEvent</code> from <code>redis.c:initServer</code> function is given below:</p> <pre><code>aeCreateTimeEvent(server.el /*eventLoop*/, 1 /*milliseconds*/, serverCron /*proc*/, NULL /*clientData*/, NULL /*finalizerProc*/);\n</code></pre> <p><code>redis.c:serverCron</code> performs many operations that helps keep Redis running properly.</p>"},{"location":"8-reference/internals/internals-rediseventlib/#aecreatefileevent","title":"<code>aeCreateFileEvent</code>","text":"<p>The essence of <code>aeCreateFileEvent</code> function is to execute <code>epoll_ctl</code> system call which adds a watch for <code>EPOLLIN</code> event on the listening descriptor create by <code>anetTcpServer</code> and associate it with the <code>epoll</code> descriptor created by a call to <code>aeCreateEventLoop</code>.</p> <p>Following is an explanation of what precisely <code>aeCreateFileEvent</code> does when called from <code>redis.c:initServer</code>.</p> <p><code>initServer</code> passes the following arguments to <code>aeCreateFileEvent</code>:</p> <ul> <li><code>server.el</code>: The event loop created by <code>aeCreateEventLoop</code>. The <code>epoll</code> descriptor is got from <code>server.el</code>.</li> <li><code>server.fd</code>: The listening descriptor that also serves as an index to access the relevant file event structure from the <code>eventLoop-&gt;events</code> table and store extra information like the callback function.</li> <li><code>AE_READABLE</code>: Signifies that <code>server.fd</code> has to be watched for <code>EPOLLIN</code> event.</li> <li><code>acceptHandler</code>: The function that has to be executed when the event being watched for is ready. This function pointer is stored in <code>eventLoop-&gt;events[server.fd]-&gt;rfileProc</code>.</li> </ul> <p>This completes the initialization of Redis event loop.</p>"},{"location":"8-reference/internals/internals-rediseventlib/#event-loop-processing","title":"Event Loop Processing","text":"<p><code>ae.c:aeMain</code> called from <code>redis.c:main</code> does the job of processing the event loop that is initialized in the previous phase.</p> <p><code>ae.c:aeMain</code> calls <code>ae.c:aeProcessEvents</code> in a while loop that processes pending time and file events.</p>"},{"location":"8-reference/internals/internals-rediseventlib/#aeprocessevents","title":"<code>aeProcessEvents</code>","text":"<p><code>ae.c:aeProcessEvents</code> looks for the time event that will be pending in the smallest amount of time by calling <code>ae.c:aeSearchNearestTimer</code> on the event loop. In our case there is only one timer event in the event loop that was created by <code>ae.c:aeCreateTimeEvent</code>.</p> <p>Remember, that the timer event created by <code>aeCreateTimeEvent</code> has probably elapsed by now because it had an expiry time of one millisecond. Since the timer has already expired, the seconds and microseconds fields of the <code>tvp</code> <code>timeval</code> structure variable is initialized to zero.</p> <p>The <code>tvp</code> structure variable along with the event loop variable is passed to <code>ae_epoll.c:aeApiPoll</code>.</p> <p><code>aeApiPoll</code> functions does an <code>epoll_wait</code> on the <code>epoll</code> descriptor and populates the <code>eventLoop-&gt;fired</code> table with the details:</p> <ul> <li><code>fd</code>: The descriptor that is now ready to do a read/write operation depending on the mask value.</li> <li><code>mask</code>: The read/write event that can now be performed on the corresponding descriptor.</li> </ul> <p><code>aeApiPoll</code> returns the number of such file events ready for operation. Now to put things in context, if any client has requested for a connection then <code>aeApiPoll</code> would have noticed it and populated the <code>eventLoop-&gt;fired</code> table with an entry of the descriptor being the listening descriptor and mask being <code>AE_READABLE</code>.</p> <p>Now, <code>aeProcessEvents</code> calls the <code>redis.c:acceptHandler</code> registered as the callback. <code>acceptHandler</code> executes accept on the listening descriptor returning a connected descriptor with the client. <code>redis.c:createClient</code> adds a file event on the connected descriptor through a call to <code>ae.c:aeCreateFileEvent</code> like below:</p> <pre><code>if (aeCreateFileEvent(server.el, c-&gt;fd, AE_READABLE,\n    readQueryFromClient, c) == AE_ERR) {\n    freeClient(c);\n    return NULL;\n}\n</code></pre> <p><code>c</code> is the <code>redisClient</code> structure variable and <code>c-&gt;fd</code> is the connected descriptor.</p> <p>Next the <code>ae.c:aeProcessEvent</code> calls <code>ae.c:processTimeEvents</code></p>"},{"location":"8-reference/internals/internals-rediseventlib/#processtimeevents","title":"<code>processTimeEvents</code>","text":"<p><code>ae.processTimeEvents</code> iterates over list of time events starting at <code>eventLoop-&gt;timeEventHead</code>.</p> <p>For every timed event that has elapsed <code>processTimeEvents</code> calls the registered callback. In this case it calls the only timed event callback registered, that is, <code>redis.c:serverCron</code>. The callback returns the time in milliseconds after which the callback must be called again. This change is recorded via a call to <code>ae.c:aeAddMilliSeconds</code> and will be handled on the next iteration of <code>ae.c:aeMain</code> while loop.</p> <p>That's all.</p>"},{"location":"8-reference/internals/internals-sds/","title":"String internals","text":"<p>Note: this document was written by the creator of Redis, Salvatore Sanfilippo, early in the development of Redis (c. 2010). Virtual Memory has been deprecated since Redis 2.6, so this documentation is here only for historical interest.</p> <p>The implementation of Redis strings is contained in <code>sds.c</code> (<code>sds</code> stands for Simple Dynamic Strings). The implementation is available as a standalone library at https://github.com/antirez/sds.</p> <p>The C structure <code>sdshdr</code> declared in <code>sds.h</code> represents a Redis string:</p> <pre><code>struct sdshdr {\n    long len;\n    long free;\n    char buf[];\n};\n</code></pre> <p>The <code>buf</code> character array stores the actual string.</p> <p>The <code>len</code> field stores the length of <code>buf</code>. This makes obtaining the length of a Redis string an O(1) operation.</p> <p>The <code>free</code> field stores the number of additional bytes available for use.</p> <p>Together the <code>len</code> and <code>free</code> field can be thought of as holding the metadata of the <code>buf</code> character array.</p>"},{"location":"8-reference/internals/internals-sds/#creating-redis-strings","title":"Creating Redis Strings","text":"<p>A new data type named <code>sds</code> is defined in <code>sds.h</code> to be a synonym for a character pointer:</p> <pre><code>typedef char *sds;\n</code></pre> <p><code>sdsnewlen</code> function defined in <code>sds.c</code> creates a new Redis String:</p> <pre><code>sds sdsnewlen(const void *init, size_t initlen) {\n    struct sdshdr *sh;\n\n    sh = zmalloc(sizeof(struct sdshdr)+initlen+1);\n#ifdef SDS_ABORT_ON_OOM\n    if (sh == NULL) sdsOomAbort();\n#else\n    if (sh == NULL) return NULL;\n#endif\n    sh-&gt;len = initlen;\n    sh-&gt;free = 0;\n    if (initlen) {\n        if (init) memcpy(sh-&gt;buf, init, initlen);\n        else memset(sh-&gt;buf,0,initlen);\n    }\n    sh-&gt;buf[initlen] = '\\0';\n    return (char*)sh-&gt;buf;\n}\n</code></pre> <p>Remember a Redis string is a variable of type <code>struct sdshdr</code>. But <code>sdsnewlen</code> returns a character pointer!!</p> <p>That's a trick and needs some explanation.</p> <p>Suppose I create a Redis string using <code>sdsnewlen</code> like below:</p> <pre><code>sdsnewlen(\"redis\", 5);\n</code></pre> <p>This creates a new variable of type <code>struct sdshdr</code> allocating memory for <code>len</code> and <code>free</code> fields as well as for the <code>buf</code> character array.</p> <pre><code>sh = zmalloc(sizeof(struct sdshdr)+initlen+1); // initlen is length of init argument.\n</code></pre> <p>After <code>sdsnewlen</code> successfully creates a Redis string the result is something like:</p> <pre><code>-----------\n|5|0|redis|\n-----------\n^   ^\nsh  sh-&gt;buf\n</code></pre> <p><code>sdsnewlen</code> returns <code>sh-&gt;buf</code> to the caller.</p> <p>What do you do if you need to free the Redis string pointed by <code>sh</code>?</p> <p>You want the pointer <code>sh</code> but you only have the pointer <code>sh-&gt;buf</code>.</p> <p>Can you get the pointer <code>sh</code> from <code>sh-&gt;buf</code>?</p> <p>Yes. Pointer arithmetic. Notice from the above ASCII art that if you subtract the size of two longs from <code>sh-&gt;buf</code> you get the pointer <code>sh</code>.</p> <p>The <code>sizeof</code> two longs happens to be the size of <code>struct sdshdr</code>.</p> <p>Look at <code>sdslen</code> function and see this trick at work:</p> <pre><code>size_t sdslen(const sds s) {\n    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));\n    return sh-&gt;len;\n}\n</code></pre> <p>Knowing this trick you could easily go through the rest of the functions in <code>sds.c</code>.</p> <p>The Redis string implementation is hidden behind an interface that accepts only character pointers. The users of Redis strings need not care about how it's implemented and can treat Redis strings as a character pointer.</p>"},{"location":"8-reference/internals/internals-vm/","title":"Virtual memory (deprecated)","text":"<p>Note: this document was written by the creator of Redis, Salvatore Sanfilippo, early in the development of Redis (c. 2010). Virtual Memory has been deprecated since Redis 2.6, so this documentation is here only for historical interest.</p> <p>This document details the internals of the Redis Virtual Memory subsystem prior to Redis 2.6. The intended audience is not the final user but programmers willing to understand or modify the Virtual Memory implementation.</p>"},{"location":"8-reference/internals/internals-vm/#keys-vs-values-what-is-swapped-out","title":"Keys vs Values: what is swapped out?","text":"<p>The goal of the VM subsystem is to free memory transferring Redis Objects from memory to disk. This is a very generic command, but specifically, Redis transfers only objects associated with values. In order to understand better this concept we'll show, using the DEBUG command, how a key holding a value looks from the point of view of the Redis internals:</p> <pre><code>redis&gt; set foo bar\nOK\nredis&gt; debug object foo\nKey at:0x100101d00 refcount:1, value at:0x100101ce0 refcount:1 encoding:raw serializedlength:4\n</code></pre> <p>As you can see from the above output, the Redis top level hash table maps Redis Objects (keys) to other Redis Objects (values). The Virtual Memory is only able to swap values on disk, the objects associated to keys are always taken in memory: this trade off guarantees very good lookup performances, as one of the main design goals of the Redis VM is to have performances similar to Redis with VM disabled when the part of the dataset frequently used fits in RAM.</p>"},{"location":"8-reference/internals/internals-vm/#how-does-a-swapped-value-looks-like-internally","title":"How does a swapped value looks like internally","text":"<p>When an object is swapped out, this is what happens in the hash table entry:</p> <ul> <li>The key continues to hold a Redis Object representing the key.</li> <li>The value is set to NULL</li> </ul> <p>So you may wonder where we store the information that a given value (associated to a given key) was swapped out. Just in the key object!</p> <p>This is how the Redis Object structure robj looks like:</p> <pre><code>/* The actual Redis Object */\ntypedef struct redisObject {\n    void *ptr;\n    unsigned char type;\n    unsigned char encoding;\n    unsigned char storage;  /* If this object is a key, where is the value?\n                             * REDIS_VM_MEMORY, REDIS_VM_SWAPPED, ... */\n    unsigned char vtype; /* If this object is a key, and value is swapped out,\n                          * this is the type of the swapped out object. */\n    int refcount;\n    /* VM fields, this are only allocated if VM is active, otherwise the\n     * object allocation function will just allocate\n     * sizeof(redisObject) minus sizeof(redisObjectVM), so using\n     * Redis without VM active will not have any overhead. */\n    struct redisObjectVM vm;\n} robj;\n</code></pre> <p>As you can see there are a few fields about VM. The most important one is storage, that can be one of this values:</p> <ul> <li><code>REDIS_VM_MEMORY</code>: the associated value is in memory.</li> <li><code>REDIS_VM_SWAPPED</code>: the associated values is swapped, and the value entry of the hash table is just set to NULL.</li> <li><code>REDIS_VM_LOADING</code>: the value is swapped on disk, the entry is NULL, but there is a job to load the object from the swap to the memory (this field is only used when threaded VM is active).</li> <li><code>REDIS_VM_SWAPPING</code>: the value is in memory, the entry is a pointer to the actual Redis Object, but there is an I/O job in order to transfer this value to the swap file.</li> </ul> <p>If an object is swapped on disk (<code>REDIS_VM_SWAPPED</code> or <code>REDIS_VM_LOADING</code>), how do we know where it is stored, what type it is, and so forth? That's simple: the vtype field is set to the original type of the Redis object swapped, while the vm field (that is a redisObjectVM structure) holds information about the location of the object. This is the definition of this additional structure:</p> <pre><code>/* The VM object structure */\nstruct redisObjectVM {\n    off_t page;         /* the page at which the object is stored on disk */\n    off_t usedpages;    /* number of pages used on disk */\n    time_t atime;       /* Last access time */\n} vm;\n</code></pre> <p>As you can see the structure contains the page at which the object is located in the swap file, the number of pages used, and the last access time of the object (this is very useful for the algorithm that select what object is a good candidate for swapping, as we want to transfer on disk objects that are rarely accessed).</p> <p>As you can see, while all the other fields are using unused bytes in the old Redis Object structure (we had some free bit due to natural memory alignment concerns), the vm field is new, and indeed uses additional memory. Should we pay such a memory cost even when VM is disabled? No! This is the code to create a new Redis Object:</p> <pre><code>... some code ...\n        if (server.vm_enabled) {\n            pthread_mutex_unlock(&amp;server.obj_freelist_mutex);\n            o = zmalloc(sizeof(*o));\n        } else {\n            o = zmalloc(sizeof(*o)-sizeof(struct redisObjectVM));\n        }\n... some code ...\n</code></pre> <p>As you can see if the VM system is not enabled we allocate just <code>sizeof(*o)-sizeof(struct redisObjectVM)</code> of memory. Given that the vm field is the last in the object structure, and that this fields are never accessed if VM is disabled, we are safe and Redis without VM does not pay the memory overhead.</p>"},{"location":"8-reference/internals/internals-vm/#the-swap-file","title":"The Swap File","text":"<p>The next step in order to understand how the VM subsystem works is understanding how objects are stored inside the swap file. The good news is that's not some kind of special format, we just use the same format used to store the objects in .rdb files, that are the usual dump files produced by Redis using the <code>SAVE</code> command.</p> <p>The swap file is composed of a given number of pages, where every page size is a given number of bytes. This parameters can be changed in redis.conf, since different Redis instances may work better with different values: it depends on the actual data you store inside it. The following are the default values:</p> <pre><code>vm-page-size 32\nvm-pages 134217728\n</code></pre> <p>Redis takes a \"bitmap\" (a contiguous array of bits set to zero or one) in memory, every bit represent a page of the swap file on disk: if a given bit is set to 1, it represents a page that is already used (there is some Redis Object stored there), while if the corresponding bit is zero, the page is free.</p> <p>Taking this bitmap (that will call the page table) in memory is a huge win in terms of performances, and the memory used is small: we just need 1 bit for every page on disk. For instance in the example below 134217728 pages of 32 bytes each (4GB swap file) is using just 16 MB of RAM for the page table.</p>"},{"location":"8-reference/internals/internals-vm/#transferring-objects-from-memory-to-swap","title":"Transferring objects from memory to swap","text":"<p>In order to transfer an object from memory to disk we need to perform the following steps (assuming non threaded VM, just a simple blocking approach):</p> <ul> <li>Find how many pages are needed in order to store this object on the swap file. This is trivially accomplished just calling the function <code>rdbSavedObjectPages</code> that returns the number of pages used by an object on disk. Note that this function does not duplicate the .rdb saving code just to understand what will be the length after an object will be saved on disk, we use the trick of opening /dev/null and writing the object there, finally calling <code>ftello</code> in order check the amount of bytes required. What we do basically is to save the object on a virtual very fast file, that is, /dev/null.</li> <li>Now that we know how many pages are required in the swap file, we need to find this number of contiguous free pages inside the swap file. This task is accomplished by the <code>vmFindContiguousPages</code> function. As you can guess this function may fail if the swap is full, or so fragmented that we can't easily find the required number of contiguous free pages. When this happens we just abort the swapping of the object, that will continue to live in memory.</li> <li>Finally we can write the object on disk, at the specified position, just calling the function <code>vmWriteObjectOnSwap</code>.</li> </ul> <p>As you can guess once the object was correctly written in the swap file, it is freed from memory, the storage field in the associated key is set to <code>REDIS_VM_SWAPPED</code>, and the used pages are marked as used in the page table.</p>"},{"location":"8-reference/internals/internals-vm/#loading-objects-back-in-memory","title":"Loading objects back in memory","text":"<p>Loading an object from swap to memory is simpler, as we already know where the object is located and how many pages it is using. We also know the type of the object (the loading functions are required to know this information, as there is no header or any other information about the object type on disk), but this is stored in the vtype field of the associated key as already seen above.</p> <p>Calling the function <code>vmLoadObject</code> passing the key object associated to the value object we want to load back is enough. The function will also take care of fixing the storage type of the key (that will be <code>REDIS_VM_MEMORY</code>), marking the pages as freed in the page table, and so forth.</p> <p>The return value of the function is the loaded Redis Object itself, that we'll have to set again as value in the main hash table (instead of the NULL value we put in place of the object pointer when the value was originally swapped out).</p>"},{"location":"8-reference/internals/internals-vm/#how-blocking-vm-works","title":"How blocking VM works","text":"<p>Now we have all the building blocks in order to describe how the blocking VM works. First of all, an important detail about configuration. In order to enable blocking VM in Redis <code>server.vm_max_threads</code> must be set to zero. We'll see later how this max number of threads info is used in the threaded VM, for now all it's needed to now is that Redis reverts to fully blocking VM when this is set to zero.</p> <p>We also need to introduce another important VM parameter, that is, <code>server.vm_max_memory</code>. This parameter is very important as it is used in order to trigger swapping: Redis will try to swap objects only if it is using more memory than the max memory setting, otherwise there is no need to swap as we are matching the user requested memory usage.</p>"},{"location":"8-reference/internals/internals-vm/#blocking-vm-swapping","title":"Blocking VM swapping","text":"<p>Swapping of object from memory to disk happens in the cron function. This function used to be called every second, while in the recent Redis versions on git it is called every 100 milliseconds (that is, 10 times per second). If this function detects we are out of memory, that is, the memory used is greater than the vm-max-memory setting, it starts transferring objects from memory to disk in a loop calling the function <code>vmSwapOneObect</code>. This function takes just one argument, if 0 it will swap objects in a blocking way, otherwise if it is 1, I/O threads are used. In the blocking scenario we just call it with zero as argument.</p> <p>vmSwapOneObject acts performing the following steps:</p> <ul> <li>The key space in inspected in order to find a good candidate for swapping (we'll see later what a good candidate for swapping is).</li> <li>The associated value is transferred to disk, in a blocking way.</li> <li>The key storage field is set to <code>REDIS_VM_SWAPPED</code>, while the vm fields of the object are set to the right values (the page index where the object was swapped, and the number of pages used to swap it).</li> <li>Finally the value object is freed and the value entry of the hash table is set to NULL.</li> </ul> <p>The function is called again and again until one of the following happens: there is no way to swap more objects because either the swap file is full or nearly all the objects are already transferred on disk, or simply the memory usage is already under the vm-max-memory parameter.</p>"},{"location":"8-reference/internals/internals-vm/#what-values-to-swap-when-we-are-out-of-memory","title":"What values to swap when we are out of memory?","text":"<p>Understanding what's a good candidate for swapping is not too hard. A few objects at random are sampled, and for each their swappability is commuted as:</p> <pre><code>swappability = age*log(size_in_memory)\n</code></pre> <p>The age is the number of seconds the key was not requested, while size_in_memory is a fast estimation of the amount of memory (in bytes) used by the object in memory. So we try to swap out objects that are rarely accessed, and we try to swap bigger objects over smaller one, but the latter is a less important factor (because of the logarithmic function used). This is because we don't want bigger objects to be swapped out and in too often as the bigger the object the more I/O and CPU is required in order to transfer it.</p>"},{"location":"8-reference/internals/internals-vm/#blocking-vm-loading","title":"Blocking VM loading","text":"<p>What happens if an operation against a key associated with a swapped out object is requested? For instance Redis may just happen to process the following command:</p> <pre><code>GET foo\n</code></pre> <p>If the value object of the <code>foo</code> key is swapped we need to load it back in memory before processing the operation. In Redis the key lookup process is centralized in the <code>lookupKeyRead</code> and <code>lookupKeyWrite</code> functions, this two functions are used in the implementation of all the Redis commands accessing the keyspace, so we have a single point in the code where to handle the loading of the key from the swap file to memory.</p> <p>So this is what happens:</p> <ul> <li>The user calls some command having as argument a swapped key</li> <li>The command implementation calls the lookup function</li> <li>The lookup function search for the key in the top level hash table. If the value associated with the requested key is swapped (we can see that checking the storage field of the key object), we load it back in memory in a blocking way before to return to the user.</li> </ul> <p>This is pretty straightforward, but things will get more interesting with the threads. From the point of view of the blocking VM the only real problem is the saving of the dataset using another process, that is, handling <code>BGSAVE</code> and <code>BGREWRITEAOF</code> commands.</p>"},{"location":"8-reference/internals/internals-vm/#background-saving-when-vm-is-active","title":"Background saving when VM is active","text":"<p>The default Redis way to persist on disk is to create .rdb files using a child process. Redis calls the fork() system call in order to create a child, that has the exact copy of the in memory dataset, since fork duplicates the whole program memory space (actually thanks to a technique called Copy on Write memory pages are shared between the parent and child process, so the fork() call will not require too much memory).</p> <p>In the child process we have a copy of the dataset in a given point in the time. Other commands issued by clients will just be served by the parent process and will not modify the child data.</p> <p>The child process will just store the whole dataset into the dump.rdb file and finally will exit. But what happens when the VM is active? Values can be swapped out so we don't have all the data in memory, and we need to access the swap file in order to retrieve the swapped values. While child process is saving the swap file is shared between the parent and child process, since:</p> <ul> <li>The parent process needs to access the swap file in order to load values back into memory if an operation against swapped out values are performed.</li> <li>The child process needs to access the swap file in order to retrieve the full dataset while saving the data set on disk.</li> </ul> <p>In order to avoid problems while both the processes are accessing the same swap file we do a simple thing, that is, not allowing values to be swapped out in the parent process while a background saving is in progress. This way both the processes will access the swap file in read only. This approach has the problem that while the child process is saving no new values can be transferred on the swap file even if Redis is using more memory than the max memory parameters dictates. This is usually not a problem as the background saving will terminate in a short amount of time and if still needed a percentage of values will be swapped on disk ASAP.</p> <p>An alternative to this scenario is to enable the Append Only File that will have this problem only when a log rewrite is performed using the <code>BGREWRITEAOF</code> command.</p>"},{"location":"8-reference/internals/internals-vm/#the-problem-with-the-blocking-vm","title":"The problem with the blocking VM","text":"<p>The problem of blocking VM is that... it's blocking :) This is not a problem when Redis is used in batch processing activities, but for real-time usage one of the good points of Redis is the low latency. The blocking VM will have bad latency behaviors as when a client is accessing a swapped out value, or when Redis needs to swap out values, no other clients will be served in the meantime.</p> <p>Swapping out keys should happen in background. Similarly when a client is accessing a swapped out value other clients accessing in memory values should be served mostly as fast as when VM is disabled. Only the clients dealing with swapped out keys should be delayed.</p> <p>All this limitations called for a non-blocking VM implementation.</p>"},{"location":"8-reference/internals/internals-vm/#threaded-vm","title":"Threaded VM","text":"<p>There are basically three main ways to turn the blocking VM into a non blocking one. * 1: One way is obvious, and in my opinion, not a good idea at all, that is, turning Redis itself into a threaded server: if every request is served by a different thread automatically other clients don't need to wait for blocked ones. Redis is fast, exports atomic operations, has no locks, and is just 10k lines of code, because it is single threaded, so this was not an option for me. * 2: Using non-blocking I/O against the swap file. After all you can think Redis already event-loop based, why don't just handle disk I/O in a non-blocking fashion? I also discarded this possibility because of two main reasons. One is that non blocking file operations, unlike sockets, are an incompatibility nightmare. It's not just like calling select, you need to use OS-specific things. The other problem is that the I/O is just one part of the time consumed to handle VM, another big part is the CPU used in order to encode/decode data to/from the swap file. This is I picked option three, that is... * 3: Using I/O threads, that is, a pool of threads handling the swap I/O operations. This is what the Redis VM is using, so let's detail how this works.</p>"},{"location":"8-reference/internals/internals-vm/#io-threads","title":"I/O Threads","text":"<p>The threaded VM design goals where the following, in order of importance:</p> <ul> <li>Simple implementation, little room for race conditions, simple locking, VM system more or less completely decoupled from the rest of Redis code.</li> <li>Good performances, no locks for clients accessing values in memory.</li> <li>Ability to decode/encode objects in the I/O threads.</li> </ul> <p>The above goals resulted in an implementation where the Redis main thread (the one serving actual clients) and the I/O threads communicate using a queue of jobs, with a single mutex. Basically when main thread requires some work done in the background by some I/O thread, it pushes an I/O job structure in the <code>server.io_newjobs</code> queue (that is, just a linked list). If there are no active I/O threads, one is started. At this point some I/O thread will process the I/O job, and the result of the processing is pushed in the <code>server.io_processed</code> queue. The I/O thread will send a byte using an UNIX pipe to the main thread in order to signal that a new job was processed and the result is ready to be processed.</p> <p>This is how the <code>iojob</code> structure looks like:</p> <pre><code>typedef struct iojob {\n    int type;   /* Request type, REDIS_IOJOB_* */\n    redisDb *db;/* Redis database */\n    robj *key;  /* This I/O request is about swapping this key */\n    robj *val;  /* the value to swap for REDIS_IOREQ_*_SWAP, otherwise this\n                 * field is populated by the I/O thread for REDIS_IOREQ_LOAD. */\n    off_t page; /* Swap page where to read/write the object */\n    off_t pages; /* Swap pages needed to save object. PREPARE_SWAP return val */\n    int canceled; /* True if this command was canceled by blocking side of VM */\n    pthread_t thread; /* ID of the thread processing this entry */\n} iojob;\n</code></pre> <p>There are just three type of jobs that an I/O thread can perform (the type is specified by the <code>type</code> field of the structure):</p> <ul> <li><code>REDIS_IOJOB_LOAD</code>: load the value associated to a given key from swap to memory. The object offset inside the swap file is <code>page</code>, the object type is <code>key-&gt;vtype</code>. The result of this operation will populate the <code>val</code> field of the structure.</li> <li><code>REDIS_IOJOB_PREPARE_SWAP</code>: compute the number of pages needed in order to save the object pointed by <code>val</code> into the swap. The result of this operation will populate the <code>pages</code> field.</li> <li><code>REDIS_IOJOB_DO_SWAP</code>: Transfer the object pointed by <code>val</code> to the swap file, at page offset <code>page</code>.</li> </ul> <p>The main thread delegates just the above three tasks. All the rest is handled by the I/O thread itself, for instance finding a suitable range of free pages in the swap file page table (that is a fast operation), deciding what object to swap, altering the storage field of a Redis object to reflect the current state of a value.</p>"},{"location":"8-reference/internals/internals-vm/#non-blocking-vm-as-probabilistic-enhancement-of-blocking-vm","title":"Non blocking VM as probabilistic enhancement of blocking VM","text":"<p>So now we have a way to request background jobs dealing with slow VM operations. How to add this to the mix of the rest of the work done by the main thread? While blocking VM was aware that an object was swapped out just when the object was looked up, this is too late for us: in C it is not trivial to start a background job in the middle of the command, leave the function, and re-enter in the same point the computation when the I/O thread finished what we requested (that is, no co-routines or continuations or alike).</p> <p>Fortunately there was a much, much simpler way to do this. And we love simple things: basically consider the VM implementation a blocking one, but add an optimization (using non the no blocking VM operations we are able to perform) to make the blocking very unlikely.</p> <p>This is what we do:</p> <ul> <li>Every time a client sends us a command, before the command is executed, we examine the argument vector of the command in search for swapped keys. After all we know for every command what arguments are keys, as the Redis command format is pretty simple.</li> <li>If we detect that at least a key in the requested command is swapped on disk, we block the client instead of really issuing the command. For every swapped value associated to a requested key, an I/O job is created, in order to bring the values back in memory. The main thread continues the execution of the event loop, without caring about the blocked client.</li> <li>In the meanwhile, I/O threads are loading values in memory. Every time an I/O thread finished loading a value, it sends a byte to the main thread using an UNIX pipe. The pipe file descriptor has a readable event associated in the main thread event loop, that is the function <code>vmThreadedIOCompletedJob</code>. If this function detects that all the values needed for a blocked client were loaded, the client is restarted and the original command called.</li> </ul> <p>So you can think of this as a blocked VM that almost always happen to have the right keys in memory, since we pause clients that are going to issue commands about swapped out values until this values are loaded.</p> <p>If the function checking what argument is a key fails in some way, there is no problem: the lookup function will see that a given key is associated to a swapped out value and will block loading it. So our non blocking VM reverts to a blocking one when it is not possible to anticipate what keys are touched.</p> <p>For instance in the case of the <code>SORT</code> command used together with the <code>GET</code> or <code>BY</code> options, it is not trivial to know beforehand what keys will be requested, so at least in the first implementation, <code>SORT BY/GET</code> resorts to the blocking VM implementation.</p>"},{"location":"8-reference/internals/internals-vm/#blocking-clients-on-swapped-keys","title":"Blocking clients on swapped keys","text":"<p>How to block clients? To suspend a client in an event-loop based server is pretty trivial. All we do is canceling its read handler. Sometimes we do something different (for instance for BLPOP) that is just marking the client as blocked, but not processing new data (just accumulating the new data into input buffers).</p>"},{"location":"8-reference/internals/internals-vm/#aborting-io-jobs","title":"Aborting I/O jobs","text":"<p>There is something hard to solve about the interactions between our blocking and non blocking VM, that is, what happens if a blocking operation starts about a key that is also \"interested\" by a non blocking operation at the same time?</p> <p>For instance while SORT BY is executed, a few keys are being loaded in a blocking manner by the sort command. At the same time, another client may request the same keys with a simple GET key command, that will trigger the creation of an I/O job to load the key in background.</p> <p>The only simple way to deal with this problem is to be able to kill I/O jobs in the main thread, so that if a key that we want to load or swap in a blocking way is in the <code>REDIS_VM_LOADING</code> or <code>REDIS_VM_SWAPPING</code> state (that is, there is an I/O job about this key), we can just kill the I/O job about this key, and go ahead with the blocking operation we want to perform.</p> <p>This is not as trivial as it is. In a given moment an I/O job can be in one of the following three queues:</p> <ul> <li>server.io_newjobs: the job was already queued but no thread is handling it.</li> <li>server.io_processing: the job is being processed by an I/O thread.</li> <li>server.io_processed: the job was already processed. The function able to kill an I/O job is <code>vmCancelThreadedIOJob</code>, and this is what it does:</li> <li>If the job is in the newjobs queue, that's simple, removing the iojob structure from the queue is enough as no thread is still executing any operation.</li> <li>If the job is in the processing queue, a thread is messing with our job (and possibly with the associated object!). The only thing we can do is waiting for the item to move to the next queue in a blocking way. Fortunately this condition happens very rarely so it's not a performance problem.</li> <li>If the job is in the processed queue, we just mark it as canceled marking setting the <code>canceled</code> field to 1 in the iojob structure. The function processing completed jobs will just ignored and free the job instead of really processing it.</li> </ul>"},{"location":"8-reference/internals/internals-vm/#questions","title":"Questions?","text":"<p>This document is in no way complete, the only way to get the whole picture is reading the source code, but it should be a good introduction in order to make the code review / understanding a lot simpler.</p> <p>Something is not clear about this page? Please leave a comment and I'll try to address the issue possibly integrating the answer in this document.</p>"},{"location":"8-reference/internals/rdd/","title":"Redis design draft #2 (historical)","text":"<p>Note: this document was written by the creator of Redis, Salvatore Sanfilippo, early in the development of Redis (c. 2013), as part of a series of design drafts. This is preserved for historical interest.</p>"},{"location":"8-reference/internals/rdd/#redis-design-draft-2-rdb-version-7-info-fields","title":"Redis Design Draft 2 -- RDB version 7 info fields","text":"<ul> <li>Author: Salvatore Sanfilippo <code>antirez@gmail.com</code></li> <li>GitHub issue #1048</li> </ul>"},{"location":"8-reference/internals/rdd/#history-of-revisions","title":"History of revisions","text":"<p>1.0, 10 April 2013 - Initial draft.</p>"},{"location":"8-reference/internals/rdd/#overview","title":"Overview","text":"<p>The Redis RDB format lacks a simple way to add info fields to an RDB file without causing a backward compatibility issue even if the added meta data is not required in order to load data from the RDB file.</p> <p>For example thanks to the info fields specified in this document it will be possible to add to RDB information like file creation time, Redis version generating the file, and any other useful information, in a way that not every field is required for an RDB version 7 file to be correctly processed.</p> <p>Also with minimal changes it will be possible to add RDB version 7 support to Redis 2.6 without actually supporting the additional fields but just skipping them when loading an RDB file.</p> <p>RDB info fields may have semantic meaning if needed, so that the presence of the field may add information about the data set specified in the RDB file format, however when an info field is required to be correctly decoded in order to understand and load the data set content of the RDB file, the RDB file format must be increased so that previous versions of Redis will not attempt to load it.</p> <p>However currently the info fields are designed to only hold additional information that are not useful to load the dataset, but can better specify how the RDB file was created.</p>"},{"location":"8-reference/internals/rdd/#info-fields-representation","title":"Info fields representation","text":"<p>The RDB format 6 has the following layout:</p> <ul> <li>A 9 bytes magic \"REDIS0006\"</li> <li>key-value pairs</li> <li>An EOF opcode</li> <li>CRC64 checksum</li> </ul> <p>The proposal for RDB format 7 is to add the optional fields immediately after the first 9 bytes magic, so that the new format will be:</p> <ul> <li>A 9 bytes magic \"REDIS0007\"</li> <li>Info field 1</li> <li>Info field 2</li> <li>...</li> <li>Info field N</li> <li>Info field end-of-fields</li> <li>key-value pairs</li> <li>An EOF opcode</li> <li>CRC64 checksum</li> </ul> <p>Every single info field has the following structure:</p> <ul> <li>A 16 bit identifier</li> <li>A 64 bit data length</li> <li>A data section of the exact length as specified</li> </ul> <p>Both the identifier and the data length are stored in little endian byte ordering.</p> <p>The special identifier 0 means that there are no other info fields, and that the remaining of the RDB file contains the key-value pairs.</p>"},{"location":"8-reference/internals/rdd/#handling-of-info-fields","title":"Handling of info fields","text":"<p>A program can simply skip every info field it does not understand, as long as the RDB version matches the one that it is capable to load.</p>"},{"location":"8-reference/internals/rdd/#specification-of-info-fields-ids-and-content","title":"Specification of info fields IDs and content.","text":""},{"location":"8-reference/internals/rdd/#info-field-0-end-of-info-fields","title":"Info field 0 -- End of info fields","text":"<p>This just means there are no longer info fields to process.</p>"},{"location":"8-reference/internals/rdd/#info-field-1-creation-date","title":"Info field 1 -- Creation date","text":"<p>This field represents the unix time at which the RDB file was created. The format of the unix time is a 64 bit little endian integer representing seconds since 1th January 1970.</p>"},{"location":"8-reference/internals/rdd/#info-field-2-redis-version","title":"Info field 2 -- Redis version","text":"<p>This field represents a null-terminated string containing the Redis version that generated the file, as displayed in the Redis version INFO field.</p>"},{"location":"8-reference/modules/_index/","title":"Redis modules API","text":"<p>The modules documentation is composed of the following pages:</p> <ul> <li>Introduction to Redis modules (this file). An overview about Redis Modules system and API. It's a good idea to start your reading here.</li> <li>Implementing native data types covers the implementation of native data types into modules.</li> <li>Blocking operations shows how to write blocking commands that will not reply immediately, but will block the client, without blocking the Redis server, and will provide a reply whenever will be possible.</li> <li>Redis modules API reference is generated from module.c top comments of RedisModule functions. It is a good reference in order to understand how each function works.</li> </ul> <p>Redis modules make it possible to extend Redis functionality using external modules, rapidly implementing new Redis commands with features similar to what can be done inside the core itself.</p> <p>Redis modules are dynamic libraries that can be loaded into Redis at startup, or using the <code>MODULE LOAD</code> command. Redis exports a C API, in the form of a single C header file called <code>redismodule.h</code>. Modules are meant to be written in C, however it will be possible to use C++ or other languages that have C binding functionalities.</p> <p>Modules are designed in order to be loaded into different versions of Redis, so a given module does not need to be designed, or recompiled, in order to run with a specific version of Redis. For this reason, the module will register to the Redis core using a specific API version. The current API version is \"1\".</p> <p>This document is about an alpha version of Redis modules. API, functionalities and other details may change in the future.</p>"},{"location":"8-reference/modules/_index/#loading-modules","title":"Loading modules","text":"<p>In order to test the module you are developing, you can load the module using the following <code>redis.conf</code> configuration directive:</p> <pre><code>loadmodule /path/to/mymodule.so\n</code></pre> <p>It is also possible to load a module at runtime using the following command:</p> <pre><code>MODULE LOAD /path/to/mymodule.so\n</code></pre> <p>In order to list all loaded modules, use:</p> <pre><code>MODULE LIST\n</code></pre> <p>Finally, you can unload (and later reload if you wish) a module using the following command:</p> <pre><code>MODULE UNLOAD mymodule\n</code></pre> <p>Note that <code>mymodule</code> above is not the filename without the <code>.so</code> suffix, but instead, the name the module used to register itself into the Redis core. The name can be obtained using <code>MODULE LIST</code>. However it is good practice that the filename of the dynamic library is the same as the name the module uses to register itself into the Redis core.</p>"},{"location":"8-reference/modules/_index/#the-simplest-module-you-can-write","title":"The simplest module you can write","text":"<p>In order to show the different parts of a module, here we'll show a very simple module that implements a command that outputs a random number.</p> <pre><code>#include \"redismodule.h\"\n#include &lt;stdlib.h&gt;\n\nint HelloworldRand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_ReplyWithLongLong(ctx,rand());\n    return REDISMODULE_OK;\n}\n\nint RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    if (RedisModule_Init(ctx,\"helloworld\",1,REDISMODULE_APIVER_1)\n        == REDISMODULE_ERR) return REDISMODULE_ERR;\n\n    if (RedisModule_CreateCommand(ctx,\"helloworld.rand\",\n        HelloworldRand_RedisCommand, \"fast random\",\n        0, 0, 0) == REDISMODULE_ERR)\n        return REDISMODULE_ERR;\n\n    return REDISMODULE_OK;\n}\n</code></pre> <p>The example module has two functions. One implements a command called HELLOWORLD.RAND. This function is specific of that module. However the other function called <code>RedisModule_OnLoad()</code> must be present in each Redis module. It is the entry point for the module to be initialized, register its commands, and potentially other private data structures it uses.</p> <p>Note that it is a good idea for modules to call commands with the name of the module followed by a dot, and finally the command name, like in the case of <code>HELLOWORLD.RAND</code>. This way it is less likely to have collisions.</p> <p>Note that if different modules have colliding commands, they'll not be able to work in Redis at the same time, since the function <code>RedisModule_CreateCommand</code> will fail in one of the modules, so the module loading will abort returning an error condition.</p>"},{"location":"8-reference/modules/_index/#module-initialization","title":"Module initialization","text":"<p>The above example shows the usage of the function <code>RedisModule_Init()</code>. It should be the first function called by the module <code>OnLoad</code> function. The following is the function prototype:</p> <pre><code>int RedisModule_Init(RedisModuleCtx *ctx, const char *modulename,\n                     int module_version, int api_version);\n</code></pre> <p>The <code>Init</code> function announces the Redis core that the module has a given name, its version (that is reported by <code>MODULE LIST</code>), and that is willing to use a specific version of the API.</p> <p>If the API version is wrong, the name is already taken, or there are other similar errors, the function will return <code>REDISMODULE_ERR</code>, and the module <code>OnLoad</code> function should return ASAP with an error.</p> <p>Before the <code>Init</code> function is called, no other API function can be called, otherwise the module will segfault and the Redis instance will crash.</p> <p>The second function called, <code>RedisModule_CreateCommand</code>, is used in order to register commands into the Redis core. The following is the prototype:</p> <pre><code>int RedisModule_CreateCommand(RedisModuleCtx *ctx, const char *name,\n                              RedisModuleCmdFunc cmdfunc, const char *strflags,\n                              int firstkey, int lastkey, int keystep);\n</code></pre> <p>As you can see, most Redis modules API calls all take as first argument the <code>context</code> of the module, so that they have a reference to the module calling it, to the command and client executing a given command, and so forth.</p> <p>To create a new command, the above function needs the context, the command's name, a pointer to the function implementing the command, the command's flags and the positions of key names in the command's arguments.</p> <p>The function that implements the command must have the following prototype:</p> <pre><code>int mycommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);\n</code></pre> <p>The command function arguments are just the context, that will be passed to all the other API calls, the command argument vector, and total number of arguments, as passed by the user.</p> <p>As you can see, the arguments are provided as pointers to a specific data type, the <code>RedisModuleString</code>. This is an opaque data type you have API functions to access and use, direct access to its fields is never needed.</p> <p>Zooming into the example command implementation, we can find another call:</p> <pre><code>int RedisModule_ReplyWithLongLong(RedisModuleCtx *ctx, long long integer);\n</code></pre> <p>This function returns an integer to the client that invoked the command, exactly like other Redis commands do, like for example <code>INCR</code> or <code>SCARD</code>.</p>"},{"location":"8-reference/modules/_index/#module-cleanup","title":"Module cleanup","text":"<p>In most cases, there is no need for special cleanup. When a module is unloaded, Redis will automatically unregister commands and unsubscribe from notifications. However in the case where a module contains some persistent memory or configuration, a module may include an optional <code>RedisModule_OnUnload</code> function. If a module provides this function, it will be invoked during the module unload process. The following is the function prototype:</p> <pre><code>int RedisModule_OnUnload(RedisModuleCtx *ctx);\n</code></pre> <p>The <code>OnUnload</code> function may prevent module unloading by returning <code>REDISMODULE_ERR</code>. Otherwise, <code>REDISMODULE_OK</code> should be returned.</p>"},{"location":"8-reference/modules/_index/#setup-and-dependencies-of-a-redis-module","title":"Setup and dependencies of a Redis module","text":"<p>Redis modules don't depend on Redis or some other library, nor they need to be compiled with a specific <code>redismodule.h</code> file. In order to create a new module, just copy a recent version of <code>redismodule.h</code> in your source tree, link all the libraries you want, and create a dynamic library having the <code>RedisModule_OnLoad()</code> function symbol exported.</p> <p>The module will be able to load into different versions of Redis.</p> <p>A module can be designed to support both newer and older Redis versions where certain API functions are not available in all versions. If an API function is not implemented in the currently running Redis version, the function pointer is set to NULL. This allows the module to check if a function exists before using it:</p> <pre><code>if (RedisModule_SetCommandInfo != NULL) {\n    RedisModule_SetCommandInfo(cmd, &amp;info);\n}\n</code></pre> <p>In recent versions of <code>redismodule.h</code>, a convenience macro <code>RMAPI_FUNC_SUPPORTED(funcname)</code> is defined. Using the macro or just comparing with NULL is a matter of personal preference.</p>"},{"location":"8-reference/modules/_index/#passing-configuration-parameters-to-redis-modules","title":"Passing configuration parameters to Redis modules","text":"<p>When the module is loaded with the <code>MODULE LOAD</code> command, or using the <code>loadmodule</code> directive in the <code>redis.conf</code> file, the user is able to pass configuration parameters to the module by adding arguments after the module file name:</p> <pre><code>loadmodule mymodule.so foo bar 1234\n</code></pre> <p>In the above example the strings <code>foo</code>, <code>bar</code> and <code>1234</code> will be passed to the module <code>OnLoad()</code> function in the <code>argv</code> argument as an array of RedisModuleString pointers. The number of arguments passed is into <code>argc</code>.</p> <p>The way you can access those strings will be explained in the rest of this document. Normally the module will store the module configuration parameters in some <code>static</code> global variable that can be accessed module wide, so that the configuration can change the behavior of different commands.</p>"},{"location":"8-reference/modules/_index/#working-with-redismodulestring-objects","title":"Working with RedisModuleString objects","text":"<p>The command argument vector <code>argv</code> passed to module commands, and the return value of other module APIs functions, are of type <code>RedisModuleString</code>.</p> <p>Usually you directly pass module strings to other API calls, however sometimes you may need to directly access the string object.</p> <p>There are a few functions in order to work with string objects:</p> <pre><code>const char *RedisModule_StringPtrLen(RedisModuleString *string, size_t *len);\n</code></pre> <p>The above function accesses a string by returning its pointer and setting its length in <code>len</code>. You should never write to a string object pointer, as you can see from the <code>const</code> pointer qualifier.</p> <p>However, if you want, you can create new string objects using the following API:</p> <pre><code>RedisModuleString *RedisModule_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len);\n</code></pre> <p>The string returned by the above command must be freed using a corresponding call to <code>RedisModule_FreeString()</code>:</p> <pre><code>void RedisModule_FreeString(RedisModuleString *str);\n</code></pre> <p>However if you want to avoid having to free strings, the automatic memory management, covered later in this document, can be a good alternative, by doing it for you.</p> <p>Note that the strings provided via the argument vector <code>argv</code> never need to be freed. You only need to free new strings you create, or new strings returned by other APIs, where it is specified that the returned string must be freed.</p>"},{"location":"8-reference/modules/_index/#creating-strings-from-numbers-or-parsing-strings-as-numbers","title":"Creating strings from numbers or parsing strings as numbers","text":"<p>Creating a new string from an integer is a very common operation, so there is a function to do this:</p> <pre><code>RedisModuleString *mystr = RedisModule_CreateStringFromLongLong(ctx,10);\n</code></pre> <p>Similarly in order to parse a string as a number:</p> <pre><code>long long myval;\nif (RedisModule_StringToLongLong(ctx,argv[1],&amp;myval) == REDISMODULE_OK) {\n    /* Do something with 'myval' */\n}\n</code></pre>"},{"location":"8-reference/modules/_index/#accessing-redis-keys-from-modules","title":"Accessing Redis keys from modules","text":"<p>Most Redis modules, in order to be useful, have to interact with the Redis data space (this is not always true, for example an ID generator may never touch Redis keys). Redis modules have two different APIs in order to access the Redis data space, one is a low level API that provides very fast access and a set of functions to manipulate Redis data structures. The other API is more high level, and allows to call Redis commands and fetch the result, similarly to how Lua scripts access Redis.</p> <p>The high level API is also useful in order to access Redis functionalities that are not available as APIs.</p> <p>In general modules developers should prefer the low level API, because commands implemented using the low level API run at a speed comparable to the speed of native Redis commands. However there are definitely use cases for the higher level API. For example often the bottleneck could be processing the data and not accessing it.</p> <p>Also note that sometimes using the low level API is not harder compared to the higher level one.</p>"},{"location":"8-reference/modules/_index/#calling-redis-commands","title":"Calling Redis commands","text":"<p>The high level API to access Redis is the sum of the <code>RedisModule_Call()</code> function, together with the functions needed in order to access the reply object returned by <code>Call()</code>.</p> <p><code>RedisModule_Call</code> uses a special calling convention, with a format specifier that is used to specify what kind of objects you are passing as arguments to the function.</p> <p>Redis commands are invoked just using a command name and a list of arguments. However when calling commands, the arguments may originate from different kind of strings: null-terminated C strings, RedisModuleString objects as received from the <code>argv</code> parameter in the command implementation, binary safe C buffers with a pointer and a length, and so forth.</p> <p>For example if I want to call <code>INCRBY</code> using a first argument (the key) a string received in the argument vector <code>argv</code>, which is an array of RedisModuleString object pointers, and a C string representing the number \"10\" as second argument (the increment), I'll use the following function call:</p> <pre><code>RedisModuleCallReply *reply;\nreply = RedisModule_Call(ctx,\"INCRBY\",\"sc\",argv[1],\"10\");\n</code></pre> <p>The first argument is the context, and the second is always a null terminated C string with the command name. The third argument is the format specifier where each character corresponds to the type of the arguments that will follow. In the above case <code>\"sc\"</code> means a RedisModuleString object, and a null terminated C string. The other arguments are just the two arguments as specified. In fact <code>argv[1]</code> is a RedisModuleString and <code>\"10\"</code> is a null terminated C string.</p> <p>This is the full list of format specifiers:</p> <ul> <li>c -- Null terminated C string pointer.</li> <li>b -- C buffer, two arguments needed: C string pointer and <code>size_t</code> length.</li> <li>s -- RedisModuleString as received in <code>argv</code> or by other Redis module APIs returning a RedisModuleString object.</li> <li>l -- Long long integer.</li> <li>v -- Array of RedisModuleString objects.</li> <li>! -- This modifier just tells the function to replicate the command to replicas and AOF. It is ignored from the point of view of arguments parsing.</li> <li>A -- This modifier, when <code>!</code> is given, tells to suppress AOF propagation: the command will be propagated only to replicas.</li> <li>R -- This modifier, when <code>!</code> is given, tells to suppress replicas propagation: the command will be propagated only to the AOF if enabled.</li> </ul> <p>The function returns a <code>RedisModuleCallReply</code> object on success, on error NULL is returned.</p> <p>NULL is returned when the command name is invalid, the format specifier uses characters that are not recognized, or when the command is called with the wrong number of arguments. In the above cases the <code>errno</code> var is set to <code>EINVAL</code>. NULL is also returned when, in an instance with Cluster enabled, the target keys are about non local hash slots. In this case <code>errno</code> is set to <code>EPERM</code>.</p>"},{"location":"8-reference/modules/_index/#working-with-redismodulecallreply-objects","title":"Working with RedisModuleCallReply objects.","text":"<p><code>RedisModuleCall</code> returns reply objects that can be accessed using the <code>RedisModule_CallReply*</code> family of functions.</p> <p>In order to obtain the type or reply (corresponding to one of the data types supported by the Redis protocol), the function <code>RedisModule_CallReplyType()</code> is used:</p> <pre><code>reply = RedisModule_Call(ctx,\"INCRBY\",\"sc\",argv[1],\"10\");\nif (RedisModule_CallReplyType(reply) == REDISMODULE_REPLY_INTEGER) {\n    long long myval = RedisModule_CallReplyInteger(reply);\n    /* Do something with myval. */\n}\n</code></pre> <p>Valid reply types are:</p> <ul> <li><code>REDISMODULE_REPLY_STRING</code> Bulk string or status replies.</li> <li><code>REDISMODULE_REPLY_ERROR</code> Errors.</li> <li><code>REDISMODULE_REPLY_INTEGER</code> Signed 64 bit integers.</li> <li><code>REDISMODULE_REPLY_ARRAY</code> Array of replies.</li> <li><code>REDISMODULE_REPLY_NULL</code> NULL reply.</li> </ul> <p>Strings, errors and arrays have an associated length. For strings and errors the length corresponds to the length of the string. For arrays the length is the number of elements. To obtain the reply length the following function is used:</p> <pre><code>size_t reply_len = RedisModule_CallReplyLength(reply);\n</code></pre> <p>In order to obtain the value of an integer reply, the following function is used, as already shown in the example above:</p> <pre><code>long long reply_integer_val = RedisModule_CallReplyInteger(reply);\n</code></pre> <p>Called with a reply object of the wrong type, the above function always returns <code>LLONG_MIN</code>.</p> <p>Sub elements of array replies are accessed this way:</p> <pre><code>RedisModuleCallReply *subreply;\nsubreply = RedisModule_CallReplyArrayElement(reply,idx);\n</code></pre> <p>The above function returns NULL if you try to access out of range elements.</p> <p>Strings and errors (which are like strings but with a different type) can be accessed using in the following way, making sure to never write to the resulting pointer (that is returned as a <code>const</code> pointer so that misusing must be pretty explicit):</p> <pre><code>size_t len;\nchar *ptr = RedisModule_CallReplyStringPtr(reply,&amp;len);\n</code></pre> <p>If the reply type is not a string or an error, NULL is returned.</p> <p>RedisCallReply objects are not the same as module string objects (RedisModuleString types). However sometimes you may need to pass replies of type string or integer, to API functions expecting a module string.</p> <p>When this is the case, you may want to evaluate if using the low level API could be a simpler way to implement your command, or you can use the following function in order to create a new string object from a call reply of type string, error or integer:</p> <pre><code>RedisModuleString *mystr = RedisModule_CreateStringFromCallReply(myreply);\n</code></pre> <p>If the reply is not of the right type, NULL is returned. The returned string object should be released with <code>RedisModule_FreeString()</code> as usually, or by enabling automatic memory management (see corresponding section).</p>"},{"location":"8-reference/modules/_index/#releasing-call-reply-objects","title":"Releasing call reply objects","text":"<p>Reply objects must be freed using <code>RedisModule_FreeCallReply</code>. For arrays, you need to free only the top level reply, not the nested replies. Currently the module implementation provides a protection in order to avoid crashing if you free a nested reply object for error, however this feature is not guaranteed to be here forever, so should not be considered part of the API.</p> <p>If you use automatic memory management (explained later in this document) you don't need to free replies (but you still could if you wish to release memory ASAP).</p>"},{"location":"8-reference/modules/_index/#returning-values-from-redis-commands","title":"Returning values from Redis commands","text":"<p>Like normal Redis commands, new commands implemented via modules must be able to return values to the caller. The API exports a set of functions for this goal, in order to return the usual types of the Redis protocol, and arrays of such types as elements. Also errors can be returned with any error string and code (the error code is the initial uppercase letters in the error message, like the \"BUSY\" string in the \"BUSY the sever is busy\" error message).</p> <p>All the functions to send a reply to the client are called <code>RedisModule_ReplyWith&lt;something&gt;</code>.</p> <p>To return an error, use:</p> <pre><code>RedisModule_ReplyWithError(RedisModuleCtx *ctx, const char *err);\n</code></pre> <p>There is a predefined error string for key of wrong type errors:</p> <pre><code>REDISMODULE_ERRORMSG_WRONGTYPE\n</code></pre> <p>Example usage:</p> <pre><code>RedisModule_ReplyWithError(ctx,\"ERR invalid arguments\");\n</code></pre> <p>We already saw how to reply with a <code>long long</code> in the examples above:</p> <pre><code>RedisModule_ReplyWithLongLong(ctx,12345);\n</code></pre> <p>To reply with a simple string, that can't contain binary values or newlines, (so it's suitable to send small words, like \"OK\") we use:</p> <pre><code>RedisModule_ReplyWithSimpleString(ctx,\"OK\");\n</code></pre> <p>It's possible to reply with \"bulk strings\" that are binary safe, using two different functions:</p> <pre><code>int RedisModule_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len);\n\nint RedisModule_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str);\n</code></pre> <p>The first function gets a C pointer and length. The second a RedisModuleString object. Use one or the other depending on the source type you have at hand.</p> <p>In order to reply with an array, you just need to use a function to emit the array length, followed by as many calls to the above functions as the number of elements of the array are:</p> <pre><code>RedisModule_ReplyWithArray(ctx,2);\nRedisModule_ReplyWithStringBuffer(ctx,\"age\",3);\nRedisModule_ReplyWithLongLong(ctx,22);\n</code></pre> <p>To return nested arrays is easy, your nested array element just uses another call to <code>RedisModule_ReplyWithArray()</code> followed by the calls to emit the sub array elements.</p>"},{"location":"8-reference/modules/_index/#returning-arrays-with-dynamic-length","title":"Returning arrays with dynamic length","text":"<p>Sometimes it is not possible to know beforehand the number of items of an array. As an example, think of a Redis module implementing a FACTOR command that given a number outputs the prime factors. Instead of factorializing the number, storing the prime factors into an array, and later produce the command reply, a better solution is to start an array reply where the length is not known, and set it later. This is accomplished with a special argument to <code>RedisModule_ReplyWithArray()</code>:</p> <pre><code>RedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_LEN);\n</code></pre> <p>The above call starts an array reply so we can use other <code>ReplyWith</code> calls in order to produce the array items. Finally in order to set the length, use the following call:</p> <pre><code>RedisModule_ReplySetArrayLength(ctx, number_of_items);\n</code></pre> <p>In the case of the FACTOR command, this translates to some code similar to this:</p> <pre><code>RedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_LEN);\nnumber_of_factors = 0;\nwhile(still_factors) {\n    RedisModule_ReplyWithLongLong(ctx, some_factor);\n    number_of_factors++;\n}\nRedisModule_ReplySetArrayLength(ctx, number_of_factors);\n</code></pre> <p>Another common use case for this feature is iterating over the arrays of some collection and only returning the ones passing some kind of filtering.</p> <p>It is possible to have multiple nested arrays with postponed reply. Each call to <code>SetArray()</code> will set the length of the latest corresponding call to <code>ReplyWithArray()</code>:</p> <pre><code>RedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_LEN);\n... generate 100 elements ...\nRedisModule_ReplyWithArray(ctx, REDISMODULE_POSTPONED_LEN);\n... generate 10 elements ...\nRedisModule_ReplySetArrayLength(ctx, 10);\nRedisModule_ReplySetArrayLength(ctx, 100);\n</code></pre> <p>This creates a 100 items array having as last element a 10 items array.</p>"},{"location":"8-reference/modules/_index/#arity-and-type-checks","title":"Arity and type checks","text":"<p>Often commands need to check that the number of arguments and type of the key is correct. In order to report a wrong arity, there is a specific function called <code>RedisModule_WrongArity()</code>. The usage is trivial:</p> <pre><code>if (argc != 2) return RedisModule_WrongArity(ctx);\n</code></pre> <p>Checking for the wrong type involves opening the key and checking the type:</p> <pre><code>RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n    REDISMODULE_READ|REDISMODULE_WRITE);\n\nint keytype = RedisModule_KeyType(key);\nif (keytype != REDISMODULE_KEYTYPE_STRING &amp;&amp;\n    keytype != REDISMODULE_KEYTYPE_EMPTY)\n{\n    RedisModule_CloseKey(key);\n    return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n}\n</code></pre> <p>Note that you often want to proceed with a command both if the key is of the expected type, or if it's empty.</p>"},{"location":"8-reference/modules/_index/#low-level-access-to-keys","title":"Low level access to keys","text":"<p>Low level access to keys allow to perform operations on value objects associated to keys directly, with a speed similar to what Redis uses internally to implement the built-in commands.</p> <p>Once a key is opened, a key pointer is returned that will be used with all the other low level API calls in order to perform operations on the key or its associated value.</p> <p>Because the API is meant to be very fast, it cannot do too many run-time checks, so the user must be aware of certain rules to follow:</p> <ul> <li>Opening the same key multiple times where at least one instance is opened for writing, is undefined and may lead to crashes.</li> <li>While a key is open, it should only be accessed via the low level key API. For example opening a key, then calling DEL on the same key using the <code>RedisModule_Call()</code> API will result into a crash. However it is safe to open a key, perform some operation with the low level API, closing it, then using other APIs to manage the same key, and later opening it again to do some more work.</li> </ul> <p>In order to open a key the <code>RedisModule_OpenKey</code> function is used. It returns a key pointer, that we'll use with all the next calls to access and modify the value:</p> <pre><code>RedisModuleKey *key;\nkey = RedisModule_OpenKey(ctx,argv[1],REDISMODULE_READ);\n</code></pre> <p>The second argument is the key name, that must be a <code>RedisModuleString</code> object. The third argument is the mode: <code>REDISMODULE_READ</code> or <code>REDISMODULE_WRITE</code>. It is possible to use <code>|</code> to bitwise OR the two modes to open the key in both modes. Currently a key opened for writing can also be accessed for reading but this is to be considered an implementation detail. The right mode should be used in sane modules.</p> <p>You can open non existing keys for writing, since the keys will be created when an attempt to write to the key is performed. However when opening keys just for reading, <code>RedisModule_OpenKey</code> will return NULL if the key does not exist.</p> <p>Once you are done using a key, you can close it with:</p> <pre><code>RedisModule_CloseKey(key);\n</code></pre> <p>Note that if automatic memory management is enabled, you are not forced to close keys. When the module function returns, Redis will take care to close all the keys which are still open.</p>"},{"location":"8-reference/modules/_index/#getting-the-key-type","title":"Getting the key type","text":"<p>In order to obtain the value of a key, use the <code>RedisModule_KeyType()</code> function:</p> <pre><code>int keytype = RedisModule_KeyType(key);\n</code></pre> <p>It returns one of the following values:</p> <pre><code>REDISMODULE_KEYTYPE_EMPTY\nREDISMODULE_KEYTYPE_STRING\nREDISMODULE_KEYTYPE_LIST\nREDISMODULE_KEYTYPE_HASH\nREDISMODULE_KEYTYPE_SET\nREDISMODULE_KEYTYPE_ZSET\n</code></pre> <p>The above are just the usual Redis key types, with the addition of an empty type, that signals the key pointer is associated with an empty key that does not yet exists.</p>"},{"location":"8-reference/modules/_index/#creating-new-keys","title":"Creating new keys","text":"<p>To create a new key, open it for writing and then write to it using one of the key writing functions. Example:</p> <pre><code>RedisModuleKey *key;\nkey = RedisModule_OpenKey(ctx,argv[1],REDISMODULE_WRITE);\nif (RedisModule_KeyType(key) == REDISMODULE_KEYTYPE_EMPTY) {\n    RedisModule_StringSet(key,argv[2]);\n}\n</code></pre>"},{"location":"8-reference/modules/_index/#deleting-keys","title":"Deleting keys","text":"<p>Just use:</p> <pre><code>RedisModule_DeleteKey(key);\n</code></pre> <p>The function returns <code>REDISMODULE_ERR</code> if the key is not open for writing. Note that after a key gets deleted, it is setup in order to be targeted by new key commands. For example <code>RedisModule_KeyType()</code> will return it is an empty key, and writing to it will create a new key, possibly of another type (depending on the API used).</p>"},{"location":"8-reference/modules/_index/#managing-key-expires-ttls","title":"Managing key expires (TTLs)","text":"<p>To control key expires two functions are provided, that are able to set, modify, get, and unset the time to live associated with a key.</p> <p>One function is used in order to query the current expire of an open key:</p> <pre><code>mstime_t RedisModule_GetExpire(RedisModuleKey *key);\n</code></pre> <p>The function returns the time to live of the key in milliseconds, or <code>REDISMODULE_NO_EXPIRE</code> as a special value to signal the key has no associated expire or does not exist at all (you can differentiate the two cases checking if the key type is <code>REDISMODULE_KEYTYPE_EMPTY</code>).</p> <p>In order to change the expire of a key the following function is used instead:</p> <pre><code>int RedisModule_SetExpire(RedisModuleKey *key, mstime_t expire);\n</code></pre> <p>When called on a non existing key, <code>REDISMODULE_ERR</code> is returned, because the function can only associate expires to existing open keys (non existing open keys are only useful in order to create new values with data type specific write operations).</p> <p>Again the <code>expire</code> time is specified in milliseconds. If the key has currently no expire, a new expire is set. If the key already have an expire, it is replaced with the new value.</p> <p>If the key has an expire, and the special value <code>REDISMODULE_NO_EXPIRE</code> is used as a new expire, the expire is removed, similarly to the Redis <code>PERSIST</code> command. In case the key was already persistent, no operation is performed.</p>"},{"location":"8-reference/modules/_index/#obtaining-the-length-of-values","title":"Obtaining the length of values","text":"<p>There is a single function in order to retrieve the length of the value associated to an open key. The returned length is value-specific, and is the string length for strings, and the number of elements for the aggregated data types (how many elements there is in a list, set, sorted set, hash).</p> <pre><code>size_t len = RedisModule_ValueLength(key);\n</code></pre> <p>If the key does not exist, 0 is returned by the function:</p>"},{"location":"8-reference/modules/_index/#string-type-api","title":"String type API","text":"<p>Setting a new string value, like the Redis <code>SET</code> command does, is performed using:</p> <pre><code>int RedisModule_StringSet(RedisModuleKey *key, RedisModuleString *str);\n</code></pre> <p>The function works exactly like the Redis <code>SET</code> command itself, that is, if there is a prior value (of any type) it will be deleted.</p> <p>Accessing existing string values is performed using DMA (direct memory access) for speed. The API will return a pointer and a length, so that's possible to access and, if needed, modify the string directly.</p> <pre><code>size_t len, j;\nchar *myptr = RedisModule_StringDMA(key,&amp;len,REDISMODULE_WRITE);\nfor (j = 0; j &lt; len; j++) myptr[j] = 'A';\n</code></pre> <p>In the above example we write directly on the string. Note that if you want to write, you must be sure to ask for <code>WRITE</code> mode.</p> <p>DMA pointers are only valid if no other operations are performed with the key before using the pointer, after the DMA call.</p> <p>Sometimes when we want to manipulate strings directly, we need to change their size as well. For this scope, the <code>RedisModule_StringTruncate</code> function is used. Example:</p> <pre><code>RedisModule_StringTruncate(mykey,1024);\n</code></pre> <p>The function truncates, or enlarges the string as needed, padding it with zero bytes if the previous length is smaller than the new length we request. If the string does not exist since <code>key</code> is associated to an open empty key, a string value is created and associated to the key.</p> <p>Note that every time <code>StringTruncate()</code> is called, we need to re-obtain the DMA pointer again, since the old may be invalid.</p>"},{"location":"8-reference/modules/_index/#list-type-api","title":"List type API","text":"<p>It's possible to push and pop values from list values:</p> <pre><code>int RedisModule_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele);\nRedisModuleString *RedisModule_ListPop(RedisModuleKey *key, int where);\n</code></pre> <p>In both the APIs the <code>where</code> argument specifies if to push or pop from tail or head, using the following macros:</p> <pre><code>REDISMODULE_LIST_HEAD\nREDISMODULE_LIST_TAIL\n</code></pre> <p>Elements returned by <code>RedisModule_ListPop()</code> are like strings created with <code>RedisModule_CreateString()</code>, they must be released with <code>RedisModule_FreeString()</code> or by enabling automatic memory management.</p>"},{"location":"8-reference/modules/_index/#set-type-api","title":"Set type API","text":"<p>Work in progress.</p>"},{"location":"8-reference/modules/_index/#sorted-set-type-api","title":"Sorted set type API","text":"<p>Documentation missing, please refer to the top comments inside <code>module.c</code> for the following functions:</p> <ul> <li><code>RedisModule_ZsetAdd</code></li> <li><code>RedisModule_ZsetIncrby</code></li> <li><code>RedisModule_ZsetScore</code></li> <li><code>RedisModule_ZsetRem</code></li> </ul> <p>And for the sorted set iterator:</p> <ul> <li><code>RedisModule_ZsetRangeStop</code></li> <li><code>RedisModule_ZsetFirstInScoreRange</code></li> <li><code>RedisModule_ZsetLastInScoreRange</code></li> <li><code>RedisModule_ZsetFirstInLexRange</code></li> <li><code>RedisModule_ZsetLastInLexRange</code></li> <li><code>RedisModule_ZsetRangeCurrentElement</code></li> <li><code>RedisModule_ZsetRangeNext</code></li> <li><code>RedisModule_ZsetRangePrev</code></li> <li><code>RedisModule_ZsetRangeEndReached</code></li> </ul>"},{"location":"8-reference/modules/_index/#hash-type-api","title":"Hash type API","text":"<p>Documentation missing, please refer to the top comments inside <code>module.c</code> for the following functions:</p> <ul> <li><code>RedisModule_HashSet</code></li> <li><code>RedisModule_HashGet</code></li> </ul>"},{"location":"8-reference/modules/_index/#iterating-aggregated-values","title":"Iterating aggregated values","text":"<p>Work in progress.</p>"},{"location":"8-reference/modules/_index/#replicating-commands","title":"Replicating commands","text":"<p>If you want to use module commands exactly like normal Redis commands, in the context of replicated Redis instances, or using the AOF file for persistence, it is important for module commands to handle their replication in a consistent way.</p> <p>When using the higher level APIs to invoke commands, replication happens automatically if you use the \"!\" modifier in the format string of <code>RedisModule_Call()</code> as in the following example:</p> <pre><code>reply = RedisModule_Call(ctx,\"INCRBY\",\"!sc\",argv[1],\"10\");\n</code></pre> <p>As you can see the format specifier is <code>\"!sc\"</code>. The bang is not parsed as a format specifier, but it internally flags the command as \"must replicate\".</p> <p>If you use the above programming style, there are no problems. However sometimes things are more complex than that, and you use the low level API. In this case, if there are no side effects in the command execution, and it consistently always performs the same work, what is possible to do is to replicate the command verbatim as the user executed it. To do that, you just need to call the following function:</p> <pre><code>RedisModule_ReplicateVerbatim(ctx);\n</code></pre> <p>When you use the above API, you should not use any other replication function since they are not guaranteed to mix well.</p> <p>However this is not the only option. It's also possible to exactly tell Redis what commands to replicate as the effect of the command execution, using an API similar to <code>RedisModule_Call()</code> but that instead of calling the command sends it to the AOF / replicas stream. Example:</p> <pre><code>RedisModule_Replicate(ctx,\"INCRBY\",\"cl\",\"foo\",my_increment);\n</code></pre> <p>It's possible to call <code>RedisModule_Replicate</code> multiple times, and each will emit a command. All the sequence emitted is wrapped between a <code>MULTI/EXEC</code> transaction, so that the AOF and replication effects are the same as executing a single command.</p> <p>Note that <code>Call()</code> replication and <code>Replicate()</code> replication have a rule, in case you want to mix both forms of replication (not necessarily a good idea if there are simpler approaches). Commands replicated with <code>Call()</code> are always the first emitted in the final <code>MULTI/EXEC</code> block, while all the commands emitted with <code>Replicate()</code> will follow.</p>"},{"location":"8-reference/modules/_index/#automatic-memory-management","title":"Automatic memory management","text":"<p>Normally when writing programs in the C language, programmers need to manage memory manually. This is why the Redis modules API has functions to release strings, close open keys, free replies, and so forth.</p> <p>However given that commands are executed in a contained environment and with a set of strict APIs, Redis is able to provide automatic memory management to modules, at the cost of some performance (most of the time, a very low cost).</p> <p>When automatic memory management is enabled:</p> <ol> <li>You don't need to close open keys.</li> <li>You don't need to free replies.</li> <li>You don't need to free RedisModuleString objects.</li> </ol> <p>However you can still do it, if you want. For example, automatic memory management may be active, but inside a loop allocating a lot of strings, you may still want to free strings no longer used.</p> <p>In order to enable automatic memory management, just call the following function at the start of the command implementation:</p> <pre><code>RedisModule_AutoMemory(ctx);\n</code></pre> <p>Automatic memory management is usually the way to go, however experienced C programmers may not use it in order to gain some speed and memory usage benefit.</p>"},{"location":"8-reference/modules/_index/#allocating-memory-into-modules","title":"Allocating memory into modules","text":"<p>Normal C programs use <code>malloc()</code> and <code>free()</code> in order to allocate and release memory dynamically. While in Redis modules the use of malloc is not technically forbidden, it is a lot better to use the Redis Modules specific functions, that are exact replacements for <code>malloc</code>, <code>free</code>, <code>realloc</code> and <code>strdup</code>. These functions are:</p> <pre><code>void *RedisModule_Alloc(size_t bytes);\nvoid* RedisModule_Realloc(void *ptr, size_t bytes);\nvoid RedisModule_Free(void *ptr);\nvoid RedisModule_Calloc(size_t nmemb, size_t size);\nchar *RedisModule_Strdup(const char *str);\n</code></pre> <p>They work exactly like their <code>libc</code> equivalent calls, however they use the same allocator Redis uses, and the memory allocated using these functions is reported by the <code>INFO</code> command in the memory section, is accounted when enforcing the <code>maxmemory</code> policy, and in general is a first citizen of the Redis executable. On the contrary, the method allocated inside modules with libc <code>malloc()</code> is transparent to Redis.</p> <p>Another reason to use the modules functions in order to allocate memory is that, when creating native data types inside modules, the RDB loading functions can return deserialized strings (from the RDB file) directly as <code>RedisModule_Alloc()</code> allocations, so they can be used directly to populate data structures after loading, instead of having to copy them to the data structure.</p>"},{"location":"8-reference/modules/_index/#pool-allocator","title":"Pool allocator","text":"<p>Sometimes in commands implementations, it is required to perform many small allocations that will be not retained at the end of the command execution, but are just functional to execute the command itself.</p> <p>This work can be more easily accomplished using the Redis pool allocator:</p> <pre><code>void *RedisModule_PoolAlloc(RedisModuleCtx *ctx, size_t bytes);\n</code></pre> <p>It works similarly to <code>malloc()</code>, and returns memory aligned to the next power of two of greater or equal to <code>bytes</code> (for a maximum alignment of 8 bytes). However it allocates memory in blocks, so it the overhead of the allocations is small, and more important, the memory allocated is automatically released when the command returns.</p> <p>So in general short living allocations are a good candidates for the pool allocator.</p>"},{"location":"8-reference/modules/_index/#writing-commands-compatible-with-redis-cluster","title":"Writing commands compatible with Redis Cluster","text":"<p>Documentation missing, please check the following functions inside <code>module.c</code>:</p> <pre><code>RedisModule_IsKeysPositionRequest(ctx);\nRedisModule_KeyAtPos(ctx,pos);\n</code></pre>"},{"location":"8-reference/modules/modules-api-ref/","title":"Modules API reference","text":""},{"location":"8-reference/modules/modules-api-ref/#sections","title":"Sections","text":"<ul> <li>Heap allocation raw functions</li> <li>Commands API</li> <li>Module information and time measurement</li> <li>Automatic memory management for modules</li> <li>String objects APIs</li> <li>Reply APIs</li> <li>Commands replication API</li> <li>DB and Key APIs \u2013 Generic API</li> <li>Key API for String type</li> <li>Key API for List type</li> <li>Key API for Sorted Set type</li> <li>Key API for Sorted Set iterator</li> <li>Key API for Hash type</li> <li>Key API for Stream type</li> <li>Calling Redis commands from modules</li> <li>Modules data types</li> <li>RDB loading and saving functions</li> <li>Key digest API (DEBUG DIGEST interface for modules types)</li> <li>AOF API for modules data types</li> <li>IO context handling</li> <li>Logging</li> <li>Blocking clients from modules</li> <li>Thread Safe Contexts</li> <li>Module Keyspace Notifications API</li> <li>Modules Cluster API</li> <li>Modules Timers API</li> <li>Modules EventLoop API</li> <li>Modules ACL API</li> <li>Modules Dictionary API</li> <li>Modules Info fields</li> <li>Modules utility APIs</li> <li>Modules API exporting / importing</li> <li>Module Command Filter API</li> <li>Scanning keyspace and hashes</li> <li>Module fork API</li> <li>Server hooks implementation</li> <li>Module Configurations API</li> <li>RDB load/save API</li> <li>Key eviction API</li> <li>Miscellaneous APIs</li> <li>Defrag API</li> <li>Function index</li> </ul>"},{"location":"8-reference/modules/modules-api-ref/#heap-allocation-raw-functions","title":"Heap allocation raw functions","text":"<p>Memory allocated with these functions are taken into account by Redis key eviction algorithms and are reported in Redis memory usage information.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_alloc","title":"<code>RedisModule_Alloc</code>","text":"<pre><code>void *RedisModule_Alloc(size_t bytes);\n</code></pre> <p>Available since: 4.0.0</p> <p>Use like <code>malloc()</code>. Memory allocated with this function is reported in Redis INFO memory, used for keys eviction according to maxmemory settings and in general is taken into account as memory allocated by Redis. You should avoid using <code>malloc()</code>. This function panics if unable to allocate enough memory.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_tryalloc","title":"<code>RedisModule_TryAlloc</code>","text":"<pre><code>void *RedisModule_TryAlloc(size_t bytes);\n</code></pre> <p>Available since: 7.0.0</p> <p>Similar to <code>RedisModule_Alloc</code>, but returns NULL in case of allocation failure, instead of panicking.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_calloc","title":"<code>RedisModule_Calloc</code>","text":"<pre><code>void *RedisModule_Calloc(size_t nmemb, size_t size);\n</code></pre> <p>Available since: 4.0.0</p> <p>Use like <code>calloc()</code>. Memory allocated with this function is reported in Redis INFO memory, used for keys eviction according to maxmemory settings and in general is taken into account as memory allocated by Redis. You should avoid using <code>calloc()</code> directly.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_realloc","title":"<code>RedisModule_Realloc</code>","text":"<pre><code>void* RedisModule_Realloc(void *ptr, size_t bytes);\n</code></pre> <p>Available since: 4.0.0</p> <p>Use like <code>realloc()</code> for memory obtained with <code>RedisModule_Alloc()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_free","title":"<code>RedisModule_Free</code>","text":"<pre><code>void RedisModule_Free(void *ptr);\n</code></pre> <p>Available since: 4.0.0</p> <p>Use like <code>free()</code> for memory obtained by <code>RedisModule_Alloc()</code> and <code>RedisModule_Realloc()</code>. However you should never try to free with <code>RedisModule_Free()</code> memory allocated with <code>malloc()</code> inside your module.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_strdup","title":"<code>RedisModule_Strdup</code>","text":"<pre><code>char *RedisModule_Strdup(const char *str);\n</code></pre> <p>Available since: 4.0.0</p> <p>Like <code>strdup()</code> but returns memory allocated with <code>RedisModule_Alloc()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_poolalloc","title":"<code>RedisModule_PoolAlloc</code>","text":"<pre><code>void *RedisModule_PoolAlloc(RedisModuleCtx *ctx, size_t bytes);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return heap allocated memory that will be freed automatically when the module callback function returns. Mostly suitable for small allocations that are short living and must be released when the callback returns anyway. The returned memory is aligned to the architecture word size if at least word size bytes are requested, otherwise it is just aligned to the next power of two, so for example a 3 bytes request is 4 bytes aligned while a 2 bytes request is 2 bytes aligned.</p> <p>There is no realloc style function since when this is needed to use the pool allocator is not a good idea.</p> <p>The function returns NULL if <code>bytes</code> is 0.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#commands-api","title":"Commands API","text":"<p>These functions are used to implement custom Redis commands.</p> <p>For examples, see https://redis.io/topics/modules-intro.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_iskeyspositionrequest","title":"<code>RedisModule_IsKeysPositionRequest</code>","text":"<pre><code>int RedisModule_IsKeysPositionRequest(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return non-zero if a module command, that was declared with the flag \"getkeys-api\", is called in a special way to get the keys positions and not to get executed. Otherwise zero is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_keyatposwithflags","title":"<code>RedisModule_KeyAtPosWithFlags</code>","text":"<pre><code>void RedisModule_KeyAtPosWithFlags(RedisModuleCtx *ctx, int pos, int flags);\n</code></pre> <p>Available since: 7.0.0</p> <p>When a module command is called in order to obtain the position of keys, since it was flagged as \"getkeys-api\" during the registration, the command implementation checks for this special call using the <code>RedisModule_IsKeysPositionRequest()</code> API and uses this function in order to report keys.</p> <p>The supported flags are the ones used by <code>RedisModule_SetCommandInfo</code>, see <code>REDISMODULE_CMD_KEY_</code>*.</p> <p>The following is an example of how it could be used:</p> <pre><code>if (RedisModule_IsKeysPositionRequest(ctx)) {\n    RedisModule_KeyAtPosWithFlags(ctx, 2, REDISMODULE_CMD_KEY_RO | REDISMODULE_CMD_KEY_ACCESS);\n    RedisModule_KeyAtPosWithFlags(ctx, 1, REDISMODULE_CMD_KEY_RW | REDISMODULE_CMD_KEY_UPDATE | REDISMODULE_CMD_KEY_ACCESS);\n}\n</code></pre> <p>Note: in the example above the get keys API could have been handled by key-specs (preferred).  Implementing the getkeys-api is required only when is it not possible to declare key-specs that cover all keys.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_keyatpos","title":"<code>RedisModule_KeyAtPos</code>","text":"<pre><code>void RedisModule_KeyAtPos(RedisModuleCtx *ctx, int pos);\n</code></pre> <p>Available since: 4.0.0</p> <p>This API existed before <code>RedisModule_KeyAtPosWithFlags</code> was added, now deprecated and can be used for compatibility with older versions, before key-specs and flags were introduced.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_ischannelspositionrequest","title":"<code>RedisModule_IsChannelsPositionRequest</code>","text":"<pre><code>int RedisModule_IsChannelsPositionRequest(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 7.0.0</p> <p>Return non-zero if a module command, that was declared with the flag \"getchannels-api\", is called in a special way to get the channel positions and not to get executed. Otherwise zero is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_channelatposwithflags","title":"<code>RedisModule_ChannelAtPosWithFlags</code>","text":"<pre><code>void RedisModule_ChannelAtPosWithFlags(RedisModuleCtx *ctx,\n                                       int pos,\n                                       int flags);\n</code></pre> <p>Available since: 7.0.0</p> <p>When a module command is called in order to obtain the position of channels, since it was flagged as \"getchannels-api\" during the registration, the command implementation checks for this special call using the <code>RedisModule_IsChannelsPositionRequest()</code> API and uses this function in order to report the channels.</p> <p>The supported flags are: * <code>REDISMODULE_CMD_CHANNEL_SUBSCRIBE</code>: This command will subscribe to the channel. * <code>REDISMODULE_CMD_CHANNEL_UNSUBSCRIBE</code>: This command will unsubscribe from this channel. * <code>REDISMODULE_CMD_CHANNEL_PUBLISH</code>: This command will publish to this channel. * <code>REDISMODULE_CMD_CHANNEL_PATTERN</code>: Instead of acting on a specific channel, will act on any                                     channel specified by the pattern. This is the same access                                    used by the PSUBSCRIBE and PUNSUBSCRIBE commands available                                     in Redis. Not intended to be used with PUBLISH permissions.</p> <p>The following is an example of how it could be used:</p> <pre><code>if (RedisModule_IsChannelsPositionRequest(ctx)) {\n    RedisModule_ChannelAtPosWithFlags(ctx, 1, REDISMODULE_CMD_CHANNEL_SUBSCRIBE | REDISMODULE_CMD_CHANNEL_PATTERN);\n    RedisModule_ChannelAtPosWithFlags(ctx, 1, REDISMODULE_CMD_CHANNEL_PUBLISH);\n}\n</code></pre> <p>Note: One usage of declaring channels is for evaluating ACL permissions. In this context, unsubscribing is always allowed, so commands will only be checked against subscribe and publish permissions. This is preferred over using <code>RedisModule_ACLCheckChannelPermissions</code>, since it allows the ACLs to be checked before the command is executed.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_createcommand","title":"<code>RedisModule_CreateCommand</code>","text":"<pre><code>int RedisModule_CreateCommand(RedisModuleCtx *ctx,\n                              const char *name,\n                              RedisModuleCmdFunc cmdfunc,\n                              const char *strflags,\n                              int firstkey,\n                              int lastkey,\n                              int keystep);\n</code></pre> <p>Available since: 4.0.0</p> <p>Register a new command in the Redis server, that will be handled by calling the function pointer 'cmdfunc' using the RedisModule calling convention.</p> <p>The function returns <code>REDISMODULE_ERR</code> in these cases: - If creation of module command is called outside the <code>RedisModule_OnLoad</code>. - The specified command is already busy. - The command name contains some chars that are not allowed. - A set of invalid flags were passed.</p> <p>Otherwise <code>REDISMODULE_OK</code> is returned and the new command is registered.</p> <p>This function must be called during the initialization of the module inside the <code>RedisModule_OnLoad()</code> function. Calling this function outside of the initialization function is not defined.</p> <p>The command function type is the following:</p> <pre><code> int MyCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);\n</code></pre> <p>And is supposed to always return <code>REDISMODULE_OK</code>.</p> <p>The set of flags 'strflags' specify the behavior of the command, and should be passed as a C string composed of space separated words, like for example \"write deny-oom\". The set of flags are:</p> <ul> <li>\"write\":     The command may modify the data set (it may also read                    from it).</li> <li>\"readonly\":  The command returns data from keys but never writes.</li> <li>\"admin\":     The command is an administrative command (may change                    replication or perform similar tasks).</li> <li>\"deny-oom\":  The command may use additional memory and should be                    denied during out of memory conditions.</li> <li>\"deny-script\":   Don't allow this command in Lua scripts.</li> <li>\"allow-loading\": Allow this command while the server is loading data.                        Only commands not interacting with the data set                        should be allowed to run in this mode. If not sure                        don't use this flag.</li> <li>\"pubsub\":    The command publishes things on Pub/Sub channels.</li> <li>\"random\":    The command may have different outputs even starting                    from the same input arguments and key values.                    Starting from Redis 7.0 this flag has been deprecated.                    Declaring a command as \"random\" can be done using                    command tips, see https://redis.io/topics/command-tips.</li> <li>\"allow-stale\": The command is allowed to run on slaves that don't                      serve stale data. Don't use if you don't know what                      this means.</li> <li>\"no-monitor\": Don't propagate the command on monitor. Use this if                     the command has sensitive data among the arguments.</li> <li>\"no-slowlog\": Don't log this command in the slowlog. Use this if                     the command has sensitive data among the arguments.</li> <li>\"fast\":      The command time complexity is not greater                    than O(log(N)) where N is the size of the collection or                    anything else representing the normal scalability                    issue with the command.</li> <li>\"getkeys-api\": The command implements the interface to return                      the arguments that are keys. Used when start/stop/step                      is not enough because of the command syntax.</li> <li>\"no-cluster\": The command should not register in Redis Cluster                     since is not designed to work with it because, for                     example, is unable to report the position of the                     keys, programmatically creates key names, or any                     other reason.</li> <li>\"no-auth\":    This command can be run by an un-authenticated client.                     Normally this is used by a command that is used                     to authenticate a client.</li> <li>\"may-replicate\": This command may generate replication traffic, even                        though it's not a write command.</li> <li>\"no-mandatory-keys\": All the keys this command may take are optional</li> <li>\"blocking\": The command has the potential to block the client.</li> <li>\"allow-busy\": Permit the command while the server is blocked either by                     a script or by a slow module command, see                     RedisModule_Yield.</li> <li>\"getchannels-api\": The command implements the interface to return                          the arguments that are channels.</li> </ul> <p>The last three parameters specify which arguments of the new command are Redis keys. See https://redis.io/commands/command for more information.</p> <ul> <li><code>firstkey</code>: One-based index of the first argument that's a key.               Position 0 is always the command name itself.               0 for commands with no keys.</li> <li><code>lastkey</code>:  One-based index of the last argument that's a key.               Negative numbers refer to counting backwards from the last               argument (-1 means the last argument provided)               0 for commands with no keys.</li> <li><code>keystep</code>:  Step between first and last key indexes.               0 for commands with no keys.</li> </ul> <p>This information is used by ACL, Cluster and the <code>COMMAND</code> command.</p> <p>NOTE: The scheme described above serves a limited purpose and can only be used to find keys that exist at constant indices. For non-trivial key arguments, you may pass 0,0,0 and use <code>RedisModule_SetCommandInfo</code> to set key specs using a more advanced scheme and use <code>RedisModule_SetCommandACLCategories</code> to set Redis ACL categories of the commands.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getcommand","title":"<code>RedisModule_GetCommand</code>","text":"<pre><code>RedisModuleCommand *RedisModule_GetCommand(RedisModuleCtx *ctx,\n                                           const char *name);\n</code></pre> <p>Available since: 7.0.0</p> <p>Get an opaque structure, representing a module command, by command name. This structure is used in some of the command-related APIs.</p> <p>NULL is returned in case of the following errors:</p> <ul> <li>Command not found</li> <li>The command is not a module command</li> <li>The command doesn't belong to the calling module</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_createsubcommand","title":"<code>RedisModule_CreateSubcommand</code>","text":"<pre><code>int RedisModule_CreateSubcommand(RedisModuleCommand *parent,\n                                 const char *name,\n                                 RedisModuleCmdFunc cmdfunc,\n                                 const char *strflags,\n                                 int firstkey,\n                                 int lastkey,\n                                 int keystep);\n</code></pre> <p>Available since: 7.0.0</p> <p>Very similar to <code>RedisModule_CreateCommand</code> except that it is used to create a subcommand, associated with another, container, command.</p> <p>Example: If a module has a configuration command, MODULE.CONFIG, then GET and SET should be individual subcommands, while MODULE.CONFIG is a command, but should not be registered with a valid <code>funcptr</code>:</p> <pre><code> if (RedisModule_CreateCommand(ctx,\"module.config\",NULL,\"\",0,0,0) == REDISMODULE_ERR)\n     return REDISMODULE_ERR;\n\n RedisModuleCommand *parent = RedisModule_GetCommand(ctx,,\"module.config\");\n\n if (RedisModule_CreateSubcommand(parent,\"set\",cmd_config_set,\"\",0,0,0) == REDISMODULE_ERR)\n    return REDISMODULE_ERR;\n\n if (RedisModule_CreateSubcommand(parent,\"get\",cmd_config_get,\"\",0,0,0) == REDISMODULE_ERR)\n    return REDISMODULE_ERR;\n</code></pre> <p>Returns <code>REDISMODULE_OK</code> on success and <code>REDISMODULE_ERR</code> in case of the following errors:</p> <ul> <li>Error while parsing <code>strflags</code></li> <li>Command is marked as <code>no-cluster</code> but cluster mode is enabled</li> <li><code>parent</code> is already a subcommand (we do not allow more than one level of command nesting)</li> <li><code>parent</code> is a command with an implementation (<code>RedisModuleCmdFunc</code>) (A parent command should be a pure container of subcommands)</li> <li><code>parent</code> already has a subcommand called <code>name</code></li> <li>Creating a subcommand is called outside of <code>RedisModule_OnLoad</code>.</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_setcommandaclcategories","title":"<code>RedisModule_SetCommandACLCategories</code>","text":"<pre><code>int RedisModule_SetCommandACLCategories(RedisModuleCommand *command,\n                                        const char *aclflags);\n</code></pre> <p>Available since: 7.2.0</p> <p><code>RedisModule_SetCommandACLCategories</code> can be used to set ACL categories to module commands and subcommands. The set of ACL categories should be passed as a space separated C string 'aclflags'.</p> <p>Example, the acl flags 'write slow' marks the command as part of the write and  slow ACL categories.</p> <p>On success <code>REDISMODULE_OK</code> is returned. On error <code>REDISMODULE_ERR</code> is returned.</p> <p>This function can only be called during the <code>RedisModule_OnLoad</code> function. If called outside of this function, an error is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_setcommandinfo","title":"<code>RedisModule_SetCommandInfo</code>","text":"<pre><code>int RedisModule_SetCommandInfo(RedisModuleCommand *command,\n                               const RedisModuleCommandInfo *info);\n</code></pre> <p>Available since: 7.0.0</p> <p>Set additional command information.</p> <p>Affects the output of <code>COMMAND</code>, <code>COMMAND INFO</code> and <code>COMMAND DOCS</code>, Cluster, ACL and is used to filter commands with the wrong number of arguments before the call reaches the module code.</p> <p>This function can be called after creating a command using <code>RedisModule_CreateCommand</code> and fetching the command pointer using <code>RedisModule_GetCommand</code>. The information can only be set once for each command and has the following structure:</p> <pre><code>typedef struct RedisModuleCommandInfo {\n    const RedisModuleCommandInfoVersion *version;\n    const char *summary;\n    const char *complexity;\n    const char *since;\n    RedisModuleCommandHistoryEntry *history;\n    const char *tips;\n    int arity;\n    RedisModuleCommandKeySpec *key_specs;\n    RedisModuleCommandArg *args;\n} RedisModuleCommandInfo;\n</code></pre> <p>All fields except <code>version</code> are optional. Explanation of the fields:</p> <ul> <li> <p><code>version</code>: This field enables compatibility with different Redis versions.   Always set this field to <code>REDISMODULE_COMMAND_INFO_VERSION</code>.</p> </li> <li> <p><code>summary</code>: A short description of the command (optional).</p> </li> <li> <p><code>complexity</code>: Complexity description (optional).</p> </li> <li> <p><code>since</code>: The version where the command was introduced (optional).   Note: The version specified should be the module's, not Redis version.</p> </li> <li> <p><code>history</code>: An array of <code>RedisModuleCommandHistoryEntry</code> (optional), which is   a struct with the following fields:</p> <pre><code>const char *since;\nconst char *changes;\n</code></pre> <p><code>since</code> is a version string and <code>changes</code> is a string describing the changes. The array is terminated by a zeroed entry, i.e. an entry with both strings set to NULL.</p> </li> <li> <p><code>tips</code>: A string of space-separated tips regarding this command, meant for   clients and proxies. See https://redis.io/topics/command-tips.</p> </li> <li> <p><code>arity</code>: Number of arguments, including the command name itself. A positive   number specifies an exact number of arguments and a negative number   specifies a minimum number of arguments, so use -N to say &gt;= N. Redis   validates a call before passing it to a module, so this can replace an   arity check inside the module command implementation. A value of 0 (or an   omitted arity field) is equivalent to -2 if the command has sub commands   and -1 otherwise.</p> </li> <li> <p><code>key_specs</code>: An array of <code>RedisModuleCommandKeySpec</code>, terminated by an   element memset to zero. This is a scheme that tries to describe the   positions of key arguments better than the old <code>RedisModule_CreateCommand</code> arguments   <code>firstkey</code>, <code>lastkey</code>, <code>keystep</code> and is needed if those three are not   enough to describe the key positions. There are two steps to retrieve key   positions: begin search (BS) in which index should find the first key and   find keys (FK) which, relative to the output of BS, describes how can we   will which arguments are keys. Additionally, there are key specific flags.</p> <p>Key-specs cause the triplet (firstkey, lastkey, keystep) given in RedisModule_CreateCommand to be recomputed, but it is still useful to provide these three parameters in RedisModule_CreateCommand, to better support old Redis versions where RedisModule_SetCommandInfo is not available.</p> <p>Note that key-specs don't fully replace the \"getkeys-api\" (see RedisModule_CreateCommand, RedisModule_IsKeysPositionRequest and RedisModule_KeyAtPosWithFlags) so it may be a good idea to supply both key-specs and implement the getkeys-api.</p> <p>A key-spec has the following structure:</p> <pre><code>typedef struct RedisModuleCommandKeySpec {\n    const char *notes;\n    uint64_t flags;\n    RedisModuleKeySpecBeginSearchType begin_search_type;\n    union {\n        struct {\n            int pos;\n        } index;\n        struct {\n            const char *keyword;\n            int startfrom;\n        } keyword;\n    } bs;\n    RedisModuleKeySpecFindKeysType find_keys_type;\n    union {\n        struct {\n            int lastkey;\n            int keystep;\n            int limit;\n        } range;\n        struct {\n            int keynumidx;\n            int firstkey;\n            int keystep;\n        } keynum;\n    } fk;\n} RedisModuleCommandKeySpec;\n</code></pre> <p>Explanation of the fields of RedisModuleCommandKeySpec:</p> <ul> <li> <p><code>notes</code>: Optional notes or clarifications about this key spec.</p> </li> <li> <p><code>flags</code>: A bitwise or of key-spec flags described below.</p> </li> <li> <p><code>begin_search_type</code>: This describes how the first key is discovered.   There are two ways to determine the first key:</p> <ul> <li><code>REDISMODULE_KSPEC_BS_UNKNOWN</code>: There is no way to tell where the   key args start.</li> <li><code>REDISMODULE_KSPEC_BS_INDEX</code>: Key args start at a constant index.</li> <li><code>REDISMODULE_KSPEC_BS_KEYWORD</code>: Key args start just after a   specific keyword.</li> </ul> </li> <li> <p><code>bs</code>: This is a union in which the <code>index</code> or <code>keyword</code> branch is used   depending on the value of the <code>begin_search_type</code> field.</p> <ul> <li> <p><code>bs.index.pos</code>: The index from which we start the search for keys.   (<code>REDISMODULE_KSPEC_BS_INDEX</code> only.)</p> </li> <li> <p><code>bs.keyword.keyword</code>: The keyword (string) that indicates the   beginning of key arguments. (<code>REDISMODULE_KSPEC_BS_KEYWORD</code> only.)</p> </li> <li> <p><code>bs.keyword.startfrom</code>: An index in argv from which to start   searching. Can be negative, which means start search from the end,   in reverse. Example: -2 means to start in reverse from the   penultimate argument. (<code>REDISMODULE_KSPEC_BS_KEYWORD</code> only.)</p> </li> </ul> </li> <li> <p><code>find_keys_type</code>: After the \"begin search\", this describes which   arguments are keys. The strategies are:</p> <ul> <li><code>REDISMODULE_KSPEC_BS_UNKNOWN</code>: There is no way to tell where the   key args are located.</li> <li><code>REDISMODULE_KSPEC_FK_RANGE</code>: Keys end at a specific index (or   relative to the last argument).</li> <li><code>REDISMODULE_KSPEC_FK_KEYNUM</code>: There's an argument that contains   the number of key args somewhere before the keys themselves.</li> </ul> </li> </ul> <p><code>find_keys_type</code> and <code>fk</code> can be omitted if this keyspec describes   exactly one key.</p> <ul> <li> <p><code>fk</code>: This is a union in which the <code>range</code> or <code>keynum</code> branch is used   depending on the value of the <code>find_keys_type</code> field.</p> <ul> <li> <p><code>fk.range</code> (for <code>REDISMODULE_KSPEC_FK_RANGE</code>): A struct with the   following fields:</p> <ul> <li> <p><code>lastkey</code>: Index of the last key relative to the result of the   begin search step. Can be negative, in which case it's not   relative. -1 indicates the last argument, -2 one before the   last and so on.</p> </li> <li> <p><code>keystep</code>: How many arguments should we skip after finding a   key, in order to find the next one?</p> </li> <li> <p><code>limit</code>: If <code>lastkey</code> is -1, we use <code>limit</code> to stop the search   by a factor. 0 and 1 mean no limit. 2 means 1/2 of the   remaining args, 3 means 1/3, and so on.</p> </li> </ul> </li> <li> <p><code>fk.keynum</code> (for <code>REDISMODULE_KSPEC_FK_KEYNUM</code>): A struct with the   following fields:</p> <ul> <li> <p><code>keynumidx</code>: Index of the argument containing the number of   keys to come, relative to the result of the begin search step.</p> </li> <li> <p><code>firstkey</code>: Index of the fist key relative to the result of the   begin search step. (Usually it's just after <code>keynumidx</code>, in   which case it should be set to <code>keynumidx + 1</code>.)</p> </li> <li> <p><code>keystep</code>: How many arguments should we skip after finding a   key, in order to find the next one?</p> </li> </ul> </li> </ul> </li> </ul> <p>Key-spec flags:</p> <p>The first four refer to what the command actually does with the value or metadata of the key, and not necessarily the user data or how it affects it. Each key-spec may must have exactly one of these. Any operation that's not distinctly deletion, overwrite or read-only would be marked as RW.</p> <ul> <li> <p><code>REDISMODULE_CMD_KEY_RO</code>: Read-Only. Reads the value of the key, but   doesn't necessarily return it.</p> </li> <li> <p><code>REDISMODULE_CMD_KEY_RW</code>: Read-Write. Modifies the data stored in the   value of the key or its metadata.</p> </li> <li> <p><code>REDISMODULE_CMD_KEY_OW</code>: Overwrite. Overwrites the data stored in the   value of the key.</p> </li> <li> <p><code>REDISMODULE_CMD_KEY_RM</code>: Deletes the key.</p> </li> </ul> <p>The next four refer to user data inside the value of the key, not the metadata like LRU, type, cardinality. It refers to the logical operation on the user's data (actual input strings or TTL), being used/returned/copied/changed. It doesn't refer to modification or returning of metadata (like type, count, presence of data). ACCESS can be combined with one of the write operations INSERT, DELETE or UPDATE. Any write that's not an INSERT or a DELETE would be UPDATE.</p> <ul> <li> <p><code>REDISMODULE_CMD_KEY_ACCESS</code>: Returns, copies or uses the user data   from the value of the key.</p> </li> <li> <p><code>REDISMODULE_CMD_KEY_UPDATE</code>: Updates data to the value, new value may   depend on the old value.</p> </li> <li> <p><code>REDISMODULE_CMD_KEY_INSERT</code>: Adds data to the value with no chance of   modification or deletion of existing data.</p> </li> <li> <p><code>REDISMODULE_CMD_KEY_DELETE</code>: Explicitly deletes some content from the   value of the key.</p> </li> </ul> <p>Other flags:</p> <ul> <li> <p><code>REDISMODULE_CMD_KEY_NOT_KEY</code>: The key is not actually a key, but    should be routed in cluster mode as if it was a key.</p> </li> <li> <p><code>REDISMODULE_CMD_KEY_INCOMPLETE</code>: The keyspec might not point out all   the keys it should cover.</p> </li> <li> <p><code>REDISMODULE_CMD_KEY_VARIABLE_FLAGS</code>: Some keys might have different   flags depending on arguments.</p> </li> </ul> </li> <li> <p><code>args</code>: An array of <code>RedisModuleCommandArg</code>, terminated by an element memset   to zero. <code>RedisModuleCommandArg</code> is a structure with at the fields described   below.</p> <pre><code>typedef struct RedisModuleCommandArg {\n    const char *name;\n    RedisModuleCommandArgType type;\n    int key_spec_index;\n    const char *token;\n    const char *summary;\n    const char *since;\n    int flags;\n    struct RedisModuleCommandArg *subargs;\n} RedisModuleCommandArg;\n</code></pre> <p>Explanation of the fields:</p> <ul> <li> <p><code>name</code>: Name of the argument.</p> </li> <li> <p><code>type</code>: The type of the argument. See below for details. The types   <code>REDISMODULE_ARG_TYPE_ONEOF</code> and <code>REDISMODULE_ARG_TYPE_BLOCK</code> require   an argument to have sub-arguments, i.e. <code>subargs</code>.</p> </li> <li> <p><code>key_spec_index</code>: If the <code>type</code> is <code>REDISMODULE_ARG_TYPE_KEY</code> you must   provide the index of the key-spec associated with this argument. See   <code>key_specs</code> above. If the argument is not a key, you may specify -1.</p> </li> <li> <p><code>token</code>: The token preceding the argument (optional). Example: the   argument <code>seconds</code> in <code>SET</code> has a token <code>EX</code>. If the argument consists   of only a token (for example <code>NX</code> in <code>SET</code>) the type should be   <code>REDISMODULE_ARG_TYPE_PURE_TOKEN</code> and <code>value</code> should be NULL.</p> </li> <li> <p><code>summary</code>: A short description of the argument (optional).</p> </li> <li> <p><code>since</code>: The first version which included this argument (optional).</p> </li> <li> <p><code>flags</code>: A bitwise or of the macros <code>REDISMODULE_CMD_ARG_*</code>. See below.</p> </li> <li> <p><code>value</code>: The display-value of the argument. This string is what should   be displayed when creating the command syntax from the output of   <code>COMMAND</code>. If <code>token</code> is not NULL, it should also be displayed.</p> </li> </ul> <p>Explanation of <code>RedisModuleCommandArgType</code>:</p> <ul> <li><code>REDISMODULE_ARG_TYPE_STRING</code>: String argument.</li> <li><code>REDISMODULE_ARG_TYPE_INTEGER</code>: Integer argument.</li> <li><code>REDISMODULE_ARG_TYPE_DOUBLE</code>: Double-precision float argument.</li> <li><code>REDISMODULE_ARG_TYPE_KEY</code>: String argument representing a keyname.</li> <li><code>REDISMODULE_ARG_TYPE_PATTERN</code>: String, but regex pattern.</li> <li><code>REDISMODULE_ARG_TYPE_UNIX_TIME</code>: Integer, but Unix timestamp.</li> <li><code>REDISMODULE_ARG_TYPE_PURE_TOKEN</code>: Argument doesn't have a placeholder.   It's just a token without a value. Example: the <code>KEEPTTL</code> option of the   <code>SET</code> command.</li> <li><code>REDISMODULE_ARG_TYPE_ONEOF</code>: Used when the user can choose only one of   a few sub-arguments. Requires <code>subargs</code>. Example: the <code>NX</code> and <code>XX</code>   options of <code>SET</code>.</li> <li><code>REDISMODULE_ARG_TYPE_BLOCK</code>: Used when one wants to group together   several sub-arguments, usually to apply something on all of them, like   making the entire group \"optional\". Requires <code>subargs</code>. Example: the   <code>LIMIT offset count</code> parameters in <code>ZRANGE</code>.</li> </ul> <p>Explanation of the command argument flags:</p> <ul> <li><code>REDISMODULE_CMD_ARG_OPTIONAL</code>: The argument is optional (like GET in   the SET command).</li> <li><code>REDISMODULE_CMD_ARG_MULTIPLE</code>: The argument may repeat itself (like   key in DEL).</li> <li><code>REDISMODULE_CMD_ARG_MULTIPLE_TOKEN</code>: The argument may repeat itself,   and so does its token (like <code>GET pattern</code> in SORT).</li> </ul> </li> </ul> <p>On success <code>REDISMODULE_OK</code> is returned. On error <code>REDISMODULE_ERR</code> is returned and <code>errno</code> is set to EINVAL if invalid info was provided or EEXIST if info has already been set. If the info is invalid, a warning is logged explaining which part of the info is invalid and why.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#module-information-and-time-measurement","title":"Module information and time measurement","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_ismodulenamebusy","title":"<code>RedisModule_IsModuleNameBusy</code>","text":"<pre><code>int RedisModule_IsModuleNameBusy(const char *name);\n</code></pre> <p>Available since: 4.0.3</p> <p>Return non-zero if the module name is busy. Otherwise zero is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_milliseconds","title":"<code>RedisModule_Milliseconds</code>","text":"<pre><code>mstime_t RedisModule_Milliseconds(void);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return the current UNIX time in milliseconds.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_monotonicmicroseconds","title":"<code>RedisModule_MonotonicMicroseconds</code>","text":"<pre><code>uint64_t RedisModule_MonotonicMicroseconds(void);\n</code></pre> <p>Available since: 7.0.0</p> <p>Return counter of micro-seconds relative to an arbitrary point in time.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_microseconds","title":"<code>RedisModule_Microseconds</code>","text":"<pre><code>ustime_t RedisModule_Microseconds(void);\n</code></pre> <p>Available since: 7.2.0</p> <p>Return the current UNIX time in microseconds</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_cachedmicroseconds","title":"<code>RedisModule_CachedMicroseconds</code>","text":"<pre><code>ustime_t RedisModule_CachedMicroseconds(void);\n</code></pre> <p>Available since: 7.2.0</p> <p>Return the cached UNIX time in microseconds. It is updated in the server cron job and before executing a command. It is useful for complex call stacks, such as a command causing a key space notification, causing a module to execute a <code>RedisModule_Call</code>, causing another notification, etc. It makes sense that all this callbacks would use the same clock.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_blockedclientmeasuretimestart","title":"<code>RedisModule_BlockedClientMeasureTimeStart</code>","text":"<pre><code>int RedisModule_BlockedClientMeasureTimeStart(RedisModuleBlockedClient *bc);\n</code></pre> <p>Available since: 6.2.0</p> <p>Mark a point in time that will be used as the start time to calculate the elapsed execution time when <code>RedisModule_BlockedClientMeasureTimeEnd()</code> is called. Within the same command, you can call multiple times <code>RedisModule_BlockedClientMeasureTimeStart()</code> and <code>RedisModule_BlockedClientMeasureTimeEnd()</code> to accumulate independent time intervals to the background duration. This method always return <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_blockedclientmeasuretimeend","title":"<code>RedisModule_BlockedClientMeasureTimeEnd</code>","text":"<pre><code>int RedisModule_BlockedClientMeasureTimeEnd(RedisModuleBlockedClient *bc);\n</code></pre> <p>Available since: 6.2.0</p> <p>Mark a point in time that will be used as the end time to calculate the elapsed execution time. On success <code>REDISMODULE_OK</code> is returned. This method only returns <code>REDISMODULE_ERR</code> if no start time was previously defined ( meaning <code>RedisModule_BlockedClientMeasureTimeStart</code> was not called ).</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_yield","title":"<code>RedisModule_Yield</code>","text":"<pre><code>void RedisModule_Yield(RedisModuleCtx *ctx, int flags, const char *busy_reply);\n</code></pre> <p>Available since: 7.0.0</p> <p>This API allows modules to let Redis process background tasks, and some commands during long blocking execution of a module command. The module can call this API periodically. The flags is a bit mask of these:</p> <ul> <li><code>REDISMODULE_YIELD_FLAG_NONE</code>: No special flags, can perform some background                                  operations, but not process client commands.</li> <li><code>REDISMODULE_YIELD_FLAG_CLIENTS</code>: Redis can also process client commands.</li> </ul> <p>The <code>busy_reply</code> argument is optional, and can be used to control the verbose error string after the <code>-BUSY</code> error code.</p> <p>When the <code>REDISMODULE_YIELD_FLAG_CLIENTS</code> is used, Redis will only start processing client commands after the time defined by the <code>busy-reply-threshold</code> config, in which case Redis will start rejecting most commands with <code>-BUSY</code> error, but allow the ones marked with the <code>allow-busy</code> flag to be executed. This API can also be used in thread safe context (while locked), and during loading (in the <code>rdb_load</code> callback, in which case it'll reject commands with the -LOADING error)</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_setmoduleoptions","title":"<code>RedisModule_SetModuleOptions</code>","text":"<pre><code>void RedisModule_SetModuleOptions(RedisModuleCtx *ctx, int options);\n</code></pre> <p>Available since: 6.0.0</p> <p>Set flags defining capabilities or behavior bit flags.</p> <p><code>REDISMODULE_OPTIONS_HANDLE_IO_ERRORS</code>: Generally, modules don't need to bother with this, as the process will just terminate if a read error happens, however, setting this flag would allow repl-diskless-load to work if enabled. The module should use <code>RedisModule_IsIOError</code> after reads, before using the data that was read, and in case of error, propagate it upwards, and also be able to release the partially populated value and all it's allocations.</p> <p><code>REDISMODULE_OPTION_NO_IMPLICIT_SIGNAL_MODIFIED</code>: See <code>RedisModule_SignalModifiedKey()</code>.</p> <p><code>REDISMODULE_OPTIONS_HANDLE_REPL_ASYNC_LOAD</code>: Setting this flag indicates module awareness of diskless async replication (repl-diskless-load=swapdb) and that redis could be serving reads during replication instead of blocking with LOADING status.</p> <p><code>REDISMODULE_OPTIONS_ALLOW_NESTED_KEYSPACE_NOTIFICATIONS</code>: Declare that the module wants to get nested key-space notifications. By default, Redis will not fire key-space notifications that happened inside a key-space notification callback. This flag allows to change this behavior and fire nested key-space notifications. Notice: if enabled, the module should protected itself from infinite recursion.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_signalmodifiedkey","title":"<code>RedisModule_SignalModifiedKey</code>","text":"<pre><code>int RedisModule_SignalModifiedKey(RedisModuleCtx *ctx,\n                                  RedisModuleString *keyname);\n</code></pre> <p>Available since: 6.0.0</p> <p>Signals that the key is modified from user's perspective (i.e. invalidate WATCH and client side caching).</p> <p>This is done automatically when a key opened for writing is closed, unless the option <code>REDISMODULE_OPTION_NO_IMPLICIT_SIGNAL_MODIFIED</code> has been set using <code>RedisModule_SetModuleOptions()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#automatic-memory-management-for-modules","title":"Automatic memory management for modules","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_automemory","title":"<code>RedisModule_AutoMemory</code>","text":"<pre><code>void RedisModule_AutoMemory(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 4.0.0</p> <p>Enable automatic memory management.</p> <p>The function must be called as the first function of a command implementation that wants to use automatic memory.</p> <p>When enabled, automatic memory management tracks and automatically frees keys, call replies and Redis string objects once the command returns. In most cases this eliminates the need of calling the following functions:</p> <ol> <li><code>RedisModule_CloseKey()</code></li> <li><code>RedisModule_FreeCallReply()</code></li> <li><code>RedisModule_FreeString()</code></li> </ol> <p>These functions can still be used with automatic memory management enabled, to optimize loops that make numerous allocations for example.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#string-objects-apis","title":"String objects APIs","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_createstring","title":"<code>RedisModule_CreateString</code>","text":"<pre><code>RedisModuleString *RedisModule_CreateString(RedisModuleCtx *ctx,\n                                            const char *ptr,\n                                            size_t len);\n</code></pre> <p>Available since: 4.0.0</p> <p>Create a new module string object. The returned string must be freed with <code>RedisModule_FreeString()</code>, unless automatic memory is enabled.</p> <p>The string is created by copying the <code>len</code> bytes starting at <code>ptr</code>. No reference is retained to the passed buffer.</p> <p>The module context 'ctx' is optional and may be NULL if you want to create a string out of the context scope. However in that case, the automatic memory management will not be available, and the string memory must be managed manually.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_createstringprintf","title":"<code>RedisModule_CreateStringPrintf</code>","text":"<pre><code>RedisModuleString *RedisModule_CreateStringPrintf(RedisModuleCtx *ctx,\n                                                  const char *fmt,\n                                                  ...);\n</code></pre> <p>Available since: 4.0.0</p> <p>Create a new module string object from a printf format and arguments. The returned string must be freed with <code>RedisModule_FreeString()</code>, unless automatic memory is enabled.</p> <p>The string is created using the sds formatter function <code>sdscatvprintf()</code>.</p> <p>The passed context 'ctx' may be NULL if necessary, see the <code>RedisModule_CreateString()</code> documentation for more info.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_createstringfromlonglong","title":"<code>RedisModule_CreateStringFromLongLong</code>","text":"<pre><code>RedisModuleString *RedisModule_CreateStringFromLongLong(RedisModuleCtx *ctx,\n                                                        long long ll);\n</code></pre> <p>Available since: 4.0.0</p> <p>Like <code>RedisModule_CreateString()</code>, but creates a string starting from a <code>long long</code> integer instead of taking a buffer and its length.</p> <p>The returned string must be released with <code>RedisModule_FreeString()</code> or by enabling automatic memory management.</p> <p>The passed context 'ctx' may be NULL if necessary, see the <code>RedisModule_CreateString()</code> documentation for more info.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_createstringfromulonglong","title":"<code>RedisModule_CreateStringFromULongLong</code>","text":"<pre><code>RedisModuleString *RedisModule_CreateStringFromULongLong(RedisModuleCtx *ctx,\n                                                         unsigned long long ull);\n</code></pre> <p>Available since: 7.0.3</p> <p>Like <code>RedisModule_CreateString()</code>, but creates a string starting from a <code>unsigned long long</code> integer instead of taking a buffer and its length.</p> <p>The returned string must be released with <code>RedisModule_FreeString()</code> or by enabling automatic memory management.</p> <p>The passed context 'ctx' may be NULL if necessary, see the <code>RedisModule_CreateString()</code> documentation for more info.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_createstringfromdouble","title":"<code>RedisModule_CreateStringFromDouble</code>","text":"<pre><code>RedisModuleString *RedisModule_CreateStringFromDouble(RedisModuleCtx *ctx,\n                                                      double d);\n</code></pre> <p>Available since: 6.0.0</p> <p>Like <code>RedisModule_CreateString()</code>, but creates a string starting from a double instead of taking a buffer and its length.</p> <p>The returned string must be released with <code>RedisModule_FreeString()</code> or by enabling automatic memory management.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_createstringfromlongdouble","title":"<code>RedisModule_CreateStringFromLongDouble</code>","text":"<pre><code>RedisModuleString *RedisModule_CreateStringFromLongDouble(RedisModuleCtx *ctx,\n                                                          long double ld,\n                                                          int humanfriendly);\n</code></pre> <p>Available since: 6.0.0</p> <p>Like <code>RedisModule_CreateString()</code>, but creates a string starting from a long double.</p> <p>The returned string must be released with <code>RedisModule_FreeString()</code> or by enabling automatic memory management.</p> <p>The passed context 'ctx' may be NULL if necessary, see the <code>RedisModule_CreateString()</code> documentation for more info.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_createstringfromstring","title":"<code>RedisModule_CreateStringFromString</code>","text":"<pre><code>RedisModuleString *RedisModule_CreateStringFromString(RedisModuleCtx *ctx,\n                                                      const RedisModuleString *str);\n</code></pre> <p>Available since: 4.0.0</p> <p>Like <code>RedisModule_CreateString()</code>, but creates a string starting from another <code>RedisModuleString</code>.</p> <p>The returned string must be released with <code>RedisModule_FreeString()</code> or by enabling automatic memory management.</p> <p>The passed context 'ctx' may be NULL if necessary, see the <code>RedisModule_CreateString()</code> documentation for more info.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_createstringfromstreamid","title":"<code>RedisModule_CreateStringFromStreamID</code>","text":"<pre><code>RedisModuleString *RedisModule_CreateStringFromStreamID(RedisModuleCtx *ctx,\n                                                        const RedisModuleStreamID *id);\n</code></pre> <p>Available since: 6.2.0</p> <p>Creates a string from a stream ID. The returned string must be released with <code>RedisModule_FreeString()</code>, unless automatic memory is enabled.</p> <p>The passed context <code>ctx</code> may be NULL if necessary. See the <code>RedisModule_CreateString()</code> documentation for more info.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_freestring","title":"<code>RedisModule_FreeString</code>","text":"<pre><code>void RedisModule_FreeString(RedisModuleCtx *ctx, RedisModuleString *str);\n</code></pre> <p>Available since: 4.0.0</p> <p>Free a module string object obtained with one of the Redis modules API calls that return new string objects.</p> <p>It is possible to call this function even when automatic memory management is enabled. In that case the string will be released ASAP and removed from the pool of string to release at the end.</p> <p>If the string was created with a NULL context 'ctx', it is also possible to pass ctx as NULL when releasing the string (but passing a context will not create any issue). Strings created with a context should be freed also passing the context, so if you want to free a string out of context later, make sure to create it using a NULL context.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_retainstring","title":"<code>RedisModule_RetainString</code>","text":"<pre><code>void RedisModule_RetainString(RedisModuleCtx *ctx, RedisModuleString *str);\n</code></pre> <p>Available since: 4.0.0</p> <p>Every call to this function, will make the string 'str' requiring an additional call to <code>RedisModule_FreeString()</code> in order to really free the string. Note that the automatic freeing of the string obtained enabling modules automatic memory management counts for one <code>RedisModule_FreeString()</code> call (it is just executed automatically).</p> <p>Normally you want to call this function when, at the same time the following conditions are true:</p> <ol> <li>You have automatic memory management enabled.</li> <li>You want to create string objects.</li> <li>Those string objects you create need to live after the callback    function(for example a command implementation) creating them returns.</li> </ol> <p>Usually you want this in order to store the created string object into your own data structure, for example when implementing a new data type.</p> <p>Note that when memory management is turned off, you don't need any call to RetainString() since creating a string will always result into a string that lives after the callback function returns, if no FreeString() call is performed.</p> <p>It is possible to call this function with a NULL context.</p> <p>When strings are going to be retained for an extended duration, it is good practice to also call <code>RedisModule_TrimStringAllocation()</code> in order to optimize memory usage.</p> <p>Threaded modules that reference retained strings from other threads must explicitly trim the allocation as soon as the string is retained. Not doing so may result with automatic trimming which is not thread safe.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_holdstring","title":"<code>RedisModule_HoldString</code>","text":"<pre><code>RedisModuleString* RedisModule_HoldString(RedisModuleCtx *ctx,\n                                          RedisModuleString *str);\n</code></pre> <p>Available since: 6.0.7</p> <p>This function can be used instead of <code>RedisModule_RetainString()</code>. The main difference between the two is that this function will always succeed, whereas <code>RedisModule_RetainString()</code> may fail because of an assertion.</p> <p>The function returns a pointer to <code>RedisModuleString</code>, which is owned by the caller. It requires a call to <code>RedisModule_FreeString()</code> to free the string when automatic memory management is disabled for the context. When automatic memory management is enabled, you can either call <code>RedisModule_FreeString()</code> or let the automation free it.</p> <p>This function is more efficient than <code>RedisModule_CreateStringFromString()</code> because whenever possible, it avoids copying the underlying <code>RedisModuleString</code>. The disadvantage of using this function is that it might not be possible to use <code>RedisModule_StringAppendBuffer()</code> on the returned <code>RedisModuleString</code>.</p> <p>It is possible to call this function with a NULL context.</p> <p>When strings are going to be held for an extended duration, it is good practice to also call <code>RedisModule_TrimStringAllocation()</code> in order to optimize memory usage.</p> <p>Threaded modules that reference held strings from other threads must explicitly trim the allocation as soon as the string is held. Not doing so may result with automatic trimming which is not thread safe.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_stringptrlen","title":"<code>RedisModule_StringPtrLen</code>","text":"<pre><code>const char *RedisModule_StringPtrLen(const RedisModuleString *str,\n                                     size_t *len);\n</code></pre> <p>Available since: 4.0.0</p> <p>Given a string module object, this function returns the string pointer and length of the string. The returned pointer and length should only be used for read only accesses and never modified.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_stringtolonglong","title":"<code>RedisModule_StringToLongLong</code>","text":"<pre><code>int RedisModule_StringToLongLong(const RedisModuleString *str, long long *ll);\n</code></pre> <p>Available since: 4.0.0</p> <p>Convert the string into a <code>long long</code> integer, storing it at <code>*ll</code>. Returns <code>REDISMODULE_OK</code> on success. If the string can't be parsed as a valid, strict <code>long long</code> (no spaces before/after), <code>REDISMODULE_ERR</code> is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_stringtoulonglong","title":"<code>RedisModule_StringToULongLong</code>","text":"<pre><code>int RedisModule_StringToULongLong(const RedisModuleString *str,\n                                  unsigned long long *ull);\n</code></pre> <p>Available since: 7.0.3</p> <p>Convert the string into a <code>unsigned long long</code> integer, storing it at <code>*ull</code>. Returns <code>REDISMODULE_OK</code> on success. If the string can't be parsed as a valid, strict <code>unsigned long long</code> (no spaces before/after), <code>REDISMODULE_ERR</code> is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_stringtodouble","title":"<code>RedisModule_StringToDouble</code>","text":"<pre><code>int RedisModule_StringToDouble(const RedisModuleString *str, double *d);\n</code></pre> <p>Available since: 4.0.0</p> <p>Convert the string into a double, storing it at <code>*d</code>. Returns <code>REDISMODULE_OK</code> on success or <code>REDISMODULE_ERR</code> if the string is not a valid string representation of a double value.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_stringtolongdouble","title":"<code>RedisModule_StringToLongDouble</code>","text":"<pre><code>int RedisModule_StringToLongDouble(const RedisModuleString *str,\n                                   long double *ld);\n</code></pre> <p>Available since: 6.0.0</p> <p>Convert the string into a long double, storing it at <code>*ld</code>. Returns <code>REDISMODULE_OK</code> on success or <code>REDISMODULE_ERR</code> if the string is not a valid string representation of a double value.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_stringtostreamid","title":"<code>RedisModule_StringToStreamID</code>","text":"<pre><code>int RedisModule_StringToStreamID(const RedisModuleString *str,\n                                 RedisModuleStreamID *id);\n</code></pre> <p>Available since: 6.2.0</p> <p>Convert the string into a stream ID, storing it at <code>*id</code>. Returns <code>REDISMODULE_OK</code> on success and returns <code>REDISMODULE_ERR</code> if the string is not a valid string representation of a stream ID. The special IDs \"+\" and \"-\" are allowed.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_stringcompare","title":"<code>RedisModule_StringCompare</code>","text":"<pre><code>int RedisModule_StringCompare(const RedisModuleString *a,\n                              const RedisModuleString *b);\n</code></pre> <p>Available since: 4.0.0</p> <p>Compare two string objects, returning -1, 0 or 1 respectively if a &lt; b, a == b, a &gt; b. Strings are compared byte by byte as two binary blobs without any encoding care / collation attempt.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_stringappendbuffer","title":"<code>RedisModule_StringAppendBuffer</code>","text":"<pre><code>int RedisModule_StringAppendBuffer(RedisModuleCtx *ctx,\n                                   RedisModuleString *str,\n                                   const char *buf,\n                                   size_t len);\n</code></pre> <p>Available since: 4.0.0</p> <p>Append the specified buffer to the string 'str'. The string must be a string created by the user that is referenced only a single time, otherwise <code>REDISMODULE_ERR</code> is returned and the operation is not performed.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_trimstringallocation","title":"<code>RedisModule_TrimStringAllocation</code>","text":"<pre><code>void RedisModule_TrimStringAllocation(RedisModuleString *str);\n</code></pre> <p>Available since: 7.0.0</p> <p>Trim possible excess memory allocated for a <code>RedisModuleString</code>.</p> <p>Sometimes a <code>RedisModuleString</code> may have more memory allocated for it than required, typically for argv arguments that were constructed from network buffers. This function optimizes such strings by reallocating their memory, which is useful for strings that are not short lived but retained for an extended duration.</p> <p>This operation is not thread safe and should only be called when no concurrent access to the string is guaranteed. Using it for an argv string in a module command before the string is potentially available to other threads is generally safe.</p> <p>Currently, Redis may also automatically trim retained strings when a module command returns. However, doing this explicitly should still be a preferred option:</p> <ol> <li>Future versions of Redis may abandon auto-trimming.</li> <li>Auto-trimming as currently implemented is not thread safe.    A background thread manipulating a recently retained string may end up    in a race condition with the auto-trim, which could result with    data corruption.</li> </ol> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#reply-apis","title":"Reply APIs","text":"<p>These functions are used for sending replies to the client.</p> <p>Most functions always return <code>REDISMODULE_OK</code> so you can use it with 'return' in order to return from the command implementation with:</p> <pre><code>if (... some condition ...)\n    return RedisModule_ReplyWithLongLong(ctx,mycount);\n</code></pre>"},{"location":"8-reference/modules/modules-api-ref/#reply-with-collection-functions","title":"Reply with collection functions","text":"<p>After starting a collection reply, the module must make calls to other <code>ReplyWith*</code> style functions in order to emit the elements of the collection. Collection types include: Array, Map, Set and Attribute.</p> <p>When producing collections with a number of elements that is not known beforehand, the function can be called with a special flag <code>REDISMODULE_POSTPONED_LEN</code> (<code>REDISMODULE_POSTPONED_ARRAY_LEN</code> in the past), and the actual number of elements can be later set with <code>RedisModule_ReplySet</code>*Length() call (which will set the latest \"open\" count if there are multiple ones).</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_wrongarity","title":"<code>RedisModule_WrongArity</code>","text":"<pre><code>int RedisModule_WrongArity(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 4.0.0</p> <p>Send an error about the number of arguments given to the command, citing the command name in the error message. Returns <code>REDISMODULE_OK</code>.</p> <p>Example:</p> <pre><code>if (argc != 3) return RedisModule_WrongArity(ctx);\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithlonglong","title":"<code>RedisModule_ReplyWithLongLong</code>","text":"<pre><code>int RedisModule_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll);\n</code></pre> <p>Available since: 4.0.0</p> <p>Send an integer reply to the client, with the specified <code>long long</code> value. The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywitherror","title":"<code>RedisModule_ReplyWithError</code>","text":"<pre><code>int RedisModule_ReplyWithError(RedisModuleCtx *ctx, const char *err);\n</code></pre> <p>Available since: 4.0.0</p> <p>Reply with the error 'err'.</p> <p>Note that 'err' must contain all the error, including the initial error code. The function only provides the initial \"-\", so the usage is, for example:</p> <pre><code>RedisModule_ReplyWithError(ctx,\"ERR Wrong Type\");\n</code></pre> <p>and not just:</p> <pre><code>RedisModule_ReplyWithError(ctx,\"Wrong Type\");\n</code></pre> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywitherrorformat","title":"<code>RedisModule_ReplyWithErrorFormat</code>","text":"<pre><code>int RedisModule_ReplyWithErrorFormat(RedisModuleCtx *ctx,\n                                     const char *fmt,\n                                     ...);\n</code></pre> <p>Available since: 7.2.0</p> <p>Reply with the error create from a printf format and arguments.</p> <p>Note that 'fmt' must contain all the error, including the initial error code. The function only provides the initial \"-\", so the usage is, for example:</p> <pre><code>RedisModule_ReplyWithErrorFormat(ctx,\"ERR Wrong Type: %s\",type);\n</code></pre> <p>and not just:</p> <pre><code>RedisModule_ReplyWithErrorFormat(ctx,\"Wrong Type: %s\",type);\n</code></pre> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithsimplestring","title":"<code>RedisModule_ReplyWithSimpleString</code>","text":"<pre><code>int RedisModule_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg);\n</code></pre> <p>Available since: 4.0.0</p> <p>Reply with a simple string (<code>+... \\r\\n</code> in RESP protocol). This replies are suitable only when sending a small non-binary string with small overhead, like \"OK\" or similar replies.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywitharray","title":"<code>RedisModule_ReplyWithArray</code>","text":"<pre><code>int RedisModule_ReplyWithArray(RedisModuleCtx *ctx, long len);\n</code></pre> <p>Available since: 4.0.0</p> <p>Reply with an array type of 'len' elements.</p> <p>After starting an array reply, the module must make <code>len</code> calls to other <code>ReplyWith*</code> style functions in order to emit the elements of the array. See Reply APIs section for more details.</p> <p>Use <code>RedisModule_ReplySetArrayLength()</code> to set deferred length.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithmap","title":"<code>RedisModule_ReplyWithMap</code>","text":"<pre><code>int RedisModule_ReplyWithMap(RedisModuleCtx *ctx, long len);\n</code></pre> <p>Available since: 7.0.0</p> <p>Reply with a RESP3 Map type of 'len' pairs. Visit https://github.com/antirez/RESP3/blob/master/spec.md for more info about RESP3.</p> <p>After starting a map reply, the module must make <code>len*2</code> calls to other <code>ReplyWith*</code> style functions in order to emit the elements of the map. See Reply APIs section for more details.</p> <p>If the connected client is using RESP2, the reply will be converted to a flat array.</p> <p>Use <code>RedisModule_ReplySetMapLength()</code> to set deferred length.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithset","title":"<code>RedisModule_ReplyWithSet</code>","text":"<pre><code>int RedisModule_ReplyWithSet(RedisModuleCtx *ctx, long len);\n</code></pre> <p>Available since: 7.0.0</p> <p>Reply with a RESP3 Set type of 'len' elements. Visit https://github.com/antirez/RESP3/blob/master/spec.md for more info about RESP3.</p> <p>After starting a set reply, the module must make <code>len</code> calls to other <code>ReplyWith*</code> style functions in order to emit the elements of the set. See Reply APIs section for more details.</p> <p>If the connected client is using RESP2, the reply will be converted to an array type.</p> <p>Use <code>RedisModule_ReplySetSetLength()</code> to set deferred length.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithattribute","title":"<code>RedisModule_ReplyWithAttribute</code>","text":"<pre><code>int RedisModule_ReplyWithAttribute(RedisModuleCtx *ctx, long len);\n</code></pre> <p>Available since: 7.0.0</p> <p>Add attributes (metadata) to the reply. Should be done before adding the actual reply. see https://github.com/antirez/RESP3/blob/master/spec.md#attribute-type</p> <p>After starting an attribute's reply, the module must make <code>len*2</code> calls to other <code>ReplyWith*</code> style functions in order to emit the elements of the attribute map. See Reply APIs section for more details.</p> <p>Use <code>RedisModule_ReplySetAttributeLength()</code> to set deferred length.</p> <p>Not supported by RESP2 and will return <code>REDISMODULE_ERR</code>, otherwise the function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithnullarray","title":"<code>RedisModule_ReplyWithNullArray</code>","text":"<pre><code>int RedisModule_ReplyWithNullArray(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 6.0.0</p> <p>Reply to the client with a null array, simply null in RESP3, null array in RESP2.</p> <p>Note: In RESP3 there's no difference between Null reply and NullArray reply, so to prevent ambiguity it's better to avoid using this API and use <code>RedisModule_ReplyWithNull</code> instead.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithemptyarray","title":"<code>RedisModule_ReplyWithEmptyArray</code>","text":"<pre><code>int RedisModule_ReplyWithEmptyArray(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 6.0.0</p> <p>Reply to the client with an empty array.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replysetarraylength","title":"<code>RedisModule_ReplySetArrayLength</code>","text":"<pre><code>void RedisModule_ReplySetArrayLength(RedisModuleCtx *ctx, long len);\n</code></pre> <p>Available since: 4.0.0</p> <p>When <code>RedisModule_ReplyWithArray()</code> is used with the argument <code>REDISMODULE_POSTPONED_LEN</code>, because we don't know beforehand the number of items we are going to output as elements of the array, this function will take care to set the array length.</p> <p>Since it is possible to have multiple array replies pending with unknown length, this function guarantees to always set the latest array length that was created in a postponed way.</p> <p>For example in order to output an array like [1,[10,20,30]] we could write:</p> <pre><code> RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_LEN);\n RedisModule_ReplyWithLongLong(ctx,1);\n RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_LEN);\n RedisModule_ReplyWithLongLong(ctx,10);\n RedisModule_ReplyWithLongLong(ctx,20);\n RedisModule_ReplyWithLongLong(ctx,30);\n RedisModule_ReplySetArrayLength(ctx,3); // Set len of 10,20,30 array.\n RedisModule_ReplySetArrayLength(ctx,2); // Set len of top array\n</code></pre> <p>Note that in the above example there is no reason to postpone the array length, since we produce a fixed number of elements, but in the practice the code may use an iterator or other ways of creating the output so that is not easy to calculate in advance the number of elements.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replysetmaplength","title":"<code>RedisModule_ReplySetMapLength</code>","text":"<pre><code>void RedisModule_ReplySetMapLength(RedisModuleCtx *ctx, long len);\n</code></pre> <p>Available since: 7.0.0</p> <p>Very similar to <code>RedisModule_ReplySetArrayLength</code> except <code>len</code> should exactly half of the number of <code>ReplyWith*</code> functions called in the context of the map. Visit https://github.com/antirez/RESP3/blob/master/spec.md for more info about RESP3.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replysetsetlength","title":"<code>RedisModule_ReplySetSetLength</code>","text":"<pre><code>void RedisModule_ReplySetSetLength(RedisModuleCtx *ctx, long len);\n</code></pre> <p>Available since: 7.0.0</p> <p>Very similar to <code>RedisModule_ReplySetArrayLength</code> Visit https://github.com/antirez/RESP3/blob/master/spec.md for more info about RESP3.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replysetattributelength","title":"<code>RedisModule_ReplySetAttributeLength</code>","text":"<pre><code>void RedisModule_ReplySetAttributeLength(RedisModuleCtx *ctx, long len);\n</code></pre> <p>Available since: 7.0.0</p> <p>Very similar to <code>RedisModule_ReplySetMapLength</code> Visit https://github.com/antirez/RESP3/blob/master/spec.md for more info about RESP3.</p> <p>Must not be called if <code>RedisModule_ReplyWithAttribute</code> returned an error.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithstringbuffer","title":"<code>RedisModule_ReplyWithStringBuffer</code>","text":"<pre><code>int RedisModule_ReplyWithStringBuffer(RedisModuleCtx *ctx,\n                                      const char *buf,\n                                      size_t len);\n</code></pre> <p>Available since: 4.0.0</p> <p>Reply with a bulk string, taking in input a C buffer pointer and length.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithcstring","title":"<code>RedisModule_ReplyWithCString</code>","text":"<pre><code>int RedisModule_ReplyWithCString(RedisModuleCtx *ctx, const char *buf);\n</code></pre> <p>Available since: 5.0.6</p> <p>Reply with a bulk string, taking in input a C buffer pointer that is assumed to be null-terminated.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithstring","title":"<code>RedisModule_ReplyWithString</code>","text":"<pre><code>int RedisModule_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str);\n</code></pre> <p>Available since: 4.0.0</p> <p>Reply with a bulk string, taking in input a <code>RedisModuleString</code> object.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithemptystring","title":"<code>RedisModule_ReplyWithEmptyString</code>","text":"<pre><code>int RedisModule_ReplyWithEmptyString(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 6.0.0</p> <p>Reply with an empty string.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithverbatimstringtype","title":"<code>RedisModule_ReplyWithVerbatimStringType</code>","text":"<pre><code>int RedisModule_ReplyWithVerbatimStringType(RedisModuleCtx *ctx,\n                                            const char *buf,\n                                            size_t len,\n                                            const char *ext);\n</code></pre> <p>Available since: 7.0.0</p> <p>Reply with a binary safe string, which should not be escaped or filtered taking in input a C buffer pointer, length and a 3 character type/extension.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithverbatimstring","title":"<code>RedisModule_ReplyWithVerbatimString</code>","text":"<pre><code>int RedisModule_ReplyWithVerbatimString(RedisModuleCtx *ctx,\n                                        const char *buf,\n                                        size_t len);\n</code></pre> <p>Available since: 6.0.0</p> <p>Reply with a binary safe string, which should not be escaped or filtered taking in input a C buffer pointer and length.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithnull","title":"<code>RedisModule_ReplyWithNull</code>","text":"<pre><code>int RedisModule_ReplyWithNull(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 4.0.0</p> <p>Reply to the client with a NULL.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithbool","title":"<code>RedisModule_ReplyWithBool</code>","text":"<pre><code>int RedisModule_ReplyWithBool(RedisModuleCtx *ctx, int b);\n</code></pre> <p>Available since: 7.0.0</p> <p>Reply with a RESP3 Boolean type. Visit https://github.com/antirez/RESP3/blob/master/spec.md for more info about RESP3.</p> <p>In RESP3, this is boolean type In RESP2, it's a string response of \"1\" and \"0\" for true and false respectively.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithcallreply","title":"<code>RedisModule_ReplyWithCallReply</code>","text":"<pre><code>int RedisModule_ReplyWithCallReply(RedisModuleCtx *ctx,\n                                   RedisModuleCallReply *reply);\n</code></pre> <p>Available since: 4.0.0</p> <p>Reply exactly what a Redis command returned us with <code>RedisModule_Call()</code>. This function is useful when we use <code>RedisModule_Call()</code> in order to execute some command, as we want to reply to the client exactly the same reply we obtained by the command.</p> <p>Return: - <code>REDISMODULE_OK</code> on success. - <code>REDISMODULE_ERR</code> if the given reply is in RESP3 format but the client expects RESP2.   In case of an error, it's the module writer responsibility to translate the reply   to RESP2 (or handle it differently by returning an error). Notice that for   module writer convenience, it is possible to pass <code>0</code> as a parameter to the fmt   argument of <code>RedisModule_Call</code> so that the <code>RedisModuleCallReply</code> will return in the same   protocol (RESP2 or RESP3) as set in the current client's context.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithdouble","title":"<code>RedisModule_ReplyWithDouble</code>","text":"<pre><code>int RedisModule_ReplyWithDouble(RedisModuleCtx *ctx, double d);\n</code></pre> <p>Available since: 4.0.0</p> <p>Reply with a RESP3 Double type. Visit https://github.com/antirez/RESP3/blob/master/spec.md for more info about RESP3.</p> <p>Send a string reply obtained converting the double 'd' into a bulk string. This function is basically equivalent to converting a double into a string into a C buffer, and then calling the function <code>RedisModule_ReplyWithStringBuffer()</code> with the buffer and length.</p> <p>In RESP3 the string is tagged as a double, while in RESP2 it's just a plain string  that the user will have to parse.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithbignumber","title":"<code>RedisModule_ReplyWithBigNumber</code>","text":"<pre><code>int RedisModule_ReplyWithBigNumber(RedisModuleCtx *ctx,\n                                   const char *bignum,\n                                   size_t len);\n</code></pre> <p>Available since: 7.0.0</p> <p>Reply with a RESP3 BigNumber type. Visit https://github.com/antirez/RESP3/blob/master/spec.md for more info about RESP3.</p> <p>In RESP3, this is a string of length <code>len</code> that is tagged as a BigNumber,  however, it's up to the caller to ensure that it's a valid BigNumber. In RESP2, this is just a plain bulk string response.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replywithlongdouble","title":"<code>RedisModule_ReplyWithLongDouble</code>","text":"<pre><code>int RedisModule_ReplyWithLongDouble(RedisModuleCtx *ctx, long double ld);\n</code></pre> <p>Available since: 6.0.0</p> <p>Send a string reply obtained converting the long double 'ld' into a bulk string. This function is basically equivalent to converting a long double into a string into a C buffer, and then calling the function <code>RedisModule_ReplyWithStringBuffer()</code> with the buffer and length. The double string uses human readable formatting (see <code>addReplyHumanLongDouble</code> in networking.c).</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#commands-replication-api","title":"Commands replication API","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_replicate","title":"<code>RedisModule_Replicate</code>","text":"<pre><code>int RedisModule_Replicate(RedisModuleCtx *ctx,\n                          const char *cmdname,\n                          const char *fmt,\n                          ...);\n</code></pre> <p>Available since: 4.0.0</p> <p>Replicate the specified command and arguments to slaves and AOF, as effect of execution of the calling command implementation.</p> <p>The replicated commands are always wrapped into the MULTI/EXEC that contains all the commands replicated in a given module command execution. However the commands replicated with <code>RedisModule_Call()</code> are the first items, the ones replicated with <code>RedisModule_Replicate()</code> will all follow before the EXEC.</p> <p>Modules should try to use one interface or the other.</p> <p>This command follows exactly the same interface of <code>RedisModule_Call()</code>, so a set of format specifiers must be passed, followed by arguments matching the provided format specifiers.</p> <p>Please refer to <code>RedisModule_Call()</code> for more information.</p> <p>Using the special \"A\" and \"R\" modifiers, the caller can exclude either the AOF or the replicas from the propagation of the specified command. Otherwise, by default, the command will be propagated in both channels.</p>"},{"location":"8-reference/modules/modules-api-ref/#note-about-calling-this-function-from-a-thread-safe-context","title":"Note about calling this function from a thread safe context:","text":"<p>Normally when you call this function from the callback implementing a module command, or any other callback provided by the Redis Module API, Redis will accumulate all the calls to this function in the context of the callback, and will propagate all the commands wrapped in a MULTI/EXEC transaction. However when calling this function from a threaded safe context that can live an undefined amount of time, and can be locked/unlocked in at will, the behavior is different: MULTI/EXEC wrapper is not emitted and the command specified is inserted in the AOF and replication stream immediately.</p>"},{"location":"8-reference/modules/modules-api-ref/#return-value","title":"Return value","text":"<p>The command returns <code>REDISMODULE_ERR</code> if the format specifiers are invalid or the command name does not belong to a known command.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_replicateverbatim","title":"<code>RedisModule_ReplicateVerbatim</code>","text":"<pre><code>int RedisModule_ReplicateVerbatim(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 4.0.0</p> <p>This function will replicate the command exactly as it was invoked by the client. Note that this function will not wrap the command into a MULTI/EXEC stanza, so it should not be mixed with other replication commands.</p> <p>Basically this form of replication is useful when you want to propagate the command to the slaves and AOF file exactly as it was called, since the command can just be re-executed to deterministically re-create the new state starting from the old one.</p> <p>The function always returns <code>REDISMODULE_OK</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#db-and-key-apis-generic-api","title":"DB and Key APIs \u2013 Generic API","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_getclientid","title":"<code>RedisModule_GetClientId</code>","text":"<pre><code>unsigned long long RedisModule_GetClientId(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return the ID of the current client calling the currently active module command. The returned ID has a few guarantees:</p> <ol> <li>The ID is different for each different client, so if the same client    executes a module command multiple times, it can be recognized as    having the same ID, otherwise the ID will be different.</li> <li>The ID increases monotonically. Clients connecting to the server later    are guaranteed to get IDs greater than any past ID previously seen.</li> </ol> <p>Valid IDs are from 1 to 2^64 - 1. If 0 is returned it means there is no way to fetch the ID in the context the function was currently called.</p> <p>After obtaining the ID, it is possible to check if the command execution is actually happening in the context of AOF loading, using this macro:</p> <pre><code> if (RedisModule_IsAOFClient(RedisModule_GetClientId(ctx)) {\n     // Handle it differently.\n }\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getclientusernamebyid","title":"<code>RedisModule_GetClientUserNameById</code>","text":"<pre><code>RedisModuleString *RedisModule_GetClientUserNameById(RedisModuleCtx *ctx,\n                                                     uint64_t id);\n</code></pre> <p>Available since: 6.2.1</p> <p>Return the ACL user name used by the client with the specified client ID. Client ID can be obtained with <code>RedisModule_GetClientId()</code> API. If the client does not exist, NULL is returned and errno is set to ENOENT. If the client isn't using an ACL user, NULL is returned and errno is set to ENOTSUP</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getclientinfobyid","title":"<code>RedisModule_GetClientInfoById</code>","text":"<pre><code>int RedisModule_GetClientInfoById(void *ci, uint64_t id);\n</code></pre> <p>Available since: 6.0.0</p> <p>Return information about the client with the specified ID (that was previously obtained via the <code>RedisModule_GetClientId()</code> API). If the client exists, <code>REDISMODULE_OK</code> is returned, otherwise <code>REDISMODULE_ERR</code> is returned.</p> <p>When the client exist and the <code>ci</code> pointer is not NULL, but points to a structure of type <code>RedisModuleClientInfoV</code>1, previously initialized with the correct <code>REDISMODULE_CLIENTINFO_INITIALIZER_V1</code>, the structure is populated with the following fields:</p> <pre><code> uint64_t flags;         // REDISMODULE_CLIENTINFO_FLAG_*\n uint64_t id;            // Client ID\n char addr[46];          // IPv4 or IPv6 address.\n uint16_t port;          // TCP port.\n uint16_t db;            // Selected DB.\n</code></pre> <p>Note: the client ID is useless in the context of this call, since we       already know, however the same structure could be used in other       contexts where we don't know the client ID, yet the same structure       is returned.</p> <p>With flags having the following meaning:</p> <pre><code>REDISMODULE_CLIENTINFO_FLAG_SSL          Client using SSL connection.\nREDISMODULE_CLIENTINFO_FLAG_PUBSUB       Client in Pub/Sub mode.\nREDISMODULE_CLIENTINFO_FLAG_BLOCKED      Client blocked in command.\nREDISMODULE_CLIENTINFO_FLAG_TRACKING     Client with keys tracking on.\nREDISMODULE_CLIENTINFO_FLAG_UNIXSOCKET   Client using unix domain socket.\nREDISMODULE_CLIENTINFO_FLAG_MULTI        Client in MULTI state.\n</code></pre> <p>However passing NULL is a way to just check if the client exists in case we are not interested in any additional information.</p> <p>This is the correct usage when we want the client info structure returned:</p> <pre><code> RedisModuleClientInfo ci = REDISMODULE_CLIENTINFO_INITIALIZER;\n int retval = RedisModule_GetClientInfoById(&amp;ci,client_id);\n if (retval == REDISMODULE_OK) {\n     printf(\"Address: %s\\n\", ci.addr);\n }\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getclientnamebyid","title":"<code>RedisModule_GetClientNameById</code>","text":"<pre><code>RedisModuleString *RedisModule_GetClientNameById(RedisModuleCtx *ctx,\n                                                 uint64_t id);\n</code></pre> <p>Available since: 7.0.3</p> <p>Returns the name of the client connection with the given ID.</p> <p>If the client ID does not exist or if the client has no name associated with it, NULL is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_setclientnamebyid","title":"<code>RedisModule_SetClientNameById</code>","text":"<pre><code>int RedisModule_SetClientNameById(uint64_t id, RedisModuleString *name);\n</code></pre> <p>Available since: 7.0.3</p> <p>Sets the name of the client with the given ID. This is equivalent to the client calling <code>CLIENT SETNAME name</code>.</p> <p>Returns <code>REDISMODULE_OK</code> on success. On failure, <code>REDISMODULE_ERR</code> is returned and errno is set as follows:</p> <ul> <li>ENOENT if the client does not exist</li> <li>EINVAL if the name contains invalid characters</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_publishmessage","title":"<code>RedisModule_PublishMessage</code>","text":"<pre><code>int RedisModule_PublishMessage(RedisModuleCtx *ctx,\n                               RedisModuleString *channel,\n                               RedisModuleString *message);\n</code></pre> <p>Available since: 6.0.0</p> <p>Publish a message to subscribers (see PUBLISH command).</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_publishmessageshard","title":"<code>RedisModule_PublishMessageShard</code>","text":"<pre><code>int RedisModule_PublishMessageShard(RedisModuleCtx *ctx,\n                                    RedisModuleString *channel,\n                                    RedisModuleString *message);\n</code></pre> <p>Available since: 7.0.0</p> <p>Publish a message to shard-subscribers (see SPUBLISH command).</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getselecteddb","title":"<code>RedisModule_GetSelectedDb</code>","text":"<pre><code>int RedisModule_GetSelectedDb(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return the currently selected DB.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getcontextflags","title":"<code>RedisModule_GetContextFlags</code>","text":"<pre><code>int RedisModule_GetContextFlags(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 4.0.3</p> <p>Return the current context's flags. The flags provide information on the current request context (whether the client is a Lua script or in a MULTI), and about the Redis instance in general, i.e replication and persistence.</p> <p>It is possible to call this function even with a NULL context, however in this case the following flags will not be reported:</p> <ul> <li>LUA, MULTI, REPLICATED, DIRTY (see below for more info).</li> </ul> <p>Available flags and their meaning:</p> <ul> <li> <p><code>REDISMODULE_CTX_FLAGS_LUA</code>: The command is running in a Lua script</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_MULTI</code>: The command is running inside a transaction</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_REPLICATED</code>: The command was sent over the replication    link by the MASTER</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_MASTER</code>: The Redis instance is a master</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_SLAVE</code>: The Redis instance is a slave</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_READONLY</code>: The Redis instance is read-only</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_CLUSTER</code>: The Redis instance is in cluster mode</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_AOF</code>: The Redis instance has AOF enabled</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_RDB</code>: The instance has RDB enabled</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_MAXMEMORY</code>:  The instance has Maxmemory set</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_EVICT</code>:  Maxmemory is set and has an eviction    policy that may delete keys</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_OOM</code>: Redis is out of memory according to the    maxmemory setting.</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_OOM_WARNING</code>: Less than 25% of memory remains before                                       reaching the maxmemory level.</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_LOADING</code>: Server is loading RDB/AOF</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_REPLICA_IS_STALE</code>: No active link with the master.</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_REPLICA_IS_CONNECTING</code>: The replica is trying to                                                 connect with the master.</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_REPLICA_IS_TRANSFERRING</code>: Master -&gt; Replica RDB                                                   transfer is in progress.</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_REPLICA_IS_ONLINE</code>: The replica has an active link                                             with its master. This is the                                             contrary of STALE state.</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_ACTIVE_CHILD</code>: There is currently some background                                        process active (RDB, AUX or module).</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_MULTI_DIRTY</code>: The next EXEC will fail due to dirty                                       CAS (touched keys).</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_IS_CHILD</code>: Redis is currently running inside                                    background child process.</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_RESP3</code>: Indicate the that client attached to this                                 context is using RESP3.</p> </li> <li> <p><code>REDISMODULE_CTX_FLAGS_SERVER_STARTUP</code>: The Redis instance is starting</p> </li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_avoidreplicatraffic","title":"<code>RedisModule_AvoidReplicaTraffic</code>","text":"<pre><code>int RedisModule_AvoidReplicaTraffic(void);\n</code></pre> <p>Available since: 6.0.0</p> <p>Returns true if a client sent the CLIENT PAUSE command to the server or if Redis Cluster does a manual failover, pausing the clients. This is needed when we have a master with replicas, and want to write, without adding further data to the replication channel, that the replicas replication offset, match the one of the master. When this happens, it is safe to failover the master without data loss.</p> <p>However modules may generate traffic by calling <code>RedisModule_Call()</code> with the \"!\" flag, or by calling <code>RedisModule_Replicate()</code>, in a context outside commands execution, for instance in timeout callbacks, threads safe contexts, and so forth. When modules will generate too much traffic, it will be hard for the master and replicas offset to match, because there is more data to send in the replication channel.</p> <p>So modules may want to try to avoid very heavy background work that has the effect of creating data to the replication channel, when this function returns true. This is mostly useful for modules that have background garbage collection tasks, or that do writes and replicate such writes periodically in timer callbacks or other periodic callbacks.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_selectdb","title":"<code>RedisModule_SelectDb</code>","text":"<pre><code>int RedisModule_SelectDb(RedisModuleCtx *ctx, int newid);\n</code></pre> <p>Available since: 4.0.0</p> <p>Change the currently selected DB. Returns an error if the id is out of range.</p> <p>Note that the client will retain the currently selected DB even after the Redis command implemented by the module calling this function returns.</p> <p>If the module command wishes to change something in a different DB and returns back to the original one, it should call <code>RedisModule_GetSelectedDb()</code> before in order to restore the old DB number before returning.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_keyexists","title":"<code>RedisModule_KeyExists</code>","text":"<pre><code>int RedisModule_KeyExists(RedisModuleCtx *ctx, robj *keyname);\n</code></pre> <p>Available since: 7.0.0</p> <p>Check if a key exists, without affecting its last access time.</p> <p>This is equivalent to calling <code>RedisModule_OpenKey</code> with the mode <code>REDISMODULE_READ</code> | <code>REDISMODULE_OPEN_KEY_NOTOUCH</code>, then checking if NULL was returned and, if not, calling <code>RedisModule_CloseKey</code> on the opened key.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_openkey","title":"<code>RedisModule_OpenKey</code>","text":"<pre><code>RedisModuleKey *RedisModule_OpenKey(RedisModuleCtx *ctx,\n                                    robj *keyname,\n                                    int mode);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return a handle representing a Redis key, so that it is possible to call other APIs with the key handle as argument to perform operations on the key.</p> <p>The return value is the handle representing the key, that must be closed with <code>RedisModule_CloseKey()</code>.</p> <p>If the key does not exist and <code>REDISMODULE_WRITE</code> mode is requested, the handle is still returned, since it is possible to perform operations on a yet not existing key (that will be created, for example, after a list push operation). If the mode is just <code>REDISMODULE_READ</code> instead, and the key does not exist, NULL is returned. However it is still safe to call <code>RedisModule_CloseKey()</code> and <code>RedisModule_KeyType()</code> on a NULL value.</p> <p>Extra flags that can be pass to the API under the mode argument: * <code>REDISMODULE_OPEN_KEY_NOTOUCH</code> - Avoid touching the LRU/LFU of the key when opened. * <code>REDISMODULE_OPEN_KEY_NONOTIFY</code> - Don't trigger keyspace event on key misses. * <code>REDISMODULE_OPEN_KEY_NOSTATS</code> - Don't update keyspace hits/misses counters. * <code>REDISMODULE_OPEN_KEY_NOEXPIRE</code> - Avoid deleting lazy expired keys. * <code>REDISMODULE_OPEN_KEY_NOEFFECTS</code> - Avoid any effects from fetching the key.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getopenkeymodesall","title":"<code>RedisModule_GetOpenKeyModesAll</code>","text":"<pre><code>int RedisModule_GetOpenKeyModesAll(void);\n</code></pre> <p>Available since: 7.2.0</p> <p>Returns the full OpenKey modes mask, using the return value the module can check if a certain set of OpenKey modes are supported by the redis server version in use. Example:</p> <pre><code>   int supportedMode = RedisModule_GetOpenKeyModesAll();\n   if (supportedMode &amp; REDISMODULE_OPEN_KEY_NOTOUCH) {\n         // REDISMODULE_OPEN_KEY_NOTOUCH is supported\n   } else{\n         // REDISMODULE_OPEN_KEY_NOTOUCH is not supported\n   }\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_closekey","title":"<code>RedisModule_CloseKey</code>","text":"<pre><code>void RedisModule_CloseKey(RedisModuleKey *key);\n</code></pre> <p>Available since: 4.0.0</p> <p>Close a key handle.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_keytype","title":"<code>RedisModule_KeyType</code>","text":"<pre><code>int RedisModule_KeyType(RedisModuleKey *key);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return the type of the key. If the key pointer is NULL then <code>REDISMODULE_KEYTYPE_EMPTY</code> is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_valuelength","title":"<code>RedisModule_ValueLength</code>","text":"<pre><code>size_t RedisModule_ValueLength(RedisModuleKey *key);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return the length of the value associated with the key. For strings this is the length of the string. For all the other types is the number of elements (just counting keys for hashes).</p> <p>If the key pointer is NULL or the key is empty, zero is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_deletekey","title":"<code>RedisModule_DeleteKey</code>","text":"<pre><code>int RedisModule_DeleteKey(RedisModuleKey *key);\n</code></pre> <p>Available since: 4.0.0</p> <p>If the key is open for writing, remove it, and setup the key to accept new writes as an empty key (that will be created on demand). On success <code>REDISMODULE_OK</code> is returned. If the key is not open for writing <code>REDISMODULE_ERR</code> is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_unlinkkey","title":"<code>RedisModule_UnlinkKey</code>","text":"<pre><code>int RedisModule_UnlinkKey(RedisModuleKey *key);\n</code></pre> <p>Available since: 4.0.7</p> <p>If the key is open for writing, unlink it (that is delete it in a non-blocking way, not reclaiming memory immediately) and setup the key to accept new writes as an empty key (that will be created on demand). On success <code>REDISMODULE_OK</code> is returned. If the key is not open for writing <code>REDISMODULE_ERR</code> is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getexpire","title":"<code>RedisModule_GetExpire</code>","text":"<pre><code>mstime_t RedisModule_GetExpire(RedisModuleKey *key);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return the key expire value, as milliseconds of remaining TTL. If no TTL is associated with the key or if the key is empty, <code>REDISMODULE_NO_EXPIRE</code> is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_setexpire","title":"<code>RedisModule_SetExpire</code>","text":"<pre><code>int RedisModule_SetExpire(RedisModuleKey *key, mstime_t expire);\n</code></pre> <p>Available since: 4.0.0</p> <p>Set a new expire for the key. If the special expire <code>REDISMODULE_NO_EXPIRE</code> is set, the expire is cancelled if there was one (the same as the PERSIST command).</p> <p>Note that the expire must be provided as a positive integer representing the number of milliseconds of TTL the key should have.</p> <p>The function returns <code>REDISMODULE_OK</code> on success or <code>REDISMODULE_ERR</code> if the key was not open for writing or is an empty key.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getabsexpire","title":"<code>RedisModule_GetAbsExpire</code>","text":"<pre><code>mstime_t RedisModule_GetAbsExpire(RedisModuleKey *key);\n</code></pre> <p>Available since: 6.2.2</p> <p>Return the key expire value, as absolute Unix timestamp. If no TTL is associated with the key or if the key is empty, <code>REDISMODULE_NO_EXPIRE</code> is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_setabsexpire","title":"<code>RedisModule_SetAbsExpire</code>","text":"<pre><code>int RedisModule_SetAbsExpire(RedisModuleKey *key, mstime_t expire);\n</code></pre> <p>Available since: 6.2.2</p> <p>Set a new expire for the key. If the special expire <code>REDISMODULE_NO_EXPIRE</code> is set, the expire is cancelled if there was one (the same as the PERSIST command).</p> <p>Note that the expire must be provided as a positive integer representing the absolute Unix timestamp the key should have.</p> <p>The function returns <code>REDISMODULE_OK</code> on success or <code>REDISMODULE_ERR</code> if the key was not open for writing or is an empty key.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_resetdataset","title":"<code>RedisModule_ResetDataset</code>","text":"<pre><code>void RedisModule_ResetDataset(int restart_aof, int async);\n</code></pre> <p>Available since: 6.0.0</p> <p>Performs similar operation to FLUSHALL, and optionally start a new AOF file (if enabled) If <code>restart_aof</code> is true, you must make sure the command that triggered this call is not propagated to the AOF file. When async is set to true, db contents will be freed by a background thread.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dbsize","title":"<code>RedisModule_DbSize</code>","text":"<pre><code>unsigned long long RedisModule_DbSize(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 6.0.0</p> <p>Returns the number of keys in the current db.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_randomkey","title":"<code>RedisModule_RandomKey</code>","text":"<pre><code>RedisModuleString *RedisModule_RandomKey(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 6.0.0</p> <p>Returns a name of a random key, or NULL if current db is empty.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getkeynamefromoptctx","title":"<code>RedisModule_GetKeyNameFromOptCtx</code>","text":"<pre><code>const RedisModuleString *RedisModule_GetKeyNameFromOptCtx(RedisModuleKeyOptCtx *ctx);\n</code></pre> <p>Available since: 7.0.0</p> <p>Returns the name of the key currently being processed.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_gettokeynamefromoptctx","title":"<code>RedisModule_GetToKeyNameFromOptCtx</code>","text":"<pre><code>const RedisModuleString *RedisModule_GetToKeyNameFromOptCtx(RedisModuleKeyOptCtx *ctx);\n</code></pre> <p>Available since: 7.0.0</p> <p>Returns the name of the target key currently being processed.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getdbidfromoptctx","title":"<code>RedisModule_GetDbIdFromOptCtx</code>","text":"<pre><code>int RedisModule_GetDbIdFromOptCtx(RedisModuleKeyOptCtx *ctx);\n</code></pre> <p>Available since: 7.0.0</p> <p>Returns the dbid currently being processed.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_gettodbidfromoptctx","title":"<code>RedisModule_GetToDbIdFromOptCtx</code>","text":"<pre><code>int RedisModule_GetToDbIdFromOptCtx(RedisModuleKeyOptCtx *ctx);\n</code></pre> <p>Available since: 7.0.0</p> <p>Returns the target dbid currently being processed.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#key-api-for-string-type","title":"Key API for String type","text":"<p>See also <code>RedisModule_ValueLength()</code>, which returns the length of a string.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_stringset","title":"<code>RedisModule_StringSet</code>","text":"<pre><code>int RedisModule_StringSet(RedisModuleKey *key, RedisModuleString *str);\n</code></pre> <p>Available since: 4.0.0</p> <p>If the key is open for writing, set the specified string 'str' as the value of the key, deleting the old value if any. On success <code>REDISMODULE_OK</code> is returned. If the key is not open for writing or there is an active iterator, <code>REDISMODULE_ERR</code> is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_stringdma","title":"<code>RedisModule_StringDMA</code>","text":"<pre><code>char *RedisModule_StringDMA(RedisModuleKey *key, size_t *len, int mode);\n</code></pre> <p>Available since: 4.0.0</p> <p>Prepare the key associated string value for DMA access, and returns a pointer and size (by reference), that the user can use to read or modify the string in-place accessing it directly via pointer.</p> <p>The 'mode' is composed by bitwise OR-ing the following flags:</p> <pre><code>REDISMODULE_READ -- Read access\nREDISMODULE_WRITE -- Write access\n</code></pre> <p>If the DMA is not requested for writing, the pointer returned should only be accessed in a read-only fashion.</p> <p>On error (wrong type) NULL is returned.</p> <p>DMA access rules:</p> <ol> <li> <p>No other key writing function should be called since the moment the pointer is obtained, for all the time we want to use DMA access to read or modify the string.</p> </li> <li> <p>Each time <code>RedisModule_StringTruncate()</code> is called, to continue with the DMA access, <code>RedisModule_StringDMA()</code> should be called again to re-obtain a new pointer and length.</p> </li> <li> <p>If the returned pointer is not NULL, but the length is zero, no byte can be touched (the string is empty, or the key itself is empty) so a <code>RedisModule_StringTruncate()</code> call should be used if there is to enlarge the string, and later call StringDMA() again to get the pointer.</p> </li> </ol> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_stringtruncate","title":"<code>RedisModule_StringTruncate</code>","text":"<pre><code>int RedisModule_StringTruncate(RedisModuleKey *key, size_t newlen);\n</code></pre> <p>Available since: 4.0.0</p> <p>If the key is open for writing and is of string type, resize it, padding with zero bytes if the new length is greater than the old one.</p> <p>After this call, <code>RedisModule_StringDMA()</code> must be called again to continue DMA access with the new pointer.</p> <p>The function returns <code>REDISMODULE_OK</code> on success, and <code>REDISMODULE_ERR</code> on error, that is, the key is not open for writing, is not a string or resizing for more than 512 MB is requested.</p> <p>If the key is empty, a string key is created with the new string value unless the new length value requested is zero.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#key-api-for-list-type","title":"Key API for List type","text":"<p>Many of the list functions access elements by index. Since a list is in essence a doubly-linked list, accessing elements by index is generally an O(N) operation. However, if elements are accessed sequentially or with indices close together, the functions are optimized to seek the index from the previous index, rather than seeking from the ends of the list.</p> <p>This enables iteration to be done efficiently using a simple for loop:</p> <pre><code>long n = RedisModule_ValueLength(key);\nfor (long i = 0; i &lt; n; i++) {\n    RedisModuleString *elem = RedisModule_ListGet(key, i);\n    // Do stuff...\n}\n</code></pre> <p>Note that after modifying a list using <code>RedisModule_ListPop</code>, <code>RedisModule_ListSet</code> or <code>RedisModule_ListInsert</code>, the internal iterator is invalidated so the next operation will require a linear seek.</p> <p>Modifying a list in any another way, for example using <code>RedisModule_Call()</code>, while a key is open will confuse the internal iterator and may cause trouble if the key is used after such modifications. The key must be reopened in this case.</p> <p>See also <code>RedisModule_ValueLength()</code>, which returns the length of a list.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_listpush","title":"<code>RedisModule_ListPush</code>","text":"<pre><code>int RedisModule_ListPush(RedisModuleKey *key,\n                         int where,\n                         RedisModuleString *ele);\n</code></pre> <p>Available since: 4.0.0</p> <p>Push an element into a list, on head or tail depending on 'where' argument (<code>REDISMODULE_LIST_HEAD</code> or <code>REDISMODULE_LIST_TAIL</code>). If the key refers to an empty key opened for writing, the key is created. On success, <code>REDISMODULE_OK</code> is returned. On failure, <code>REDISMODULE_ERR</code> is returned and <code>errno</code> is set as follows:</p> <ul> <li>EINVAL if key or ele is NULL.</li> <li>ENOTSUP if the key is of another type than list.</li> <li>EBADF if the key is not opened for writing.</li> </ul> <p>Note: Before Redis 7.0, <code>errno</code> was not set by this function.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_listpop","title":"<code>RedisModule_ListPop</code>","text":"<pre><code>RedisModuleString *RedisModule_ListPop(RedisModuleKey *key, int where);\n</code></pre> <p>Available since: 4.0.0</p> <p>Pop an element from the list, and returns it as a module string object that the user should be free with <code>RedisModule_FreeString()</code> or by enabling automatic memory. The <code>where</code> argument specifies if the element should be popped from the beginning or the end of the list (<code>REDISMODULE_LIST_HEAD</code> or <code>REDISMODULE_LIST_TAIL</code>). On failure, the command returns NULL and sets <code>errno</code> as follows:</p> <ul> <li>EINVAL if key is NULL.</li> <li>ENOTSUP if the key is empty or of another type than list.</li> <li>EBADF if the key is not opened for writing.</li> </ul> <p>Note: Before Redis 7.0, <code>errno</code> was not set by this function.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_listget","title":"<code>RedisModule_ListGet</code>","text":"<pre><code>RedisModuleString *RedisModule_ListGet(RedisModuleKey *key, long index);\n</code></pre> <p>Available since: 7.0.0</p> <p>Returns the element at index <code>index</code> in the list stored at <code>key</code>, like the LINDEX command. The element should be free'd using <code>RedisModule_FreeString()</code> or using automatic memory management.</p> <p>The index is zero-based, so 0 means the first element, 1 the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, -1 means the last element, -2 means the penultimate and so forth.</p> <p>When no value is found at the given key and index, NULL is returned and <code>errno</code> is set as follows:</p> <ul> <li>EINVAL if key is NULL.</li> <li>ENOTSUP if the key is not a list.</li> <li>EBADF if the key is not opened for reading.</li> <li>EDOM if the index is not a valid index in the list.</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_listset","title":"<code>RedisModule_ListSet</code>","text":"<pre><code>int RedisModule_ListSet(RedisModuleKey *key,\n                        long index,\n                        RedisModuleString *value);\n</code></pre> <p>Available since: 7.0.0</p> <p>Replaces the element at index <code>index</code> in the list stored at <code>key</code>.</p> <p>The index is zero-based, so 0 means the first element, 1 the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, -1 means the last element, -2 means the penultimate and so forth.</p> <p>On success, <code>REDISMODULE_OK</code> is returned. On failure, <code>REDISMODULE_ERR</code> is returned and <code>errno</code> is set as follows:</p> <ul> <li>EINVAL if key or value is NULL.</li> <li>ENOTSUP if the key is not a list.</li> <li>EBADF if the key is not opened for writing.</li> <li>EDOM if the index is not a valid index in the list.</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_listinsert","title":"<code>RedisModule_ListInsert</code>","text":"<pre><code>int RedisModule_ListInsert(RedisModuleKey *key,\n                           long index,\n                           RedisModuleString *value);\n</code></pre> <p>Available since: 7.0.0</p> <p>Inserts an element at the given index.</p> <p>The index is zero-based, so 0 means the first element, 1 the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, -1 means the last element, -2 means the penultimate and so forth. The index is the element's index after inserting it.</p> <p>On success, <code>REDISMODULE_OK</code> is returned. On failure, <code>REDISMODULE_ERR</code> is returned and <code>errno</code> is set as follows:</p> <ul> <li>EINVAL if key or value is NULL.</li> <li>ENOTSUP if the key of another type than list.</li> <li>EBADF if the key is not opened for writing.</li> <li>EDOM if the index is not a valid index in the list.</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_listdelete","title":"<code>RedisModule_ListDelete</code>","text":"<pre><code>int RedisModule_ListDelete(RedisModuleKey *key, long index);\n</code></pre> <p>Available since: 7.0.0</p> <p>Removes an element at the given index. The index is 0-based. A negative index can also be used, counting from the end of the list.</p> <p>On success, <code>REDISMODULE_OK</code> is returned. On failure, <code>REDISMODULE_ERR</code> is returned and <code>errno</code> is set as follows:</p> <ul> <li>EINVAL if key or value is NULL.</li> <li>ENOTSUP if the key is not a list.</li> <li>EBADF if the key is not opened for writing.</li> <li>EDOM if the index is not a valid index in the list.</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#key-api-for-sorted-set-type","title":"Key API for Sorted Set type","text":"<p>See also <code>RedisModule_ValueLength()</code>, which returns the length of a sorted set.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_zsetadd","title":"<code>RedisModule_ZsetAdd</code>","text":"<pre><code>int RedisModule_ZsetAdd(RedisModuleKey *key,\n                        double score,\n                        RedisModuleString *ele,\n                        int *flagsptr);\n</code></pre> <p>Available since: 4.0.0</p> <p>Add a new element into a sorted set, with the specified 'score'. If the element already exists, the score is updated.</p> <p>A new sorted set is created at value if the key is an empty open key setup for writing.</p> <p>Additional flags can be passed to the function via a pointer, the flags are both used to receive input and to communicate state when the function returns. 'flagsptr' can be NULL if no special flags are used.</p> <p>The input flags are:</p> <pre><code>REDISMODULE_ZADD_XX: Element must already exist. Do nothing otherwise.\nREDISMODULE_ZADD_NX: Element must not exist. Do nothing otherwise.\nREDISMODULE_ZADD_GT: If element exists, new score must be greater than the current score. \n                     Do nothing otherwise. Can optionally be combined with XX.\nREDISMODULE_ZADD_LT: If element exists, new score must be less than the current score.\n                     Do nothing otherwise. Can optionally be combined with XX.\n</code></pre> <p>The output flags are:</p> <pre><code>REDISMODULE_ZADD_ADDED: The new element was added to the sorted set.\nREDISMODULE_ZADD_UPDATED: The score of the element was updated.\nREDISMODULE_ZADD_NOP: No operation was performed because XX or NX flags.\n</code></pre> <p>On success the function returns <code>REDISMODULE_OK</code>. On the following errors <code>REDISMODULE_ERR</code> is returned:</p> <ul> <li>The key was not opened for writing.</li> <li>The key is of the wrong type.</li> <li>'score' double value is not a number (NaN).</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_zsetincrby","title":"<code>RedisModule_ZsetIncrby</code>","text":"<pre><code>int RedisModule_ZsetIncrby(RedisModuleKey *key,\n                           double score,\n                           RedisModuleString *ele,\n                           int *flagsptr,\n                           double *newscore);\n</code></pre> <p>Available since: 4.0.0</p> <p>This function works exactly like <code>RedisModule_ZsetAdd()</code>, but instead of setting a new score, the score of the existing element is incremented, or if the element does not already exist, it is added assuming the old score was zero.</p> <p>The input and output flags, and the return value, have the same exact meaning, with the only difference that this function will return <code>REDISMODULE_ERR</code> even when 'score' is a valid double number, but adding it to the existing score results into a NaN (not a number) condition.</p> <p>This function has an additional field 'newscore', if not NULL is filled with the new score of the element after the increment, if no error is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_zsetrem","title":"<code>RedisModule_ZsetRem</code>","text":"<pre><code>int RedisModule_ZsetRem(RedisModuleKey *key,\n                        RedisModuleString *ele,\n                        int *deleted);\n</code></pre> <p>Available since: 4.0.0</p> <p>Remove the specified element from the sorted set. The function returns <code>REDISMODULE_OK</code> on success, and <code>REDISMODULE_ERR</code> on one of the following conditions:</p> <ul> <li>The key was not opened for writing.</li> <li>The key is of the wrong type.</li> </ul> <p>The return value does NOT indicate the fact the element was really removed (since it existed) or not, just if the function was executed with success.</p> <p>In order to know if the element was removed, the additional argument 'deleted' must be passed, that populates the integer by reference setting it to 1 or 0 depending on the outcome of the operation. The 'deleted' argument can be NULL if the caller is not interested to know if the element was really removed.</p> <p>Empty keys will be handled correctly by doing nothing.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_zsetscore","title":"<code>RedisModule_ZsetScore</code>","text":"<pre><code>int RedisModule_ZsetScore(RedisModuleKey *key,\n                          RedisModuleString *ele,\n                          double *score);\n</code></pre> <p>Available since: 4.0.0</p> <p>On success retrieve the double score associated at the sorted set element 'ele' and returns <code>REDISMODULE_OK</code>. Otherwise <code>REDISMODULE_ERR</code> is returned to signal one of the following conditions:</p> <ul> <li>There is no such element 'ele' in the sorted set.</li> <li>The key is not a sorted set.</li> <li>The key is an open empty key.</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#key-api-for-sorted-set-iterator","title":"Key API for Sorted Set iterator","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_zsetrangestop","title":"<code>RedisModule_ZsetRangeStop</code>","text":"<pre><code>void RedisModule_ZsetRangeStop(RedisModuleKey *key);\n</code></pre> <p>Available since: 4.0.0</p> <p>Stop a sorted set iteration.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_zsetrangeendreached","title":"<code>RedisModule_ZsetRangeEndReached</code>","text":"<pre><code>int RedisModule_ZsetRangeEndReached(RedisModuleKey *key);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return the \"End of range\" flag value to signal the end of the iteration.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_zsetfirstinscorerange","title":"<code>RedisModule_ZsetFirstInScoreRange</code>","text":"<pre><code>int RedisModule_ZsetFirstInScoreRange(RedisModuleKey *key,\n                                      double min,\n                                      double max,\n                                      int minex,\n                                      int maxex);\n</code></pre> <p>Available since: 4.0.0</p> <p>Setup a sorted set iterator seeking the first element in the specified range. Returns <code>REDISMODULE_OK</code> if the iterator was correctly initialized otherwise <code>REDISMODULE_ERR</code> is returned in the following conditions:</p> <ol> <li>The value stored at key is not a sorted set or the key is empty.</li> </ol> <p>The range is specified according to the two double values 'min' and 'max'. Both can be infinite using the following two macros:</p> <ul> <li><code>REDISMODULE_POSITIVE_INFINITE</code> for positive infinite value</li> <li><code>REDISMODULE_NEGATIVE_INFINITE</code> for negative infinite value</li> </ul> <p>'minex' and 'maxex' parameters, if true, respectively setup a range where the min and max value are exclusive (not included) instead of inclusive.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_zsetlastinscorerange","title":"<code>RedisModule_ZsetLastInScoreRange</code>","text":"<pre><code>int RedisModule_ZsetLastInScoreRange(RedisModuleKey *key,\n                                     double min,\n                                     double max,\n                                     int minex,\n                                     int maxex);\n</code></pre> <p>Available since: 4.0.0</p> <p>Exactly like <code>RedisModule_ZsetFirstInScoreRange()</code> but the last element of the range is selected for the start of the iteration instead.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_zsetfirstinlexrange","title":"<code>RedisModule_ZsetFirstInLexRange</code>","text":"<pre><code>int RedisModule_ZsetFirstInLexRange(RedisModuleKey *key,\n                                    RedisModuleString *min,\n                                    RedisModuleString *max);\n</code></pre> <p>Available since: 4.0.0</p> <p>Setup a sorted set iterator seeking the first element in the specified lexicographical range. Returns <code>REDISMODULE_OK</code> if the iterator was correctly initialized otherwise <code>REDISMODULE_ERR</code> is returned in the following conditions:</p> <ol> <li>The value stored at key is not a sorted set or the key is empty.</li> <li>The lexicographical range 'min' and 'max' format is invalid.</li> </ol> <p>'min' and 'max' should be provided as two <code>RedisModuleString</code> objects in the same format as the parameters passed to the ZRANGEBYLEX command. The function does not take ownership of the objects, so they can be released ASAP after the iterator is setup.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_zsetlastinlexrange","title":"<code>RedisModule_ZsetLastInLexRange</code>","text":"<pre><code>int RedisModule_ZsetLastInLexRange(RedisModuleKey *key,\n                                   RedisModuleString *min,\n                                   RedisModuleString *max);\n</code></pre> <p>Available since: 4.0.0</p> <p>Exactly like <code>RedisModule_ZsetFirstInLexRange()</code> but the last element of the range is selected for the start of the iteration instead.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_zsetrangecurrentelement","title":"<code>RedisModule_ZsetRangeCurrentElement</code>","text":"<pre><code>RedisModuleString *RedisModule_ZsetRangeCurrentElement(RedisModuleKey *key,\n                                                       double *score);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return the current sorted set element of an active sorted set iterator or NULL if the range specified in the iterator does not include any element.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_zsetrangenext","title":"<code>RedisModule_ZsetRangeNext</code>","text":"<pre><code>int RedisModule_ZsetRangeNext(RedisModuleKey *key);\n</code></pre> <p>Available since: 4.0.0</p> <p>Go to the next element of the sorted set iterator. Returns 1 if there was a next element, 0 if we are already at the latest element or the range does not include any item at all.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_zsetrangeprev","title":"<code>RedisModule_ZsetRangePrev</code>","text":"<pre><code>int RedisModule_ZsetRangePrev(RedisModuleKey *key);\n</code></pre> <p>Available since: 4.0.0</p> <p>Go to the previous element of the sorted set iterator. Returns 1 if there was a previous element, 0 if we are already at the first element or the range does not include any item at all.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#key-api-for-hash-type","title":"Key API for Hash type","text":"<p>See also <code>RedisModule_ValueLength()</code>, which returns the number of fields in a hash.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_hashset","title":"<code>RedisModule_HashSet</code>","text":"<pre><code>int RedisModule_HashSet(RedisModuleKey *key, int flags, ...);\n</code></pre> <p>Available since: 4.0.0</p> <p>Set the field of the specified hash field to the specified value. If the key is an empty key open for writing, it is created with an empty hash value, in order to set the specified field.</p> <p>The function is variadic and the user must specify pairs of field names and values, both as <code>RedisModuleString</code> pointers (unless the CFIELD option is set, see later). At the end of the field/value-ptr pairs, NULL must be specified as last argument to signal the end of the arguments in the variadic function.</p> <p>Example to set the hash argv[1] to the value argv[2]:</p> <pre><code> RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],argv[2],NULL);\n</code></pre> <p>The function can also be used in order to delete fields (if they exist) by setting them to the specified value of <code>REDISMODULE_HASH_DELETE</code>:</p> <pre><code> RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],\n                     REDISMODULE_HASH_DELETE,NULL);\n</code></pre> <p>The behavior of the command changes with the specified flags, that can be set to <code>REDISMODULE_HASH_NONE</code> if no special behavior is needed.</p> <pre><code>REDISMODULE_HASH_NX: The operation is performed only if the field was not\n                     already existing in the hash.\nREDISMODULE_HASH_XX: The operation is performed only if the field was\n                     already existing, so that a new value could be\n                     associated to an existing filed, but no new fields\n                     are created.\nREDISMODULE_HASH_CFIELDS: The field names passed are null terminated C\n                          strings instead of RedisModuleString objects.\nREDISMODULE_HASH_COUNT_ALL: Include the number of inserted fields in the\n                            returned number, in addition to the number of\n                            updated and deleted fields. (Added in Redis\n                            6.2.)\n</code></pre> <p>Unless NX is specified, the command overwrites the old field value with the new one.</p> <p>When using <code>REDISMODULE_HASH_CFIELDS</code>, field names are reported using normal C strings, so for example to delete the field \"foo\" the following code can be used:</p> <pre><code> RedisModule_HashSet(key,REDISMODULE_HASH_CFIELDS,\"foo\",\n                     REDISMODULE_HASH_DELETE,NULL);\n</code></pre> <p>Return value:</p> <p>The number of fields existing in the hash prior to the call, which have been updated (its old value has been replaced by a new value) or deleted. If the flag <code>REDISMODULE_HASH_COUNT_ALL</code> is set, inserted fields not previously existing in the hash are also counted.</p> <p>If the return value is zero, <code>errno</code> is set (since Redis 6.2) as follows:</p> <ul> <li>EINVAL if any unknown flags are set or if key is NULL.</li> <li>ENOTSUP if the key is associated with a non Hash value.</li> <li>EBADF if the key was not opened for writing.</li> <li>ENOENT if no fields were counted as described under Return value above.   This is not actually an error. The return value can be zero if all fields   were just created and the <code>COUNT_ALL</code> flag was unset, or if changes were held   back due to the NX and XX flags.</li> </ul> <p>NOTICE: The return value semantics of this function are very different between Redis 6.2 and older versions. Modules that use it should determine the Redis version and handle it accordingly.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_hashget","title":"<code>RedisModule_HashGet</code>","text":"<pre><code>int RedisModule_HashGet(RedisModuleKey *key, int flags, ...);\n</code></pre> <p>Available since: 4.0.0</p> <p>Get fields from a hash value. This function is called using a variable number of arguments, alternating a field name (as a <code>RedisModuleString</code> pointer) with a pointer to a <code>RedisModuleString</code> pointer, that is set to the value of the field if the field exists, or NULL if the field does not exist. At the end of the field/value-ptr pairs, NULL must be specified as last argument to signal the end of the arguments in the variadic function.</p> <p>This is an example usage:</p> <pre><code> RedisModuleString *first, *second;\n RedisModule_HashGet(mykey,REDISMODULE_HASH_NONE,argv[1],&amp;first,\n                     argv[2],&amp;second,NULL);\n</code></pre> <p>As with <code>RedisModule_HashSet()</code> the behavior of the command can be specified passing flags different than <code>REDISMODULE_HASH_NONE</code>:</p> <p><code>REDISMODULE_HASH_CFIELDS</code>: field names as null terminated C strings.</p> <p><code>REDISMODULE_HASH_EXISTS</code>: instead of setting the value of the field expecting a <code>RedisModuleString</code> pointer to pointer, the function just reports if the field exists or not and expects an integer pointer as the second element of each pair.</p> <p>Example of <code>REDISMODULE_HASH_CFIELDS</code>:</p> <pre><code> RedisModuleString *username, *hashedpass;\n RedisModule_HashGet(mykey,REDISMODULE_HASH_CFIELDS,\"username\",&amp;username,\"hp\",&amp;hashedpass, NULL);\n</code></pre> <p>Example of <code>REDISMODULE_HASH_EXISTS</code>:</p> <pre><code> int exists;\n RedisModule_HashGet(mykey,REDISMODULE_HASH_EXISTS,argv[1],&amp;exists,NULL);\n</code></pre> <p>The function returns <code>REDISMODULE_OK</code> on success and <code>REDISMODULE_ERR</code> if the key is not a hash value.</p> <p>Memory management:</p> <p>The returned <code>RedisModuleString</code> objects should be released with <code>RedisModule_FreeString()</code>, or by enabling automatic memory management.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#key-api-for-stream-type","title":"Key API for Stream type","text":"<p>For an introduction to streams, see https://redis.io/topics/streams-intro.</p> <p>The type <code>RedisModuleStreamID</code>, which is used in stream functions, is a struct with two 64-bit fields and is defined as</p> <pre><code>typedef struct RedisModuleStreamID {\n    uint64_t ms;\n    uint64_t seq;\n} RedisModuleStreamID;\n</code></pre> <p>See also <code>RedisModule_ValueLength()</code>, which returns the length of a stream, and the conversion functions <code>RedisModule_StringToStreamID()</code> and <code>RedisModule_CreateStringFromStreamID()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_streamadd","title":"<code>RedisModule_StreamAdd</code>","text":"<pre><code>int RedisModule_StreamAdd(RedisModuleKey *key,\n                          int flags,\n                          RedisModuleStreamID *id,\n                          RedisModuleString **argv,\n                          long numfields);\n</code></pre> <p>Available since: 6.2.0</p> <p>Adds an entry to a stream. Like XADD without trimming.</p> <ul> <li><code>key</code>: The key where the stream is (or will be) stored</li> <li><code>flags</code>: A bit field of</li> <li><code>REDISMODULE_STREAM_ADD_AUTOID</code>: Assign a stream ID automatically, like     <code>*</code> in the XADD command.</li> <li><code>id</code>: If the <code>AUTOID</code> flag is set, this is where the assigned ID is   returned. Can be NULL if <code>AUTOID</code> is set, if you don't care to receive the   ID. If <code>AUTOID</code> is not set, this is the requested ID.</li> <li><code>argv</code>: A pointer to an array of size <code>numfields * 2</code> containing the   fields and values.</li> <li><code>numfields</code>: The number of field-value pairs in <code>argv</code>.</li> </ul> <p>Returns <code>REDISMODULE_OK</code> if an entry has been added. On failure, <code>REDISMODULE_ERR</code> is returned and <code>errno</code> is set as follows:</p> <ul> <li>EINVAL if called with invalid arguments</li> <li>ENOTSUP if the key refers to a value of a type other than stream</li> <li>EBADF if the key was not opened for writing</li> <li>EDOM if the given ID was 0-0 or not greater than all other IDs in the   stream (only if the AUTOID flag is unset)</li> <li>EFBIG if the stream has reached the last possible ID</li> <li>ERANGE if the elements are too large to be stored.</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_streamdelete","title":"<code>RedisModule_StreamDelete</code>","text":"<pre><code>int RedisModule_StreamDelete(RedisModuleKey *key, RedisModuleStreamID *id);\n</code></pre> <p>Available since: 6.2.0</p> <p>Deletes an entry from a stream.</p> <ul> <li><code>key</code>: A key opened for writing, with no stream iterator started.</li> <li><code>id</code>: The stream ID of the entry to delete.</li> </ul> <p>Returns <code>REDISMODULE_OK</code> on success. On failure, <code>REDISMODULE_ERR</code> is returned and <code>errno</code> is set as follows:</p> <ul> <li>EINVAL if called with invalid arguments</li> <li>ENOTSUP if the key refers to a value of a type other than stream or if the   key is empty</li> <li>EBADF if the key was not opened for writing or if a stream iterator is   associated with the key</li> <li>ENOENT if no entry with the given stream ID exists</li> </ul> <p>See also <code>RedisModule_StreamIteratorDelete()</code> for deleting the current entry while iterating using a stream iterator.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_streamiteratorstart","title":"<code>RedisModule_StreamIteratorStart</code>","text":"<pre><code>int RedisModule_StreamIteratorStart(RedisModuleKey *key,\n                                    int flags,\n                                    RedisModuleStreamID *start,\n                                    RedisModuleStreamID *end);\n</code></pre> <p>Available since: 6.2.0</p> <p>Sets up a stream iterator.</p> <ul> <li><code>key</code>: The stream key opened for reading using <code>RedisModule_OpenKey()</code>.</li> <li><code>flags</code>:</li> <li><code>REDISMODULE_STREAM_ITERATOR_EXCLUSIVE</code>: Don't include <code>start</code> and <code>end</code>     in the iterated range.</li> <li><code>REDISMODULE_STREAM_ITERATOR_REVERSE</code>: Iterate in reverse order, starting     from the <code>end</code> of the range.</li> <li><code>start</code>: The lower bound of the range. Use NULL for the beginning of the   stream.</li> <li><code>end</code>: The upper bound of the range. Use NULL for the end of the stream.</li> </ul> <p>Returns <code>REDISMODULE_OK</code> on success. On failure, <code>REDISMODULE_ERR</code> is returned and <code>errno</code> is set as follows:</p> <ul> <li>EINVAL if called with invalid arguments</li> <li>ENOTSUP if the key refers to a value of a type other than stream or if the   key is empty</li> <li>EBADF if the key was not opened for writing or if a stream iterator is   already associated with the key</li> <li>EDOM if <code>start</code> or <code>end</code> is outside the valid range</li> </ul> <p>Returns <code>REDISMODULE_OK</code> on success and <code>REDISMODULE_ERR</code> if the key doesn't refer to a stream or if invalid arguments were given.</p> <p>The stream IDs are retrieved using <code>RedisModule_StreamIteratorNextID()</code> and for each stream ID, the fields and values are retrieved using <code>RedisModule_StreamIteratorNextField()</code>. The iterator is freed by calling <code>RedisModule_StreamIteratorStop()</code>.</p> <p>Example (error handling omitted):</p> <pre><code>RedisModule_StreamIteratorStart(key, 0, startid_ptr, endid_ptr);\nRedisModuleStreamID id;\nlong numfields;\nwhile (RedisModule_StreamIteratorNextID(key, &amp;id, &amp;numfields) ==\n       REDISMODULE_OK) {\n    RedisModuleString *field, *value;\n    while (RedisModule_StreamIteratorNextField(key, &amp;field, &amp;value) ==\n           REDISMODULE_OK) {\n        //\n        // ... Do stuff ...\n        //\n        RedisModule_FreeString(ctx, field);\n        RedisModule_FreeString(ctx, value);\n    }\n}\nRedisModule_StreamIteratorStop(key);\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_streamiteratorstop","title":"<code>RedisModule_StreamIteratorStop</code>","text":"<pre><code>int RedisModule_StreamIteratorStop(RedisModuleKey *key);\n</code></pre> <p>Available since: 6.2.0</p> <p>Stops a stream iterator created using <code>RedisModule_StreamIteratorStart()</code> and reclaims its memory.</p> <p>Returns <code>REDISMODULE_OK</code> on success. On failure, <code>REDISMODULE_ERR</code> is returned and <code>errno</code> is set as follows:</p> <ul> <li>EINVAL if called with a NULL key</li> <li>ENOTSUP if the key refers to a value of a type other than stream or if the   key is empty</li> <li>EBADF if the key was not opened for writing or if no stream iterator is   associated with the key</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_streamiteratornextid","title":"<code>RedisModule_StreamIteratorNextID</code>","text":"<pre><code>int RedisModule_StreamIteratorNextID(RedisModuleKey *key,\n                                     RedisModuleStreamID *id,\n                                     long *numfields);\n</code></pre> <p>Available since: 6.2.0</p> <p>Finds the next stream entry and returns its stream ID and the number of fields.</p> <ul> <li><code>key</code>: Key for which a stream iterator has been started using   <code>RedisModule_StreamIteratorStart()</code>.</li> <li><code>id</code>: The stream ID returned. NULL if you don't care.</li> <li><code>numfields</code>: The number of fields in the found stream entry. NULL if you   don't care.</li> </ul> <p>Returns <code>REDISMODULE_OK</code> and sets <code>*id</code> and <code>*numfields</code> if an entry was found. On failure, <code>REDISMODULE_ERR</code> is returned and <code>errno</code> is set as follows:</p> <ul> <li>EINVAL if called with a NULL key</li> <li>ENOTSUP if the key refers to a value of a type other than stream or if the   key is empty</li> <li>EBADF if no stream iterator is associated with the key</li> <li>ENOENT if there are no more entries in the range of the iterator</li> </ul> <p>In practice, if <code>RedisModule_StreamIteratorNextID()</code> is called after a successful call to <code>RedisModule_StreamIteratorStart()</code> and with the same key, it is safe to assume that an <code>REDISMODULE_ERR</code> return value means that there are no more entries.</p> <p>Use <code>RedisModule_StreamIteratorNextField()</code> to retrieve the fields and values. See the example at <code>RedisModule_StreamIteratorStart()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_streamiteratornextfield","title":"<code>RedisModule_StreamIteratorNextField</code>","text":"<pre><code>int RedisModule_StreamIteratorNextField(RedisModuleKey *key,\n                                        RedisModuleString **field_ptr,\n                                        RedisModuleString **value_ptr);\n</code></pre> <p>Available since: 6.2.0</p> <p>Retrieves the next field of the current stream ID and its corresponding value in a stream iteration. This function should be called repeatedly after calling <code>RedisModule_StreamIteratorNextID()</code> to fetch each field-value pair.</p> <ul> <li><code>key</code>: Key where a stream iterator has been started.</li> <li><code>field_ptr</code>: This is where the field is returned.</li> <li><code>value_ptr</code>: This is where the value is returned.</li> </ul> <p>Returns <code>REDISMODULE_OK</code> and points <code>*field_ptr</code> and <code>*value_ptr</code> to freshly allocated <code>RedisModuleString</code> objects. The string objects are freed automatically when the callback finishes if automatic memory is enabled. On failure, <code>REDISMODULE_ERR</code> is returned and <code>errno</code> is set as follows:</p> <ul> <li>EINVAL if called with a NULL key</li> <li>ENOTSUP if the key refers to a value of a type other than stream or if the   key is empty</li> <li>EBADF if no stream iterator is associated with the key</li> <li>ENOENT if there are no more fields in the current stream entry</li> </ul> <p>In practice, if <code>RedisModule_StreamIteratorNextField()</code> is called after a successful call to <code>RedisModule_StreamIteratorNextID()</code> and with the same key, it is safe to assume that an <code>REDISMODULE_ERR</code> return value means that there are no more fields.</p> <p>See the example at <code>RedisModule_StreamIteratorStart()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_streamiteratordelete","title":"<code>RedisModule_StreamIteratorDelete</code>","text":"<pre><code>int RedisModule_StreamIteratorDelete(RedisModuleKey *key);\n</code></pre> <p>Available since: 6.2.0</p> <p>Deletes the current stream entry while iterating.</p> <p>This function can be called after <code>RedisModule_StreamIteratorNextID()</code> or after any calls to <code>RedisModule_StreamIteratorNextField()</code>.</p> <p>Returns <code>REDISMODULE_OK</code> on success. On failure, <code>REDISMODULE_ERR</code> is returned and <code>errno</code> is set as follows:</p> <ul> <li>EINVAL if key is NULL</li> <li>ENOTSUP if the key is empty or is of another type than stream</li> <li>EBADF if the key is not opened for writing, if no iterator has been started</li> <li>ENOENT if the iterator has no current stream entry</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_streamtrimbylength","title":"<code>RedisModule_StreamTrimByLength</code>","text":"<pre><code>long long RedisModule_StreamTrimByLength(RedisModuleKey *key,\n                                         int flags,\n                                         long long length);\n</code></pre> <p>Available since: 6.2.0</p> <p>Trim a stream by length, similar to XTRIM with MAXLEN.</p> <ul> <li><code>key</code>: Key opened for writing.</li> <li><code>flags</code>: A bitfield of</li> <li><code>REDISMODULE_STREAM_TRIM_APPROX</code>: Trim less if it improves performance,     like XTRIM with <code>~</code>.</li> <li><code>length</code>: The number of stream entries to keep after trimming.</li> </ul> <p>Returns the number of entries deleted. On failure, a negative value is returned and <code>errno</code> is set as follows:</p> <ul> <li>EINVAL if called with invalid arguments</li> <li>ENOTSUP if the key is empty or of a type other than stream</li> <li>EBADF if the key is not opened for writing</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_streamtrimbyid","title":"<code>RedisModule_StreamTrimByID</code>","text":"<pre><code>long long RedisModule_StreamTrimByID(RedisModuleKey *key,\n                                     int flags,\n                                     RedisModuleStreamID *id);\n</code></pre> <p>Available since: 6.2.0</p> <p>Trim a stream by ID, similar to XTRIM with MINID.</p> <ul> <li><code>key</code>: Key opened for writing.</li> <li><code>flags</code>: A bitfield of</li> <li><code>REDISMODULE_STREAM_TRIM_APPROX</code>: Trim less if it improves performance,     like XTRIM with <code>~</code>.</li> <li><code>id</code>: The smallest stream ID to keep after trimming.</li> </ul> <p>Returns the number of entries deleted. On failure, a negative value is returned and <code>errno</code> is set as follows:</p> <ul> <li>EINVAL if called with invalid arguments</li> <li>ENOTSUP if the key is empty or of a type other than stream</li> <li>EBADF if the key is not opened for writing</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#calling-redis-commands-from-modules","title":"Calling Redis commands from modules","text":"<p><code>RedisModule_Call()</code> sends a command to Redis. The remaining functions handle the reply.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_freecallreply","title":"<code>RedisModule_FreeCallReply</code>","text":"<pre><code>void RedisModule_FreeCallReply(RedisModuleCallReply *reply);\n</code></pre> <p>Available since: 4.0.0</p> <p>Free a Call reply and all the nested replies it contains if it's an array.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplytype","title":"<code>RedisModule_CallReplyType</code>","text":"<pre><code>int RedisModule_CallReplyType(RedisModuleCallReply *reply);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return the reply type as one of the following:</p> <ul> <li><code>REDISMODULE_REPLY_UNKNOWN</code></li> <li><code>REDISMODULE_REPLY_STRING</code></li> <li><code>REDISMODULE_REPLY_ERROR</code></li> <li><code>REDISMODULE_REPLY_INTEGER</code></li> <li><code>REDISMODULE_REPLY_ARRAY</code></li> <li><code>REDISMODULE_REPLY_NULL</code></li> <li><code>REDISMODULE_REPLY_MAP</code></li> <li><code>REDISMODULE_REPLY_SET</code></li> <li><code>REDISMODULE_REPLY_BOOL</code></li> <li><code>REDISMODULE_REPLY_DOUBLE</code></li> <li><code>REDISMODULE_REPLY_BIG_NUMBER</code></li> <li><code>REDISMODULE_REPLY_VERBATIM_STRING</code></li> <li><code>REDISMODULE_REPLY_ATTRIBUTE</code></li> <li><code>REDISMODULE_REPLY_PROMISE</code></li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplylength","title":"<code>RedisModule_CallReplyLength</code>","text":"<pre><code>size_t RedisModule_CallReplyLength(RedisModuleCallReply *reply);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return the reply type length, where applicable.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplyarrayelement","title":"<code>RedisModule_CallReplyArrayElement</code>","text":"<pre><code>RedisModuleCallReply *RedisModule_CallReplyArrayElement(RedisModuleCallReply *reply,\n                                                        size_t idx);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return the 'idx'-th nested call reply element of an array reply, or NULL if the reply type is wrong or the index is out of range.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplyinteger","title":"<code>RedisModule_CallReplyInteger</code>","text":"<pre><code>long long RedisModule_CallReplyInteger(RedisModuleCallReply *reply);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return the <code>long long</code> of an integer reply.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplydouble","title":"<code>RedisModule_CallReplyDouble</code>","text":"<pre><code>double RedisModule_CallReplyDouble(RedisModuleCallReply *reply);\n</code></pre> <p>Available since: 7.0.0</p> <p>Return the double value of a double reply.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplybignumber","title":"<code>RedisModule_CallReplyBigNumber</code>","text":"<pre><code>const char *RedisModule_CallReplyBigNumber(RedisModuleCallReply *reply,\n                                           size_t *len);\n</code></pre> <p>Available since: 7.0.0</p> <p>Return the big number value of a big number reply.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplyverbatim","title":"<code>RedisModule_CallReplyVerbatim</code>","text":"<pre><code>const char *RedisModule_CallReplyVerbatim(RedisModuleCallReply *reply,\n                                          size_t *len,\n                                          const char **format);\n</code></pre> <p>Available since: 7.0.0</p> <p>Return the value of a verbatim string reply, An optional output argument can be given to get verbatim reply format.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplybool","title":"<code>RedisModule_CallReplyBool</code>","text":"<pre><code>int RedisModule_CallReplyBool(RedisModuleCallReply *reply);\n</code></pre> <p>Available since: 7.0.0</p> <p>Return the Boolean value of a Boolean reply.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplysetelement","title":"<code>RedisModule_CallReplySetElement</code>","text":"<pre><code>RedisModuleCallReply *RedisModule_CallReplySetElement(RedisModuleCallReply *reply,\n                                                      size_t idx);\n</code></pre> <p>Available since: 7.0.0</p> <p>Return the 'idx'-th nested call reply element of a set reply, or NULL if the reply type is wrong or the index is out of range.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplymapelement","title":"<code>RedisModule_CallReplyMapElement</code>","text":"<pre><code>int RedisModule_CallReplyMapElement(RedisModuleCallReply *reply,\n                                    size_t idx,\n                                    RedisModuleCallReply **key,\n                                    RedisModuleCallReply **val);\n</code></pre> <p>Available since: 7.0.0</p> <p>Retrieve the 'idx'-th key and value of a map reply.</p> <p>Returns: - <code>REDISMODULE_OK</code> on success. - <code>REDISMODULE_ERR</code> if idx out of range or if the reply type is wrong.</p> <p>The <code>key</code> and <code>value</code> arguments are used to return by reference, and may be NULL if not required.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplyattribute","title":"<code>RedisModule_CallReplyAttribute</code>","text":"<pre><code>RedisModuleCallReply *RedisModule_CallReplyAttribute(RedisModuleCallReply *reply);\n</code></pre> <p>Available since: 7.0.0</p> <p>Return the attribute of the given reply, or NULL if no attribute exists.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplyattributeelement","title":"<code>RedisModule_CallReplyAttributeElement</code>","text":"<pre><code>int RedisModule_CallReplyAttributeElement(RedisModuleCallReply *reply,\n                                          size_t idx,\n                                          RedisModuleCallReply **key,\n                                          RedisModuleCallReply **val);\n</code></pre> <p>Available since: 7.0.0</p> <p>Retrieve the 'idx'-th key and value of an attribute reply.</p> <p>Returns: - <code>REDISMODULE_OK</code> on success. - <code>REDISMODULE_ERR</code> if idx out of range or if the reply type is wrong.</p> <p>The <code>key</code> and <code>value</code> arguments are used to return by reference, and may be NULL if not required.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplypromisesetunblockhandler","title":"<code>RedisModule_CallReplyPromiseSetUnblockHandler</code>","text":"<pre><code>void RedisModule_CallReplyPromiseSetUnblockHandler(RedisModuleCallReply *reply,\n                                                   RedisModuleOnUnblocked on_unblock,\n                                                   void *private_data);\n</code></pre> <p>Available since: 7.2.0</p> <p>Set unblock handler (callback and private data) on the given promise <code>RedisModuleCallReply</code>. The given reply must be of promise type (<code>REDISMODULE_REPLY_PROMISE</code>).</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplypromiseabort","title":"<code>RedisModule_CallReplyPromiseAbort</code>","text":"<pre><code>int RedisModule_CallReplyPromiseAbort(RedisModuleCallReply *reply,\n                                      void **private_data);\n</code></pre> <p>Available since: 7.2.0</p> <p>Abort the execution of a given promise <code>RedisModuleCallReply</code>. return <code>REDMODULE_OK</code> in case the abort was done successfully and <code>REDISMODULE_ERR</code> if its not possible to abort the execution (execution already finished). In case the execution was aborted (<code>REDMODULE_OK</code> was returned), the <code>private_data</code> out parameter will be set with the value of the private data that was given on '<code>RedisModule_CallReplyPromiseSetUnblockHandler</code>' so the caller will be able to release the private data.</p> <p>If the execution was aborted successfully, it is promised that the unblock handler will not be called. That said, it is possible that the abort operation will successes but the operation will still continue. This can happened if, for example, a module implements some blocking command and does not respect the disconnect callback. For pure Redis commands this can not happened.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplystringptr","title":"<code>RedisModule_CallReplyStringPtr</code>","text":"<pre><code>const char *RedisModule_CallReplyStringPtr(RedisModuleCallReply *reply,\n                                           size_t *len);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return the pointer and length of a string or error reply.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_createstringfromcallreply","title":"<code>RedisModule_CreateStringFromCallReply</code>","text":"<pre><code>RedisModuleString *RedisModule_CreateStringFromCallReply(RedisModuleCallReply *reply);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return a new string object from a call reply of type string, error or integer. Otherwise (wrong reply type) return NULL.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_setcontextuser","title":"<code>RedisModule_SetContextUser</code>","text":"<pre><code>void RedisModule_SetContextUser(RedisModuleCtx *ctx,\n                                const RedisModuleUser *user);\n</code></pre> <p>Available since: 7.0.6</p> <p>Modifies the user that <code>RedisModule_Call</code> will use (e.g. for ACL checks)</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_call","title":"<code>RedisModule_Call</code>","text":"<pre><code>RedisModuleCallReply *RedisModule_Call(RedisModuleCtx *ctx,\n                                       const char *cmdname,\n                                       const char *fmt,\n                                       ...);\n</code></pre> <p>Available since: 4.0.0</p> <p>Exported API to call any Redis command from modules.</p> <ul> <li>cmdname: The Redis command to call.</li> <li> <p>fmt: A format specifier string for the command's arguments. Each   of the arguments should be specified by a valid type specification. The   format specifier can also contain the modifiers <code>!</code>, <code>A</code>, <code>3</code> and <code>R</code> which   don't have a corresponding argument.</p> <ul> <li><code>b</code> -- The argument is a buffer and is immediately followed by another          argument that is the buffer's length.</li> <li><code>c</code> -- The argument is a pointer to a plain C string (null-terminated).</li> <li><code>l</code> -- The argument is a <code>long long</code> integer.</li> <li><code>s</code> -- The argument is a RedisModuleString.</li> <li><code>v</code> -- The argument(s) is a vector of RedisModuleString.</li> <li><code>!</code> -- Sends the Redis command and its arguments to replicas and AOF.</li> <li><code>A</code> -- Suppress AOF propagation, send only to replicas (requires <code>!</code>).</li> <li><code>R</code> -- Suppress replicas propagation, send only to AOF (requires <code>!</code>).</li> <li><code>3</code> -- Return a RESP3 reply. This will change the command reply.          e.g., HGETALL returns a map instead of a flat array.</li> <li><code>0</code> -- Return the reply in auto mode, i.e. the reply format will be the          same as the client attached to the given RedisModuleCtx. This will          probably used when you want to pass the reply directly to the client.</li> <li><code>C</code> -- Run a command as the user attached to the context.          User is either attached automatically via the client that directly          issued the command and created the context or via RedisModule_SetContextUser.          If the context is not directly created by an issued command (such as a          background context and no user was set on it via RedisModule_SetContextUser,          RedisModule_Call will fail.          Checks if the command can be executed according to ACL rules and causes          the command to run as the determined user, so that any future user          dependent activity, such as ACL checks within scripts will proceed as          expected.          Otherwise, the command will run as the Redis unrestricted user.</li> <li><code>S</code> -- Run the command in a script mode, this means that it will raise          an error if a command which are not allowed inside a script          (flagged with the <code>deny-script</code> flag) is invoked (like SHUTDOWN).          In addition, on script mode, write commands are not allowed if there are          not enough good replicas (as configured with <code>min-replicas-to-write</code>)          or when the server is unable to persist to the disk.</li> <li><code>W</code> -- Do not allow to run any write command (flagged with the <code>write</code> flag).</li> <li><code>M</code> -- Do not allow <code>deny-oom</code> flagged commands when over the memory limit.</li> <li><code>E</code> -- Return error as RedisModuleCallReply. If there is an error before          invoking the command, the error is returned using errno mechanism.          This flag allows to get the error also as an error CallReply with          relevant error message.</li> <li>'D' -- A \"Dry Run\" mode. Return before executing the underlying call().          If everything succeeded, it will return with a NULL, otherwise it will          return with a CallReply object denoting the error, as if it was called with          the 'E' code.</li> <li>'K' -- Allow running blocking commands. If enabled and the command gets blocked, a          special REDISMODULE_REPLY_PROMISE will be returned. This reply type          indicates that the command was blocked and the reply will be given asynchronously.          The module can use this reply object to set a handler which will be called when          the command gets unblocked using RedisModule_CallReplyPromiseSetUnblockHandler.          The handler must be set immediately after the command invocation (without releasing          the Redis lock in between). If the handler is not set, the blocking command will          still continue its execution but the reply will be ignored (fire and forget),          notice that this is dangerous in case of role change, as explained below.          The module can use RedisModule_CallReplyPromiseAbort to abort the command invocation          if it was not yet finished (see RedisModule_CallReplyPromiseAbort documentation for more          details). It is also the module's responsibility to abort the execution on role change, either by using          server event (to get notified when the instance becomes a replica) or relying on the disconnect          callback of the original client. Failing to do so can result in a write operation on a replica.          Unlike other call replies, promise call reply must be freed while the Redis GIL is locked.          Notice that on unblocking, the only promise is that the unblock handler will be called,          If the blocking RedisModule_Call caused the module to also block some real client (using RedisModule_BlockClient),          it is the module responsibility to unblock this client on the unblock handler.          On the unblock handler it is only allowed to perform the following:          * Calling additional Redis commands using RedisModule_Call          * Open keys using RedisModule_OpenKey          * Replicate data to the replica or AOF<pre><code> Specifically, it is not allowed to call any Redis module API which are client related such as:\n * RedisModule_Reply* API's\n * RedisModule_BlockClient\n * RedisModule_GetCurrentUserName\n</code></pre> </li> </ul> </li> <li> <p>...: The actual arguments to the Redis command.</p> </li> </ul> <p>On success a <code>RedisModuleCallReply</code> object is returned, otherwise NULL is returned and errno is set to the following values:</p> <ul> <li>EBADF: wrong format specifier.</li> <li>EINVAL: wrong command arity.</li> <li>ENOENT: command does not exist.</li> <li>EPERM: operation in Cluster instance with key in non local slot.</li> <li>EROFS: operation in Cluster instance when a write command is sent          in a readonly state.</li> <li>ENETDOWN: operation in Cluster instance when cluster is down.</li> <li>ENOTSUP: No ACL user for the specified module context</li> <li>EACCES: Command cannot be executed, according to ACL rules</li> <li>ENOSPC: Write or deny-oom command is not allowed</li> <li>ESPIPE: Command not allowed on script mode</li> </ul> <p>Example code fragment:</p> <pre><code> reply = RedisModule_Call(ctx,\"INCRBY\",\"sc\",argv[1],\"10\");\n if (RedisModule_CallReplyType(reply) == REDISMODULE_REPLY_INTEGER) {\n   long long myval = RedisModule_CallReplyInteger(reply);\n   // Do something with myval.\n }\n</code></pre> <p>This API is documented here: https://redis.io/topics/modules-intro</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_callreplyproto","title":"<code>RedisModule_CallReplyProto</code>","text":"<pre><code>const char *RedisModule_CallReplyProto(RedisModuleCallReply *reply,\n                                       size_t *len);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return a pointer, and a length, to the protocol returned by the command that returned the reply object.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#modules-data-types","title":"Modules data types","text":"<p>When String DMA or using existing data structures is not enough, it is possible to create new data types from scratch and export them to Redis. The module must provide a set of callbacks for handling the new values exported (for example in order to provide RDB saving/loading, AOF rewrite, and so forth). In this section we define this API.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_createdatatype","title":"<code>RedisModule_CreateDataType</code>","text":"<pre><code>moduleType *RedisModule_CreateDataType(RedisModuleCtx *ctx,\n                                       const char *name,\n                                       int encver,\n                                       void *typemethods_ptr);\n</code></pre> <p>Available since: 4.0.0</p> <p>Register a new data type exported by the module. The parameters are the following. Please for in depth documentation check the modules API documentation, especially https://redis.io/topics/modules-native-types.</p> <ul> <li>name: A 9 characters data type name that MUST be unique in the Redis   Modules ecosystem. Be creative... and there will be no collisions. Use   the charset A-Z a-z 9-0, plus the two \"-_\" characters. A good   idea is to use, for example <code>&lt;typename&gt;-&lt;vendor&gt;</code>. For example   \"tree-AntZ\" may mean \"Tree data structure by @antirez\". To use both   lower case and upper case letters helps in order to prevent collisions.</li> <li> <p>encver: Encoding version, which is, the version of the serialization   that a module used in order to persist data. As long as the \"name\"   matches, the RDB loading will be dispatched to the type callbacks   whatever 'encver' is used, however the module can understand if   the encoding it must load are of an older version of the module.   For example the module \"tree-AntZ\" initially used encver=0. Later   after an upgrade, it started to serialize data in a different format   and to register the type with encver=1. However this module may   still load old data produced by an older version if the <code>rdb_load</code>   callback is able to check the encver value and act accordingly.   The encver must be a positive value between 0 and 1023.</p> </li> <li> <p>typemethods_ptr is a pointer to a <code>RedisModuleTypeMethods</code> structure   that should be populated with the methods callbacks and structure   version, like in the following example:</p> <pre><code>RedisModuleTypeMethods tm = {\n    .version = REDISMODULE_TYPE_METHOD_VERSION,\n    .rdb_load = myType_RDBLoadCallBack,\n    .rdb_save = myType_RDBSaveCallBack,\n    .aof_rewrite = myType_AOFRewriteCallBack,\n    .free = myType_FreeCallBack,\n\n    // Optional fields\n    .digest = myType_DigestCallBack,\n    .mem_usage = myType_MemUsageCallBack,\n    .aux_load = myType_AuxRDBLoadCallBack,\n    .aux_save = myType_AuxRDBSaveCallBack,\n    .free_effort = myType_FreeEffortCallBack,\n    .unlink = myType_UnlinkCallBack,\n    .copy = myType_CopyCallback,\n    .defrag = myType_DefragCallback\n\n    // Enhanced optional fields\n    .mem_usage2 = myType_MemUsageCallBack2,\n    .free_effort2 = myType_FreeEffortCallBack2,\n    .unlink2 = myType_UnlinkCallBack2,\n    .copy2 = myType_CopyCallback2,\n}\n</code></pre> </li> <li> <p>rdb_load: A callback function pointer that loads data from RDB files.</p> </li> <li>rdb_save: A callback function pointer that saves data to RDB files.</li> <li>aof_rewrite: A callback function pointer that rewrites data as commands.</li> <li>digest: A callback function pointer that is used for <code>DEBUG DIGEST</code>.</li> <li>free: A callback function pointer that can free a type value.</li> <li>aux_save: A callback function pointer that saves out of keyspace data to RDB files.   'when' argument is either <code>REDISMODULE_AUX_BEFORE_RDB</code> or <code>REDISMODULE_AUX_AFTER_RDB</code>.</li> <li>aux_load: A callback function pointer that loads out of keyspace data from RDB files.   Similar to <code>aux_save</code>, returns <code>REDISMODULE_OK</code> on success, and ERR otherwise.</li> <li>free_effort: A callback function pointer that used to determine whether the module's   memory needs to be lazy reclaimed. The module should return the complexity involved by   freeing the value. for example: how many pointers are gonna be freed. Note that if it    returns 0, we'll always do an async free.</li> <li>unlink: A callback function pointer that used to notifies the module that the key has    been removed from the DB by redis, and may soon be freed by a background thread. Note that    it won't be called on FLUSHALL/FLUSHDB (both sync and async), and the module can use the    <code>RedisModuleEvent_FlushDB</code> to hook into that.</li> <li> <p>copy: A callback function pointer that is used to make a copy of the specified key.   The module is expected to perform a deep copy of the specified value and return it.   In addition, hints about the names of the source and destination keys is provided.   A NULL return value is considered an error and the copy operation fails.   Note: if the target key exists and is being overwritten, the copy callback will be   called first, followed by a free callback to the value that is being replaced.</p> </li> <li> <p>defrag: A callback function pointer that is used to request the module to defrag   a key. The module should then iterate pointers and call the relevant <code>RedisModule_Defrag*()</code>   functions to defragment pointers or complex types. The module should continue   iterating as long as <code>RedisModule_DefragShouldStop()</code> returns a zero value, and return a   zero value if finished or non-zero value if more work is left to be done. If more work   needs to be done, <code>RedisModule_DefragCursorSet()</code> and <code>RedisModule_DefragCursorGet()</code> can be used to track   this work across different calls.   Normally, the defrag mechanism invokes the callback without a time limit, so   <code>RedisModule_DefragShouldStop()</code> always returns zero. The \"late defrag\" mechanism which has   a time limit and provides cursor support is used only for keys that are determined   to have significant internal complexity. To determine this, the defrag mechanism   uses the <code>free_effort</code> callback and the 'active-defrag-max-scan-fields' config directive.   NOTE: The value is passed as a <code>void**</code> and the function is expected to update the   pointer if the top-level value pointer is defragmented and consequently changes.</p> </li> <li> <p>mem_usage2: Similar to <code>mem_usage</code>, but provides the <code>RedisModuleKeyOptCtx</code> parameter   so that meta information such as key name and db id can be obtained, and   the <code>sample_size</code> for size estimation (see MEMORY USAGE command).</p> </li> <li>free_effort2: Similar to <code>free_effort</code>, but provides the <code>RedisModuleKeyOptCtx</code> parameter   so that meta information such as key name and db id can be obtained.</li> <li>unlink2: Similar to <code>unlink</code>, but provides the <code>RedisModuleKeyOptCtx</code> parameter   so that meta information such as key name and db id can be obtained.</li> <li>copy2: Similar to <code>copy</code>, but provides the <code>RedisModuleKeyOptCtx</code> parameter   so that meta information such as key names and db ids can be obtained.</li> <li>aux_save2: Similar to <code>aux_save</code>, but with small semantic change, if the module   saves nothing on this callback then no data about this aux field will be written to the   RDB and it will be possible to load the RDB even if the module is not loaded.</li> </ul> <p>Note: the module name \"AAAAAAAAA\" is reserved and produces an error, it happens to be pretty lame as well.</p> <p>If <code>RedisModule_CreateDataType()</code> is called outside of <code>RedisModule_OnLoad()</code> function, there is already a module registering a type with the same name, or if the module name or encver is invalid, NULL is returned. Otherwise the new type is registered into Redis, and a reference of type <code>RedisModuleType</code> is returned: the caller of the function should store this reference into a global variable to make future use of it in the modules type API, since a single module may register multiple types. Example code fragment:</p> <pre><code> static RedisModuleType *BalancedTreeType;\n\n int RedisModule_OnLoad(RedisModuleCtx *ctx) {\n     // some code here ...\n     BalancedTreeType = RedisModule_CreateDataType(...);\n }\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_moduletypesetvalue","title":"<code>RedisModule_ModuleTypeSetValue</code>","text":"<pre><code>int RedisModule_ModuleTypeSetValue(RedisModuleKey *key,\n                                   moduleType *mt,\n                                   void *value);\n</code></pre> <p>Available since: 4.0.0</p> <p>If the key is open for writing, set the specified module type object as the value of the key, deleting the old value if any. On success <code>REDISMODULE_OK</code> is returned. If the key is not open for writing or there is an active iterator, <code>REDISMODULE_ERR</code> is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_moduletypegettype","title":"<code>RedisModule_ModuleTypeGetType</code>","text":"<pre><code>moduleType *RedisModule_ModuleTypeGetType(RedisModuleKey *key);\n</code></pre> <p>Available since: 4.0.0</p> <p>Assuming <code>RedisModule_KeyType()</code> returned <code>REDISMODULE_KEYTYPE_MODULE</code> on the key, returns the module type pointer of the value stored at key.</p> <p>If the key is NULL, is not associated with a module type, or is empty, then NULL is returned instead.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_moduletypegetvalue","title":"<code>RedisModule_ModuleTypeGetValue</code>","text":"<pre><code>void *RedisModule_ModuleTypeGetValue(RedisModuleKey *key);\n</code></pre> <p>Available since: 4.0.0</p> <p>Assuming <code>RedisModule_KeyType()</code> returned <code>REDISMODULE_KEYTYPE_MODULE</code> on the key, returns the module type low-level value stored at key, as it was set by the user via <code>RedisModule_ModuleTypeSetValue()</code>.</p> <p>If the key is NULL, is not associated with a module type, or is empty, then NULL is returned instead.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#rdb-loading-and-saving-functions","title":"RDB loading and saving functions","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_isioerror","title":"<code>RedisModule_IsIOError</code>","text":"<pre><code>int RedisModule_IsIOError(RedisModuleIO *io);\n</code></pre> <p>Available since: 6.0.0</p> <p>Returns true if any previous IO API failed. for <code>Load*</code> APIs the <code>REDISMODULE_OPTIONS_HANDLE_IO_ERRORS</code> flag must be set with <code>RedisModule_SetModuleOptions</code> first.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_saveunsigned","title":"<code>RedisModule_SaveUnsigned</code>","text":"<pre><code>void RedisModule_SaveUnsigned(RedisModuleIO *io, uint64_t value);\n</code></pre> <p>Available since: 4.0.0</p> <p>Save an unsigned 64 bit value into the RDB file. This function should only be called in the context of the <code>rdb_save</code> method of modules implementing new data types.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_loadunsigned","title":"<code>RedisModule_LoadUnsigned</code>","text":"<pre><code>uint64_t RedisModule_LoadUnsigned(RedisModuleIO *io);\n</code></pre> <p>Available since: 4.0.0</p> <p>Load an unsigned 64 bit value from the RDB file. This function should only be called in the context of the <code>rdb_load</code> method of modules implementing new data types.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_savesigned","title":"<code>RedisModule_SaveSigned</code>","text":"<pre><code>void RedisModule_SaveSigned(RedisModuleIO *io, int64_t value);\n</code></pre> <p>Available since: 4.0.0</p> <p>Like <code>RedisModule_SaveUnsigned()</code> but for signed 64 bit values.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_loadsigned","title":"<code>RedisModule_LoadSigned</code>","text":"<pre><code>int64_t RedisModule_LoadSigned(RedisModuleIO *io);\n</code></pre> <p>Available since: 4.0.0</p> <p>Like <code>RedisModule_LoadUnsigned()</code> but for signed 64 bit values.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_savestring","title":"<code>RedisModule_SaveString</code>","text":"<pre><code>void RedisModule_SaveString(RedisModuleIO *io, RedisModuleString *s);\n</code></pre> <p>Available since: 4.0.0</p> <p>In the context of the <code>rdb_save</code> method of a module type, saves a string into the RDB file taking as input a <code>RedisModuleString</code>.</p> <p>The string can be later loaded with <code>RedisModule_LoadString()</code> or other Load family functions expecting a serialized string inside the RDB file.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_savestringbuffer","title":"<code>RedisModule_SaveStringBuffer</code>","text":"<pre><code>void RedisModule_SaveStringBuffer(RedisModuleIO *io,\n                                  const char *str,\n                                  size_t len);\n</code></pre> <p>Available since: 4.0.0</p> <p>Like <code>RedisModule_SaveString()</code> but takes a raw C pointer and length as input.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_loadstring","title":"<code>RedisModule_LoadString</code>","text":"<pre><code>RedisModuleString *RedisModule_LoadString(RedisModuleIO *io);\n</code></pre> <p>Available since: 4.0.0</p> <p>In the context of the <code>rdb_load</code> method of a module data type, loads a string from the RDB file, that was previously saved with <code>RedisModule_SaveString()</code> functions family.</p> <p>The returned string is a newly allocated <code>RedisModuleString</code> object, and the user should at some point free it with a call to <code>RedisModule_FreeString()</code>.</p> <p>If the data structure does not store strings as <code>RedisModuleString</code> objects, the similar function <code>RedisModule_LoadStringBuffer()</code> could be used instead.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_loadstringbuffer","title":"<code>RedisModule_LoadStringBuffer</code>","text":"<pre><code>char *RedisModule_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr);\n</code></pre> <p>Available since: 4.0.0</p> <p>Like <code>RedisModule_LoadString()</code> but returns a heap allocated string that was allocated with <code>RedisModule_Alloc()</code>, and can be resized or freed with <code>RedisModule_Realloc()</code> or <code>RedisModule_Free()</code>.</p> <p>The size of the string is stored at '*lenptr' if not NULL. The returned string is not automatically NULL terminated, it is loaded exactly as it was stored inside the RDB file.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_savedouble","title":"<code>RedisModule_SaveDouble</code>","text":"<pre><code>void RedisModule_SaveDouble(RedisModuleIO *io, double value);\n</code></pre> <p>Available since: 4.0.0</p> <p>In the context of the <code>rdb_save</code> method of a module data type, saves a double value to the RDB file. The double can be a valid number, a NaN or infinity. It is possible to load back the value with <code>RedisModule_LoadDouble()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_loaddouble","title":"<code>RedisModule_LoadDouble</code>","text":"<pre><code>double RedisModule_LoadDouble(RedisModuleIO *io);\n</code></pre> <p>Available since: 4.0.0</p> <p>In the context of the <code>rdb_save</code> method of a module data type, loads back the double value saved by <code>RedisModule_SaveDouble()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_savefloat","title":"<code>RedisModule_SaveFloat</code>","text":"<pre><code>void RedisModule_SaveFloat(RedisModuleIO *io, float value);\n</code></pre> <p>Available since: 4.0.0</p> <p>In the context of the <code>rdb_save</code> method of a module data type, saves a float value to the RDB file. The float can be a valid number, a NaN or infinity. It is possible to load back the value with <code>RedisModule_LoadFloat()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_loadfloat","title":"<code>RedisModule_LoadFloat</code>","text":"<pre><code>float RedisModule_LoadFloat(RedisModuleIO *io);\n</code></pre> <p>Available since: 4.0.0</p> <p>In the context of the <code>rdb_save</code> method of a module data type, loads back the float value saved by <code>RedisModule_SaveFloat()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_savelongdouble","title":"<code>RedisModule_SaveLongDouble</code>","text":"<pre><code>void RedisModule_SaveLongDouble(RedisModuleIO *io, long double value);\n</code></pre> <p>Available since: 6.0.0</p> <p>In the context of the <code>rdb_save</code> method of a module data type, saves a long double value to the RDB file. The double can be a valid number, a NaN or infinity. It is possible to load back the value with <code>RedisModule_LoadLongDouble()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_loadlongdouble","title":"<code>RedisModule_LoadLongDouble</code>","text":"<pre><code>long double RedisModule_LoadLongDouble(RedisModuleIO *io);\n</code></pre> <p>Available since: 6.0.0</p> <p>In the context of the <code>rdb_save</code> method of a module data type, loads back the long double value saved by <code>RedisModule_SaveLongDouble()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#key-digest-api-debug-digest-interface-for-modules-types","title":"Key digest API (DEBUG DIGEST interface for modules types)","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_digestaddstringbuffer","title":"<code>RedisModule_DigestAddStringBuffer</code>","text":"<pre><code>void RedisModule_DigestAddStringBuffer(RedisModuleDigest *md,\n                                       const char *ele,\n                                       size_t len);\n</code></pre> <p>Available since: 4.0.0</p> <p>Add a new element to the digest. This function can be called multiple times one element after the other, for all the elements that constitute a given data structure. The function call must be followed by the call to <code>RedisModule_DigestEndSequence</code> eventually, when all the elements that are always in a given order are added. See the Redis Modules data types documentation for more info. However this is a quick example that uses Redis data types as an example.</p> <p>To add a sequence of unordered elements (for example in the case of a Redis Set), the pattern to use is:</p> <pre><code>foreach element {\n    AddElement(element);\n    EndSequence();\n}\n</code></pre> <p>Because Sets are not ordered, so every element added has a position that does not depend from the other. However if instead our elements are ordered in pairs, like field-value pairs of a Hash, then one should use:</p> <pre><code>foreach key,value {\n    AddElement(key);\n    AddElement(value);\n    EndSequence();\n}\n</code></pre> <p>Because the key and value will be always in the above order, while instead the single key-value pairs, can appear in any position into a Redis hash.</p> <p>A list of ordered elements would be implemented with:</p> <pre><code>foreach element {\n    AddElement(element);\n}\nEndSequence();\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_digestaddlonglong","title":"<code>RedisModule_DigestAddLongLong</code>","text":"<pre><code>void RedisModule_DigestAddLongLong(RedisModuleDigest *md, long long ll);\n</code></pre> <p>Available since: 4.0.0</p> <p>Like <code>RedisModule_DigestAddStringBuffer()</code> but takes a <code>long long</code> as input that gets converted into a string before adding it to the digest.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_digestendsequence","title":"<code>RedisModule_DigestEndSequence</code>","text":"<pre><code>void RedisModule_DigestEndSequence(RedisModuleDigest *md);\n</code></pre> <p>Available since: 4.0.0</p> <p>See the documentation for <code>RedisModule_DigestAddElement()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_loaddatatypefromstringencver","title":"<code>RedisModule_LoadDataTypeFromStringEncver</code>","text":"<pre><code>void *RedisModule_LoadDataTypeFromStringEncver(const RedisModuleString *str,\n                                               const moduleType *mt,\n                                               int encver);\n</code></pre> <p>Available since: 7.0.0</p> <p>Decode a serialized representation of a module data type 'mt', in a specific encoding version 'encver' from string 'str' and return a newly allocated value, or NULL if decoding failed.</p> <p>This call basically reuses the '<code>rdb_load</code>' callback which module data types implement in order to allow a module to arbitrarily serialize/de-serialize keys, similar to how the Redis 'DUMP' and 'RESTORE' commands are implemented.</p> <p>Modules should generally use the <code>REDISMODULE_OPTIONS_HANDLE_IO_ERRORS</code> flag and make sure the de-serialization code properly checks and handles IO errors (freeing allocated buffers and returning a NULL).</p> <p>If this is NOT done, Redis will handle corrupted (or just truncated) serialized data by producing an error message and terminating the process.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_loaddatatypefromstring","title":"<code>RedisModule_LoadDataTypeFromString</code>","text":"<pre><code>void *RedisModule_LoadDataTypeFromString(const RedisModuleString *str,\n                                         const moduleType *mt);\n</code></pre> <p>Available since: 6.0.0</p> <p>Similar to <code>RedisModule_LoadDataTypeFromStringEncver</code>, original version of the API, kept for backward compatibility.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_savedatatypetostring","title":"<code>RedisModule_SaveDataTypeToString</code>","text":"<pre><code>RedisModuleString *RedisModule_SaveDataTypeToString(RedisModuleCtx *ctx,\n                                                    void *data,\n                                                    const moduleType *mt);\n</code></pre> <p>Available since: 6.0.0</p> <p>Encode a module data type 'mt' value 'data' into serialized form, and return it as a newly allocated <code>RedisModuleString</code>.</p> <p>This call basically reuses the '<code>rdb_save</code>' callback which module data types implement in order to allow a module to arbitrarily serialize/de-serialize keys, similar to how the Redis 'DUMP' and 'RESTORE' commands are implemented.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getkeynamefromdigest","title":"<code>RedisModule_GetKeyNameFromDigest</code>","text":"<pre><code>const RedisModuleString *RedisModule_GetKeyNameFromDigest(RedisModuleDigest *dig);\n</code></pre> <p>Available since: 7.0.0</p> <p>Returns the name of the key currently being processed.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getdbidfromdigest","title":"<code>RedisModule_GetDbIdFromDigest</code>","text":"<pre><code>int RedisModule_GetDbIdFromDigest(RedisModuleDigest *dig);\n</code></pre> <p>Available since: 7.0.0</p> <p>Returns the database id of the key currently being processed.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#aof-api-for-modules-data-types","title":"AOF API for modules data types","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_emitaof","title":"<code>RedisModule_EmitAOF</code>","text":"<pre><code>void RedisModule_EmitAOF(RedisModuleIO *io,\n                         const char *cmdname,\n                         const char *fmt,\n                         ...);\n</code></pre> <p>Available since: 4.0.0</p> <p>Emits a command into the AOF during the AOF rewriting process. This function is only called in the context of the <code>aof_rewrite</code> method of data types exported by a module. The command works exactly like <code>RedisModule_Call()</code> in the way the parameters are passed, but it does not return anything as the error handling is performed by Redis itself.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#io-context-handling","title":"IO context handling","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_getkeynamefromio","title":"<code>RedisModule_GetKeyNameFromIO</code>","text":"<pre><code>const RedisModuleString *RedisModule_GetKeyNameFromIO(RedisModuleIO *io);\n</code></pre> <p>Available since: 5.0.5</p> <p>Returns the name of the key currently being processed. There is no guarantee that the key name is always available, so this may return NULL.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getkeynamefrommodulekey","title":"<code>RedisModule_GetKeyNameFromModuleKey</code>","text":"<pre><code>const RedisModuleString *RedisModule_GetKeyNameFromModuleKey(RedisModuleKey *key);\n</code></pre> <p>Available since: 6.0.0</p> <p>Returns a <code>RedisModuleString</code> with the name of the key from <code>RedisModuleKey</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getdbidfrommodulekey","title":"<code>RedisModule_GetDbIdFromModuleKey</code>","text":"<pre><code>int RedisModule_GetDbIdFromModuleKey(RedisModuleKey *key);\n</code></pre> <p>Available since: 7.0.0</p> <p>Returns a database id of the key from <code>RedisModuleKey</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getdbidfromio","title":"<code>RedisModule_GetDbIdFromIO</code>","text":"<pre><code>int RedisModule_GetDbIdFromIO(RedisModuleIO *io);\n</code></pre> <p>Available since: 7.0.0</p> <p>Returns the database id of the key currently being processed. There is no guarantee that this info is always available, so this may return -1.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#logging","title":"Logging","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_log","title":"<code>RedisModule_Log</code>","text":"<pre><code>void RedisModule_Log(RedisModuleCtx *ctx,\n                     const char *levelstr,\n                     const char *fmt,\n                     ...);\n</code></pre> <p>Available since: 4.0.0</p> <p>Produces a log message to the standard Redis log, the format accepts printf-alike specifiers, while level is a string describing the log level to use when emitting the log, and must be one of the following:</p> <ul> <li>\"debug\" (<code>REDISMODULE_LOGLEVEL_DEBUG</code>)</li> <li>\"verbose\" (<code>REDISMODULE_LOGLEVEL_VERBOSE</code>)</li> <li>\"notice\" (<code>REDISMODULE_LOGLEVEL_NOTICE</code>)</li> <li>\"warning\" (<code>REDISMODULE_LOGLEVEL_WARNING</code>)</li> </ul> <p>If the specified log level is invalid, verbose is used by default. There is a fixed limit to the length of the log line this function is able to emit, this limit is not specified but is guaranteed to be more than a few lines of text.</p> <p>The ctx argument may be NULL if cannot be provided in the context of the caller for instance threads or callbacks, in which case a generic \"module\" will be used instead of the module name.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_logioerror","title":"<code>RedisModule_LogIOError</code>","text":"<pre><code>void RedisModule_LogIOError(RedisModuleIO *io,\n                            const char *levelstr,\n                            const char *fmt,\n                            ...);\n</code></pre> <p>Available since: 4.0.0</p> <p>Log errors from RDB / AOF serialization callbacks.</p> <p>This function should be used when a callback is returning a critical error to the caller since cannot load or save the data for some critical reason.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule__assert","title":"<code>RedisModule__Assert</code>","text":"<pre><code>void RedisModule__Assert(const char *estr, const char *file, int line);\n</code></pre> <p>Available since: 6.0.0</p> <p>Redis-like assert function.</p> <p>The macro <code>RedisModule_Assert(expression)</code> is recommended, rather than calling this function directly.</p> <p>A failed assertion will shut down the server and produce logging information that looks identical to information generated by Redis itself.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_latencyaddsample","title":"<code>RedisModule_LatencyAddSample</code>","text":"<pre><code>void RedisModule_LatencyAddSample(const char *event, mstime_t latency);\n</code></pre> <p>Available since: 6.0.0</p> <p>Allows adding event to the latency monitor to be observed by the LATENCY command. The call is skipped if the latency is smaller than the configured latency-monitor-threshold.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#blocking-clients-from-modules","title":"Blocking clients from modules","text":"<p>For a guide about blocking commands in modules, see https://redis.io/topics/modules-blocking-ops.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_registerauthcallback","title":"<code>RedisModule_RegisterAuthCallback</code>","text":"<pre><code>void RedisModule_RegisterAuthCallback(RedisModuleCtx *ctx,\n                                      RedisModuleAuthCallback cb);\n</code></pre> <p>Available since: 7.2.0</p> <p>This API registers a callback to execute in addition to normal password based authentication. Multiple callbacks can be registered across different modules. When a Module is unloaded, all the auth callbacks registered by it are unregistered. The callbacks are attempted (in the order of most recently registered first) when the AUTH/HELLO (with AUTH field provided) commands are called. The callbacks will be called with a module context along with a username and a password, and are expected to take one of the following actions: (1) Authenticate - Use the <code>RedisModule_AuthenticateClient</code>* API and return <code>REDISMODULE_AUTH_HANDLED</code>. This will immediately end the auth chain as successful and add the OK reply. (2) Deny Authentication - Return <code>REDISMODULE_AUTH_HANDLED</code> without authenticating or blocking the client. Optionally, <code>err</code> can be set to a custom error message and <code>err</code> will be automatically freed by the server. This will immediately end the auth chain as unsuccessful and add the ERR reply. (3) Block a client on authentication - Use the <code>RedisModule_BlockClientOnAuth</code> API and return <code>REDISMODULE_AUTH_HANDLED</code>. Here, the client will be blocked until the <code>RedisModule_UnblockClient</code> API is used which will trigger the auth reply callback (provided through the <code>RedisModule_BlockClientOnAuth</code>). In this reply callback, the Module should authenticate, deny or skip handling authentication. (4) Skip handling Authentication - Return <code>REDISMODULE_AUTH_NOT_HANDLED</code> without blocking the client. This will allow the engine to attempt the next module auth callback. If none of the callbacks authenticate or deny auth, then password based auth is attempted and will authenticate or add failure logs and reply to the clients accordingly.</p> <p>Note: If a client is disconnected while it was in the middle of blocking module auth, that occurrence of the AUTH or HELLO command will not be tracked in the INFO command stats.</p> <p>The following is an example of how non-blocking module based authentication can be used:</p> <pre><code> int auth_cb(RedisModuleCtx *ctx, RedisModuleString *username, RedisModuleString *password, RedisModuleString **err) {\n     const char *user = RedisModule_StringPtrLen(username, NULL);\n     const char *pwd = RedisModule_StringPtrLen(password, NULL);\n     if (!strcmp(user,\"foo\") &amp;&amp; !strcmp(pwd,\"valid_password\")) {\n         RedisModule_AuthenticateClientWithACLUser(ctx, \"foo\", 3, NULL, NULL, NULL);\n         return REDISMODULE_AUTH_HANDLED;\n     }\n\n     else if (!strcmp(user,\"foo\") &amp;&amp; !strcmp(pwd,\"wrong_password\")) {\n         RedisModuleString *log = RedisModule_CreateString(ctx, \"Module Auth\", 11);\n         RedisModule_ACLAddLogEntryByUserName(ctx, username, log, REDISMODULE_ACL_LOG_AUTH);\n         RedisModule_FreeString(ctx, log);\n         const char *err_msg = \"Auth denied by Misc Module.\";\n         *err = RedisModule_CreateString(ctx, err_msg, strlen(err_msg));\n         return REDISMODULE_AUTH_HANDLED;\n     }\n     return REDISMODULE_AUTH_NOT_HANDLED;\n  }\n\n int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n     if (RedisModule_Init(ctx,\"authmodule\",1,REDISMODULE_APIVER_1)== REDISMODULE_ERR)\n         return REDISMODULE_ERR;\n     RedisModule_RegisterAuthCallback(ctx, auth_cb);\n     return REDISMODULE_OK;\n }\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_blockclient","title":"<code>RedisModule_BlockClient</code>","text":"<pre><code>RedisModuleBlockedClient *RedisModule_BlockClient(RedisModuleCtx *ctx,\n                                                  RedisModuleCmdFunc reply_callback,\n                                                  ;\n</code></pre> <p>Available since: 4.0.0</p> <p>Block a client in the context of a blocking command, returning a handle which will be used, later, in order to unblock the client with a call to <code>RedisModule_UnblockClient()</code>. The arguments specify callback functions and a timeout after which the client is unblocked.</p> <p>The callbacks are called in the following contexts:</p> <pre><code>reply_callback:   called after a successful RedisModule_UnblockClient()\n                  call in order to reply to the client and unblock it.\n\ntimeout_callback: called when the timeout is reached or if `CLIENT UNBLOCK`\n                  is invoked, in order to send an error to the client.\n\nfree_privdata:    called in order to free the private data that is passed\n                  by RedisModule_UnblockClient() call.\n</code></pre> <p>Note: <code>RedisModule_UnblockClient</code> should be called for every blocked client,       even if client was killed, timed-out or disconnected. Failing to do so       will result in memory leaks.</p> <p>There are some cases where <code>RedisModule_BlockClient()</code> cannot be used:</p> <ol> <li>If the client is a Lua script.</li> <li>If the client is executing a MULTI block.</li> </ol> <p>In these cases, a call to <code>RedisModule_BlockClient()</code> will not block the client, but instead produce a specific error reply.</p> <p>A module that registers a <code>timeout_callback</code> function can also be unblocked using the <code>CLIENT UNBLOCK</code> command, which will trigger the timeout callback. If a callback function is not registered, then the blocked client will be treated as if it is not in a blocked state and <code>CLIENT UNBLOCK</code> will return a zero value.</p> <p>Measuring background time: By default the time spent in the blocked command is not account for the total command duration. To include such time you should use <code>RedisModule_BlockedClientMeasureTimeStart()</code> and <code>RedisModule_BlockedClientMeasureTimeEnd()</code> one, or multiple times within the blocking command background work.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_blockclientonauth","title":"<code>RedisModule_BlockClientOnAuth</code>","text":"<pre><code>RedisModuleBlockedClient *RedisModule_BlockClientOnAuth(RedisModuleCtx *ctx,\n                                                        RedisModuleAuthCallback reply_callback,\n                                                        ;\n</code></pre> <p>Available since: 7.2.0</p> <p>Block the current client for module authentication in the background. If module auth is not in progress on the client, the API returns NULL. Otherwise, the client is blocked and the <code>RedisModule_BlockedClient</code> is returned similar to the <code>RedisModule_BlockClient</code> API. Note: Only use this API from the context of a module auth callback.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_blockclientgetprivatedata","title":"<code>RedisModule_BlockClientGetPrivateData</code>","text":"<pre><code>void *RedisModule_BlockClientGetPrivateData(RedisModuleBlockedClient *blocked_client);\n</code></pre> <p>Available since: 7.2.0</p> <p>Get the private data that was previusely set on a blocked client</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_blockclientsetprivatedata","title":"<code>RedisModule_BlockClientSetPrivateData</code>","text":"<pre><code>void RedisModule_BlockClientSetPrivateData(RedisModuleBlockedClient *blocked_client,\n                                           void *private_data);\n</code></pre> <p>Available since: 7.2.0</p> <p>Set private data on a blocked client</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_blockclientonkeys","title":"<code>RedisModule_BlockClientOnKeys</code>","text":"<pre><code>RedisModuleBlockedClient *RedisModule_BlockClientOnKeys(RedisModuleCtx *ctx,\n                                                        RedisModuleCmdFunc reply_callback,\n                                                        ;\n</code></pre> <p>Available since: 6.0.0</p> <p>This call is similar to <code>RedisModule_BlockClient()</code>, however in this case we don't just block the client, but also ask Redis to unblock it automatically once certain keys become \"ready\", that is, contain more data.</p> <p>Basically this is similar to what a typical Redis command usually does, like BLPOP or BZPOPMAX: the client blocks if it cannot be served ASAP, and later when the key receives new data (a list push for instance), the client is unblocked and served.</p> <p>However in the case of this module API, when the client is unblocked?</p> <ol> <li>If you block on a key of a type that has blocking operations associated,    like a list, a sorted set, a stream, and so forth, the client may be    unblocked once the relevant key is targeted by an operation that normally    unblocks the native blocking operations for that type. So if we block    on a list key, an RPUSH command may unblock our client and so forth.</li> <li>If you are implementing your native data type, or if you want to add new    unblocking conditions in addition to \"1\", you can call the modules API    <code>RedisModule_SignalKeyAsReady()</code>.</li> </ol> <p>Anyway we can't be sure if the client should be unblocked just because the key is signaled as ready: for instance a successive operation may change the key, or a client in queue before this one can be served, modifying the key as well and making it empty again. So when a client is blocked with <code>RedisModule_BlockClientOnKeys()</code> the reply callback is not called after <code>RedisModule_UnblockClient()</code> is called, but every time a key is signaled as ready: if the reply callback can serve the client, it returns <code>REDISMODULE_OK</code> and the client is unblocked, otherwise it will return <code>REDISMODULE_ERR</code> and we'll try again later.</p> <p>The reply callback can access the key that was signaled as ready by calling the API <code>RedisModule_GetBlockedClientReadyKey()</code>, that returns just the string name of the key as a <code>RedisModuleString</code> object.</p> <p>Thanks to this system we can setup complex blocking scenarios, like unblocking a client only if a list contains at least 5 items or other more fancy logics.</p> <p>Note that another difference with <code>RedisModule_BlockClient()</code>, is that here we pass the private data directly when blocking the client: it will be accessible later in the reply callback. Normally when blocking with <code>RedisModule_BlockClient()</code> the private data to reply to the client is passed when calling <code>RedisModule_UnblockClient()</code> but here the unblocking is performed by Redis itself, so we need to have some private data before hand. The private data is used to store any information about the specific unblocking operation that you are implementing. Such information will be freed using the <code>free_privdata</code> callback provided by the user.</p> <p>However the reply callback will be able to access the argument vector of the command, so the private data is often not needed.</p> <p>Note: Under normal circumstances <code>RedisModule_UnblockClient</code> should not be       called for clients that are blocked on keys (Either the key will       become ready or a timeout will occur). If for some reason you do want       to call RedisModule_UnblockClient it is possible: Client will be       handled as if it were timed-out (You must implement the timeout       callback in that case).</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_blockclientonkeyswithflags","title":"<code>RedisModule_BlockClientOnKeysWithFlags</code>","text":"<pre><code>RedisModuleBlockedClient *RedisModule_BlockClientOnKeysWithFlags(RedisModuleCtx *ctx,\n                                                                 RedisModuleCmdFunc reply_callback,\n                                                                 ;\n</code></pre> <p>Available since: 7.2.0</p> <p>Same as <code>RedisModule_BlockClientOnKeys</code>, but can take <code>REDISMODULE_BLOCK_</code>* flags Can be either <code>REDISMODULE_BLOCK_UNBLOCK_DEFAULT</code>, which means default behavior (same as calling <code>RedisModule_BlockClientOnKeys</code>)</p> <p>The flags is a bit mask of these:</p> <ul> <li><code>REDISMODULE_BLOCK_UNBLOCK_DELETED</code>: The clients should to be awakened in case any of <code>keys</code> are deleted.                                        Mostly useful for commands that require the key to exist (like XREADGROUP)</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_signalkeyasready","title":"<code>RedisModule_SignalKeyAsReady</code>","text":"<pre><code>void RedisModule_SignalKeyAsReady(RedisModuleCtx *ctx, RedisModuleString *key);\n</code></pre> <p>Available since: 6.0.0</p> <p>This function is used in order to potentially unblock a client blocked on keys with <code>RedisModule_BlockClientOnKeys()</code>. When this function is called, all the clients blocked for this key will get their <code>reply_callback</code> called.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_unblockclient","title":"<code>RedisModule_UnblockClient</code>","text":"<pre><code>int RedisModule_UnblockClient(RedisModuleBlockedClient *bc, void *privdata);\n</code></pre> <p>Available since: 4.0.0</p> <p>Unblock a client blocked by <code>RedisModule_BlockedClient</code>. This will trigger the reply callbacks to be called in order to reply to the client. The 'privdata' argument will be accessible by the reply callback, so the caller of this function can pass any value that is needed in order to actually reply to the client.</p> <p>A common usage for 'privdata' is a thread that computes something that needs to be passed to the client, included but not limited some slow to compute reply or some reply obtained via networking.</p> <p>Note 1: this function can be called from threads spawned by the module.</p> <p>Note 2: when we unblock a client that is blocked for keys using the API <code>RedisModule_BlockClientOnKeys()</code>, the privdata argument here is not used. Unblocking a client that was blocked for keys using this API will still require the client to get some reply, so the function will use the \"timeout\" handler in order to do so (The privdata provided in <code>RedisModule_BlockClientOnKeys()</code> is accessible from the timeout callback via <code>RedisModule_GetBlockedClientPrivateData</code>).</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_abortblock","title":"<code>RedisModule_AbortBlock</code>","text":"<pre><code>int RedisModule_AbortBlock(RedisModuleBlockedClient *bc);\n</code></pre> <p>Available since: 4.0.0</p> <p>Abort a blocked client blocking operation: the client will be unblocked without firing any callback.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_setdisconnectcallback","title":"<code>RedisModule_SetDisconnectCallback</code>","text":"<pre><code>void RedisModule_SetDisconnectCallback(RedisModuleBlockedClient *bc,\n                                       RedisModuleDisconnectFunc callback);\n</code></pre> <p>Available since: 5.0.0</p> <p>Set a callback that will be called if a blocked client disconnects before the module has a chance to call <code>RedisModule_UnblockClient()</code></p> <p>Usually what you want to do there, is to cleanup your module state so that you can call <code>RedisModule_UnblockClient()</code> safely, otherwise the client will remain blocked forever if the timeout is large.</p> <p>Notes:</p> <ol> <li> <p>It is not safe to call Reply* family functions here, it is also    useless since the client is gone.</p> </li> <li> <p>This callback is not called if the client disconnects because of    a timeout. In such a case, the client is unblocked automatically    and the timeout callback is called.</p> </li> </ol> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_isblockedreplyrequest","title":"<code>RedisModule_IsBlockedReplyRequest</code>","text":"<pre><code>int RedisModule_IsBlockedReplyRequest(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return non-zero if a module command was called in order to fill the reply for a blocked client.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_isblockedtimeoutrequest","title":"<code>RedisModule_IsBlockedTimeoutRequest</code>","text":"<pre><code>int RedisModule_IsBlockedTimeoutRequest(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return non-zero if a module command was called in order to fill the reply for a blocked client that timed out.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getblockedclientprivatedata","title":"<code>RedisModule_GetBlockedClientPrivateData</code>","text":"<pre><code>void *RedisModule_GetBlockedClientPrivateData(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 4.0.0</p> <p>Get the private data set by <code>RedisModule_UnblockClient()</code></p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getblockedclientreadykey","title":"<code>RedisModule_GetBlockedClientReadyKey</code>","text":"<pre><code>RedisModuleString *RedisModule_GetBlockedClientReadyKey(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 6.0.0</p> <p>Get the key that is ready when the reply callback is called in the context of a client blocked by <code>RedisModule_BlockClientOnKeys()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getblockedclienthandle","title":"<code>RedisModule_GetBlockedClientHandle</code>","text":"<pre><code>RedisModuleBlockedClient *RedisModule_GetBlockedClientHandle(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 5.0.0</p> <p>Get the blocked client associated with a given context. This is useful in the reply and timeout callbacks of blocked clients, before sometimes the module has the blocked client handle references around, and wants to cleanup it.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_blockedclientdisconnected","title":"<code>RedisModule_BlockedClientDisconnected</code>","text":"<pre><code>int RedisModule_BlockedClientDisconnected(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 5.0.0</p> <p>Return true if when the free callback of a blocked client is called, the reason for the client to be unblocked is that it disconnected while it was blocked.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#thread-safe-contexts","title":"Thread Safe Contexts","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_getthreadsafecontext","title":"<code>RedisModule_GetThreadSafeContext</code>","text":"<pre><code>RedisModuleCtx *RedisModule_GetThreadSafeContext(RedisModuleBlockedClient *bc);\n</code></pre> <p>Available since: 4.0.0</p> <p>Return a context which can be used inside threads to make Redis context calls with certain modules APIs. If 'bc' is not NULL then the module will be bound to a blocked client, and it will be possible to use the <code>RedisModule_Reply*</code> family of functions to accumulate a reply for when the client will be unblocked. Otherwise the thread safe context will be detached by a specific client.</p> <p>To call non-reply APIs, the thread safe context must be prepared with:</p> <pre><code>RedisModule_ThreadSafeContextLock(ctx);\n... make your call here ...\nRedisModule_ThreadSafeContextUnlock(ctx);\n</code></pre> <p>This is not needed when using <code>RedisModule_Reply*</code> functions, assuming that a blocked client was used when the context was created, otherwise no <code>RedisModule_Reply</code>* call should be made at all.</p> <p>NOTE: If you're creating a detached thread safe context (bc is NULL), consider using <code>RedisModule_GetDetachedThreadSafeContext</code> which will also retain the module ID and thus be more useful for logging.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getdetachedthreadsafecontext","title":"<code>RedisModule_GetDetachedThreadSafeContext</code>","text":"<pre><code>RedisModuleCtx *RedisModule_GetDetachedThreadSafeContext(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 6.0.9</p> <p>Return a detached thread safe context that is not associated with any specific blocked client, but is associated with the module's context.</p> <p>This is useful for modules that wish to hold a global context over a long term, for purposes such as logging.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_freethreadsafecontext","title":"<code>RedisModule_FreeThreadSafeContext</code>","text":"<pre><code>void RedisModule_FreeThreadSafeContext(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 4.0.0</p> <p>Release a thread safe context.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_threadsafecontextlock","title":"<code>RedisModule_ThreadSafeContextLock</code>","text":"<pre><code>void RedisModule_ThreadSafeContextLock(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 4.0.0</p> <p>Acquire the server lock before executing a thread safe API call. This is not needed for <code>RedisModule_Reply*</code> calls when there is a blocked client connected to the thread safe context.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_threadsafecontexttrylock","title":"<code>RedisModule_ThreadSafeContextTryLock</code>","text":"<pre><code>int RedisModule_ThreadSafeContextTryLock(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 6.0.8</p> <p>Similar to <code>RedisModule_ThreadSafeContextLock</code> but this function would not block if the server lock is already acquired.</p> <p>If successful (lock acquired) <code>REDISMODULE_OK</code> is returned, otherwise <code>REDISMODULE_ERR</code> is returned and errno is set accordingly.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_threadsafecontextunlock","title":"<code>RedisModule_ThreadSafeContextUnlock</code>","text":"<pre><code>void RedisModule_ThreadSafeContextUnlock(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 4.0.0</p> <p>Release the server lock after a thread safe API call was executed.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#module-keyspace-notifications-api","title":"Module Keyspace Notifications API","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_subscribetokeyspaceevents","title":"<code>RedisModule_SubscribeToKeyspaceEvents</code>","text":"<pre><code>int RedisModule_SubscribeToKeyspaceEvents(RedisModuleCtx *ctx,\n                                          int types,\n                                          RedisModuleNotificationFunc callback);\n</code></pre> <p>Available since: 4.0.9</p> <p>Subscribe to keyspace notifications. This is a low-level version of the keyspace-notifications API. A module can register callbacks to be notified when keyspace events occur.</p> <p>Notification events are filtered by their type (string events, set events, etc), and the subscriber callback receives only events that match a specific mask of event types.</p> <p>When subscribing to notifications with <code>RedisModule_SubscribeToKeyspaceEvents</code> the module must provide an event type-mask, denoting the events the subscriber is interested in. This can be an ORed mask of any of the following flags:</p> <ul> <li><code>REDISMODULE_NOTIFY_GENERIC</code>: Generic commands like DEL, EXPIRE, RENAME</li> <li><code>REDISMODULE_NOTIFY_STRING</code>: String events</li> <li><code>REDISMODULE_NOTIFY_LIST</code>: List events</li> <li><code>REDISMODULE_NOTIFY_SET</code>: Set events</li> <li><code>REDISMODULE_NOTIFY_HASH</code>: Hash events</li> <li><code>REDISMODULE_NOTIFY_ZSET</code>: Sorted Set events</li> <li><code>REDISMODULE_NOTIFY_EXPIRED</code>: Expiration events</li> <li><code>REDISMODULE_NOTIFY_EVICTED</code>: Eviction events</li> <li><code>REDISMODULE_NOTIFY_STREAM</code>: Stream events</li> <li><code>REDISMODULE_NOTIFY_MODULE</code>: Module types events</li> <li><code>REDISMODULE_NOTIFY_KEYMISS</code>: Key-miss events                                Notice, key-miss event is the only type                                of event that is fired from within a read command.                                Performing RedisModule_Call with a write command from within                                this notification is wrong and discourage. It will                                cause the read command that trigger the event to be                                replicated to the AOF/Replica.</li> <li><code>REDISMODULE_NOTIFY_ALL</code>: All events (Excluding <code>REDISMODULE_NOTIFY_KEYMISS</code>)</li> <li><code>REDISMODULE_NOTIFY_LOADED</code>: A special notification available only for modules,                               indicates that the key was loaded from persistence.                               Notice, when this event fires, the given key                               can not be retained, use RedisModule_CreateStringFromString                               instead.</li> </ul> <p>We do not distinguish between key events and keyspace events, and it is up to the module to filter the actions taken based on the key.</p> <p>The subscriber signature is:</p> <pre><code>int (*RedisModuleNotificationFunc) (RedisModuleCtx *ctx, int type,\n                                    const char *event,\n                                    RedisModuleString *key);\n</code></pre> <p><code>type</code> is the event type bit, that must match the mask given at registration time. The event string is the actual command being executed, and key is the relevant Redis key.</p> <p>Notification callback gets executed with a redis context that can not be used to send anything to the client, and has the db number where the event occurred as its selected db number.</p> <p>Notice that it is not necessary to enable notifications in redis.conf for module notifications to work.</p> <p>Warning: the notification callbacks are performed in a synchronous manner, so notification callbacks must to be fast, or they would slow Redis down. If you need to take long actions, use threads to offload them.</p> <p>Moreover, the fact that the notification is executed synchronously means that the notification code will be executed in the middle on Redis logic (commands logic, eviction, expire). Changing the key space while the logic runs is dangerous and discouraged. In order to react to key space events with write actions, please refer to <code>RedisModule_AddPostNotificationJob</code>.</p> <p>See https://redis.io/topics/notifications for more information.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_addpostnotificationjob","title":"<code>RedisModule_AddPostNotificationJob</code>","text":"<pre><code>int RedisModule_AddPostNotificationJob(RedisModuleCtx *ctx,\n                                       RedisModulePostNotificationJobFunc callback,\n                                       void *privdata,\n                                       void (*free_privdata)(void*));\n</code></pre> <p>Available since: 7.2.0</p> <p>When running inside a key space notification callback, it is dangerous and highly discouraged to perform any write operation (See <code>RedisModule_SubscribeToKeyspaceEvents</code>). In order to still perform write actions in this scenario, Redis provides <code>RedisModule_AddPostNotificationJob</code> API. The API allows to register a job callback which Redis will call when the following condition are promised to be fulfilled: 1. It is safe to perform any write operation. 2. The job will be called atomically along side the key space notification.</p> <p>Notice, one job might trigger key space notifications that will trigger more jobs. This raises a concerns of entering an infinite loops, we consider infinite loops as a logical bug that need to be fixed in the module, an attempt to protect against infinite loops by halting the execution could result in violation of the feature correctness and so Redis will make no attempt to protect the module from infinite loops.</p> <p>'<code>free_pd</code>' can be NULL and in such case will not be used.</p> <p>Return <code>REDISMODULE_OK</code> on success and <code>REDISMODULE_ERR</code> if was called while loading data from disk (AOF or RDB) or if the instance is a readonly replica.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getnotifykeyspaceevents","title":"<code>RedisModule_GetNotifyKeyspaceEvents</code>","text":"<pre><code>int RedisModule_GetNotifyKeyspaceEvents(void);\n</code></pre> <p>Available since: 6.0.0</p> <p>Get the configured bitmap of notify-keyspace-events (Could be used for additional filtering in <code>RedisModuleNotificationFunc</code>)</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_notifykeyspaceevent","title":"<code>RedisModule_NotifyKeyspaceEvent</code>","text":"<pre><code>int RedisModule_NotifyKeyspaceEvent(RedisModuleCtx *ctx,\n                                    int type,\n                                    const char *event,\n                                    RedisModuleString *key);\n</code></pre> <p>Available since: 6.0.0</p> <p>Expose notifyKeyspaceEvent to modules</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#modules-cluster-api","title":"Modules Cluster API","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_registerclustermessagereceiver","title":"<code>RedisModule_RegisterClusterMessageReceiver</code>","text":"<pre><code>void RedisModule_RegisterClusterMessageReceiver(RedisModuleCtx *ctx,\n                                                uint8_t type,\n                                                RedisModuleClusterMessageReceiver callback);\n</code></pre> <p>Available since: 5.0.0</p> <p>Register a callback receiver for cluster messages of type 'type'. If there was already a registered callback, this will replace the callback function with the one provided, otherwise if the callback is set to NULL and there is already a callback for this function, the callback is unregistered (so this API call is also used in order to delete the receiver).</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_sendclustermessage","title":"<code>RedisModule_SendClusterMessage</code>","text":"<pre><code>int RedisModule_SendClusterMessage(RedisModuleCtx *ctx,\n                                   const char *target_id,\n                                   uint8_t type,\n                                   const char *msg,\n                                   uint32_t len);\n</code></pre> <p>Available since: 5.0.0</p> <p>Send a message to all the nodes in the cluster if <code>target</code> is NULL, otherwise at the specified target, which is a <code>REDISMODULE_NODE_ID_LEN</code> bytes node ID, as returned by the receiver callback or by the nodes iteration functions.</p> <p>The function returns <code>REDISMODULE_OK</code> if the message was successfully sent, otherwise if the node is not connected or such node ID does not map to any known cluster node, <code>REDISMODULE_ERR</code> is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getclusternodeslist","title":"<code>RedisModule_GetClusterNodesList</code>","text":"<pre><code>char **RedisModule_GetClusterNodesList(RedisModuleCtx *ctx, size_t *numnodes);\n</code></pre> <p>Available since: 5.0.0</p> <p>Return an array of string pointers, each string pointer points to a cluster node ID of exactly <code>REDISMODULE_NODE_ID_LEN</code> bytes (without any null term). The number of returned node IDs is stored into <code>*numnodes</code>. However if this function is called by a module not running an a Redis instance with Redis Cluster enabled, NULL is returned instead.</p> <p>The IDs returned can be used with <code>RedisModule_GetClusterNodeInfo()</code> in order to get more information about single node.</p> <p>The array returned by this function must be freed using the function <code>RedisModule_FreeClusterNodesList()</code>.</p> <p>Example:</p> <pre><code>size_t count, j;\nchar **ids = RedisModule_GetClusterNodesList(ctx,&amp;count);\nfor (j = 0; j &lt; count; j++) {\n    RedisModule_Log(ctx,\"notice\",\"Node %.*s\",\n        REDISMODULE_NODE_ID_LEN,ids[j]);\n}\nRedisModule_FreeClusterNodesList(ids);\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_freeclusternodeslist","title":"<code>RedisModule_FreeClusterNodesList</code>","text":"<pre><code>void RedisModule_FreeClusterNodesList(char **ids);\n</code></pre> <p>Available since: 5.0.0</p> <p>Free the node list obtained with <code>RedisModule_GetClusterNodesList</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getmyclusterid","title":"<code>RedisModule_GetMyClusterID</code>","text":"<pre><code>const char *RedisModule_GetMyClusterID(void);\n</code></pre> <p>Available since: 5.0.0</p> <p>Return this node ID (<code>REDISMODULE_CLUSTER_ID_LEN</code> bytes) or NULL if the cluster is disabled.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getclustersize","title":"<code>RedisModule_GetClusterSize</code>","text":"<pre><code>size_t RedisModule_GetClusterSize(void);\n</code></pre> <p>Available since: 5.0.0</p> <p>Return the number of nodes in the cluster, regardless of their state (handshake, noaddress, ...) so that the number of active nodes may actually be smaller, but not greater than this number. If the instance is not in cluster mode, zero is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getclusternodeinfo","title":"<code>RedisModule_GetClusterNodeInfo</code>","text":"<pre><code>int RedisModule_GetClusterNodeInfo(RedisModuleCtx *ctx,\n                                   const char *id,\n                                   char *ip,\n                                   char *master_id,\n                                   int *port,\n                                   int *flags);\n</code></pre> <p>Available since: 5.0.0</p> <p>Populate the specified info for the node having as ID the specified 'id', then returns <code>REDISMODULE_OK</code>. Otherwise if the format of node ID is invalid or the node ID does not exist from the POV of this local node, <code>REDISMODULE_ERR</code> is returned.</p> <p>The arguments <code>ip</code>, <code>master_id</code>, <code>port</code> and <code>flags</code> can be NULL in case we don't need to populate back certain info. If an <code>ip</code> and <code>master_id</code> (only populated if the instance is a slave) are specified, they point to buffers holding at least <code>REDISMODULE_NODE_ID_LEN</code> bytes. The strings written back as <code>ip</code> and <code>master_id</code> are not null terminated.</p> <p>The list of flags reported is the following:</p> <ul> <li><code>REDISMODULE_NODE_MYSELF</code>:       This node</li> <li><code>REDISMODULE_NODE_MASTER</code>:       The node is a master</li> <li><code>REDISMODULE_NODE_SLAVE</code>:        The node is a replica</li> <li><code>REDISMODULE_NODE_PFAIL</code>:        We see the node as failing</li> <li><code>REDISMODULE_NODE_FAIL</code>:         The cluster agrees the node is failing</li> <li><code>REDISMODULE_NODE_NOFAILOVER</code>:   The slave is configured to never failover</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_setclusterflags","title":"<code>RedisModule_SetClusterFlags</code>","text":"<pre><code>void RedisModule_SetClusterFlags(RedisModuleCtx *ctx, uint64_t flags);\n</code></pre> <p>Available since: 5.0.0</p> <p>Set Redis Cluster flags in order to change the normal behavior of Redis Cluster, especially with the goal of disabling certain functions. This is useful for modules that use the Cluster API in order to create a different distributed system, but still want to use the Redis Cluster message bus. Flags that can be set:</p> <ul> <li><code>CLUSTER_MODULE_FLAG_NO_FAILOVER</code></li> <li><code>CLUSTER_MODULE_FLAG_NO_REDIRECTION</code></li> </ul> <p>With the following effects:</p> <ul> <li> <p><code>NO_FAILOVER</code>: prevent Redis Cluster slaves from failing over a dead master.                Also disables the replica migration feature.</p> </li> <li> <p><code>NO_REDIRECTION</code>: Every node will accept any key, without trying to perform                   partitioning according to the Redis Cluster algorithm.                   Slots information will still be propagated across the                   cluster, but without effect.</p> </li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#modules-timers-api","title":"Modules Timers API","text":"<p>Module timers are a high precision \"green timers\" abstraction where every module can register even millions of timers without problems, even if the actual event loop will just have a single timer that is used to awake the module timers subsystem in order to process the next event.</p> <p>All the timers are stored into a radix tree, ordered by expire time, when the main Redis event loop timer callback is called, we try to process all the timers already expired one after the other. Then we re-enter the event loop registering a timer that will expire when the next to process module timer will expire.</p> <p>Every time the list of active timers drops to zero, we unregister the main event loop timer, so that there is no overhead when such feature is not used.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_createtimer","title":"<code>RedisModule_CreateTimer</code>","text":"<pre><code>RedisModuleTimerID RedisModule_CreateTimer(RedisModuleCtx *ctx,\n                                           mstime_t period,\n                                           RedisModuleTimerProc callback,\n                                           void *data);\n</code></pre> <p>Available since: 5.0.0</p> <p>Create a new timer that will fire after <code>period</code> milliseconds, and will call the specified function using <code>data</code> as argument. The returned timer ID can be used to get information from the timer or to stop it before it fires. Note that for the common use case of a repeating timer (Re-registration of the timer inside the <code>RedisModuleTimerProc</code> callback) it matters when this API is called: If it is called at the beginning of 'callback' it means the event will triggered every 'period'. If it is called at the end of 'callback' it means there will 'period' milliseconds gaps between events. (If the time it takes to execute 'callback' is negligible the two statements above mean the same)</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_stoptimer","title":"<code>RedisModule_StopTimer</code>","text":"<pre><code>int RedisModule_StopTimer(RedisModuleCtx *ctx,\n                          RedisModuleTimerID id,\n                          void **data);\n</code></pre> <p>Available since: 5.0.0</p> <p>Stop a timer, returns <code>REDISMODULE_OK</code> if the timer was found, belonged to the calling module, and was stopped, otherwise <code>REDISMODULE_ERR</code> is returned. If not NULL, the data pointer is set to the value of the data argument when the timer was created.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_gettimerinfo","title":"<code>RedisModule_GetTimerInfo</code>","text":"<pre><code>int RedisModule_GetTimerInfo(RedisModuleCtx *ctx,\n                             RedisModuleTimerID id,\n                             uint64_t *remaining,\n                             void **data);\n</code></pre> <p>Available since: 5.0.0</p> <p>Obtain information about a timer: its remaining time before firing (in milliseconds), and the private data pointer associated with the timer. If the timer specified does not exist or belongs to a different module no information is returned and the function returns <code>REDISMODULE_ERR</code>, otherwise <code>REDISMODULE_OK</code> is returned. The arguments remaining or data can be NULL if the caller does not need certain information.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#modules-eventloop-api","title":"Modules EventLoop API","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_eventloopadd","title":"<code>RedisModule_EventLoopAdd</code>","text":"<pre><code>int RedisModule_EventLoopAdd(int fd,\n                             int mask,\n                             RedisModuleEventLoopFunc func,\n                             void *user_data);\n</code></pre> <p>Available since: 7.0.0</p> <p>Add a pipe / socket event to the event loop.</p> <ul> <li> <p><code>mask</code> must be one of the following values:</p> <ul> <li><code>REDISMODULE_EVENTLOOP_READABLE</code></li> <li><code>REDISMODULE_EVENTLOOP_WRITABLE</code></li> <li><code>REDISMODULE_EVENTLOOP_READABLE | REDISMODULE_EVENTLOOP_WRITABLE</code></li> </ul> </li> </ul> <p>On success <code>REDISMODULE_OK</code> is returned, otherwise <code>REDISMODULE_ERR</code> is returned and errno is set to the following values:</p> <ul> <li>ERANGE: <code>fd</code> is negative or higher than <code>maxclients</code> Redis config.</li> <li>EINVAL: <code>callback</code> is NULL or <code>mask</code> value is invalid.</li> </ul> <p><code>errno</code> might take other values in case of an internal error.</p> <p>Example:</p> <pre><code>void onReadable(int fd, void *user_data, int mask) {\n    char buf[32];\n    int bytes = read(fd,buf,sizeof(buf));\n    printf(\"Read %d bytes \\n\", bytes);\n}\nRedisModule_EventLoopAdd(fd, REDISMODULE_EVENTLOOP_READABLE, onReadable, NULL);\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_eventloopdel","title":"<code>RedisModule_EventLoopDel</code>","text":"<pre><code>int RedisModule_EventLoopDel(int fd, int mask);\n</code></pre> <p>Available since: 7.0.0</p> <p>Delete a pipe / socket event from the event loop.</p> <ul> <li> <p><code>mask</code> must be one of the following values:</p> <ul> <li><code>REDISMODULE_EVENTLOOP_READABLE</code></li> <li><code>REDISMODULE_EVENTLOOP_WRITABLE</code></li> <li><code>REDISMODULE_EVENTLOOP_READABLE | REDISMODULE_EVENTLOOP_WRITABLE</code></li> </ul> </li> </ul> <p>On success <code>REDISMODULE_OK</code> is returned, otherwise <code>REDISMODULE_ERR</code> is returned and errno is set to the following values:</p> <ul> <li>ERANGE: <code>fd</code> is negative or higher than <code>maxclients</code> Redis config.</li> <li>EINVAL: <code>mask</code> value is invalid.</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_eventloopaddoneshot","title":"<code>RedisModule_EventLoopAddOneShot</code>","text":"<pre><code>int RedisModule_EventLoopAddOneShot(RedisModuleEventLoopOneShotFunc func,\n                                    void *user_data);\n</code></pre> <p>Available since: 7.0.0</p> <p>This function can be called from other threads to trigger callback on Redis main thread. On success <code>REDISMODULE_OK</code> is returned. If <code>func</code> is NULL <code>REDISMODULE_ERR</code> is returned and errno is set to EINVAL.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#modules-acl-api","title":"Modules ACL API","text":"<p>Implements a hook into the authentication and authorization within Redis.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_createmoduleuser","title":"<code>RedisModule_CreateModuleUser</code>","text":"<pre><code>RedisModuleUser *RedisModule_CreateModuleUser(const char *name);\n</code></pre> <p>Available since: 6.0.0</p> <p>Creates a Redis ACL user that the module can use to authenticate a client. After obtaining the user, the module should set what such user can do using the <code>RedisModule_SetUserACL()</code> function. Once configured, the user can be used in order to authenticate a connection, with the specified ACL rules, using the <code>RedisModule_AuthClientWithUser()</code> function.</p> <p>Note that:</p> <ul> <li>Users created here are not listed by the ACL command.</li> <li>Users created here are not checked for duplicated name, so it's up to   the module calling this function to take care of not creating users   with the same name.</li> <li>The created user can be used to authenticate multiple Redis connections.</li> </ul> <p>The caller can later free the user using the function <code>RedisModule_FreeModuleUser()</code>. When this function is called, if there are still clients authenticated with this user, they are disconnected. The function to free the user should only be used when the caller really wants to invalidate the user to define a new one with different capabilities.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_freemoduleuser","title":"<code>RedisModule_FreeModuleUser</code>","text":"<pre><code>int RedisModule_FreeModuleUser(RedisModuleUser *user);\n</code></pre> <p>Available since: 6.0.0</p> <p>Frees a given user and disconnects all of the clients that have been authenticated with it. See <code>RedisModule_CreateModuleUser</code> for detailed usage.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_setmoduleuseracl","title":"<code>RedisModule_SetModuleUserACL</code>","text":"<pre><code>int RedisModule_SetModuleUserACL(RedisModuleUser *user, const char* acl);\n</code></pre> <p>Available since: 6.0.0</p> <p>Sets the permissions of a user created through the redis module interface. The syntax is the same as ACL SETUSER, so refer to the documentation in acl.c for more information. See <code>RedisModule_CreateModuleUser</code> for detailed usage.</p> <p>Returns <code>REDISMODULE_OK</code> on success and <code>REDISMODULE_ERR</code> on failure and will set an errno describing why the operation failed.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_setmoduleuseraclstring","title":"<code>RedisModule_SetModuleUserACLString</code>","text":"<pre><code>int RedisModule_SetModuleUserACLString(RedisModuleCtx *ctx,\n                                       RedisModuleUser *user,\n                                       const char *acl,\n                                       RedisModuleString **error);\n</code></pre> <p>Available since: 7.0.6</p> <p>Sets the permission of a user with a complete ACL string, such as one would use on the redis ACL SETUSER command line API. This differs from <code>RedisModule_SetModuleUserACL</code>, which only takes single ACL operations at a time.</p> <p>Returns <code>REDISMODULE_OK</code> on success and <code>REDISMODULE_ERR</code> on failure if a <code>RedisModuleString</code> is provided in error, a string describing the error will be returned</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getmoduleuseraclstring","title":"<code>RedisModule_GetModuleUserACLString</code>","text":"<pre><code>RedisModuleString *RedisModule_GetModuleUserACLString(RedisModuleUser *user);\n</code></pre> <p>Available since: 7.0.6</p> <p>Get the ACL string for a given user Returns a <code>RedisModuleString</code></p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getcurrentusername","title":"<code>RedisModule_GetCurrentUserName</code>","text":"<pre><code>RedisModuleString *RedisModule_GetCurrentUserName(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 7.0.0</p> <p>Retrieve the user name of the client connection behind the current context. The user name can be used later, in order to get a <code>RedisModuleUser</code>. See more information in <code>RedisModule_GetModuleUserFromUserName</code>.</p> <p>The returned string must be released with <code>RedisModule_FreeString()</code> or by enabling automatic memory management.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getmoduleuserfromusername","title":"<code>RedisModule_GetModuleUserFromUserName</code>","text":"<pre><code>RedisModuleUser *RedisModule_GetModuleUserFromUserName(RedisModuleString *name);\n</code></pre> <p>Available since: 7.0.0</p> <p>A <code>RedisModuleUser</code> can be used to check if command, key or channel can be executed or accessed according to the ACLs rules associated with that user. When a Module wants to do ACL checks on a general ACL user (not created by <code>RedisModule_CreateModuleUser</code>), it can get the <code>RedisModuleUser</code> from this API, based on the user name retrieved by <code>RedisModule_GetCurrentUserName</code>.</p> <p>Since a general ACL user can be deleted at any time, this <code>RedisModuleUser</code> should be used only in the context where this function was called. In order to do ACL checks out of that context, the Module can store the user name, and call this API at any other context.</p> <p>Returns NULL if the user is disabled or the user does not exist. The caller should later free the user using the function <code>RedisModule_FreeModuleUser()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_aclcheckcommandpermissions","title":"<code>RedisModule_ACLCheckCommandPermissions</code>","text":"<pre><code>int RedisModule_ACLCheckCommandPermissions(RedisModuleUser *user,\n                                           RedisModuleString **argv,\n                                           int argc);\n</code></pre> <p>Available since: 7.0.0</p> <p>Checks if the command can be executed by the user, according to the ACLs associated with it.</p> <p>On success a <code>REDISMODULE_OK</code> is returned, otherwise <code>REDISMODULE_ERR</code> is returned and errno is set to the following values:</p> <ul> <li>ENOENT: Specified command does not exist.</li> <li>EACCES: Command cannot be executed, according to ACL rules</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_aclcheckkeypermissions","title":"<code>RedisModule_ACLCheckKeyPermissions</code>","text":"<pre><code>int RedisModule_ACLCheckKeyPermissions(RedisModuleUser *user,\n                                       RedisModuleString *key,\n                                       int flags);\n</code></pre> <p>Available since: 7.0.0</p> <p>Check if the key can be accessed by the user according to the ACLs attached to the user and the flags representing the key access. The flags are the same that are used in the keyspec for logical operations. These flags are documented in <code>RedisModule_SetCommandInfo</code> as the <code>REDISMODULE_CMD_KEY_ACCESS</code>, <code>REDISMODULE_CMD_KEY_UPDATE</code>, <code>REDISMODULE_CMD_KEY_INSERT</code>, and <code>REDISMODULE_CMD_KEY_DELETE</code> flags.</p> <p>If no flags are supplied, the user is still required to have some access to the key for this command to return successfully.</p> <p>If the user is able to access the key then <code>REDISMODULE_OK</code> is returned, otherwise <code>REDISMODULE_ERR</code> is returned and errno is set to one of the following values:</p> <ul> <li>EINVAL: The provided flags are invalid.</li> <li>EACCESS: The user does not have permission to access the key.</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_aclcheckchannelpermissions","title":"<code>RedisModule_ACLCheckChannelPermissions</code>","text":"<pre><code>int RedisModule_ACLCheckChannelPermissions(RedisModuleUser *user,\n                                           RedisModuleString *ch,\n                                           int flags);\n</code></pre> <p>Available since: 7.0.0</p> <p>Check if the pubsub channel can be accessed by the user based off of the given access flags. See <code>RedisModule_ChannelAtPosWithFlags</code> for more information about the possible flags that can be passed in.</p> <p>If the user is able to access the pubsub channel then <code>REDISMODULE_OK</code> is returned, otherwise <code>REDISMODULE_ERR</code> is returned and errno is set to one of the following values:</p> <ul> <li>EINVAL: The provided flags are invalid.</li> <li>EACCESS: The user does not have permission to access the pubsub channel.</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_acladdlogentry","title":"<code>RedisModule_ACLAddLogEntry</code>","text":"<pre><code>int RedisModule_ACLAddLogEntry(RedisModuleCtx *ctx,\n                               RedisModuleUser *user,\n                               RedisModuleString *object,\n                               RedisModuleACLLogEntryReason reason);\n</code></pre> <p>Available since: 7.0.0</p> <p>Adds a new entry in the ACL log. Returns <code>REDISMODULE_OK</code> on success and <code>REDISMODULE_ERR</code> on error.</p> <p>For more information about ACL log, please refer to https://redis.io/commands/acl-log</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_acladdlogentrybyusername","title":"<code>RedisModule_ACLAddLogEntryByUserName</code>","text":"<pre><code>int RedisModule_ACLAddLogEntryByUserName(RedisModuleCtx *ctx,\n                                         RedisModuleString *username,\n                                         RedisModuleString *object,\n                                         RedisModuleACLLogEntryReason reason);\n</code></pre> <p>Available since: 7.2.0</p> <p>Adds a new entry in the ACL log with the <code>username</code> <code>RedisModuleString</code> provided. Returns <code>REDISMODULE_OK</code> on success and <code>REDISMODULE_ERR</code> on error.</p> <p>For more information about ACL log, please refer to https://redis.io/commands/acl-log</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_authenticateclientwithuser","title":"<code>RedisModule_AuthenticateClientWithUser</code>","text":"<pre><code>int RedisModule_AuthenticateClientWithUser(RedisModuleCtx *ctx,\n                                           RedisModuleUser *module_user,\n                                           RedisModuleUserChangedFunc callback,\n                                           void *privdata,\n                                           uint64_t *client_id);\n</code></pre> <p>Available since: 6.0.0</p> <p>Authenticate the current context's user with the provided redis acl user. Returns <code>REDISMODULE_ERR</code> if the user is disabled.</p> <p>See authenticateClientWithUser for information about callback, <code>client_id</code>, and general usage for authentication.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_authenticateclientwithacluser","title":"<code>RedisModule_AuthenticateClientWithACLUser</code>","text":"<pre><code>int RedisModule_AuthenticateClientWithACLUser(RedisModuleCtx *ctx,\n                                              const char *name,\n                                              size_t len,\n                                              RedisModuleUserChangedFunc callback,\n                                              void *privdata,\n                                              uint64_t *client_id);\n</code></pre> <p>Available since: 6.0.0</p> <p>Authenticate the current context's user with the provided redis acl user. Returns <code>REDISMODULE_ERR</code> if the user is disabled or the user does not exist.</p> <p>See authenticateClientWithUser for information about callback, <code>client_id</code>, and general usage for authentication.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_deauthenticateandcloseclient","title":"<code>RedisModule_DeauthenticateAndCloseClient</code>","text":"<pre><code>int RedisModule_DeauthenticateAndCloseClient(RedisModuleCtx *ctx,\n                                             uint64_t client_id);\n</code></pre> <p>Available since: 6.0.0</p> <p>Deauthenticate and close the client. The client resources will not be immediately freed, but will be cleaned up in a background job. This is the recommended way to deauthenticate a client since most clients can't handle users becoming deauthenticated. Returns <code>REDISMODULE_ERR</code> when the client doesn't exist and <code>REDISMODULE_OK</code> when the operation was successful.</p> <p>The client ID is returned from the <code>RedisModule_AuthenticateClientWithUser</code> and <code>RedisModule_AuthenticateClientWithACLUser</code> APIs, but can be obtained through the CLIENT api or through server events.</p> <p>This function is not thread safe, and must be executed within the context of a command or thread safe context.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_redactclientcommandargument","title":"<code>RedisModule_RedactClientCommandArgument</code>","text":"<pre><code>int RedisModule_RedactClientCommandArgument(RedisModuleCtx *ctx, int pos);\n</code></pre> <p>Available since: 7.0.0</p> <p>Redact the client command argument specified at the given position. Redacted arguments  are obfuscated in user facing commands such as SLOWLOG or MONITOR, as well as never being written to server logs. This command may be called multiple times on the same position.</p> <p>Note that the command name, position 0, can not be redacted. </p> <p>Returns <code>REDISMODULE_OK</code> if the argument was redacted and <code>REDISMODULE_ERR</code> if there  was an invalid parameter passed in or the position is outside the client  argument range.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getclientcertificate","title":"<code>RedisModule_GetClientCertificate</code>","text":"<pre><code>RedisModuleString *RedisModule_GetClientCertificate(RedisModuleCtx *ctx,\n                                                    uint64_t client_id);\n</code></pre> <p>Available since: 6.0.9</p> <p>Return the X.509 client-side certificate used by the client to authenticate this connection.</p> <p>The return value is an allocated <code>RedisModuleString</code> that is a X.509 certificate encoded in PEM (Base64) format. It should be freed (or auto-freed) by the caller.</p> <p>A NULL value is returned in the following conditions:</p> <ul> <li>Connection ID does not exist</li> <li>Connection is not a TLS connection</li> <li>Connection is a TLS connection but no client certificate was used</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#modules-dictionary-api","title":"Modules Dictionary API","text":"<p>Implements a sorted dictionary (actually backed by a radix tree) with the usual get / set / del / num-items API, together with an iterator capable of going back and forth.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_createdict","title":"<code>RedisModule_CreateDict</code>","text":"<pre><code>RedisModuleDict *RedisModule_CreateDict(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 5.0.0</p> <p>Create a new dictionary. The 'ctx' pointer can be the current module context or NULL, depending on what you want. Please follow the following rules:</p> <ol> <li>Use a NULL context if you plan to retain a reference to this dictionary    that will survive the time of the module callback where you created it.</li> <li>Use a NULL context if no context is available at the time you are creating    the dictionary (of course...).</li> <li>However use the current callback context as 'ctx' argument if the    dictionary time to live is just limited to the callback scope. In this    case, if enabled, you can enjoy the automatic memory management that will    reclaim the dictionary memory, as well as the strings returned by the    Next / Prev dictionary iterator calls.</li> </ol> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_freedict","title":"<code>RedisModule_FreeDict</code>","text":"<pre><code>void RedisModule_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d);\n</code></pre> <p>Available since: 5.0.0</p> <p>Free a dictionary created with <code>RedisModule_CreateDict()</code>. You need to pass the context pointer 'ctx' only if the dictionary was created using the context instead of passing NULL.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictsize","title":"<code>RedisModule_DictSize</code>","text":"<pre><code>uint64_t RedisModule_DictSize(RedisModuleDict *d);\n</code></pre> <p>Available since: 5.0.0</p> <p>Return the size of the dictionary (number of keys).</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictsetc","title":"<code>RedisModule_DictSetC</code>","text":"<pre><code>int RedisModule_DictSetC(RedisModuleDict *d,\n                         void *key,\n                         size_t keylen,\n                         void *ptr);\n</code></pre> <p>Available since: 5.0.0</p> <p>Store the specified key into the dictionary, setting its value to the pointer 'ptr'. If the key was added with success, since it did not already exist, <code>REDISMODULE_OK</code> is returned. Otherwise if the key already exists the function returns <code>REDISMODULE_ERR</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictreplacec","title":"<code>RedisModule_DictReplaceC</code>","text":"<pre><code>int RedisModule_DictReplaceC(RedisModuleDict *d,\n                             void *key,\n                             size_t keylen,\n                             void *ptr);\n</code></pre> <p>Available since: 5.0.0</p> <p>Like <code>RedisModule_DictSetC()</code> but will replace the key with the new value if the key already exists.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictset","title":"<code>RedisModule_DictSet</code>","text":"<pre><code>int RedisModule_DictSet(RedisModuleDict *d, RedisModuleString *key, void *ptr);\n</code></pre> <p>Available since: 5.0.0</p> <p>Like <code>RedisModule_DictSetC()</code> but takes the key as a <code>RedisModuleString</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictreplace","title":"<code>RedisModule_DictReplace</code>","text":"<pre><code>int RedisModule_DictReplace(RedisModuleDict *d,\n                            RedisModuleString *key,\n                            void *ptr);\n</code></pre> <p>Available since: 5.0.0</p> <p>Like <code>RedisModule_DictReplaceC()</code> but takes the key as a <code>RedisModuleString</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictgetc","title":"<code>RedisModule_DictGetC</code>","text":"<pre><code>void *RedisModule_DictGetC(RedisModuleDict *d,\n                           void *key,\n                           size_t keylen,\n                           int *nokey);\n</code></pre> <p>Available since: 5.0.0</p> <p>Return the value stored at the specified key. The function returns NULL both in the case the key does not exist, or if you actually stored NULL at key. So, optionally, if the 'nokey' pointer is not NULL, it will be set by reference to 1 if the key does not exist, or to 0 if the key exists.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictget","title":"<code>RedisModule_DictGet</code>","text":"<pre><code>void *RedisModule_DictGet(RedisModuleDict *d,\n                          RedisModuleString *key,\n                          int *nokey);\n</code></pre> <p>Available since: 5.0.0</p> <p>Like <code>RedisModule_DictGetC()</code> but takes the key as a <code>RedisModuleString</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictdelc","title":"<code>RedisModule_DictDelC</code>","text":"<pre><code>int RedisModule_DictDelC(RedisModuleDict *d,\n                         void *key,\n                         size_t keylen,\n                         void *oldval);\n</code></pre> <p>Available since: 5.0.0</p> <p>Remove the specified key from the dictionary, returning <code>REDISMODULE_OK</code> if the key was found and deleted, or <code>REDISMODULE_ERR</code> if instead there was no such key in the dictionary. When the operation is successful, if 'oldval' is not NULL, then '*oldval' is set to the value stored at the key before it was deleted. Using this feature it is possible to get a pointer to the value (for instance in order to release it), without having to call <code>RedisModule_DictGet()</code> before deleting the key.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictdel","title":"<code>RedisModule_DictDel</code>","text":"<pre><code>int RedisModule_DictDel(RedisModuleDict *d,\n                        RedisModuleString *key,\n                        void *oldval);\n</code></pre> <p>Available since: 5.0.0</p> <p>Like <code>RedisModule_DictDelC()</code> but gets the key as a <code>RedisModuleString</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictiteratorstartc","title":"<code>RedisModule_DictIteratorStartC</code>","text":"<pre><code>RedisModuleDictIter *RedisModule_DictIteratorStartC(RedisModuleDict *d,\n                                                    const char *op,\n                                                    void *key,\n                                                    size_t keylen);\n</code></pre> <p>Available since: 5.0.0</p> <p>Return an iterator, setup in order to start iterating from the specified key by applying the operator 'op', which is just a string specifying the comparison operator to use in order to seek the first element. The operators available are:</p> <ul> <li><code>^</code>   \u2013 Seek the first (lexicographically smaller) key.</li> <li><code>$</code>   \u2013 Seek the last  (lexicographically bigger) key.</li> <li><code>&gt;</code>   \u2013 Seek the first element greater than the specified key.</li> <li><code>&gt;=</code>  \u2013 Seek the first element greater or equal than the specified key.</li> <li><code>&lt;</code>   \u2013 Seek the first element smaller than the specified key.</li> <li><code>&lt;=</code>  \u2013 Seek the first element smaller or equal than the specified key.</li> <li><code>==</code>  \u2013 Seek the first element matching exactly the specified key.</li> </ul> <p>Note that for <code>^</code> and <code>$</code> the passed key is not used, and the user may just pass NULL with a length of 0.</p> <p>If the element to start the iteration cannot be seeked based on the key and operator passed, <code>RedisModule_DictNext()</code> / Prev() will just return <code>REDISMODULE_ERR</code> at the first call, otherwise they'll produce elements.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictiteratorstart","title":"<code>RedisModule_DictIteratorStart</code>","text":"<pre><code>RedisModuleDictIter *RedisModule_DictIteratorStart(RedisModuleDict *d,\n                                                   const char *op,\n                                                   RedisModuleString *key);\n</code></pre> <p>Available since: 5.0.0</p> <p>Exactly like <code>RedisModule_DictIteratorStartC</code>, but the key is passed as a <code>RedisModuleString</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictiteratorstop","title":"<code>RedisModule_DictIteratorStop</code>","text":"<pre><code>void RedisModule_DictIteratorStop(RedisModuleDictIter *di);\n</code></pre> <p>Available since: 5.0.0</p> <p>Release the iterator created with <code>RedisModule_DictIteratorStart()</code>. This call is mandatory otherwise a memory leak is introduced in the module.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictiteratorreseekc","title":"<code>RedisModule_DictIteratorReseekC</code>","text":"<pre><code>int RedisModule_DictIteratorReseekC(RedisModuleDictIter *di,\n                                    const char *op,\n                                    void *key,\n                                    size_t keylen);\n</code></pre> <p>Available since: 5.0.0</p> <p>After its creation with <code>RedisModule_DictIteratorStart()</code>, it is possible to change the currently selected element of the iterator by using this API call. The result based on the operator and key is exactly like the function <code>RedisModule_DictIteratorStart()</code>, however in this case the return value is just <code>REDISMODULE_OK</code> in case the seeked element was found, or <code>REDISMODULE_ERR</code> in case it was not possible to seek the specified element. It is possible to reseek an iterator as many times as you want.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictiteratorreseek","title":"<code>RedisModule_DictIteratorReseek</code>","text":"<pre><code>int RedisModule_DictIteratorReseek(RedisModuleDictIter *di,\n                                   const char *op,\n                                   RedisModuleString *key);\n</code></pre> <p>Available since: 5.0.0</p> <p>Like <code>RedisModule_DictIteratorReseekC()</code> but takes the key as a <code>RedisModuleString</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictnextc","title":"<code>RedisModule_DictNextC</code>","text":"<pre><code>void *RedisModule_DictNextC(RedisModuleDictIter *di,\n                            size_t *keylen,\n                            void **dataptr);\n</code></pre> <p>Available since: 5.0.0</p> <p>Return the current item of the dictionary iterator <code>di</code> and steps to the next element. If the iterator already yield the last element and there are no other elements to return, NULL is returned, otherwise a pointer to a string representing the key is provided, and the <code>*keylen</code> length is set by reference (if keylen is not NULL). The <code>*dataptr</code>, if not NULL is set to the value of the pointer stored at the returned key as auxiliary data (as set by the <code>RedisModule_DictSet</code> API).</p> <p>Usage example:</p> <pre><code> ... create the iterator here ...\n char *key;\n void *data;\n while((key = RedisModule_DictNextC(iter,&amp;keylen,&amp;data)) != NULL) {\n     printf(\"%.*s %p\\n\", (int)keylen, key, data);\n }\n</code></pre> <p>The returned pointer is of type void because sometimes it makes sense to cast it to a <code>char*</code> sometimes to an unsigned <code>char*</code> depending on the fact it contains or not binary data, so this API ends being more comfortable to use.</p> <p>The validity of the returned pointer is until the next call to the next/prev iterator step. Also the pointer is no longer valid once the iterator is released.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictprevc","title":"<code>RedisModule_DictPrevC</code>","text":"<pre><code>void *RedisModule_DictPrevC(RedisModuleDictIter *di,\n                            size_t *keylen,\n                            void **dataptr);\n</code></pre> <p>Available since: 5.0.0</p> <p>This function is exactly like <code>RedisModule_DictNext()</code> but after returning the currently selected element in the iterator, it selects the previous element (lexicographically smaller) instead of the next one.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictnext","title":"<code>RedisModule_DictNext</code>","text":"<pre><code>RedisModuleString *RedisModule_DictNext(RedisModuleCtx *ctx,\n                                        RedisModuleDictIter *di,\n                                        void **dataptr);\n</code></pre> <p>Available since: 5.0.0</p> <p>Like <code>RedisModuleNextC()</code>, but instead of returning an internally allocated buffer and key length, it returns directly a module string object allocated in the specified context 'ctx' (that may be NULL exactly like for the main API <code>RedisModule_CreateString</code>).</p> <p>The returned string object should be deallocated after use, either manually or by using a context that has automatic memory management active.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictprev","title":"<code>RedisModule_DictPrev</code>","text":"<pre><code>RedisModuleString *RedisModule_DictPrev(RedisModuleCtx *ctx,\n                                        RedisModuleDictIter *di,\n                                        void **dataptr);\n</code></pre> <p>Available since: 5.0.0</p> <p>Like <code>RedisModule_DictNext()</code> but after returning the currently selected element in the iterator, it selects the previous element (lexicographically smaller) instead of the next one.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictcomparec","title":"<code>RedisModule_DictCompareC</code>","text":"<pre><code>int RedisModule_DictCompareC(RedisModuleDictIter *di,\n                             const char *op,\n                             void *key,\n                             size_t keylen);\n</code></pre> <p>Available since: 5.0.0</p> <p>Compare the element currently pointed by the iterator to the specified element given by key/keylen, according to the operator 'op' (the set of valid operators are the same valid for <code>RedisModule_DictIteratorStart</code>). If the comparison is successful the command returns <code>REDISMODULE_OK</code> otherwise <code>REDISMODULE_ERR</code> is returned.</p> <p>This is useful when we want to just emit a lexicographical range, so in the loop, as we iterate elements, we can also check if we are still on range.</p> <p>The function return <code>REDISMODULE_ERR</code> if the iterator reached the end of elements condition as well.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_dictcompare","title":"<code>RedisModule_DictCompare</code>","text":"<pre><code>int RedisModule_DictCompare(RedisModuleDictIter *di,\n                            const char *op,\n                            RedisModuleString *key);\n</code></pre> <p>Available since: 5.0.0</p> <p>Like <code>RedisModule_DictCompareC</code> but gets the key to compare with the current iterator key as a <code>RedisModuleString</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#modules-info-fields","title":"Modules Info fields","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_infoaddsection","title":"<code>RedisModule_InfoAddSection</code>","text":"<pre><code>int RedisModule_InfoAddSection(RedisModuleInfoCtx *ctx, const char *name);\n</code></pre> <p>Available since: 6.0.0</p> <p>Used to start a new section, before adding any fields. the section name will be prefixed by <code>&lt;modulename&gt;_</code> and must only include A-Z,a-z,0-9. NULL or empty string indicates the default section (only <code>&lt;modulename&gt;</code>) is used. When return value is <code>REDISMODULE_ERR</code>, the section should and will be skipped.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_infobegindictfield","title":"<code>RedisModule_InfoBeginDictField</code>","text":"<pre><code>int RedisModule_InfoBeginDictField(RedisModuleInfoCtx *ctx, const char *name);\n</code></pre> <p>Available since: 6.0.0</p> <p>Starts a dict field, similar to the ones in INFO KEYSPACE. Use normal <code>RedisModule_InfoAddField</code>* functions to add the items to this field, and terminate with <code>RedisModule_InfoEndDictField</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_infoenddictfield","title":"<code>RedisModule_InfoEndDictField</code>","text":"<pre><code>int RedisModule_InfoEndDictField(RedisModuleInfoCtx *ctx);\n</code></pre> <p>Available since: 6.0.0</p> <p>Ends a dict field, see <code>RedisModule_InfoBeginDictField</code></p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_infoaddfieldstring","title":"<code>RedisModule_InfoAddFieldString</code>","text":"<pre><code>int RedisModule_InfoAddFieldString(RedisModuleInfoCtx *ctx,\n                                   const char *field,\n                                   RedisModuleString *value);\n</code></pre> <p>Available since: 6.0.0</p> <p>Used by <code>RedisModuleInfoFunc</code> to add info fields. Each field will be automatically prefixed by <code>&lt;modulename&gt;_</code>. Field names or values must not include <code>\\r\\n</code> or <code>:</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_infoaddfieldcstring","title":"<code>RedisModule_InfoAddFieldCString</code>","text":"<pre><code>int RedisModule_InfoAddFieldCString(RedisModuleInfoCtx *ctx,\n                                    const char *field,\n                                    const char *value);\n</code></pre> <p>Available since: 6.0.0</p> <p>See <code>RedisModule_InfoAddFieldString()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_infoaddfielddouble","title":"<code>RedisModule_InfoAddFieldDouble</code>","text":"<pre><code>int RedisModule_InfoAddFieldDouble(RedisModuleInfoCtx *ctx,\n                                   const char *field,\n                                   double value);\n</code></pre> <p>Available since: 6.0.0</p> <p>See <code>RedisModule_InfoAddFieldString()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_infoaddfieldlonglong","title":"<code>RedisModule_InfoAddFieldLongLong</code>","text":"<pre><code>int RedisModule_InfoAddFieldLongLong(RedisModuleInfoCtx *ctx,\n                                     const char *field,\n                                     long long value);\n</code></pre> <p>Available since: 6.0.0</p> <p>See <code>RedisModule_InfoAddFieldString()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_infoaddfieldulonglong","title":"<code>RedisModule_InfoAddFieldULongLong</code>","text":"<pre><code>int RedisModule_InfoAddFieldULongLong(RedisModuleInfoCtx *ctx,\n                                      const char *field,\n                                      unsigned long long value);\n</code></pre> <p>Available since: 6.0.0</p> <p>See <code>RedisModule_InfoAddFieldString()</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_registerinfofunc","title":"<code>RedisModule_RegisterInfoFunc</code>","text":"<pre><code>int RedisModule_RegisterInfoFunc(RedisModuleCtx *ctx, RedisModuleInfoFunc cb);\n</code></pre> <p>Available since: 6.0.0</p> <p>Registers callback for the INFO command. The callback should add INFO fields by calling the <code>RedisModule_InfoAddField*()</code> functions.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getserverinfo","title":"<code>RedisModule_GetServerInfo</code>","text":"<pre><code>RedisModuleServerInfoData *RedisModule_GetServerInfo(RedisModuleCtx *ctx,\n                                                     const char *section);\n</code></pre> <p>Available since: 6.0.0</p> <p>Get information about the server similar to the one that returns from the INFO command. This function takes an optional 'section' argument that may be NULL. The return value holds the output and can be used with <code>RedisModule_ServerInfoGetField</code> and alike to get the individual fields. When done, it needs to be freed with <code>RedisModule_FreeServerInfo</code> or with the automatic memory management mechanism if enabled.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_freeserverinfo","title":"<code>RedisModule_FreeServerInfo</code>","text":"<pre><code>void RedisModule_FreeServerInfo(RedisModuleCtx *ctx,\n                                RedisModuleServerInfoData *data);\n</code></pre> <p>Available since: 6.0.0</p> <p>Free data created with <code>RedisModule_GetServerInfo()</code>. You need to pass the context pointer 'ctx' only if the dictionary was created using the context instead of passing NULL.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_serverinfogetfield","title":"<code>RedisModule_ServerInfoGetField</code>","text":"<pre><code>RedisModuleString *RedisModule_ServerInfoGetField(RedisModuleCtx *ctx,\n                                                  RedisModuleServerInfoData *data,\n                                                  const char* field);\n</code></pre> <p>Available since: 6.0.0</p> <p>Get the value of a field from data collected with <code>RedisModule_GetServerInfo()</code>. You need to pass the context pointer 'ctx' only if you want to use auto memory mechanism to release the returned string. Return value will be NULL if the field was not found.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_serverinfogetfieldc","title":"<code>RedisModule_ServerInfoGetFieldC</code>","text":"<pre><code>const char *RedisModule_ServerInfoGetFieldC(RedisModuleServerInfoData *data,\n                                            const char* field);\n</code></pre> <p>Available since: 6.0.0</p> <p>Similar to <code>RedisModule_ServerInfoGetField</code>, but returns a char* which should not be freed but the caller.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_serverinfogetfieldsigned","title":"<code>RedisModule_ServerInfoGetFieldSigned</code>","text":"<pre><code>long long RedisModule_ServerInfoGetFieldSigned(RedisModuleServerInfoData *data,\n                                               const char* field,\n                                               int *out_err);\n</code></pre> <p>Available since: 6.0.0</p> <p>Get the value of a field from data collected with <code>RedisModule_GetServerInfo()</code>. If the field is not found, or is not numerical or out of range, return value will be 0, and the optional <code>out_err</code> argument will be set to <code>REDISMODULE_ERR</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_serverinfogetfieldunsigned","title":"<code>RedisModule_ServerInfoGetFieldUnsigned</code>","text":"<pre><code>unsigned long long RedisModule_ServerInfoGetFieldUnsigned(RedisModuleServerInfoData *data,\n                                                          const char* field,\n                                                          int *out_err);\n</code></pre> <p>Available since: 6.0.0</p> <p>Get the value of a field from data collected with <code>RedisModule_GetServerInfo()</code>. If the field is not found, or is not numerical or out of range, return value will be 0, and the optional <code>out_err</code> argument will be set to <code>REDISMODULE_ERR</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_serverinfogetfielddouble","title":"<code>RedisModule_ServerInfoGetFieldDouble</code>","text":"<pre><code>double RedisModule_ServerInfoGetFieldDouble(RedisModuleServerInfoData *data,\n                                            const char* field,\n                                            int *out_err);\n</code></pre> <p>Available since: 6.0.0</p> <p>Get the value of a field from data collected with <code>RedisModule_GetServerInfo()</code>. If the field is not found, or is not a double, return value will be 0, and the optional <code>out_err</code> argument will be set to <code>REDISMODULE_ERR</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#modules-utility-apis","title":"Modules utility APIs","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_getrandombytes","title":"<code>RedisModule_GetRandomBytes</code>","text":"<pre><code>void RedisModule_GetRandomBytes(unsigned char *dst, size_t len);\n</code></pre> <p>Available since: 5.0.0</p> <p>Return random bytes using SHA1 in counter mode with a /dev/urandom initialized seed. This function is fast so can be used to generate many bytes without any effect on the operating system entropy pool. Currently this function is not thread safe.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getrandomhexchars","title":"<code>RedisModule_GetRandomHexChars</code>","text":"<pre><code>void RedisModule_GetRandomHexChars(char *dst, size_t len);\n</code></pre> <p>Available since: 5.0.0</p> <p>Like <code>RedisModule_GetRandomBytes()</code> but instead of setting the string to random bytes the string is set to random characters in the in the hex charset [0-9a-f].</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#modules-api-exporting-importing","title":"Modules API exporting / importing","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_exportsharedapi","title":"<code>RedisModule_ExportSharedAPI</code>","text":"<pre><code>int RedisModule_ExportSharedAPI(RedisModuleCtx *ctx,\n                                const char *apiname,\n                                void *func);\n</code></pre> <p>Available since: 5.0.4</p> <p>This function is called by a module in order to export some API with a given name. Other modules will be able to use this API by calling the symmetrical function <code>RedisModule_GetSharedAPI()</code> and casting the return value to the right function pointer.</p> <p>The function will return <code>REDISMODULE_OK</code> if the name is not already taken, otherwise <code>REDISMODULE_ERR</code> will be returned and no operation will be performed.</p> <p>IMPORTANT: the apiname argument should be a string literal with static lifetime. The API relies on the fact that it will always be valid in the future.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getsharedapi","title":"<code>RedisModule_GetSharedAPI</code>","text":"<pre><code>void *RedisModule_GetSharedAPI(RedisModuleCtx *ctx, const char *apiname);\n</code></pre> <p>Available since: 5.0.4</p> <p>Request an exported API pointer. The return value is just a void pointer that the caller of this function will be required to cast to the right function pointer, so this is a private contract between modules.</p> <p>If the requested API is not available then NULL is returned. Because modules can be loaded at different times with different order, this function calls should be put inside some module generic API registering step, that is called every time a module attempts to execute a command that requires external APIs: if some API cannot be resolved, the command should return an error.</p> <p>Here is an example:</p> <pre><code>int ... myCommandImplementation(void) {\n   if (getExternalAPIs() == 0) {\n        reply with an error here if we cannot have the APIs\n   }\n   // Use the API:\n   myFunctionPointer(foo);\n}\n</code></pre> <p>And the function registerAPI() is:</p> <pre><code>int getExternalAPIs(void) {\n    static int api_loaded = 0;\n    if (api_loaded != 0) return 1; // APIs already resolved.\n\n    myFunctionPointer = RedisModule_GetSharedAPI(\"...\");\n    if (myFunctionPointer == NULL) return 0;\n\n    return 1;\n}\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#module-command-filter-api","title":"Module Command Filter API","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_registercommandfilter","title":"<code>RedisModule_RegisterCommandFilter</code>","text":"<pre><code>RedisModuleCommandFilter *RedisModule_RegisterCommandFilter(RedisModuleCtx *ctx,\n                                                            RedisModuleCommandFilterFunc callback,\n                                                            int flags);\n</code></pre> <p>Available since: 5.0.5</p> <p>Register a new command filter function.</p> <p>Command filtering makes it possible for modules to extend Redis by plugging into the execution flow of all commands.</p> <p>A registered filter gets called before Redis executes any command.  This includes both core Redis commands and commands registered by any module.  The filter applies in all execution paths including:</p> <ol> <li>Invocation by a client.</li> <li>Invocation through <code>RedisModule_Call()</code> by any module.</li> <li>Invocation through Lua <code>redis.call()</code>.</li> <li>Replication of a command from a master.</li> </ol> <p>The filter executes in a special filter context, which is different and more limited than a <code>RedisModuleCtx</code>.  Because the filter affects any command, it must be implemented in a very efficient way to reduce the performance impact on Redis.  All Redis Module API calls that require a valid context (such as <code>RedisModule_Call()</code>, <code>RedisModule_OpenKey()</code>, etc.) are not supported in a filter context.</p> <p>The <code>RedisModuleCommandFilterCtx</code> can be used to inspect or modify the executed command and its arguments.  As the filter executes before Redis begins processing the command, any change will affect the way the command is processed.  For example, a module can override Redis commands this way:</p> <ol> <li>Register a <code>MODULE.SET</code> command which implements an extended version of    the Redis <code>SET</code> command.</li> <li>Register a command filter which detects invocation of <code>SET</code> on a specific    pattern of keys.  Once detected, the filter will replace the first    argument from <code>SET</code> to <code>MODULE.SET</code>.</li> <li>When filter execution is complete, Redis considers the new command name    and therefore executes the module's own command.</li> </ol> <p>Note that in the above use case, if <code>MODULE.SET</code> itself uses <code>RedisModule_Call()</code> the filter will be applied on that call as well.  If that is not desired, the <code>REDISMODULE_CMDFILTER_NOSELF</code> flag can be set when registering the filter.</p> <p>The <code>REDISMODULE_CMDFILTER_NOSELF</code> flag prevents execution flows that originate from the module's own <code>RedisModule_Call()</code> from reaching the filter.  This flag is effective for all execution flows, including nested ones, as long as the execution begins from the module's command context or a thread-safe context that is associated with a blocking command.</p> <p>Detached thread-safe contexts are not associated with the module and cannot be protected by this flag.</p> <p>If multiple filters are registered (by the same or different modules), they are executed in the order of registration.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_unregistercommandfilter","title":"<code>RedisModule_UnregisterCommandFilter</code>","text":"<pre><code>int RedisModule_UnregisterCommandFilter(RedisModuleCtx *ctx,\n                                        RedisModuleCommandFilter *filter);\n</code></pre> <p>Available since: 5.0.5</p> <p>Unregister a command filter.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_commandfilterargscount","title":"<code>RedisModule_CommandFilterArgsCount</code>","text":"<pre><code>int RedisModule_CommandFilterArgsCount(RedisModuleCommandFilterCtx *fctx);\n</code></pre> <p>Available since: 5.0.5</p> <p>Return the number of arguments a filtered command has.  The number of arguments include the command itself.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_commandfilterargget","title":"<code>RedisModule_CommandFilterArgGet</code>","text":"<pre><code>RedisModuleString *RedisModule_CommandFilterArgGet(RedisModuleCommandFilterCtx *fctx,\n                                                   int pos);\n</code></pre> <p>Available since: 5.0.5</p> <p>Return the specified command argument.  The first argument (position 0) is the command itself, and the rest are user-provided args.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_commandfilterarginsert","title":"<code>RedisModule_CommandFilterArgInsert</code>","text":"<pre><code>int RedisModule_CommandFilterArgInsert(RedisModuleCommandFilterCtx *fctx,\n                                       int pos,\n                                       RedisModuleString *arg);\n</code></pre> <p>Available since: 5.0.5</p> <p>Modify the filtered command by inserting a new argument at the specified position.  The specified <code>RedisModuleString</code> argument may be used by Redis after the filter context is destroyed, so it must not be auto-memory allocated, freed or used elsewhere.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_commandfilterargreplace","title":"<code>RedisModule_CommandFilterArgReplace</code>","text":"<pre><code>int RedisModule_CommandFilterArgReplace(RedisModuleCommandFilterCtx *fctx,\n                                        int pos,\n                                        RedisModuleString *arg);\n</code></pre> <p>Available since: 5.0.5</p> <p>Modify the filtered command by replacing an existing argument with a new one. The specified <code>RedisModuleString</code> argument may be used by Redis after the filter context is destroyed, so it must not be auto-memory allocated, freed or used elsewhere.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_commandfilterargdelete","title":"<code>RedisModule_CommandFilterArgDelete</code>","text":"<pre><code>int RedisModule_CommandFilterArgDelete(RedisModuleCommandFilterCtx *fctx,\n                                       int pos);\n</code></pre> <p>Available since: 5.0.5</p> <p>Modify the filtered command by deleting an argument at the specified position.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_commandfiltergetclientid","title":"<code>RedisModule_CommandFilterGetClientId</code>","text":"<pre><code>unsigned long long RedisModule_CommandFilterGetClientId(RedisModuleCommandFilterCtx *fctx);\n</code></pre> <p>Available since: 7.2.0</p> <p>Get Client ID for client that issued the command we are filtering</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_mallocsize","title":"<code>RedisModule_MallocSize</code>","text":"<pre><code>size_t RedisModule_MallocSize(void* ptr);\n</code></pre> <p>Available since: 6.0.0</p> <p>For a given pointer allocated via <code>RedisModule_Alloc()</code> or <code>RedisModule_Realloc()</code>, return the amount of memory allocated for it. Note that this may be different (larger) than the memory we allocated with the allocation calls, since sometimes the underlying allocator will allocate more memory.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_mallocusablesize","title":"<code>RedisModule_MallocUsableSize</code>","text":"<pre><code>size_t RedisModule_MallocUsableSize(void *ptr);\n</code></pre> <p>Available since: 7.0.1</p> <p>Similar to <code>RedisModule_MallocSize</code>, the difference is that <code>RedisModule_MallocUsableSize</code> returns the usable size of memory by the module.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_mallocsizestring","title":"<code>RedisModule_MallocSizeString</code>","text":"<pre><code>size_t RedisModule_MallocSizeString(RedisModuleString* str);\n</code></pre> <p>Available since: 7.0.0</p> <p>Same as <code>RedisModule_MallocSize</code>, except it works on <code>RedisModuleString</code> pointers.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_mallocsizedict","title":"<code>RedisModule_MallocSizeDict</code>","text":"<pre><code>size_t RedisModule_MallocSizeDict(RedisModuleDict* dict);\n</code></pre> <p>Available since: 7.0.0</p> <p>Same as <code>RedisModule_MallocSize</code>, except it works on <code>RedisModuleDict</code> pointers. Note that the returned value is only the overhead of the underlying structures, it does not include the allocation size of the keys and values.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getusedmemoryratio","title":"<code>RedisModule_GetUsedMemoryRatio</code>","text":"<pre><code>float RedisModule_GetUsedMemoryRatio(void);\n</code></pre> <p>Available since: 6.0.0</p> <p>Return the a number between 0 to 1 indicating the amount of memory currently used, relative to the Redis \"maxmemory\" configuration.</p> <ul> <li>0 - No memory limit configured.</li> <li>Between 0 and 1 - The percentage of the memory used normalized in 0-1 range.</li> <li>Exactly 1 - Memory limit reached.</li> <li>Greater 1 - More memory used than the configured limit.</li> </ul> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#scanning-keyspace-and-hashes","title":"Scanning keyspace and hashes","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_scancursorcreate","title":"<code>RedisModule_ScanCursorCreate</code>","text":"<pre><code>RedisModuleScanCursor *RedisModule_ScanCursorCreate(void);\n</code></pre> <p>Available since: 6.0.0</p> <p>Create a new cursor to be used with <code>RedisModule_Scan</code></p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_scancursorrestart","title":"<code>RedisModule_ScanCursorRestart</code>","text":"<pre><code>void RedisModule_ScanCursorRestart(RedisModuleScanCursor *cursor);\n</code></pre> <p>Available since: 6.0.0</p> <p>Restart an existing cursor. The keys will be rescanned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_scancursordestroy","title":"<code>RedisModule_ScanCursorDestroy</code>","text":"<pre><code>void RedisModule_ScanCursorDestroy(RedisModuleScanCursor *cursor);\n</code></pre> <p>Available since: 6.0.0</p> <p>Destroy the cursor struct.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_scan","title":"<code>RedisModule_Scan</code>","text":"<pre><code>int RedisModule_Scan(RedisModuleCtx *ctx,\n                     RedisModuleScanCursor *cursor,\n                     RedisModuleScanCB fn,\n                     void *privdata);\n</code></pre> <p>Available since: 6.0.0</p> <p>Scan API that allows a module to scan all the keys and value in the selected db.</p> <p>Callback for scan implementation.</p> <pre><code>void scan_callback(RedisModuleCtx *ctx, RedisModuleString *keyname,\n                   RedisModuleKey *key, void *privdata);\n</code></pre> <ul> <li><code>ctx</code>: the redis module context provided to for the scan.</li> <li><code>keyname</code>: owned by the caller and need to be retained if used after this   function.</li> <li><code>key</code>: holds info on the key and value, it is provided as best effort, in   some cases it might be NULL, in which case the user should (can) use   <code>RedisModule_OpenKey()</code> (and CloseKey too).   when it is provided, it is owned by the caller and will be free when the   callback returns.</li> <li><code>privdata</code>: the user data provided to <code>RedisModule_Scan()</code>.</li> </ul> <p>The way it should be used:</p> <pre><code> RedisModuleScanCursor *c = RedisModule_ScanCursorCreate();\n while(RedisModule_Scan(ctx, c, callback, privateData));\n RedisModule_ScanCursorDestroy(c);\n</code></pre> <p>It is also possible to use this API from another thread while the lock is acquired during the actual call to <code>RedisModule_Scan</code>:</p> <pre><code> RedisModuleScanCursor *c = RedisModule_ScanCursorCreate();\n RedisModule_ThreadSafeContextLock(ctx);\n while(RedisModule_Scan(ctx, c, callback, privateData)){\n     RedisModule_ThreadSafeContextUnlock(ctx);\n     // do some background job\n     RedisModule_ThreadSafeContextLock(ctx);\n }\n RedisModule_ScanCursorDestroy(c);\n</code></pre> <p>The function will return 1 if there are more elements to scan and 0 otherwise, possibly setting errno if the call failed.</p> <p>It is also possible to restart an existing cursor using <code>RedisModule_ScanCursorRestart</code>.</p> <p>IMPORTANT: This API is very similar to the Redis SCAN command from the point of view of the guarantees it provides. This means that the API may report duplicated keys, but guarantees to report at least one time every key that was there from the start to the end of the scanning process.</p> <p>NOTE: If you do database changes within the callback, you should be aware that the internal state of the database may change. For instance it is safe to delete or modify the current key, but may not be safe to delete any other key. Moreover playing with the Redis keyspace while iterating may have the effect of returning more duplicates. A safe pattern is to store the keys names you want to modify elsewhere, and perform the actions on the keys later when the iteration is complete. However this can cost a lot of memory, so it may make sense to just operate on the current key when possible during the iteration, given that this is safe.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_scankey","title":"<code>RedisModule_ScanKey</code>","text":"<pre><code>int RedisModule_ScanKey(RedisModuleKey *key,\n                        RedisModuleScanCursor *cursor,\n                        RedisModuleScanKeyCB fn,\n                        void *privdata);\n</code></pre> <p>Available since: 6.0.0</p> <p>Scan api that allows a module to scan the elements in a hash, set or sorted set key</p> <p>Callback for scan implementation.</p> <pre><code>void scan_callback(RedisModuleKey *key, RedisModuleString* field, RedisModuleString* value, void *privdata);\n</code></pre> <ul> <li>key - the redis key context provided to for the scan.</li> <li>field - field name, owned by the caller and need to be retained if used   after this function.</li> <li>value - value string or NULL for set type, owned by the caller and need to   be retained if used after this function.</li> <li>privdata - the user data provided to <code>RedisModule_ScanKey</code>.</li> </ul> <p>The way it should be used:</p> <pre><code> RedisModuleScanCursor *c = RedisModule_ScanCursorCreate();\n RedisModuleKey *key = RedisModule_OpenKey(...)\n while(RedisModule_ScanKey(key, c, callback, privateData));\n RedisModule_CloseKey(key);\n RedisModule_ScanCursorDestroy(c);\n</code></pre> <p>It is also possible to use this API from another thread while the lock is acquired during the actual call to <code>RedisModule_ScanKey</code>, and re-opening the key each time:</p> <pre><code> RedisModuleScanCursor *c = RedisModule_ScanCursorCreate();\n RedisModule_ThreadSafeContextLock(ctx);\n RedisModuleKey *key = RedisModule_OpenKey(...)\n while(RedisModule_ScanKey(ctx, c, callback, privateData)){\n     RedisModule_CloseKey(key);\n     RedisModule_ThreadSafeContextUnlock(ctx);\n     // do some background job\n     RedisModule_ThreadSafeContextLock(ctx);\n     RedisModuleKey *key = RedisModule_OpenKey(...)\n }\n RedisModule_CloseKey(key);\n RedisModule_ScanCursorDestroy(c);\n</code></pre> <p>The function will return 1 if there are more elements to scan and 0 otherwise, possibly setting errno if the call failed. It is also possible to restart an existing cursor using <code>RedisModule_ScanCursorRestart</code>.</p> <p>NOTE: Certain operations are unsafe while iterating the object. For instance while the API guarantees to return at least one time all the elements that are present in the data structure consistently from the start to the end of the iteration (see HSCAN and similar commands documentation), the more you play with the elements, the more duplicates you may get. In general deleting the current element of the data structure is safe, while removing the key you are iterating is not safe.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#module-fork-api","title":"Module fork API","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_fork","title":"<code>RedisModule_Fork</code>","text":"<pre><code>int RedisModule_Fork(RedisModuleForkDoneHandler cb, void *user_data);\n</code></pre> <p>Available since: 6.0.0</p> <p>Create a background child process with the current frozen snapshot of the main process where you can do some processing in the background without affecting / freezing the traffic and no need for threads and GIL locking. Note that Redis allows for only one concurrent fork. When the child wants to exit, it should call <code>RedisModule_ExitFromChild</code>. If the parent wants to kill the child it should call <code>RedisModule_KillForkChild</code> The done handler callback will be executed on the parent process when the child existed (but not when killed) Return: -1 on failure, on success the parent process will get a positive PID of the child, and the child process will get 0.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_sendchildheartbeat","title":"<code>RedisModule_SendChildHeartbeat</code>","text":"<pre><code>void RedisModule_SendChildHeartbeat(double progress);\n</code></pre> <p>Available since: 6.2.0</p> <p>The module is advised to call this function from the fork child once in a while, so that it can report progress and COW memory to the parent which will be reported in INFO. The <code>progress</code> argument should between 0 and 1, or -1 when not available.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_exitfromchild","title":"<code>RedisModule_ExitFromChild</code>","text":"<pre><code>int RedisModule_ExitFromChild(int retcode);\n</code></pre> <p>Available since: 6.0.0</p> <p>Call from the child process when you want to terminate it. retcode will be provided to the done handler executed on the parent process.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_killforkchild","title":"<code>RedisModule_KillForkChild</code>","text":"<pre><code>int RedisModule_KillForkChild(int child_pid);\n</code></pre> <p>Available since: 6.0.0</p> <p>Can be used to kill the forked child process from the parent process. <code>child_pid</code> would be the return value of <code>RedisModule_Fork</code>.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#server-hooks-implementation","title":"Server hooks implementation","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_subscribetoserverevent","title":"<code>RedisModule_SubscribeToServerEvent</code>","text":"<pre><code>int RedisModule_SubscribeToServerEvent(RedisModuleCtx *ctx,\n                                       RedisModuleEvent event,\n                                       RedisModuleEventCallback callback);\n</code></pre> <p>Available since: 6.0.0</p> <p>Register to be notified, via a callback, when the specified server event happens. The callback is called with the event as argument, and an additional argument which is a void pointer and should be cased to a specific type that is event-specific (but many events will just use NULL since they do not have additional information to pass to the callback).</p> <p>If the callback is NULL and there was a previous subscription, the module will be unsubscribed. If there was a previous subscription and the callback is not null, the old callback will be replaced with the new one.</p> <p>The callback must be of this type:</p> <pre><code>int (*RedisModuleEventCallback)(RedisModuleCtx *ctx,\n                                RedisModuleEvent eid,\n                                uint64_t subevent,\n                                void *data);\n</code></pre> <p>The 'ctx' is a normal Redis module context that the callback can use in order to call other modules APIs. The 'eid' is the event itself, this is only useful in the case the module subscribed to multiple events: using the 'id' field of this structure it is possible to check if the event is one of the events we registered with this callback. The 'subevent' field depends on the event that fired.</p> <p>Finally the 'data' pointer may be populated, only for certain events, with more relevant data.</p> <p>Here is a list of events you can use as 'eid' and related sub events:</p> <ul> <li> <p><code>RedisModuleEvent_ReplicationRoleChanged</code>:</p> <p>This event is called when the instance switches from master to replica or the other way around, however the event is also called when the replica remains a replica but starts to replicate with a different master.</p> <p>The following sub events are available:</p> <ul> <li><code>REDISMODULE_SUBEVENT_REPLROLECHANGED_NOW_MASTER</code></li> <li><code>REDISMODULE_SUBEVENT_REPLROLECHANGED_NOW_REPLICA</code></li> </ul> <p>The 'data' field can be casted by the callback to a <code>RedisModuleReplicationInfo</code> structure with the following fields:</p> <pre><code>int master; // true if master, false if replica\nchar *masterhost; // master instance hostname for NOW_REPLICA\nint masterport; // master instance port for NOW_REPLICA\nchar *replid1; // Main replication ID\nchar *replid2; // Secondary replication ID\nuint64_t repl1_offset; // Main replication offset\nuint64_t repl2_offset; // Offset of replid2 validity\n</code></pre> </li> <li> <p><code>RedisModuleEvent_Persistence</code></p> <p>This event is called when RDB saving or AOF rewriting starts and ends. The following sub events are available:</p> <ul> <li><code>REDISMODULE_SUBEVENT_PERSISTENCE_RDB_START</code></li> <li><code>REDISMODULE_SUBEVENT_PERSISTENCE_AOF_START</code></li> <li><code>REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_RDB_START</code></li> <li><code>REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_AOF_START</code></li> <li><code>REDISMODULE_SUBEVENT_PERSISTENCE_ENDED</code></li> <li><code>REDISMODULE_SUBEVENT_PERSISTENCE_FAILED</code></li> </ul> <p>The above events are triggered not just when the user calls the relevant commands like BGSAVE, but also when a saving operation or AOF rewriting occurs because of internal server triggers. The SYNC_RDB_START sub events are happening in the foreground due to SAVE command, FLUSHALL, or server shutdown, and the other RDB and AOF sub events are executed in a background fork child, so any action the module takes can only affect the generated AOF or RDB, but will not be reflected in the parent process and affect connected clients and commands. Also note that the AOF_START sub event may end up saving RDB content in case of an AOF with rdb-preamble.</p> </li> <li> <p><code>RedisModuleEvent_FlushDB</code></p> <p>The FLUSHALL, FLUSHDB or an internal flush (for instance because of replication, after the replica synchronization) happened. The following sub events are available:</p> <ul> <li><code>REDISMODULE_SUBEVENT_FLUSHDB_START</code></li> <li><code>REDISMODULE_SUBEVENT_FLUSHDB_END</code></li> </ul> <p>The data pointer can be casted to a RedisModuleFlushInfo structure with the following fields:</p> <pre><code>int32_t async;  // True if the flush is done in a thread.\n                // See for instance FLUSHALL ASYNC.\n                // In this case the END callback is invoked\n                // immediately after the database is put\n                // in the free list of the thread.\nint32_t dbnum;  // Flushed database number, -1 for all the DBs\n                // in the case of the FLUSHALL operation.\n</code></pre> <p>The start event is called before the operation is initiated, thus allowing the callback to call DBSIZE or other operation on the yet-to-free keyspace.</p> </li> <li> <p><code>RedisModuleEvent_Loading</code></p> <p>Called on loading operations: at startup when the server is started, but also after a first synchronization when the replica is loading the RDB file from the master. The following sub events are available:</p> <ul> <li><code>REDISMODULE_SUBEVENT_LOADING_RDB_START</code></li> <li><code>REDISMODULE_SUBEVENT_LOADING_AOF_START</code></li> <li><code>REDISMODULE_SUBEVENT_LOADING_REPL_START</code></li> <li><code>REDISMODULE_SUBEVENT_LOADING_ENDED</code></li> <li><code>REDISMODULE_SUBEVENT_LOADING_FAILED</code></li> </ul> <p>Note that AOF loading may start with an RDB data in case of rdb-preamble, in which case you'll only receive an AOF_START event.</p> </li> <li> <p><code>RedisModuleEvent_ClientChange</code></p> <p>Called when a client connects or disconnects. The data pointer can be casted to a RedisModuleClientInfo structure, documented in RedisModule_GetClientInfoById(). The following sub events are available:</p> <ul> <li><code>REDISMODULE_SUBEVENT_CLIENT_CHANGE_CONNECTED</code></li> <li><code>REDISMODULE_SUBEVENT_CLIENT_CHANGE_DISCONNECTED</code></li> </ul> </li> <li> <p><code>RedisModuleEvent_Shutdown</code></p> <p>The server is shutting down. No subevents are available.</p> </li> <li> <p><code>RedisModuleEvent_ReplicaChange</code></p> <p>This event is called when the instance (that can be both a master or a replica) get a new online replica, or lose a replica since it gets disconnected. The following sub events are available:</p> <ul> <li><code>REDISMODULE_SUBEVENT_REPLICA_CHANGE_ONLINE</code></li> <li><code>REDISMODULE_SUBEVENT_REPLICA_CHANGE_OFFLINE</code></li> </ul> <p>No additional information is available so far: future versions of Redis will have an API in order to enumerate the replicas connected and their state.</p> </li> <li> <p><code>RedisModuleEvent_CronLoop</code></p> <p>This event is called every time Redis calls the serverCron() function in order to do certain bookkeeping. Modules that are required to do operations from time to time may use this callback. Normally Redis calls this function 10 times per second, but this changes depending on the \"hz\" configuration. No sub events are available.</p> <p>The data pointer can be casted to a RedisModuleCronLoop structure with the following fields:</p> <pre><code>int32_t hz;  // Approximate number of events per second.\n</code></pre> </li> <li> <p><code>RedisModuleEvent_MasterLinkChange</code></p> <p>This is called for replicas in order to notify when the replication link becomes functional (up) with our master, or when it goes down. Note that the link is not considered up when we just connected to the master, but only if the replication is happening correctly. The following sub events are available:</p> <ul> <li><code>REDISMODULE_SUBEVENT_MASTER_LINK_UP</code></li> <li><code>REDISMODULE_SUBEVENT_MASTER_LINK_DOWN</code></li> </ul> </li> <li> <p><code>RedisModuleEvent_ModuleChange</code></p> <p>This event is called when a new module is loaded or one is unloaded. The following sub events are available:</p> <ul> <li><code>REDISMODULE_SUBEVENT_MODULE_LOADED</code></li> <li><code>REDISMODULE_SUBEVENT_MODULE_UNLOADED</code></li> </ul> <p>The data pointer can be casted to a RedisModuleModuleChange structure with the following fields:</p> <pre><code>const char* module_name;  // Name of module loaded or unloaded.\nint32_t module_version;  // Module version.\n</code></pre> </li> <li> <p><code>RedisModuleEvent_LoadingProgress</code></p> <p>This event is called repeatedly called while an RDB or AOF file is being loaded. The following sub events are available:</p> <ul> <li><code>REDISMODULE_SUBEVENT_LOADING_PROGRESS_RDB</code></li> <li><code>REDISMODULE_SUBEVENT_LOADING_PROGRESS_AOF</code></li> </ul> <p>The data pointer can be casted to a RedisModuleLoadingProgress structure with the following fields:</p> <pre><code>int32_t hz;  // Approximate number of events per second.\nint32_t progress;  // Approximate progress between 0 and 1024,\n                   // or -1 if unknown.\n</code></pre> </li> <li> <p><code>RedisModuleEvent_SwapDB</code></p> <p>This event is called when a SWAPDB command has been successfully Executed. For this event call currently there is no subevents available.</p> <p>The data pointer can be casted to a RedisModuleSwapDbInfo structure with the following fields:</p> <pre><code>int32_t dbnum_first;    // Swap Db first dbnum\nint32_t dbnum_second;   // Swap Db second dbnum\n</code></pre> </li> <li> <p><code>RedisModuleEvent_ReplBackup</code></p> <p>WARNING: Replication Backup events are deprecated since Redis 7.0 and are never fired. See RedisModuleEvent_ReplAsyncLoad for understanding how Async Replication Loading events are now triggered when repl-diskless-load is set to swapdb.</p> <p>Called when repl-diskless-load config is set to swapdb, And redis needs to backup the current database for the possibility to be restored later. A module with global data and maybe with aux_load and aux_save callbacks may need to use this notification to backup / restore / discard its globals. The following sub events are available:</p> <ul> <li><code>REDISMODULE_SUBEVENT_REPL_BACKUP_CREATE</code></li> <li><code>REDISMODULE_SUBEVENT_REPL_BACKUP_RESTORE</code></li> <li><code>REDISMODULE_SUBEVENT_REPL_BACKUP_DISCARD</code></li> </ul> </li> <li> <p><code>RedisModuleEvent_ReplAsyncLoad</code></p> <p>Called when repl-diskless-load config is set to swapdb and a replication with a master of same data set history (matching replication ID) occurs. In which case redis serves current data set while loading new database in memory from socket. Modules must have declared they support this mechanism in order to activate it, through REDISMODULE_OPTIONS_HANDLE_REPL_ASYNC_LOAD flag. The following sub events are available:</p> <ul> <li><code>REDISMODULE_SUBEVENT_REPL_ASYNC_LOAD_STARTED</code></li> <li><code>REDISMODULE_SUBEVENT_REPL_ASYNC_LOAD_ABORTED</code></li> <li><code>REDISMODULE_SUBEVENT_REPL_ASYNC_LOAD_COMPLETED</code></li> </ul> </li> <li> <p><code>RedisModuleEvent_ForkChild</code></p> <p>Called when a fork child (AOFRW, RDBSAVE, module fork...) is born/dies The following sub events are available:</p> <ul> <li><code>REDISMODULE_SUBEVENT_FORK_CHILD_BORN</code></li> <li><code>REDISMODULE_SUBEVENT_FORK_CHILD_DIED</code></li> </ul> </li> <li> <p><code>RedisModuleEvent_EventLoop</code></p> <p>Called on each event loop iteration, once just before the event loop goes to sleep or just after it wakes up. The following sub events are available:</p> <ul> <li><code>REDISMODULE_SUBEVENT_EVENTLOOP_BEFORE_SLEEP</code></li> <li><code>REDISMODULE_SUBEVENT_EVENTLOOP_AFTER_SLEEP</code></li> </ul> </li> <li> <p><code>RedisModule_Event_Config</code></p> <p>Called when a configuration event happens The following sub events are available:</p> <ul> <li><code>REDISMODULE_SUBEVENT_CONFIG_CHANGE</code></li> </ul> <p>The data pointer can be casted to a RedisModuleConfigChange structure with the following fields:</p> <pre><code>const char **config_names; // An array of C string pointers containing the\n                           // name of each modified configuration item \nuint32_t num_changes;      // The number of elements in the config_names array\n</code></pre> </li> <li> <p><code>RedisModule_Event_Key</code></p> <p>Called when a key is removed from the keyspace. We can't modify any key in the event. The following sub events are available:</p> <ul> <li><code>REDISMODULE_SUBEVENT_KEY_DELETED</code></li> <li><code>REDISMODULE_SUBEVENT_KEY_EXPIRED</code></li> <li><code>REDISMODULE_SUBEVENT_KEY_EVICTED</code></li> <li><code>REDISMODULE_SUBEVENT_KEY_OVERWRITTEN</code></li> </ul> <p>The data pointer can be casted to a RedisModuleKeyInfo structure with the following fields:</p> <pre><code>RedisModuleKey *key;    // Key name\n</code></pre> </li> </ul> <p>The function returns <code>REDISMODULE_OK</code> if the module was successfully subscribed for the specified event. If the API is called from a wrong context or unsupported event is given then <code>REDISMODULE_ERR</code> is returned.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_issubeventsupported","title":"<code>RedisModule_IsSubEventSupported</code>","text":"<pre><code>int RedisModule_IsSubEventSupported(RedisModuleEvent event, int64_t subevent);\n</code></pre> <p>Available since: 6.0.9</p> <p>For a given server event and subevent, return zero if the subevent is not supported and non-zero otherwise.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#module-configurations-api","title":"Module Configurations API","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_registerstringconfig","title":"<code>RedisModule_RegisterStringConfig</code>","text":"<pre><code>int RedisModule_RegisterStringConfig(RedisModuleCtx *ctx,\n                                     const char *name,\n                                     const char *default_val,\n                                     unsigned int flags,\n                                     RedisModuleConfigGetStringFunc getfn,\n                                     RedisModuleConfigSetStringFunc setfn,\n                                     RedisModuleConfigApplyFunc applyfn,\n                                     void *privdata);\n</code></pre> <p>Available since: 7.0.0</p> <p>Create a string config that Redis users can interact with via the Redis config file, <code>CONFIG SET</code>, <code>CONFIG GET</code>, and <code>CONFIG REWRITE</code> commands.</p> <p>The actual config value is owned by the module, and the <code>getfn</code>, <code>setfn</code> and optional <code>applyfn</code> callbacks that are provided to Redis in order to access or manipulate the value. The <code>getfn</code> callback retrieves the value from the module, while the <code>setfn</code> callback provides a value to be stored into the module config. The optional <code>applyfn</code> callback is called after a <code>CONFIG SET</code> command modified one or more configs using the <code>setfn</code> callback and can be used to atomically apply a config after several configs were changed together. If there are multiple configs with <code>applyfn</code> callbacks set by a single <code>CONFIG SET</code> command, they will be deduplicated if their <code>applyfn</code> function and <code>privdata</code> pointers are identical, and the callback will only be run once. Both the <code>setfn</code> and <code>applyfn</code> can return an error if the provided value is invalid or cannot be used. The config also declares a type for the value that is validated by Redis and provided to the module. The config system provides the following types:</p> <ul> <li>Redis String: Binary safe string data.</li> <li>Enum: One of a finite number of string tokens, provided during registration.</li> <li>Numeric: 64 bit signed integer, which also supports min and max values.</li> <li>Bool: Yes or no value.</li> </ul> <p>The <code>setfn</code> callback is expected to return <code>REDISMODULE_OK</code> when the value is successfully applied. It can also return <code>REDISMODULE_ERR</code> if the value can't be applied, and the *err pointer can be set with a <code>RedisModuleString</code> error message to provide to the client. This <code>RedisModuleString</code> will be freed by redis after returning from the set callback.</p> <p>All configs are registered with a name, a type, a default value, private data that is made available in the callbacks, as well as several flags that modify the behavior of the config. The name must only contain alphanumeric characters or dashes. The supported flags are:</p> <ul> <li><code>REDISMODULE_CONFIG_DEFAULT</code>: The default flags for a config. This creates a config that can be modified after startup.</li> <li><code>REDISMODULE_CONFIG_IMMUTABLE</code>: This config can only be provided loading time.</li> <li><code>REDISMODULE_CONFIG_SENSITIVE</code>: The value stored in this config is redacted from all logging.</li> <li><code>REDISMODULE_CONFIG_HIDDEN</code>: The name is hidden from <code>CONFIG GET</code> with pattern matching.</li> <li><code>REDISMODULE_CONFIG_PROTECTED</code>: This config will be only be modifiable based off the value of enable-protected-configs.</li> <li><code>REDISMODULE_CONFIG_DENY_LOADING</code>: This config is not modifiable while the server is loading data.</li> <li><code>REDISMODULE_CONFIG_MEMORY</code>: For numeric configs, this config will convert data unit notations into their byte equivalent.</li> <li><code>REDISMODULE_CONFIG_BITFLAGS</code>: For enum configs, this config will allow multiple entries to be combined as bit flags.</li> </ul> <p>Default values are used on startup to set the value if it is not provided via the config file or command line. Default values are also used to compare to on a config rewrite.</p> <p>Notes:</p> <ol> <li>On string config sets that the string passed to the set callback will be freed after execution and the module must retain it.</li> <li>On string config gets the string will not be consumed and will be valid after execution.</li> </ol> <p>Example implementation:</p> <pre><code>RedisModuleString *strval;\nint adjustable = 1;\nRedisModuleString *getStringConfigCommand(const char *name, void *privdata) {\n    return strval;\n}\n\nint setStringConfigCommand(const char *name, RedisModuleString *new, void *privdata, RedisModuleString **err) {\n   if (adjustable) {\n       RedisModule_Free(strval);\n       RedisModule_RetainString(NULL, new);\n       strval = new;\n       return REDISMODULE_OK;\n   }\n   *err = RedisModule_CreateString(NULL, \"Not adjustable.\", 15);\n   return REDISMODULE_ERR;\n}\n...\nRedisModule_RegisterStringConfig(ctx, \"string\", NULL, REDISMODULE_CONFIG_DEFAULT, getStringConfigCommand, setStringConfigCommand, NULL, NULL);\n</code></pre> <p>If the registration fails, <code>REDISMODULE_ERR</code> is returned and one of the following errno is set: * EBUSY: Registering the Config outside of <code>RedisModule_OnLoad</code>. * EINVAL: The provided flags are invalid for the registration or the name of the config contains invalid characters. * EALREADY: The provided configuration name is already used.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_registerboolconfig","title":"<code>RedisModule_RegisterBoolConfig</code>","text":"<pre><code>int RedisModule_RegisterBoolConfig(RedisModuleCtx *ctx,\n                                   const char *name,\n                                   int default_val,\n                                   unsigned int flags,\n                                   RedisModuleConfigGetBoolFunc getfn,\n                                   RedisModuleConfigSetBoolFunc setfn,\n                                   RedisModuleConfigApplyFunc applyfn,\n                                   void *privdata);\n</code></pre> <p>Available since: 7.0.0</p> <p>Create a bool config that server clients can interact with via the  <code>CONFIG SET</code>, <code>CONFIG GET</code>, and <code>CONFIG REWRITE</code> commands. See  <code>RedisModule_RegisterStringConfig</code> for detailed information about configs.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_registerenumconfig","title":"<code>RedisModule_RegisterEnumConfig</code>","text":"<pre><code>int RedisModule_RegisterEnumConfig(RedisModuleCtx *ctx,\n                                   const char *name,\n                                   int default_val,\n                                   unsigned int flags,\n                                   const char **enum_values,\n                                   const int *int_values,\n                                   int num_enum_vals,\n                                   RedisModuleConfigGetEnumFunc getfn,\n                                   RedisModuleConfigSetEnumFunc setfn,\n                                   RedisModuleConfigApplyFunc applyfn,\n                                   void *privdata);\n</code></pre> <p>Available since: 7.0.0</p> <p>Create an enum config that server clients can interact with via the  <code>CONFIG SET</code>, <code>CONFIG GET</code>, and <code>CONFIG REWRITE</code> commands.  Enum configs are a set of string tokens to corresponding integer values, where  the string value is exposed to Redis clients but the value passed Redis and the module is the integer value. These values are defined in <code>enum_values</code>, an array of null-terminated c strings, and <code>int_vals</code>, an array of enum values who has an index partner in <code>enum_values</code>. Example Implementation:      const char *enum_vals[3] = {\"first\", \"second\", \"third\"};      const int int_vals[3] = {0, 2, 4};      int enum_val = 0;</p> <pre><code> int getEnumConfigCommand(const char *name, void *privdata) {\n     return enum_val;\n }\n\n int setEnumConfigCommand(const char *name, int val, void *privdata, const char **err) {\n     enum_val = val;\n     return REDISMODULE_OK;\n }\n ...\n RedisModule_RegisterEnumConfig(ctx, \"enum\", 0, REDISMODULE_CONFIG_DEFAULT, enum_vals, int_vals, 3, getEnumConfigCommand, setEnumConfigCommand, NULL, NULL);\n</code></pre> <p>Note that you can use <code>REDISMODULE_CONFIG_BITFLAGS</code> so that multiple enum string can be combined into one integer as bit flags, in which case you may want to sort your enums so that the preferred combinations are present first.</p> <p>See <code>RedisModule_RegisterStringConfig</code> for detailed general information about configs.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_registernumericconfig","title":"<code>RedisModule_RegisterNumericConfig</code>","text":"<pre><code>int RedisModule_RegisterNumericConfig(RedisModuleCtx *ctx,\n                                      const char *name,\n                                      long long default_val,\n                                      unsigned int flags,\n                                      long long min,\n                                      long long max,\n                                      RedisModuleConfigGetNumericFunc getfn,\n                                      RedisModuleConfigSetNumericFunc setfn,\n                                      RedisModuleConfigApplyFunc applyfn,\n                                      void *privdata);\n</code></pre> <p>Available since: 7.0.0</p> <p>Create an integer config that server clients can interact with via the  <code>CONFIG SET</code>, <code>CONFIG GET</code>, and <code>CONFIG REWRITE</code> commands. See  <code>RedisModule_RegisterStringConfig</code> for detailed information about configs.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_loadconfigs","title":"<code>RedisModule_LoadConfigs</code>","text":"<pre><code>int RedisModule_LoadConfigs(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 7.0.0</p> <p>Applies all pending configurations on the module load. This should be called after all of the configurations have been registered for the module inside of <code>RedisModule_OnLoad</code>. This will return <code>REDISMODULE_ERR</code> if it is called outside <code>RedisModule_OnLoad</code>. This API needs to be called when configurations are provided in either <code>MODULE LOADEX</code> or provided as startup arguments.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#rdb-loadsave-api","title":"RDB load/save API","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_rdbstreamcreatefromfile","title":"<code>RedisModule_RdbStreamCreateFromFile</code>","text":"<pre><code>RedisModuleRdbStream *RedisModule_RdbStreamCreateFromFile(const char *filename);\n</code></pre> <p>Available since: 7.2.0</p> <p>Create a stream object to save/load RDB to/from a file.</p> <p>This function returns a pointer to <code>RedisModuleRdbStream</code> which is owned by the caller. It requires a call to <code>RedisModule_RdbStreamFree()</code> to free the object.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_rdbstreamfree","title":"<code>RedisModule_RdbStreamFree</code>","text":"<pre><code>void RedisModule_RdbStreamFree(RedisModuleRdbStream *stream);\n</code></pre> <p>Available since: 7.2.0</p> <p>Release an RDB stream object.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_rdbload","title":"<code>RedisModule_RdbLoad</code>","text":"<pre><code>int RedisModule_RdbLoad(RedisModuleCtx *ctx,\n                        RedisModuleRdbStream *stream,\n                        int flags);\n</code></pre> <p>Available since: 7.2.0</p> <p>Load RDB file from the <code>stream</code>. Dataset will be cleared first and then RDB file will be loaded.</p> <p><code>flags</code> must be zero. This parameter is for future use.</p> <p>On success <code>REDISMODULE_OK</code> is returned, otherwise <code>REDISMODULE_ERR</code> is returned and errno is set accordingly.</p> <p>Example:</p> <pre><code>RedisModuleRdbStream *s = RedisModule_RdbStreamCreateFromFile(\"exp.rdb\");\nRedisModule_RdbLoad(ctx, s, 0);\nRedisModule_RdbStreamFree(s);\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_rdbsave","title":"<code>RedisModule_RdbSave</code>","text":"<pre><code>int RedisModule_RdbSave(RedisModuleCtx *ctx,\n                        RedisModuleRdbStream *stream,\n                        int flags);\n</code></pre> <p>Available since: 7.2.0</p> <p>Save dataset to the RDB stream.</p> <p><code>flags</code> must be zero. This parameter is for future use.</p> <p>On success <code>REDISMODULE_OK</code> is returned, otherwise <code>REDISMODULE_ERR</code> is returned and errno is set accordingly.</p> <p>Example:</p> <pre><code>RedisModuleRdbStream *s = RedisModule_RdbStreamCreateFromFile(\"exp.rdb\");\nRedisModule_RdbSave(ctx, s, 0);\nRedisModule_RdbStreamFree(s);\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#key-eviction-api","title":"Key eviction API","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_setlru","title":"<code>RedisModule_SetLRU</code>","text":"<pre><code>int RedisModule_SetLRU(RedisModuleKey *key, mstime_t lru_idle);\n</code></pre> <p>Available since: 6.0.0</p> <p>Set the key last access time for LRU based eviction. not relevant if the servers's maxmemory policy is LFU based. Value is idle time in milliseconds. returns <code>REDISMODULE_OK</code> if the LRU was updated, <code>REDISMODULE_ERR</code> otherwise.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getlru","title":"<code>RedisModule_GetLRU</code>","text":"<pre><code>int RedisModule_GetLRU(RedisModuleKey *key, mstime_t *lru_idle);\n</code></pre> <p>Available since: 6.0.0</p> <p>Gets the key last access time. Value is idletime in milliseconds or -1 if the server's eviction policy is LFU based. returns <code>REDISMODULE_OK</code> if when key is valid.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_setlfu","title":"<code>RedisModule_SetLFU</code>","text":"<pre><code>int RedisModule_SetLFU(RedisModuleKey *key, long long lfu_freq);\n</code></pre> <p>Available since: 6.0.0</p> <p>Set the key access frequency. only relevant if the server's maxmemory policy is LFU based. The frequency is a logarithmic counter that provides an indication of the access frequencyonly (must be &lt;= 255). returns <code>REDISMODULE_OK</code> if the LFU was updated, <code>REDISMODULE_ERR</code> otherwise.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getlfu","title":"<code>RedisModule_GetLFU</code>","text":"<pre><code>int RedisModule_GetLFU(RedisModuleKey *key, long long *lfu_freq);\n</code></pre> <p>Available since: 6.0.0</p> <p>Gets the key access frequency or -1 if the server's eviction policy is not LFU based. returns <code>REDISMODULE_OK</code> if when key is valid.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#miscellaneous-apis","title":"Miscellaneous APIs","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_getmoduleoptionsall","title":"<code>RedisModule_GetModuleOptionsAll</code>","text":"<pre><code>int RedisModule_GetModuleOptionsAll(void);\n</code></pre> <p>Available since: 7.2.0</p> <p>Returns the full module options flags mask, using the return value the module can check if a certain set of module options are supported by the redis server version in use. Example:</p> <pre><code>   int supportedFlags = RedisModule_GetModuleOptionsAll();\n   if (supportedFlags &amp; REDISMODULE_OPTIONS_ALLOW_NESTED_KEYSPACE_NOTIFICATIONS) {\n         // REDISMODULE_OPTIONS_ALLOW_NESTED_KEYSPACE_NOTIFICATIONS is supported\n   } else{\n         // REDISMODULE_OPTIONS_ALLOW_NESTED_KEYSPACE_NOTIFICATIONS is not supported\n   }\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getcontextflagsall","title":"<code>RedisModule_GetContextFlagsAll</code>","text":"<pre><code>int RedisModule_GetContextFlagsAll(void);\n</code></pre> <p>Available since: 6.0.9</p> <p>Returns the full ContextFlags mask, using the return value the module can check if a certain set of flags are supported by the redis server version in use. Example:</p> <pre><code>   int supportedFlags = RedisModule_GetContextFlagsAll();\n   if (supportedFlags &amp; REDISMODULE_CTX_FLAGS_MULTI) {\n         // REDISMODULE_CTX_FLAGS_MULTI is supported\n   } else{\n         // REDISMODULE_CTX_FLAGS_MULTI is not supported\n   }\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getkeyspacenotificationflagsall","title":"<code>RedisModule_GetKeyspaceNotificationFlagsAll</code>","text":"<pre><code>int RedisModule_GetKeyspaceNotificationFlagsAll(void);\n</code></pre> <p>Available since: 6.0.9</p> <p>Returns the full KeyspaceNotification mask, using the return value the module can check if a certain set of flags are supported by the redis server version in use. Example:</p> <pre><code>   int supportedFlags = RedisModule_GetKeyspaceNotificationFlagsAll();\n   if (supportedFlags &amp; REDISMODULE_NOTIFY_LOADED) {\n         // REDISMODULE_NOTIFY_LOADED is supported\n   } else{\n         // REDISMODULE_NOTIFY_LOADED is not supported\n   }\n</code></pre> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getserverversion","title":"<code>RedisModule_GetServerVersion</code>","text":"<pre><code>int RedisModule_GetServerVersion(void);\n</code></pre> <p>Available since: 6.0.9</p> <p>Return the redis version in format of 0x00MMmmpp. Example for 6.0.7 the return value will be 0x00060007.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_gettypemethodversion","title":"<code>RedisModule_GetTypeMethodVersion</code>","text":"<pre><code>int RedisModule_GetTypeMethodVersion(void);\n</code></pre> <p>Available since: 6.2.0</p> <p>Return the current redis-server runtime value of <code>REDISMODULE_TYPE_METHOD_VERSION</code>. You can use that when calling <code>RedisModule_CreateDataType</code> to know which fields of <code>RedisModuleTypeMethods</code> are gonna be supported and which will be ignored.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_moduletypereplacevalue","title":"<code>RedisModule_ModuleTypeReplaceValue</code>","text":"<pre><code>int RedisModule_ModuleTypeReplaceValue(RedisModuleKey *key,\n                                       moduleType *mt,\n                                       void *new_value,\n                                       void **old_value);\n</code></pre> <p>Available since: 6.0.0</p> <p>Replace the value assigned to a module type.</p> <p>The key must be open for writing, have an existing value, and have a moduleType that matches the one specified by the caller.</p> <p>Unlike <code>RedisModule_ModuleTypeSetValue()</code> which will free the old value, this function simply swaps the old value with the new value.</p> <p>The function returns <code>REDISMODULE_OK</code> on success, <code>REDISMODULE_ERR</code> on errors such as:</p> <ol> <li>Key is not opened for writing.</li> <li>Key is not a module data type key.</li> <li>Key is a module datatype other than 'mt'.</li> </ol> <p>If <code>old_value</code> is non-NULL, the old value is returned by reference.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getcommandkeyswithflags","title":"<code>RedisModule_GetCommandKeysWithFlags</code>","text":"<pre><code>int *RedisModule_GetCommandKeysWithFlags(RedisModuleCtx *ctx,\n                                         RedisModuleString **argv,\n                                         int argc,\n                                         int *num_keys,\n                                         int **out_flags);\n</code></pre> <p>Available since: 7.0.0</p> <p>For a specified command, parse its arguments and return an array that contains the indexes of all key name arguments. This function is essentially a more efficient way to do <code>COMMAND GETKEYS</code>.</p> <p>The <code>out_flags</code> argument is optional, and can be set to NULL. When provided it is filled with <code>REDISMODULE_CMD_KEY_</code> flags in matching indexes with the key indexes of the returned array.</p> <p>A NULL return value indicates the specified command has no keys, or an error condition. Error conditions are indicated by setting errno as follows:</p> <ul> <li>ENOENT: Specified command does not exist.</li> <li>EINVAL: Invalid command arity specified.</li> </ul> <p>NOTE: The returned array is not a Redis Module object so it does not get automatically freed even when auto-memory is used. The caller must explicitly call <code>RedisModule_Free()</code> to free it, same as the <code>out_flags</code> pointer if used.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getcommandkeys","title":"<code>RedisModule_GetCommandKeys</code>","text":"<pre><code>int *RedisModule_GetCommandKeys(RedisModuleCtx *ctx,\n                                RedisModuleString **argv,\n                                int argc,\n                                int *num_keys);\n</code></pre> <p>Available since: 6.0.9</p> <p>Identical to <code>RedisModule_GetCommandKeysWithFlags</code> when flags are not needed.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getcurrentcommandname","title":"<code>RedisModule_GetCurrentCommandName</code>","text":"<pre><code>const char *RedisModule_GetCurrentCommandName(RedisModuleCtx *ctx);\n</code></pre> <p>Available since: 6.2.5</p> <p>Return the name of the command currently running</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#defrag-api","title":"Defrag API","text":""},{"location":"8-reference/modules/modules-api-ref/#redismodule_registerdefragfunc","title":"<code>RedisModule_RegisterDefragFunc</code>","text":"<pre><code>int RedisModule_RegisterDefragFunc(RedisModuleCtx *ctx,\n                                   RedisModuleDefragFunc cb);\n</code></pre> <p>Available since: 6.2.0</p> <p>Register a defrag callback for global data, i.e. anything that the module may allocate that is not tied to a specific data type.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_defragshouldstop","title":"<code>RedisModule_DefragShouldStop</code>","text":"<pre><code>int RedisModule_DefragShouldStop(RedisModuleDefragCtx *ctx);\n</code></pre> <p>Available since: 6.2.0</p> <p>When the data type defrag callback iterates complex structures, this function should be called periodically. A zero (false) return indicates the callback may continue its work. A non-zero value (true) indicates it should stop.</p> <p>When stopped, the callback may use <code>RedisModule_DefragCursorSet()</code> to store its position so it can later use <code>RedisModule_DefragCursorGet()</code> to resume defragging.</p> <p>When stopped and more work is left to be done, the callback should return 1. Otherwise, it should return 0.</p> <p>NOTE: Modules should consider the frequency in which this function is called, so it generally makes sense to do small batches of work in between calls.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_defragcursorset","title":"<code>RedisModule_DefragCursorSet</code>","text":"<pre><code>int RedisModule_DefragCursorSet(RedisModuleDefragCtx *ctx,\n                                unsigned long cursor);\n</code></pre> <p>Available since: 6.2.0</p> <p>Store an arbitrary cursor value for future re-use.</p> <p>This should only be called if <code>RedisModule_DefragShouldStop()</code> has returned a non-zero value and the defrag callback is about to exit without fully iterating its data type.</p> <p>This behavior is reserved to cases where late defrag is performed. Late defrag is selected for keys that implement the <code>free_effort</code> callback and return a <code>free_effort</code> value that is larger than the defrag 'active-defrag-max-scan-fields' configuration directive.</p> <p>Smaller keys, keys that do not implement <code>free_effort</code> or the global defrag callback are not called in late-defrag mode. In those cases, a call to this function will return <code>REDISMODULE_ERR</code>.</p> <p>The cursor may be used by the module to represent some progress into the module's data type. Modules may also store additional cursor-related information locally and use the cursor as a flag that indicates when traversal of a new key begins. This is possible because the API makes a guarantee that concurrent defragmentation of multiple keys will not be performed.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_defragcursorget","title":"<code>RedisModule_DefragCursorGet</code>","text":"<pre><code>int RedisModule_DefragCursorGet(RedisModuleDefragCtx *ctx,\n                                unsigned long *cursor);\n</code></pre> <p>Available since: 6.2.0</p> <p>Fetch a cursor value that has been previously stored using <code>RedisModule_DefragCursorSet()</code>.</p> <p>If not called for a late defrag operation, <code>REDISMODULE_ERR</code> will be returned and the cursor should be ignored. See <code>RedisModule_DefragCursorSet()</code> for more details on defrag cursors.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_defragalloc","title":"<code>RedisModule_DefragAlloc</code>","text":"<pre><code>void *RedisModule_DefragAlloc(RedisModuleDefragCtx *ctx, void *ptr);\n</code></pre> <p>Available since: 6.2.0</p> <p>Defrag a memory allocation previously allocated by <code>RedisModule_Alloc</code>, <code>RedisModule_Calloc</code>, etc. The defragmentation process involves allocating a new memory block and copying the contents to it, like <code>realloc()</code>.</p> <p>If defragmentation was not necessary, NULL is returned and the operation has no other effect.</p> <p>If a non-NULL value is returned, the caller should use the new pointer instead of the old one and update any reference to the old pointer, which must not be used again.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_defragredismodulestring","title":"<code>RedisModule_DefragRedisModuleString</code>","text":"<pre><code>RedisModuleString *RedisModule_DefragRedisModuleString(RedisModuleDefragCtx *ctx,\n                                                       RedisModuleString *str);\n</code></pre> <p>Available since: 6.2.0</p> <p>Defrag a <code>RedisModuleString</code> previously allocated by <code>RedisModule_Alloc</code>, <code>RedisModule_Calloc</code>, etc. See <code>RedisModule_DefragAlloc()</code> for more information on how the defragmentation process works.</p> <p>NOTE: It is only possible to defrag strings that have a single reference. Typically this means strings retained with <code>RedisModule_RetainString</code> or <code>RedisModule_HoldString</code> may not be defragmentable. One exception is command argvs which, if retained by the module, will end up with a single reference (because the reference on the Redis side is dropped as soon as the command callback returns).</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getkeynamefromdefragctx","title":"<code>RedisModule_GetKeyNameFromDefragCtx</code>","text":"<pre><code>const RedisModuleString *RedisModule_GetKeyNameFromDefragCtx(RedisModuleDefragCtx *ctx);\n</code></pre> <p>Available since: 7.0.0</p> <p>Returns the name of the key currently being processed. There is no guarantee that the key name is always available, so this may return NULL.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#redismodule_getdbidfromdefragctx","title":"<code>RedisModule_GetDbIdFromDefragCtx</code>","text":"<pre><code>int RedisModule_GetDbIdFromDefragCtx(RedisModuleDefragCtx *ctx);\n</code></pre> <p>Available since: 7.0.0</p> <p>Returns the database id of the key currently being processed. There is no guarantee that this info is always available, so this may return -1.</p> <p></p>"},{"location":"8-reference/modules/modules-api-ref/#function-index","title":"Function index","text":"<ul> <li><code>RedisModule_ACLAddLogEntry</code></li> <li><code>RedisModule_ACLAddLogEntryByUserName</code></li> <li><code>RedisModule_ACLCheckChannelPermissions</code></li> <li><code>RedisModule_ACLCheckCommandPermissions</code></li> <li><code>RedisModule_ACLCheckKeyPermissions</code></li> <li><code>RedisModule_AbortBlock</code></li> <li><code>RedisModule_AddPostNotificationJob</code></li> <li><code>RedisModule_Alloc</code></li> <li><code>RedisModule_AuthenticateClientWithACLUser</code></li> <li><code>RedisModule_AuthenticateClientWithUser</code></li> <li><code>RedisModule_AutoMemory</code></li> <li><code>RedisModule_AvoidReplicaTraffic</code></li> <li><code>RedisModule_BlockClient</code></li> <li><code>RedisModule_BlockClientGetPrivateData</code></li> <li><code>RedisModule_BlockClientOnAuth</code></li> <li><code>RedisModule_BlockClientOnKeys</code></li> <li><code>RedisModule_BlockClientOnKeysWithFlags</code></li> <li><code>RedisModule_BlockClientSetPrivateData</code></li> <li><code>RedisModule_BlockedClientDisconnected</code></li> <li><code>RedisModule_BlockedClientMeasureTimeEnd</code></li> <li><code>RedisModule_BlockedClientMeasureTimeStart</code></li> <li><code>RedisModule_CachedMicroseconds</code></li> <li><code>RedisModule_Call</code></li> <li><code>RedisModule_CallReplyArrayElement</code></li> <li><code>RedisModule_CallReplyAttribute</code></li> <li><code>RedisModule_CallReplyAttributeElement</code></li> <li><code>RedisModule_CallReplyBigNumber</code></li> <li><code>RedisModule_CallReplyBool</code></li> <li><code>RedisModule_CallReplyDouble</code></li> <li><code>RedisModule_CallReplyInteger</code></li> <li><code>RedisModule_CallReplyLength</code></li> <li><code>RedisModule_CallReplyMapElement</code></li> <li><code>RedisModule_CallReplyPromiseAbort</code></li> <li><code>RedisModule_CallReplyPromiseSetUnblockHandler</code></li> <li><code>RedisModule_CallReplyProto</code></li> <li><code>RedisModule_CallReplySetElement</code></li> <li><code>RedisModule_CallReplyStringPtr</code></li> <li><code>RedisModule_CallReplyType</code></li> <li><code>RedisModule_CallReplyVerbatim</code></li> <li><code>RedisModule_Calloc</code></li> <li><code>RedisModule_ChannelAtPosWithFlags</code></li> <li><code>RedisModule_CloseKey</code></li> <li><code>RedisModule_CommandFilterArgDelete</code></li> <li><code>RedisModule_CommandFilterArgGet</code></li> <li><code>RedisModule_CommandFilterArgInsert</code></li> <li><code>RedisModule_CommandFilterArgReplace</code></li> <li><code>RedisModule_CommandFilterArgsCount</code></li> <li><code>RedisModule_CommandFilterGetClientId</code></li> <li><code>RedisModule_CreateCommand</code></li> <li><code>RedisModule_CreateDataType</code></li> <li><code>RedisModule_CreateDict</code></li> <li><code>RedisModule_CreateModuleUser</code></li> <li><code>RedisModule_CreateString</code></li> <li><code>RedisModule_CreateStringFromCallReply</code></li> <li><code>RedisModule_CreateStringFromDouble</code></li> <li><code>RedisModule_CreateStringFromLongDouble</code></li> <li><code>RedisModule_CreateStringFromLongLong</code></li> <li><code>RedisModule_CreateStringFromStreamID</code></li> <li><code>RedisModule_CreateStringFromString</code></li> <li><code>RedisModule_CreateStringFromULongLong</code></li> <li><code>RedisModule_CreateStringPrintf</code></li> <li><code>RedisModule_CreateSubcommand</code></li> <li><code>RedisModule_CreateTimer</code></li> <li><code>RedisModule_DbSize</code></li> <li><code>RedisModule_DeauthenticateAndCloseClient</code></li> <li><code>RedisModule_DefragAlloc</code></li> <li><code>RedisModule_DefragCursorGet</code></li> <li><code>RedisModule_DefragCursorSet</code></li> <li><code>RedisModule_DefragRedisModuleString</code></li> <li><code>RedisModule_DefragShouldStop</code></li> <li><code>RedisModule_DeleteKey</code></li> <li><code>RedisModule_DictCompare</code></li> <li><code>RedisModule_DictCompareC</code></li> <li><code>RedisModule_DictDel</code></li> <li><code>RedisModule_DictDelC</code></li> <li><code>RedisModule_DictGet</code></li> <li><code>RedisModule_DictGetC</code></li> <li><code>RedisModule_DictIteratorReseek</code></li> <li><code>RedisModule_DictIteratorReseekC</code></li> <li><code>RedisModule_DictIteratorStart</code></li> <li><code>RedisModule_DictIteratorStartC</code></li> <li><code>RedisModule_DictIteratorStop</code></li> <li><code>RedisModule_DictNext</code></li> <li><code>RedisModule_DictNextC</code></li> <li><code>RedisModule_DictPrev</code></li> <li><code>RedisModule_DictPrevC</code></li> <li><code>RedisModule_DictReplace</code></li> <li><code>RedisModule_DictReplaceC</code></li> <li><code>RedisModule_DictSet</code></li> <li><code>RedisModule_DictSetC</code></li> <li><code>RedisModule_DictSize</code></li> <li><code>RedisModule_DigestAddLongLong</code></li> <li><code>RedisModule_DigestAddStringBuffer</code></li> <li><code>RedisModule_DigestEndSequence</code></li> <li><code>RedisModule_EmitAOF</code></li> <li><code>RedisModule_EventLoopAdd</code></li> <li><code>RedisModule_EventLoopAddOneShot</code></li> <li><code>RedisModule_EventLoopDel</code></li> <li><code>RedisModule_ExitFromChild</code></li> <li><code>RedisModule_ExportSharedAPI</code></li> <li><code>RedisModule_Fork</code></li> <li><code>RedisModule_Free</code></li> <li><code>RedisModule_FreeCallReply</code></li> <li><code>RedisModule_FreeClusterNodesList</code></li> <li><code>RedisModule_FreeDict</code></li> <li><code>RedisModule_FreeModuleUser</code></li> <li><code>RedisModule_FreeServerInfo</code></li> <li><code>RedisModule_FreeString</code></li> <li><code>RedisModule_FreeThreadSafeContext</code></li> <li><code>RedisModule_GetAbsExpire</code></li> <li><code>RedisModule_GetBlockedClientHandle</code></li> <li><code>RedisModule_GetBlockedClientPrivateData</code></li> <li><code>RedisModule_GetBlockedClientReadyKey</code></li> <li><code>RedisModule_GetClientCertificate</code></li> <li><code>RedisModule_GetClientId</code></li> <li><code>RedisModule_GetClientInfoById</code></li> <li><code>RedisModule_GetClientNameById</code></li> <li><code>RedisModule_GetClientUserNameById</code></li> <li><code>RedisModule_GetClusterNodeInfo</code></li> <li><code>RedisModule_GetClusterNodesList</code></li> <li><code>RedisModule_GetClusterSize</code></li> <li><code>RedisModule_GetCommand</code></li> <li><code>RedisModule_GetCommandKeys</code></li> <li><code>RedisModule_GetCommandKeysWithFlags</code></li> <li><code>RedisModule_GetContextFlags</code></li> <li><code>RedisModule_GetContextFlagsAll</code></li> <li><code>RedisModule_GetCurrentCommandName</code></li> <li><code>RedisModule_GetCurrentUserName</code></li> <li><code>RedisModule_GetDbIdFromDefragCtx</code></li> <li><code>RedisModule_GetDbIdFromDigest</code></li> <li><code>RedisModule_GetDbIdFromIO</code></li> <li><code>RedisModule_GetDbIdFromModuleKey</code></li> <li><code>RedisModule_GetDbIdFromOptCtx</code></li> <li><code>RedisModule_GetDetachedThreadSafeContext</code></li> <li><code>RedisModule_GetExpire</code></li> <li><code>RedisModule_GetKeyNameFromDefragCtx</code></li> <li><code>RedisModule_GetKeyNameFromDigest</code></li> <li><code>RedisModule_GetKeyNameFromIO</code></li> <li><code>RedisModule_GetKeyNameFromModuleKey</code></li> <li><code>RedisModule_GetKeyNameFromOptCtx</code></li> <li><code>RedisModule_GetKeyspaceNotificationFlagsAll</code></li> <li><code>RedisModule_GetLFU</code></li> <li><code>RedisModule_GetLRU</code></li> <li><code>RedisModule_GetModuleOptionsAll</code></li> <li><code>RedisModule_GetModuleUserACLString</code></li> <li><code>RedisModule_GetModuleUserFromUserName</code></li> <li><code>RedisModule_GetMyClusterID</code></li> <li><code>RedisModule_GetNotifyKeyspaceEvents</code></li> <li><code>RedisModule_GetOpenKeyModesAll</code></li> <li><code>RedisModule_GetRandomBytes</code></li> <li><code>RedisModule_GetRandomHexChars</code></li> <li><code>RedisModule_GetSelectedDb</code></li> <li><code>RedisModule_GetServerInfo</code></li> <li><code>RedisModule_GetServerVersion</code></li> <li><code>RedisModule_GetSharedAPI</code></li> <li><code>RedisModule_GetThreadSafeContext</code></li> <li><code>RedisModule_GetTimerInfo</code></li> <li><code>RedisModule_GetToDbIdFromOptCtx</code></li> <li><code>RedisModule_GetToKeyNameFromOptCtx</code></li> <li><code>RedisModule_GetTypeMethodVersion</code></li> <li><code>RedisModule_GetUsedMemoryRatio</code></li> <li><code>RedisModule_HashGet</code></li> <li><code>RedisModule_HashSet</code></li> <li><code>RedisModule_HoldString</code></li> <li><code>RedisModule_InfoAddFieldCString</code></li> <li><code>RedisModule_InfoAddFieldDouble</code></li> <li><code>RedisModule_InfoAddFieldLongLong</code></li> <li><code>RedisModule_InfoAddFieldString</code></li> <li><code>RedisModule_InfoAddFieldULongLong</code></li> <li><code>RedisModule_InfoAddSection</code></li> <li><code>RedisModule_InfoBeginDictField</code></li> <li><code>RedisModule_InfoEndDictField</code></li> <li><code>RedisModule_IsBlockedReplyRequest</code></li> <li><code>RedisModule_IsBlockedTimeoutRequest</code></li> <li><code>RedisModule_IsChannelsPositionRequest</code></li> <li><code>RedisModule_IsIOError</code></li> <li><code>RedisModule_IsKeysPositionRequest</code></li> <li><code>RedisModule_IsModuleNameBusy</code></li> <li><code>RedisModule_IsSubEventSupported</code></li> <li><code>RedisModule_KeyAtPos</code></li> <li><code>RedisModule_KeyAtPosWithFlags</code></li> <li><code>RedisModule_KeyExists</code></li> <li><code>RedisModule_KeyType</code></li> <li><code>RedisModule_KillForkChild</code></li> <li><code>RedisModule_LatencyAddSample</code></li> <li><code>RedisModule_ListDelete</code></li> <li><code>RedisModule_ListGet</code></li> <li><code>RedisModule_ListInsert</code></li> <li><code>RedisModule_ListPop</code></li> <li><code>RedisModule_ListPush</code></li> <li><code>RedisModule_ListSet</code></li> <li><code>RedisModule_LoadConfigs</code></li> <li><code>RedisModule_LoadDataTypeFromString</code></li> <li><code>RedisModule_LoadDataTypeFromStringEncver</code></li> <li><code>RedisModule_LoadDouble</code></li> <li><code>RedisModule_LoadFloat</code></li> <li><code>RedisModule_LoadLongDouble</code></li> <li><code>RedisModule_LoadSigned</code></li> <li><code>RedisModule_LoadString</code></li> <li><code>RedisModule_LoadStringBuffer</code></li> <li><code>RedisModule_LoadUnsigned</code></li> <li><code>RedisModule_Log</code></li> <li><code>RedisModule_LogIOError</code></li> <li><code>RedisModule_MallocSize</code></li> <li><code>RedisModule_MallocSizeDict</code></li> <li><code>RedisModule_MallocSizeString</code></li> <li><code>RedisModule_MallocUsableSize</code></li> <li><code>RedisModule_Microseconds</code></li> <li><code>RedisModule_Milliseconds</code></li> <li><code>RedisModule_ModuleTypeGetType</code></li> <li><code>RedisModule_ModuleTypeGetValue</code></li> <li><code>RedisModule_ModuleTypeReplaceValue</code></li> <li><code>RedisModule_ModuleTypeSetValue</code></li> <li><code>RedisModule_MonotonicMicroseconds</code></li> <li><code>RedisModule_NotifyKeyspaceEvent</code></li> <li><code>RedisModule_OpenKey</code></li> <li><code>RedisModule_PoolAlloc</code></li> <li><code>RedisModule_PublishMessage</code></li> <li><code>RedisModule_PublishMessageShard</code></li> <li><code>RedisModule_RandomKey</code></li> <li><code>RedisModule_RdbLoad</code></li> <li><code>RedisModule_RdbSave</code></li> <li><code>RedisModule_RdbStreamCreateFromFile</code></li> <li><code>RedisModule_RdbStreamFree</code></li> <li><code>RedisModule_Realloc</code></li> <li><code>RedisModule_RedactClientCommandArgument</code></li> <li><code>RedisModule_RegisterAuthCallback</code></li> <li><code>RedisModule_RegisterBoolConfig</code></li> <li><code>RedisModule_RegisterClusterMessageReceiver</code></li> <li><code>RedisModule_RegisterCommandFilter</code></li> <li><code>RedisModule_RegisterDefragFunc</code></li> <li><code>RedisModule_RegisterEnumConfig</code></li> <li><code>RedisModule_RegisterInfoFunc</code></li> <li><code>RedisModule_RegisterNumericConfig</code></li> <li><code>RedisModule_RegisterStringConfig</code></li> <li><code>RedisModule_Replicate</code></li> <li><code>RedisModule_ReplicateVerbatim</code></li> <li><code>RedisModule_ReplySetArrayLength</code></li> <li><code>RedisModule_ReplySetAttributeLength</code></li> <li><code>RedisModule_ReplySetMapLength</code></li> <li><code>RedisModule_ReplySetSetLength</code></li> <li><code>RedisModule_ReplyWithArray</code></li> <li><code>RedisModule_ReplyWithAttribute</code></li> <li><code>RedisModule_ReplyWithBigNumber</code></li> <li><code>RedisModule_ReplyWithBool</code></li> <li><code>RedisModule_ReplyWithCString</code></li> <li><code>RedisModule_ReplyWithCallReply</code></li> <li><code>RedisModule_ReplyWithDouble</code></li> <li><code>RedisModule_ReplyWithEmptyArray</code></li> <li><code>RedisModule_ReplyWithEmptyString</code></li> <li><code>RedisModule_ReplyWithError</code></li> <li><code>RedisModule_ReplyWithErrorFormat</code></li> <li><code>RedisModule_ReplyWithLongDouble</code></li> <li><code>RedisModule_ReplyWithLongLong</code></li> <li><code>RedisModule_ReplyWithMap</code></li> <li><code>RedisModule_ReplyWithNull</code></li> <li><code>RedisModule_ReplyWithNullArray</code></li> <li><code>RedisModule_ReplyWithSet</code></li> <li><code>RedisModule_ReplyWithSimpleString</code></li> <li><code>RedisModule_ReplyWithString</code></li> <li><code>RedisModule_ReplyWithStringBuffer</code></li> <li><code>RedisModule_ReplyWithVerbatimString</code></li> <li><code>RedisModule_ReplyWithVerbatimStringType</code></li> <li><code>RedisModule_ResetDataset</code></li> <li><code>RedisModule_RetainString</code></li> <li><code>RedisModule_SaveDataTypeToString</code></li> <li><code>RedisModule_SaveDouble</code></li> <li><code>RedisModule_SaveFloat</code></li> <li><code>RedisModule_SaveLongDouble</code></li> <li><code>RedisModule_SaveSigned</code></li> <li><code>RedisModule_SaveString</code></li> <li><code>RedisModule_SaveStringBuffer</code></li> <li><code>RedisModule_SaveUnsigned</code></li> <li><code>RedisModule_Scan</code></li> <li><code>RedisModule_ScanCursorCreate</code></li> <li><code>RedisModule_ScanCursorDestroy</code></li> <li><code>RedisModule_ScanCursorRestart</code></li> <li><code>RedisModule_ScanKey</code></li> <li><code>RedisModule_SelectDb</code></li> <li><code>RedisModule_SendChildHeartbeat</code></li> <li><code>RedisModule_SendClusterMessage</code></li> <li><code>RedisModule_ServerInfoGetField</code></li> <li><code>RedisModule_ServerInfoGetFieldC</code></li> <li><code>RedisModule_ServerInfoGetFieldDouble</code></li> <li><code>RedisModule_ServerInfoGetFieldSigned</code></li> <li><code>RedisModule_ServerInfoGetFieldUnsigned</code></li> <li><code>RedisModule_SetAbsExpire</code></li> <li><code>RedisModule_SetClientNameById</code></li> <li><code>RedisModule_SetClusterFlags</code></li> <li><code>RedisModule_SetCommandACLCategories</code></li> <li><code>RedisModule_SetCommandInfo</code></li> <li><code>RedisModule_SetContextUser</code></li> <li><code>RedisModule_SetDisconnectCallback</code></li> <li><code>RedisModule_SetExpire</code></li> <li><code>RedisModule_SetLFU</code></li> <li><code>RedisModule_SetLRU</code></li> <li><code>RedisModule_SetModuleOptions</code></li> <li><code>RedisModule_SetModuleUserACL</code></li> <li><code>RedisModule_SetModuleUserACLString</code></li> <li><code>RedisModule_SignalKeyAsReady</code></li> <li><code>RedisModule_SignalModifiedKey</code></li> <li><code>RedisModule_StopTimer</code></li> <li><code>RedisModule_Strdup</code></li> <li><code>RedisModule_StreamAdd</code></li> <li><code>RedisModule_StreamDelete</code></li> <li><code>RedisModule_StreamIteratorDelete</code></li> <li><code>RedisModule_StreamIteratorNextField</code></li> <li><code>RedisModule_StreamIteratorNextID</code></li> <li><code>RedisModule_StreamIteratorStart</code></li> <li><code>RedisModule_StreamIteratorStop</code></li> <li><code>RedisModule_StreamTrimByID</code></li> <li><code>RedisModule_StreamTrimByLength</code></li> <li><code>RedisModule_StringAppendBuffer</code></li> <li><code>RedisModule_StringCompare</code></li> <li><code>RedisModule_StringDMA</code></li> <li><code>RedisModule_StringPtrLen</code></li> <li><code>RedisModule_StringSet</code></li> <li><code>RedisModule_StringToDouble</code></li> <li><code>RedisModule_StringToLongDouble</code></li> <li><code>RedisModule_StringToLongLong</code></li> <li><code>RedisModule_StringToStreamID</code></li> <li><code>RedisModule_StringToULongLong</code></li> <li><code>RedisModule_StringTruncate</code></li> <li><code>RedisModule_SubscribeToKeyspaceEvents</code></li> <li><code>RedisModule_SubscribeToServerEvent</code></li> <li><code>RedisModule_ThreadSafeContextLock</code></li> <li><code>RedisModule_ThreadSafeContextTryLock</code></li> <li><code>RedisModule_ThreadSafeContextUnlock</code></li> <li><code>RedisModule_TrimStringAllocation</code></li> <li><code>RedisModule_TryAlloc</code></li> <li><code>RedisModule_UnblockClient</code></li> <li><code>RedisModule_UnlinkKey</code></li> <li><code>RedisModule_UnregisterCommandFilter</code></li> <li><code>RedisModule_ValueLength</code></li> <li><code>RedisModule_WrongArity</code></li> <li><code>RedisModule_Yield</code></li> <li><code>RedisModule_ZsetAdd</code></li> <li><code>RedisModule_ZsetFirstInLexRange</code></li> <li><code>RedisModule_ZsetFirstInScoreRange</code></li> <li><code>RedisModule_ZsetIncrby</code></li> <li><code>RedisModule_ZsetLastInLexRange</code></li> <li><code>RedisModule_ZsetLastInScoreRange</code></li> <li><code>RedisModule_ZsetRangeCurrentElement</code></li> <li><code>RedisModule_ZsetRangeEndReached</code></li> <li><code>RedisModule_ZsetRangeNext</code></li> <li><code>RedisModule_ZsetRangePrev</code></li> <li><code>RedisModule_ZsetRangeStop</code></li> <li><code>RedisModule_ZsetRem</code></li> <li><code>RedisModule_ZsetScore</code></li> <li><code>RedisModule__Assert</code></li> </ul>"},{"location":"8-reference/modules/modules-blocking-ops/","title":"Redis modules and blocking commands","text":"<p>Redis has a few blocking commands among the built-in set of commands. One of the most used is <code>BLPOP</code> (or the symmetric <code>BRPOP</code>) which blocks waiting for elements arriving in a list.</p> <p>The interesting fact about blocking commands is that they do not block the whole server, but just the client calling them. Usually the reason to block is that we expect some external event to happen: this can be some change in the Redis data structures like in the <code>BLPOP</code> case, a long computation happening in a thread, to receive some data from the network, and so forth.</p> <p>Redis modules have the ability to implement blocking commands as well, this documentation shows how the API works and describes a few patterns that can be used in order to model blocking commands.</p>"},{"location":"8-reference/modules/modules-blocking-ops/#how-blocking-and-resuming-works","title":"How blocking and resuming works.","text":"<p>Note: You may want to check the <code>helloblock.c</code> example in the Redis source tree inside the <code>src/modules</code> directory, for a simple to understand example on how the blocking API is applied.</p> <p>In Redis modules, commands are implemented by callback functions that are invoked by the Redis core when the specific command is called by the user. Normally the callback terminates its execution sending some reply to the client. Using the following function instead, the function implementing the module command may request that the client is put into the blocked state:</p> <pre><code>RedisModuleBlockedClient *RedisModule_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(void*), long long timeout_ms);\n</code></pre> <p>The function returns a <code>RedisModuleBlockedClient</code> object, which is later used in order to unblock the client. The arguments have the following meaning:</p> <ul> <li><code>ctx</code> is the command execution context as usually in the rest of the API.</li> <li><code>reply_callback</code> is the callback, having the same prototype of a normal command function, that is called when the client is unblocked in order to return a reply to the client.</li> <li><code>timeout_callback</code> is the callback, having the same prototype of a normal command function that is called when the client reached the <code>ms</code> timeout.</li> <li><code>free_privdata</code> is the callback that is called in order to free the private data. Private data is a pointer to some data that is passed between the API used to unblock the client, to the callback that will send the reply to the client. We'll see how this mechanism works later in this document.</li> <li><code>ms</code> is the timeout in milliseconds. When the timeout is reached, the timeout callback is called and the client is automatically aborted.</li> </ul> <p>Once a client is blocked, it can be unblocked with the following API:</p> <pre><code>int RedisModule_UnblockClient(RedisModuleBlockedClient *bc, void *privdata);\n</code></pre> <p>The function takes as argument the blocked client object returned by the previous call to <code>RedisModule_BlockClient()</code>, and unblock the client. Immediately before the client gets unblocked, the <code>reply_callback</code> function specified when the client was blocked is called: this function will have access to the <code>privdata</code> pointer used here.</p> <p>IMPORTANT: The above function is thread safe, and can be called from within a thread doing some work in order to implement the command that blocked the client.</p> <p>The <code>privdata</code> data will be freed automatically using the <code>free_privdata</code> callback when the client is unblocked. This is useful since the reply callback may never be called in case the client timeouts or disconnects from the server, so it's important that it's up to an external function to have the responsibility to free the data passed if needed.</p> <p>To better understand how the API works, we can imagine writing a command that blocks a client for one second, and then send as reply \"Hello!\".</p> <p>Note: arity checks and other non important things are not implemented int his command, in order to take the example simple.</p> <pre><code>int Example_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv,\n                         int argc)\n{\n    RedisModuleBlockedClient *bc =\n        RedisModule_BlockClient(ctx,reply_func,timeout_func,NULL,0);\n\n    pthread_t tid;\n    pthread_create(&amp;tid,NULL,threadmain,bc);\n\n    return REDISMODULE_OK;\n}\n\nvoid *threadmain(void *arg) {\n    RedisModuleBlockedClient *bc = arg;\n\n    sleep(1); /* Wait one second and unblock. */\n    RedisModule_UnblockClient(bc,NULL);\n}\n</code></pre> <p>The above command blocks the client ASAP, spawning a thread that will wait a second and will unblock the client. Let's check the reply and timeout callbacks, which are in our case very similar, since they just reply the client with a different reply type.</p> <pre><code>int reply_func(RedisModuleCtx *ctx, RedisModuleString **argv,\n               int argc)\n{\n    return RedisModule_ReplyWithSimpleString(ctx,\"Hello!\");\n}\n\nint timeout_func(RedisModuleCtx *ctx, RedisModuleString **argv,\n               int argc)\n{\n    return RedisModule_ReplyWithNull(ctx);\n}\n</code></pre> <p>The reply callback just sends the \"Hello!\" string to the client. The important bit here is that the reply callback is called when the client is unblocked from the thread.</p> <p>The timeout command returns <code>NULL</code>, as it often happens with actual Redis blocking commands timing out.</p>"},{"location":"8-reference/modules/modules-blocking-ops/#passing-reply-data-when-unblocking","title":"Passing reply data when unblocking","text":"<p>The above example is simple to understand but lacks an important real world aspect of an actual blocking command implementation: often the reply function will need to know what to reply to the client, and this information is often provided as the client is unblocked.</p> <p>We could modify the above example so that the thread generates a random number after waiting one second. You can think at it as an actually expansive operation of some kind. Then this random number can be passed to the reply function so that we return it to the command caller. In order to make this working, we modify the functions as follow:</p> <pre><code>void *threadmain(void *arg) {\n    RedisModuleBlockedClient *bc = arg;\n\n    sleep(1); /* Wait one second and unblock. */\n\n    long *mynumber = RedisModule_Alloc(sizeof(long));\n    *mynumber = rand();\n    RedisModule_UnblockClient(bc,mynumber);\n}\n</code></pre> <p>As you can see, now the unblocking call is passing some private data, that is the <code>mynumber</code> pointer, to the reply callback. In order to obtain this private data, the reply callback will use the following function:</p> <pre><code>void *RedisModule_GetBlockedClientPrivateData(RedisModuleCtx *ctx);\n</code></pre> <p>So our reply callback is modified like that:</p> <pre><code>int reply_func(RedisModuleCtx *ctx, RedisModuleString **argv,\n               int argc)\n{\n    long *mynumber = RedisModule_GetBlockedClientPrivateData(ctx);\n    /* IMPORTANT: don't free mynumber here, but in the\n     * free privdata callback. */\n    return RedisModule_ReplyWithLongLong(ctx,mynumber);\n}\n</code></pre> <p>Note that we also need to pass a <code>free_privdata</code> function when blocking the client with <code>RedisModule_BlockClient()</code>, since the allocated long value must be freed. Our callback will look like the following:</p> <pre><code>void free_privdata(void *privdata) {\n    RedisModule_Free(privdata);\n}\n</code></pre> <p>NOTE: It is important to stress that the private data is best freed in the <code>free_privdata</code> callback because the reply function may not be called if the client disconnects or timeout.</p> <p>Also note that the private data is also accessible from the timeout callback, always using the <code>GetBlockedClientPrivateData()</code> API.</p>"},{"location":"8-reference/modules/modules-blocking-ops/#aborting-the-blocking-of-a-client","title":"Aborting the blocking of a client","text":"<p>One problem that sometimes arises is that we need to allocate resources in order to implement the non blocking command. So we block the client, then, for example, try to create a thread, but the thread creation function returns an error. What to do in such a condition in order to recover? We don't want to take the client blocked, nor we want to call <code>UnblockClient()</code> because this will trigger the reply callback to be called.</p> <p>In this case the best thing to do is to use the following function:</p> <pre><code>int RedisModule_AbortBlock(RedisModuleBlockedClient *bc);\n</code></pre> <p>Practically this is how to use it:</p> <pre><code>int Example_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv,\n                         int argc)\n{\n    RedisModuleBlockedClient *bc =\n        RedisModule_BlockClient(ctx,reply_func,timeout_func,NULL,0);\n\n    pthread_t tid;\n    if (pthread_create(&amp;tid,NULL,threadmain,bc) != 0) {\n        RedisModule_AbortBlock(bc);\n        RedisModule_ReplyWithError(ctx,\"Sorry can't create a thread\");\n    }\n\n    return REDISMODULE_OK;\n}\n</code></pre> <p>The client will be unblocked but the reply callback will not be called.</p>"},{"location":"8-reference/modules/modules-blocking-ops/#implementing-the-command-reply-and-timeout-callback-using-a-single-function","title":"Implementing the command, reply and timeout callback using a single function","text":"<p>The following functions can be used in order to implement the reply and callback with the same function that implements the primary command function:</p> <pre><code>int RedisModule_IsBlockedReplyRequest(RedisModuleCtx *ctx);\nint RedisModule_IsBlockedTimeoutRequest(RedisModuleCtx *ctx);\n</code></pre> <p>So I could rewrite the example command without using a separated reply and timeout callback:</p> <pre><code>int Example_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv,\n                         int argc)\n{\n    if (RedisModule_IsBlockedReplyRequest(ctx)) {\n        long *mynumber = RedisModule_GetBlockedClientPrivateData(ctx);\n        return RedisModule_ReplyWithLongLong(ctx,mynumber);\n    } else if (RedisModule_IsBlockedTimeoutRequest) {\n        return RedisModule_ReplyWithNull(ctx);\n    }\n\n    RedisModuleBlockedClient *bc =\n        RedisModule_BlockClient(ctx,reply_func,timeout_func,NULL,0);\n\n    pthread_t tid;\n    if (pthread_create(&amp;tid,NULL,threadmain,bc) != 0) {\n        RedisModule_AbortBlock(bc);\n        RedisModule_ReplyWithError(ctx,\"Sorry can't create a thread\");\n    }\n\n    return REDISMODULE_OK;\n}\n</code></pre> <p>Functionally is the same but there are people that will prefer the less verbose implementation that concentrates most of the command logic in a single function.</p>"},{"location":"8-reference/modules/modules-blocking-ops/#working-on-copies-of-data-inside-a-thread","title":"Working on copies of data inside a thread","text":"<p>An interesting pattern in order to work with threads implementing the slow part of a command, is to work with a copy of the data, so that while some operation is performed in a key, the user continues to see the old version. However when the thread terminated its work, the representations are swapped and the new, processed version, is used.</p> <p>An example of this approach is the Neural Redis module where neural networks are trained in different threads while the user can still execute and inspect their older versions.</p>"},{"location":"8-reference/modules/modules-blocking-ops/#future-work","title":"Future work","text":"<p>An API is work in progress right now in order to allow Redis modules APIs to be called in a safe way from threads, so that the threaded command can access the data space and do incremental operations.</p> <p>There is no ETA for this feature but it may appear in the course of the Redis 4.0 release at some point.</p>"},{"location":"8-reference/modules/modules-native-types/","title":"Modules API for native types","text":"<p>Redis modules can access Redis built-in data structures both at high level, by calling Redis commands, and at low level, by manipulating the data structures directly.</p> <p>By using these capabilities in order to build new abstractions on top of existing Redis data structures, or by using strings DMA in order to encode modules data structures into Redis strings, it is possible to create modules that feel like they are exporting new data types. However, for more complex problems, this is not enough, and the implementation of new data structures inside the module is needed.</p> <p>We call the ability of Redis modules to implement new data structures that feel like native Redis ones native types support. This document describes the API exported by the Redis modules system in order to create new data structures and handle the serialization in RDB files, the rewriting process in AOF, the type reporting via the <code>TYPE</code> command, and so forth.</p>"},{"location":"8-reference/modules/modules-native-types/#overview-of-native-types","title":"Overview of native types","text":"<p>A module exporting a native type is composed of the following main parts:</p> <ul> <li>The implementation of some kind of new data structure and of commands operating on the new data structure.</li> <li>A set of callbacks that handle: RDB saving, RDB loading, AOF rewriting, releasing of a value associated with a key, calculation of a value digest (hash) to be used with the <code>DEBUG DIGEST</code> command.</li> <li>A 9 characters name that is unique to each module native data type.</li> <li>An encoding version, used to persist into RDB files a module-specific data version, so that a module will be able to load older representations from RDB files.</li> </ul> <p>While to handle RDB loading, saving and AOF rewriting may look complex as a first glance, the modules API provide very high level function for handling all this, without requiring the user to handle read/write errors, so in practical terms, writing a new data structure for Redis is a simple task.</p> <p>A very easy to understand but complete example of native type implementation is available inside the Redis distribution in the <code>/modules/hellotype.c</code> file. The reader is encouraged to read the documentation by looking at this example implementation to see how things are applied in the practice.</p>"},{"location":"8-reference/modules/modules-native-types/#registering-a-new-data-type","title":"Registering a new data type","text":"<p>In order to register a new native type into the Redis core, the module needs to declare a global variable that will hold a reference to the data type. The API to register the data type will return a data type reference that will be stored in the global variable.</p> <pre><code>static RedisModuleType *MyType;\n#define MYTYPE_ENCODING_VERSION 0\n\nint RedisModule_OnLoad(RedisModuleCtx *ctx) {\nRedisModuleTypeMethods tm = {\n    .version = REDISMODULE_TYPE_METHOD_VERSION,\n    .rdb_load = MyTypeRDBLoad,\n    .rdb_save = MyTypeRDBSave,\n    .aof_rewrite = MyTypeAOFRewrite,\n    .free = MyTypeFree\n};\n\n    MyType = RedisModule_CreateDataType(ctx, \"MyType-AZ\",\n    MYTYPE_ENCODING_VERSION, &amp;tm);\n    if (MyType == NULL) return REDISMODULE_ERR;\n}\n</code></pre> <p>As you can see from the example above, a single API call is needed in order to register the new type. However a number of function pointers are passed as arguments. Certain are optionals while some are mandatory. The above set of methods must be passed, while <code>.digest</code> and <code>.mem_usage</code> are optional and are currently not actually supported by the modules internals, so for now you can just ignore them.</p> <p>The <code>ctx</code> argument is the context that we receive in the <code>OnLoad</code> function. The type <code>name</code> is a 9 character name in the character set that includes from <code>A-Z</code>, <code>a-z</code>, <code>0-9</code>, plus the underscore <code>_</code> and minus <code>-</code> characters.</p> <p>Note that this name must be unique for each data type in the Redis ecosystem, so be creative, use both lower-case and upper case if it makes sense, and try to use the convention of mixing the type name with the name of the author of the module, to create a 9 character unique name.</p> <p>NOTE: It is very important that the name is exactly 9 chars or the registration of the type will fail. Read more to understand why.</p> <p>For example if I'm building a b-tree data structure and my name is antirez I'll call my type btree1-az. The name, converted to a 64 bit integer, is stored inside the RDB file when saving the type, and will be used when the RDB data is loaded in order to resolve what module can load the data. If Redis finds no matching module, the integer is converted back to a name in order to provide some clue to the user about what module is missing in order to load the data.</p> <p>The type name is also used as a reply for the <code>TYPE</code> command when called with a key holding the registered type.</p> <p>The <code>encver</code> argument is the encoding version used by the module to store data inside the RDB file. For example I can start with an encoding version of 0, but later when I release version 2.0 of my module, I can switch encoding to something better. The new module will register with an encoding version of 1, so when it saves new RDB files, the new version will be stored on disk. However when loading RDB files, the module <code>rdb_load</code> method will be called even if there is data found for a different encoding version (and the encoding version is passed as argument to <code>rdb_load</code>), so that the module can still load old RDB files.</p> <p>The last argument is a structure used in order to pass the type methods to the registration function: <code>rdb_load</code>, <code>rdb_save</code>, <code>aof_rewrite</code>, <code>digest</code> and <code>free</code> and <code>mem_usage</code> are all callbacks with the following prototypes and uses:</p> <pre><code>typedef void *(*RedisModuleTypeLoadFunc)(RedisModuleIO *rdb, int encver);\ntypedef void (*RedisModuleTypeSaveFunc)(RedisModuleIO *rdb, void *value);\ntypedef void (*RedisModuleTypeRewriteFunc)(RedisModuleIO *aof, RedisModuleString *key, void *value);\ntypedef size_t (*RedisModuleTypeMemUsageFunc)(void *value);\ntypedef void (*RedisModuleTypeDigestFunc)(RedisModuleDigest *digest, void *value);\ntypedef void (*RedisModuleTypeFreeFunc)(void *value);\n</code></pre> <ul> <li><code>rdb_load</code> is called when loading data from the RDB file. It loads data in the same format as <code>rdb_save</code> produces.</li> <li><code>rdb_save</code> is called when saving data to the RDB file.</li> <li><code>aof_rewrite</code> is called when the AOF is being rewritten, and the module needs to tell Redis what is the sequence of commands to recreate the content of a given key.</li> <li><code>digest</code> is called when <code>DEBUG DIGEST</code> is executed and a key holding this module type is found. Currently this is not yet implemented so the function ca be left empty.</li> <li><code>mem_usage</code> is called when the <code>MEMORY</code> command asks for the total memory consumed by a specific key, and is used in order to get the amount of bytes used by the module value.</li> <li><code>free</code> is called when a key with the module native type is deleted via <code>DEL</code> or in any other mean, in order to let the module reclaim the memory associated with such a value.</li> </ul>"},{"location":"8-reference/modules/modules-native-types/#ok-but-why-modules-types-require-a-9-characters-name","title":"Ok, but why modules types require a 9 characters name?","text":"<p>Oh, I understand you need to understand this, so here is a very specific explanation.</p> <p>When Redis persists to RDB files, modules specific data types require to be persisted as well. Now RDB files are sequences of key-value pairs like the following:</p> <pre><code>[1 byte type] [key] [a type specific value]\n</code></pre> <p>The 1 byte type identifies strings, lists, sets, and so forth. In the case of modules data, it is set to a special value of <code>module data</code>, but of course this is not enough, we need the information needed to link a specific value with a specific module type that is able to load and handle it.</p> <p>So when we save a <code>type specific value</code> about a module, we prefix it with a 64 bit integer. 64 bits is large enough to store the information needed in order to lookup the module that can handle that specific type, but is short enough that we can prefix each module value we store inside the RDB without making the final RDB file too big. At the same time, this solution of prefixing the value with a 64 bit signature does not require to do strange things like defining in the RDB header a list of modules specific types. Everything is pretty simple.</p> <p>So, what you can store in 64 bits in order to identify a given module in a reliable way? Well if you build a character set of 64 symbols, you can easily store 9 characters of 6 bits, and you are left with 10 bits, that are used in order to store the encoding version of the type, so that the same type can evolve in the future and provide a different and more efficient or updated serialization format for RDB files.</p> <p>So the 64 bit prefix stored before each module value is like the following:</p> <pre><code>6|6|6|6|6|6|6|6|6|10\n</code></pre> <p>The first 9 elements are 6-bits characters, the final 10 bits is the encoding version.</p> <p>When the RDB file is loaded back, it reads the 64 bit value, masks the final 10 bits, and searches for a matching module in the modules types cache. When a matching one is found, the method to load the RDB file value is called with the 10 bits encoding version as argument, so that the module knows what version of the data layout to load, if it can support multiple versions.</p> <p>Now the interesting thing about all this is that, if instead the module type cannot be resolved, since there is no loaded module having this signature, we can convert back the 64 bit value into a 9 characters name, and print an error to the user that includes the module type name! So that she or he immediately realizes what's wrong.</p>"},{"location":"8-reference/modules/modules-native-types/#setting-and-getting-keys","title":"Setting and getting keys","text":"<p>After registering our new data type in the <code>RedisModule_OnLoad()</code> function, we also need to be able to set Redis keys having as value our native type.</p> <p>This normally happens in the context of commands that write data to a key. The native types API allow to set and get keys to module native data types, and to test if a given key is already associated to a value of a specific data type.</p> <p>The API uses the normal modules <code>RedisModule_OpenKey()</code> low level key access interface in order to deal with this. This is an example of setting a native type private data structure to a Redis key:</p> <pre><code>RedisModuleKey *key = RedisModule_OpenKey(ctx,keyname,REDISMODULE_WRITE);\nstruct some_private_struct *data = createMyDataStructure();\nRedisModule_ModuleTypeSetValue(key,MyType,data);\n</code></pre> <p>The function <code>RedisModule_ModuleTypeSetValue()</code> is used with a key handle open for writing, and gets three arguments: the key handle, the reference to the native type, as obtained during the type registration, and finally a <code>void*</code> pointer that contains the private data implementing the module native type.</p> <p>Note that Redis has no clues at all about what your data contains. It will just call the callbacks you provided during the method registration in order to perform operations on the type.</p> <p>Similarly we can retrieve the private data from a key using this function:</p> <pre><code>struct some_private_struct *data;\ndata = RedisModule_ModuleTypeGetValue(key);\n</code></pre> <p>We can also test for a key to have our native type as value:</p> <pre><code>if (RedisModule_ModuleTypeGetType(key) == MyType) {\n    /* ... do something ... */\n}\n</code></pre> <p>However for the calls to do the right thing, we need to check if the key is empty, if it contains a value of the right kind, and so forth. So the idiomatic code to implement a command writing to our native type is along these lines:</p> <pre><code>RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],\n    REDISMODULE_READ|REDISMODULE_WRITE);\nint type = RedisModule_KeyType(key);\nif (type != REDISMODULE_KEYTYPE_EMPTY &amp;&amp;\n    RedisModule_ModuleTypeGetType(key) != MyType)\n{\n    return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);\n}\n</code></pre> <p>Then if we successfully verified the key is not of the wrong type, and we are going to write to it, we usually want to create a new data structure if the key is empty, or retrieve the reference to the value associated to the key if there is already one:</p> <pre><code>/* Create an empty value object if the key is currently empty. */\nstruct some_private_struct *data;\nif (type == REDISMODULE_KEYTYPE_EMPTY) {\n    data = createMyDataStructure();\n    RedisModule_ModuleTypeSetValue(key,MyTyke,data);\n} else {\n    data = RedisModule_ModuleTypeGetValue(key);\n}\n/* Do something with 'data'... */\n</code></pre>"},{"location":"8-reference/modules/modules-native-types/#free-method","title":"Free method","text":"<p>As already mentioned, when Redis needs to free a key holding a native type value, it needs help from the module in order to release the memory. This is the reason why we pass a <code>free</code> callback during the type registration:</p> <pre><code>typedef void (*RedisModuleTypeFreeFunc)(void *value);\n</code></pre> <p>A trivial implementation of the free method can be something like this, assuming our data structure is composed of a single allocation:</p> <pre><code>void MyTypeFreeCallback(void *value) {\n    RedisModule_Free(value);\n}\n</code></pre> <p>However a more real world one will call some function that performs a more complex memory reclaiming, by casting the void pointer to some structure and freeing all the resources composing the value.</p>"},{"location":"8-reference/modules/modules-native-types/#rdb-load-and-save-methods","title":"RDB load and save methods","text":"<p>The RDB saving and loading callbacks need to create (and load back) a representation of the data type on disk. Redis offers a high level API that can automatically store inside the RDB file the following types:</p> <ul> <li>Unsigned 64 bit integers.</li> <li>Signed 64 bit integers.</li> <li>Doubles.</li> <li>Strings.</li> </ul> <p>It is up to the module to find a viable representation using the above base types. However note that while the integer and double values are stored and loaded in an architecture and endianness agnostic way, if you use the raw string saving API to, for example, save a structure on disk, you have to care those details yourself.</p> <p>This is the list of functions performing RDB saving and loading:</p> <pre><code>void RedisModule_SaveUnsigned(RedisModuleIO *io, uint64_t value);\nuint64_t RedisModule_LoadUnsigned(RedisModuleIO *io);\nvoid RedisModule_SaveSigned(RedisModuleIO *io, int64_t value);\nint64_t RedisModule_LoadSigned(RedisModuleIO *io);\nvoid RedisModule_SaveString(RedisModuleIO *io, RedisModuleString *s);\nvoid RedisModule_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len);\nRedisModuleString *RedisModule_LoadString(RedisModuleIO *io);\nchar *RedisModule_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr);\nvoid RedisModule_SaveDouble(RedisModuleIO *io, double value);\ndouble RedisModule_LoadDouble(RedisModuleIO *io);\n</code></pre> <p>The functions don't require any error checking from the module, that can always assume calls succeed.</p> <p>As an example, imagine I've a native type that implements an array of double values, with the following structure:</p> <pre><code>struct double_array {\n    size_t count;\n    double *values;\n};\n</code></pre> <p>My <code>rdb_save</code> method may look like the following:</p> <pre><code>void DoubleArrayRDBSave(RedisModuleIO *io, void *ptr) {\n    struct dobule_array *da = ptr;\n    RedisModule_SaveUnsigned(io,da-&gt;count);\n    for (size_t j = 0; j &lt; da-&gt;count; j++)\n        RedisModule_SaveDouble(io,da-&gt;values[j]);\n}\n</code></pre> <p>What we did was to store the number of elements followed by each double value. So when later we'll have to load the structure in the <code>rdb_load</code> method we'll do something like this:</p> <pre><code>void *DoubleArrayRDBLoad(RedisModuleIO *io, int encver) {\n    if (encver != DOUBLE_ARRAY_ENC_VER) {\n        /* We should actually log an error here, or try to implement\n           the ability to load older versions of our data structure. */\n        return NULL;\n    }\n\n    struct double_array *da;\n    da = RedisModule_Alloc(sizeof(*da));\n    da-&gt;count = RedisModule_LoadUnsigned(io);\n    da-&gt;values = RedisModule_Alloc(da-&gt;count * sizeof(double));\n    for (size_t j = 0; j &lt; da-&gt;count; j++)\n        da-&gt;values[j] = RedisModule_LoadDouble(io);\n    return da;\n}\n</code></pre> <p>The load callback just reconstruct back the data structure from the data we stored in the RDB file.</p> <p>Note that while there is no error handling on the API that writes and reads from disk, still the load callback can return NULL on errors in case what it reads does not look correct. Redis will just panic in that case.</p>"},{"location":"8-reference/modules/modules-native-types/#aof-rewriting","title":"AOF rewriting","text":"<pre><code>void RedisModule_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...);\n</code></pre>"},{"location":"8-reference/modules/modules-native-types/#handling-multiple-encodings","title":"Handling multiple encodings","text":"<pre><code>WORK IN PROGRESS\n</code></pre>"},{"location":"8-reference/modules/modules-native-types/#allocating-memory","title":"Allocating memory","text":"<p>Modules data types should try to use <code>RedisModule_Alloc()</code> functions family in order to allocate, reallocate and release heap memory used to implement the native data structures (see the other Redis Modules documentation for detailed information).</p> <p>This is not just useful in order for Redis to be able to account for the memory used by the module, but there are also more advantages:</p> <ul> <li>Redis uses the <code>jemalloc</code> allocator, that often prevents fragmentation problems that could be caused by using the libc allocator.</li> <li>When loading strings from the RDB file, the native types API is able to return strings allocated directly with <code>RedisModule_Alloc()</code>, so that the module can directly link this memory into the data structure representation, avoiding a useless copy of the data.</li> </ul> <p>Even if you are using external libraries implementing your data structures, the allocation functions provided by the module API is exactly compatible with <code>malloc()</code>, <code>realloc()</code>, <code>free()</code> and <code>strdup()</code>, so converting the libraries in order to use these functions should be trivial.</p> <p>In case you have an external library that uses libc <code>malloc()</code>, and you want to avoid replacing manually all the calls with the Redis Modules API calls, an approach could be to use simple macros in order to replace the libc calls with the Redis API calls. Something like this could work:</p> <pre><code>#define malloc RedisModule_Alloc\n#define realloc RedisModule_Realloc\n#define free RedisModule_Free\n#define strdup RedisModule_Strdup\n</code></pre> <p>However take in mind that mixing libc calls with Redis API calls will result into troubles and crashes, so if you replace calls using macros, you need to make sure that all the calls are correctly replaced, and that the code with the substituted calls will never, for example, attempt to call <code>RedisModule_Free()</code> with a pointer allocated using libc <code>malloc()</code>.</p>"}]}